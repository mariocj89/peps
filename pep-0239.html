<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">239</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Adding a Rational Type to Python</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0239.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Christopher A. Craig &lt;python-pep&#32;&#97;t&#32;ccraig.org&gt;, Moshe Zadka &lt;moshez&#32;&#97;t&#32;zadka.site.co.il&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">11-Mar-2001</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.2</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">16-Mar-2001</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id5">Abstract</a></li>
<li><a class="reference internal" href="#bdfl-pronouncement" id="id6">BDFL Pronouncement</a></li>
<li><a class="reference internal" href="#rationale" id="id7">Rationale</a></li>
<li><a class="reference internal" href="#rationaltype" id="id8">RationalType</a></li>
<li><a class="reference internal" href="#the-rational-builtin" id="id9">The rational() Builtin</a></li>
<li><a class="reference internal" href="#open-issues" id="id10">Open Issues</a></li>
<li><a class="reference internal" href="#references" id="id11">References</a></li>
<li><a class="reference internal" href="#copyright" id="id12">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id5">Abstract</a></h1>
<p>Python has no numeric type with the semantics of an unboundedly
precise rational number.  This proposal explains the semantics of
such a type, and suggests builtin functions and literals to
support such a type.  This PEP suggests no literals for rational
numbers; that is left for another PEP <a class="footnote-reference" href="#id3" id="id1">[1]</a>.</p>
</div>
<div class="section" id="bdfl-pronouncement">
<h1><a class="toc-backref" href="#id6">BDFL Pronouncement</a></h1>
<p>This PEP is rejected.  The needs outlined in the rationale section
have been addressed to some extent by the acceptance of <a class="reference external" href="/dev/peps/pep-0327">PEP 327</a>
for decimal arithmetic.  Guido also noted, &quot;Rational arithmetic
was the default 'exact' arithmetic in ABC and it did not work out as
expected&quot;.  See the python-dev discussion on 17 June 2005 <a class="footnote-reference" href="#id4" id="id2">[2]</a>.</p>
<p><em>Postscript:</em> With the acceptance of <a class="reference external" href="/dev/peps/pep-3141">PEP 3141</a>, &quot;A Type Hierarchy
for Numbers&quot;, a 'Rational' numeric abstract base class was added
with a concrete implementation in the 'fractions' module.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id7">Rationale</a></h1>
<p>While sometimes slower and more memory intensive (in general,
unboundedly so) rational arithmetic captures more closely the
mathematical ideal of numbers, and tends to have behavior which is
less surprising to newbies.  Though many Python implementations of
rational numbers have been written, none of these exist in the
core, or are documented in any way.  This has made them much less
accessible to people who are less Python-savvy.</p>
</div>
<div class="section" id="rationaltype">
<h1><a class="toc-backref" href="#id8">RationalType</a></h1>
<p>There will be a new numeric type added called <tt class="docutils literal">RationalType</tt>.  Its
unary operators will do the obvious thing.  Binary operators will
coerce integers and long integers to rationals, and rationals to
floats and complexes.</p>
<p>The following attributes will be supported: <tt class="docutils literal">.numerator</tt> and
<tt class="docutils literal">.denominator</tt>.  The language definition will promise that:</p>
<pre class="literal-block">
r.denominator * r == r.numerator
</pre>
<p>that the GCD of the numerator and the denominator is 1 and that
the denominator is positive.</p>
<p>The method <tt class="docutils literal">r.trim(max_denominator)</tt> will return the closest
rational <tt class="docutils literal">s</tt> to <tt class="docutils literal">r</tt> such that <tt class="docutils literal">abs(s.denominator) &lt;= max_denominator</tt>.</p>
</div>
<div class="section" id="the-rational-builtin">
<h1><a class="toc-backref" href="#id9">The rational() Builtin</a></h1>
<p>This function will have the signature <tt class="docutils literal">rational(n, d=1)</tt>.  <tt class="docutils literal">n</tt> and <tt class="docutils literal">d</tt>
must both be integers, long integers or rationals.  A guarantee is
made that:</p>
<pre class="literal-block">
rational(n, d) * d == n
</pre>
</div>
<div class="section" id="open-issues">
<h1><a class="toc-backref" href="#id10">Open Issues</a></h1>
<ul>
<li><p class="first">Maybe the type should be called rat instead of rational.
Somebody proposed that we have &quot;abstract&quot; pure mathematical
types named complex, real, rational, integer, and &quot;concrete&quot;
representation types with names like float, rat, long, int.</p>
</li>
<li><p class="first">Should a rational number with an integer value be allowed as a
sequence index?  For example, should <tt class="docutils literal">s[5/3 - 2/3]</tt> be equivalent
to <tt class="docutils literal">s[1]</tt>?</p>
</li>
<li><p class="first">Should <tt class="docutils literal">shift</tt> and <tt class="docutils literal">mask</tt> operators be allowed for rational numbers?
For rational numbers with integer values?</p>
</li>
<li><p class="first">Marcin 'Qrczak' Kowalczyk summarized the arguments for and
against unifying ints with rationals nicely on c.l.py</p>
<p>Arguments for unifying ints with rationals:</p>
<ul class="simple">
<li>Since <tt class="docutils literal">2 == 2/1</tt> and maybe <tt class="docutils literal">str(2/1) == '2'</tt>, it reduces surprises
where objects seem equal but behave differently.</li>
<li><tt class="docutils literal">/</tt> can be freely used for integer division when I <em>know</em> that
there is no remainder (if I am wrong and there is a remainder,
there will probably be some exception later).</li>
</ul>
<p>Arguments against:</p>
<ul class="simple">
<li>When I use the result of <tt class="docutils literal">/</tt> as a sequence index, it's usually
an error which should not be hidden by making the program
working for some data, since it will break for other data.</li>
<li>(this assumes that after unification int and rational would be
different types:) Types should rarely depend on values. It's
easier to reason when the type of a variable is known: I know
how I can use it. I can determine that something is an int and
expect that other objects used in this place will be ints too.</li>
<li>(this assumes the same type for them:) Int is a good type in
itself, not to be mixed with rationals.  The fact that
something is an integer should be expressible as a statement
about its type. Many operations require ints and don't accept
rationals. It's natural to think about them as about different
types.</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id11">References</a></h1>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="/dev/peps/pep-0240">PEP 240</a>, Adding a Rational Literal to Python, Zadka,
<a class="reference external" href="http://www.python.org/dev/peps/pep-0240/">http://www.python.org/dev/peps/pep-0240/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Raymond Hettinger, Propose rejection of PEPs 239 and 240 -- a builtin
rational type and rational literals
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2005-June/054281.html">https://mail.python.org/pipermail/python-dev/2005-June/054281.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id12">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

