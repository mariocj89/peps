<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">442</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Safe object finalization</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0442.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Antoine Pitrou &lt;solipsis&#32;&#97;t&#32;pitrou.net&gt;</td>
</tr>
<tr class="field"><th class="field-name">BDFL-Delegate:</th><td class="field-body">Benjamin Peterson &lt;benjamin&#32;&#97;t&#32;python.org&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">2013-05-18</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.4</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">2013-05-18</td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2013-June/126746.html">https://mail.python.org/pipermail/python-dev/2013-June/126746.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id1">Abstract</a></li>
<li><a class="reference internal" href="#definitions" id="id2">Definitions</a></li>
<li><a class="reference internal" href="#impact" id="id3">Impact</a></li>
<li><a class="reference internal" href="#benefits" id="id4">Benefits</a></li>
<li><a class="reference internal" href="#description" id="id5">Description</a><ul>
<li><a class="reference internal" href="#reference-counted-disposal" id="id6">Reference-counted disposal</a></li>
<li><a class="reference internal" href="#disposal-of-cyclic-isolates" id="id7">Disposal of cyclic isolates</a></li>
</ul>
</li>
<li><a class="reference internal" href="#c-level-changes" id="id8">C-level changes</a></li>
<li><a class="reference internal" href="#discussion" id="id9">Discussion</a><ul>
<li><a class="reference internal" href="#predictability" id="id10">Predictability</a></li>
<li><a class="reference internal" href="#safety" id="id11">Safety</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation" id="id12">Implementation</a></li>
<li><a class="reference internal" href="#validation" id="id13">Validation</a></li>
<li><a class="reference internal" href="#references" id="id14">References</a></li>
<li><a class="reference internal" href="#copyright" id="id15">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id1">Abstract</a></h1>
<p>This PEP proposes to deal with the current limitations of object
finalization.  The goal is to be able to define and run finalizers
for any object, regardless of their position in the object graph.</p>
<p>This PEP doesn't call for any change in Python code.  Objects
with existing finalizers will benefit automatically.</p>
</div>
<div class="section" id="definitions">
<h1><a class="toc-backref" href="#id2">Definitions</a></h1>
<dl class="docutils">
<dt>Reference</dt>
<dd>A directional link from an object to another.  The target of the
reference is kept alive by the reference, as long as the source is
itself alive and the reference isn't cleared.</dd>
<dt>Weak reference</dt>
<dd>A directional link from an object to another, which doesn't keep
alive its target.  This PEP focusses on non-weak references.</dd>
<dt>Reference cycle</dt>
<dd>A cyclic subgraph of directional links between objects, which keeps
those objects from being collected in a pure reference-counting
scheme.</dd>
<dt>Cyclic isolate (CI)</dt>
<dd>A standalone subgraph of objects in which no object is referenced
from the outside, containing one or several reference cycles, <em>and</em>
whose objects are still in a usable, non-broken state: they can
access each other from their respective finalizers.</dd>
<dt>Cyclic garbage collector (GC)</dt>
<dd>A device able to detect cyclic isolates and turn them into cyclic
trash.  Objects in cyclic trash are eventually disposed of by
the natural effect of the references being cleared and their
reference counts dropping to zero.</dd>
<dt>Cyclic trash (CT)</dt>
<dd>A former cyclic isolate whose objects have started being cleared
by the GC.  Objects in cyclic trash are potential zombies; if they
are accessed by Python code, the symptoms can vary from weird
AttributeErrors to crashes.</dd>
<dt>Zombie / broken object</dt>
<dd>An object part of cyclic trash.  The term stresses that the object
is not safe: its outgoing references may have been cleared, or one
of the objects it references may be zombie.  Therefore,
it should not be accessed by arbitrary code (such as finalizers).</dd>
<dt>Finalizer</dt>
<dd>A function or method called when an object is intended to be
disposed of.  The finalizer can access the object and release any
resource held by the object (for example mutexes or file
descriptors).  An example is a <tt class="docutils literal">__del__</tt> method.</dd>
<dt>Resurrection</dt>
<dd>The process by which a finalizer creates a new reference to an
object in a CI.  This can happen as a quirky but supported
side-effect of <tt class="docutils literal">__del__</tt> methods.</dd>
</dl>
</div>
<div class="section" id="impact">
<h1><a class="toc-backref" href="#id3">Impact</a></h1>
<p>While this PEP discusses CPython-specific implementation details, the
change in finalization semantics is expected to affect the Python
ecosystem as a whole.  In particular, this PEP obsoletes the current
guideline that &quot;objects with a <tt class="docutils literal">__del__</tt> method should not be part of a
reference cycle&quot;.</p>
</div>
<div class="section" id="benefits">
<h1><a class="toc-backref" href="#id4">Benefits</a></h1>
<p>The primary benefits of this PEP regard objects with finalizers, such
as objects with a <tt class="docutils literal">__del__</tt> method and generators with a <tt class="docutils literal">finally</tt>
block.  Those objects can now be reclaimed when they are part of a
reference cycle.</p>
<p>The PEP also paves the way for further benefits:</p>
<ul class="simple">
<li>The module shutdown procedure may not need to set global variables to
None anymore.  This could solve a well-known class of irritating issues.</li>
</ul>
<p>The PEP doesn't change the semantics of:</p>
<ul class="simple">
<li>Weak references caught in reference cycles.</li>
<li>C extension types with a custom <tt class="docutils literal">tp_dealloc</tt> function.</li>
</ul>
</div>
<div class="section" id="description">
<h1><a class="toc-backref" href="#id5">Description</a></h1>
<div class="section" id="reference-counted-disposal">
<h2><a class="toc-backref" href="#id6">Reference-counted disposal</a></h2>
<p>In normal reference-counted disposal, an object's finalizer is called
just before the object is deallocated.  If the finalizer resurrects
the object, deallocation is aborted.</p>
<p><em>However</em>, if the object was already finalized, then the finalizer isn't
called.  This prevents us from finalizing zombies (see below).</p>
</div>
<div class="section" id="disposal-of-cyclic-isolates">
<h2><a class="toc-backref" href="#id7">Disposal of cyclic isolates</a></h2>
<p>Cyclic isolates are first detected by the garbage collector, and then
disposed of.  The detection phase doesn't change and won't be described
here.  Disposal of a CI traditionally works in the following order:</p>
<ol class="arabic simple">
<li>Weakrefs to CI objects are cleared, and their callbacks called. At
this point, the objects are still safe to use.</li>
<li>The CI becomes a CT as the GC systematically breaks all
known references inside it (using the <tt class="docutils literal">tp_clear</tt> function).</li>
<li>Nothing.  All CT objects should have been disposed of in step 2
(as a side-effect of clearing references); this collection is
finished.</li>
</ol>
<p>This PEP proposes to turn CI disposal into the following sequence (new
steps are in bold):</p>
<ol class="arabic simple">
<li>Weakrefs to CI objects are cleared, and their callbacks called. At
this point, the objects are still safe to use.</li>
<li><strong>The finalizers of all CI objects are called.</strong></li>
<li><strong>The CI is traversed again to determine if it is still isolated.
If it is determined that at least one object in CI is now reachable
from outside the CI, this collection is aborted and the whole CI
is resurrected.  Otherwise, proceed.</strong></li>
<li>The CI becomes a CT as the GC systematically breaks all
known references inside it (using the <tt class="docutils literal">tp_clear</tt> function).</li>
<li>Nothing.  All CT objects should have been disposed of in step 4
(as a side-effect of clearing references); this collection is
finished.</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The GC doesn't recalculate the CI after step 2 above, hence the need
for step 3 to check that the whole subgraph is still isolated.</p>
</div>
</div>
</div>
<div class="section" id="c-level-changes">
<h1><a class="toc-backref" href="#id8">C-level changes</a></h1>
<p>Type objects get a new <tt class="docutils literal">tp_finalize</tt> slot to which <tt class="docutils literal">__del__</tt> methods
are mapped (and reciprocally).  Generators are modified to use this slot,
rather than <tt class="docutils literal">tp_del</tt>.  A <tt class="docutils literal">tp_finalize</tt> function is a normal C
function which will be called with a valid and alive <tt class="docutils literal">PyObject</tt> as its
only argument.  It doesn't need to manipulate the object's reference count,
as this will be done by the caller.  However, it must ensure that the
original exception state is restored before returning to the caller.</p>
<p>For compatibility, <tt class="docutils literal">tp_del</tt> is kept in the type structure.  Handling
of objects with a non-NULL <tt class="docutils literal">tp_del</tt> is unchanged: when part of a CI,
they are not finalized and end up in <tt class="docutils literal">gc.garbage</tt>.  However, a non-NULL
<tt class="docutils literal">tp_del</tt> is not encountered anymore in the CPython source tree (except
for testing purposes).</p>
<p>Two new C API functions are provided to ease calling of <tt class="docutils literal">tp_finalize</tt>,
especially from custom deallocators.</p>
<p>On the internal side, a bit is reserved in the GC header for GC-managed
objects to signal that they were finalized.  This helps avoid finalizing
an object twice (and, especially, finalizing a CT object after it was
broken by the GC).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Objects which are not GC-enabled can also have a <tt class="docutils literal">tp_finalize</tt> slot.
They don't need the additional bit since their <tt class="docutils literal">tp_finalize</tt> function
can only be called from the deallocator: it therefore cannot be called
twice, except when resurrected.</p>
</div>
</div>
<div class="section" id="discussion">
<h1><a class="toc-backref" href="#id9">Discussion</a></h1>
<div class="section" id="predictability">
<h2><a class="toc-backref" href="#id10">Predictability</a></h2>
<p>Following this scheme, an object's finalizer is always called exactly
once, even if it was resurrected afterwards.</p>
<p>For CI objects, the order in which finalizers are called (step 2 above)
is undefined.</p>
</div>
<div class="section" id="safety">
<h2><a class="toc-backref" href="#id11">Safety</a></h2>
<p>It is important to explain why the proposed change is safe.  There
are two aspects to be discussed:</p>
<ul class="simple">
<li>Can a finalizer access zombie objects (including the object being
finalized)?</li>
<li>What happens if a finalizer mutates the object graph so as to impact
the CI?</li>
</ul>
<p>Let's discuss the first issue.  We will divide possible cases in two
categories:</p>
<ul class="simple">
<li>If the object being finalized is part of the CI: by construction, no
objects in CI are zombies yet, since CI finalizers are called before
any reference breaking is done.  Therefore, the finalizer cannot
access zombie objects, which don't exist.</li>
<li>If the object being finalized is not part of the CI/CT: by definition,
objects in the CI/CT don't have any references pointing to them from
outside the CI/CT.  Therefore, the finalizer cannot reach any zombie
object (that is, even if the object being finalized was itself
referenced from a zombie object).</li>
</ul>
<p>Now for the second issue.  There are three potential cases:</p>
<ul class="simple">
<li>The finalizer clears an existing reference to a CI object.  The CI
object may be disposed of before the GC tries to break it, which
is fine (the GC simply has to be aware of this possibility).</li>
<li>The finalizer creates a new reference to a CI object.  This can only
happen from a CI object's finalizer (see above why).  Therefore, the
new reference will be detected by the GC after all CI finalizers are
called (step 3 above), and collection will be aborted without any
objects being broken.</li>
<li>The finalizer clears or creates a reference to a non-CI object.  By
construction, this is not a problem.</li>
</ul>
</div>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id12">Implementation</a></h1>
<p>An implementation is available in branch <tt class="docutils literal">finalize</tt> of the repository
at <a class="reference external" href="http://hg.python.org/features/finalize/">http://hg.python.org/features/finalize/</a>.</p>
</div>
<div class="section" id="validation">
<h1><a class="toc-backref" href="#id13">Validation</a></h1>
<p>Besides running the normal Python test suite, the implementation adds
test cases for various finalization possibilities including reference cycles,
object resurrection and legacy <tt class="docutils literal">tp_del</tt> slots.</p>
<p>The implementation has also been checked to not produce any regressions on
the following test suites:</p>
<ul class="simple">
<li><a class="reference external" href="http://code.google.com/p/tulip/">Tulip</a>, which makes an extensive
use of generators</li>
<li><a class="reference external" href="http://www.tornadoweb.org">Tornado</a></li>
<li><a class="reference external" href="http://www.sqlalchemy.org/">SQLAlchemy</a></li>
<li><a class="reference external" href="https://www.djangoproject.com/">Django</a></li>
<li><a class="reference external" href="http://pypi.python.org/pypi/zope.interface">zope.interface</a></li>
</ul>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id14">References</a></h1>
<p>Notes about reference cycle collection and weak reference callbacks:
<a class="reference external" href="http://hg.python.org/cpython/file/4e687d53b645/Modules/gc_weakref.txt">http://hg.python.org/cpython/file/4e687d53b645/Modules/gc_weakref.txt</a></p>
<p>Generator memory leak: <a class="reference external" href="http://bugs.python.org/issue17468">http://bugs.python.org/issue17468</a></p>
<p>Allow objects to decide if they can be collected by GC:
<a class="reference external" href="http://bugs.python.org/issue9141">http://bugs.python.org/issue9141</a></p>
<p>Module shutdown procedure based on GC
<a class="reference external" href="http://bugs.python.org/issue812369">http://bugs.python.org/issue812369</a></p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id15">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

