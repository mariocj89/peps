<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">298</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">The Locked Buffer Interface</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0298.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Thomas Heller &lt;theller&#32;&#97;t&#32;python.net&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Withdrawn</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">26-Jul-2002</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.3</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">30-Jul-2002, 1-Aug-2002</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id4">Abstract</a></li>
<li><a class="reference internal" href="#specification" id="id5">Specification</a></li>
<li><a class="reference internal" href="#implementation" id="id6">Implementation</a></li>
<li><a class="reference internal" href="#backward-compatibility" id="id7">Backward Compatibility</a></li>
<li><a class="reference internal" href="#reference-implementation" id="id8">Reference Implementation</a></li>
<li><a class="reference internal" href="#additional-notes-comments" id="id9">Additional Notes/Comments</a></li>
<li><a class="reference internal" href="#community-feedback" id="id10">Community Feedback</a></li>
<li><a class="reference internal" href="#references" id="id11">References</a></li>
<li><a class="reference internal" href="#copyright" id="id12">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id4">Abstract</a></h1>
<p>This PEP proposes an extension to the buffer interface called the
'locked buffer interface'.</p>
<p>The locked buffer interface avoids the flaws of the 'old' buffer
interface <a class="footnote-reference" href="#id2" id="id1">[1]</a> as defined in Python versions up to and including
2.2, and has the following semantics:</p>
<ul class="simple">
<li>The lifetime of the retrieved pointer is clearly defined and
controlled by the client.</li>
<li>The buffer size is returned as a 'size_t' data type, which
allows access to large buffers on platforms where <tt class="docutils literal">sizeof(int)
!= sizeof(void *)</tt>.</li>
</ul>
<p>(Guido comments: This second sounds like a change we could also
make to the &quot;old&quot; buffer interface, if we introduce another flag
bit that's <em>not</em> part of the default flags.)</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id5">Specification</a></h1>
<p>The locked buffer interface exposes new functions which return the
size and the pointer to the internal memory block of any python
object which chooses to implement this interface.</p>
<p>Retrieving a buffer from an object puts this object in a locked
state during which the buffer may not be freed, resized, or
reallocated.</p>
<p>The object must be unlocked again by releasing the buffer if it's
no longer used by calling another function in the locked buffer
interface.  If the object never resizes or reallocates the buffer
during its lifetime, this function may be NULL.  Failure to call
this function (if it is != NULL) is a programming error and may
have unexpected results.</p>
<p>The locked buffer interface omits the memory segment model which
is present in the old buffer interface - only a single memory
block can be exposed.</p>
<p>The memory blocks can be accessed without holding the global
interpreter lock.</p>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id6">Implementation</a></h1>
<p>Define a new flag in Include/object.h:</p>
<pre class="literal-block">
/* PyBufferProcs contains bf_acquirelockedreadbuffer,
   bf_acquirelockedwritebuffer, and bf_releaselockedbuffer */
#define Py_TPFLAGS_HAVE_LOCKEDBUFFER (1L&lt;&lt;15)
</pre>
<p>This flag would be included in <tt class="docutils literal">Py_TPFLAGS_DEFAULT</tt>:</p>
<pre class="literal-block">
#define Py_TPFLAGS_DEFAULT  ( \
                    ....
                    Py_TPFLAGS_HAVE_LOCKEDBUFFER | \
                    ....
                    0)
</pre>
<p>Extend the <tt class="docutils literal">PyBufferProcs</tt> structure by new fields in
Include/object.h:</p>
<pre class="literal-block">
typedef size_t (*acquirelockedreadbufferproc)(PyObject *,
                                              const void **);
typedef size_t (*acquirelockedwritebufferproc)(PyObject *,
                                               void **);
typedef void (*releaselockedbufferproc)(PyObject *);

typedef struct {
    getreadbufferproc bf_getreadbuffer;
    getwritebufferproc bf_getwritebuffer;
    getsegcountproc bf_getsegcount;
    getcharbufferproc bf_getcharbuffer;
    /* locked buffer interface functions */
    acquirelockedreadbufferproc bf_acquirelockedreadbuffer;
    acquirelockedwritebufferproc bf_acquirelockedwritebuffer;
    releaselockedbufferproc bf_releaselockedbuffer;
} PyBufferProcs;
</pre>
<p>The new fields are present if the <tt class="docutils literal">Py_TPFLAGS_HAVE_LOCKEDBUFFER</tt>
flag is set in the object's type.</p>
<p>The <tt class="docutils literal">Py_TPFLAGS_HAVE_LOCKEDBUFFER</tt> flag implies the
<tt class="docutils literal">Py_TPFLAGS_HAVE_GETCHARBUFFER</tt> flag.</p>
<p>The <tt class="docutils literal">acquirelockedreadbufferproc</tt> and <tt class="docutils literal">acquirelockedwritebufferproc</tt>
functions return the size in bytes of the memory block on success,
and fill in the passed void * pointer on success.  If these
functions fail - either because an error occurs or no memory block
is exposed - they must set the void * pointer to NULL and raise an
exception.  The return value is undefined in these cases and
should not be used.</p>
<p>If calls to these functions succeed, eventually the buffer must be
released by a call to the <tt class="docutils literal">releaselockedbufferproc</tt>, supplying the
original object as argument.  The <tt class="docutils literal">releaselockedbufferproc</tt> cannot
fail.  For objects that actually maintain an internal lock count
it would be a fatal error if the <tt class="docutils literal">releaselockedbufferproc</tt> function
would be called too often, leading to a negative lock count.</p>
<p>Similar to the 'old' buffer interface, any of these functions may
be set to NULL, but it is strongly recommended to implement the
<tt class="docutils literal">releaselockedbufferproc</tt> function (even if it does nothing) if any
of the <tt class="docutils literal">acquireread</tt>/<tt class="docutils literal">writelockedbufferproc</tt> functions are
implemented, to discourage extension writers from checking for a
NULL value and not calling it.</p>
<p>These functions aren't supposed to be called directly, they are
called through convenience functions declared in
Include/abstract.h:</p>
<pre class="literal-block">
int PyObject_AquireLockedReadBuffer(PyObject *obj,
                                    const void **buffer,
                                    size_t *buffer_len);

int PyObject_AcquireLockedWriteBuffer(PyObject *obj,
                                      void **buffer,
                                      size_t *buffer_len);

void PyObject_ReleaseLockedBuffer(PyObject *obj);
</pre>
<p>The former two functions return 0 on success, set buffer to the
memory location and buffer_len to the length of the memory block
in bytes. On failure, or if the locked buffer interface is not
implemented by obj, they return -1 and set an exception.</p>
<p>The latter function doesn't return anything, and cannot fail.</p>
</div>
<div class="section" id="backward-compatibility">
<h1><a class="toc-backref" href="#id7">Backward Compatibility</a></h1>
<p>The size of the <tt class="docutils literal">PyBufferProcs</tt> structure changes if this proposal
is implemented, but the type's <tt class="docutils literal">tp_flags</tt> slot can be used to
determine if the additional fields are present.</p>
</div>
<div class="section" id="reference-implementation">
<h1><a class="toc-backref" href="#id8">Reference Implementation</a></h1>
<p>An implementation has been uploaded to the SourceForge patch
manager as <a class="reference external" href="http://www.python.org/sf/652857">http://www.python.org/sf/652857</a>.</p>
</div>
<div class="section" id="additional-notes-comments">
<h1><a class="toc-backref" href="#id9">Additional Notes/Comments</a></h1>
<p>Python strings, unicode strings, mmap objects, and array objects
would expose the locked buffer interface.</p>
<p>mmap and array objects would actually enter a locked state while
the buffer is active, this is not needed for strings and unicode
objects.  Resizing locked array objects is not allowed and will
raise an exception. Whether closing a locked mmap object is an
error or will only be deferred until the lock count reaches zero
is an implementation detail.</p>
<p>Guido recommends</p>
<blockquote>
<p>But I'm still very concerned that if most built-in types
(e.g. strings, bytes) don't implement the release
functionality, it's too easy for an extension to seem to work
while forgetting to release the buffer.</p>
<p>I recommend that at least some built-in types implement the
acquire/release functionality with a counter, and assert that
the counter is zero when the object is deleted -- if the
assert fails, someone DECREF'ed their reference to the object
without releasing it.  (The rule should be that you must own a
reference to the object while you've acquired the object.)</p>
<p>For strings that might be impractical because the string
object would have to grow 4 bytes to hold the counter; but the
new bytes object (<a class="reference external" href="/dev/peps/pep-0296">PEP 296</a>) could easily implement the counter,
and the array object too -- that way there will be plenty of
opportunity to test proper use of the protocol.</p>
</blockquote>
</div>
<div class="section" id="community-feedback">
<h1><a class="toc-backref" href="#id10">Community Feedback</a></h1>
<p>Greg Ewing doubts the locked buffer interface is needed at all, he
thinks the normal buffer interface could be used if the pointer is
(re)fetched each time it's used.  This seems to be dangerous,
because even innocent looking calls to the Python API like
<tt class="docutils literal">Py_DECREF()</tt> may trigger execution of arbitrary Python code.</p>
<p>The first version of this proposal didn't have the release
function, but it turned out that this would have been too
restrictive: mmap and array objects wouldn't have been able to
implement it, because mmap objects can be closed anytime if not
locked, and array objects could resize or reallocate the buffer.</p>
<p>This PEP will probably be rejected because nobody except the
author needs it.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id11">References</a></h1>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>The buffer interface
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2000-October/009974.html">https://mail.python.org/pipermail/python-dev/2000-October/009974.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>The Buffer Problem
<a class="reference external" href="http://www.python.org/dev/peps/pep-0296/">http://www.python.org/dev/peps/pep-0296/</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id12">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>

