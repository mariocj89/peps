<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">255</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Simple Generators</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0255.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">nas&#32;&#97;t&#32;arctrix.com (Neil Schemenauer),
tim.peters&#32;&#97;t&#32;gmail.com (Tim Peters),
magnus&#32;&#97;t&#32;hetland.org (Magnus Lie Hetland)</td>
</tr>
<tr class="field"><th class="field-name">Discussions-To:</th><td class="field-body"><a class="reference external" href="mailto:python-iterators&#64;lists.sourceforge.net?subject=PEP%20255">python-iterators&#32;&#97;t&#32;lists.sourceforge.net</a></td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Requires:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0234">234</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">18-May-2001</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.2</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">14-Jun-2001, 23-Jun-2001</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id16">Abstract</a></li>
<li><a class="reference internal" href="#motivation" id="id17">Motivation</a></li>
<li><a class="reference internal" href="#specification-yield" id="id18">Specification:  Yield</a></li>
<li><a class="reference internal" href="#specification-return" id="id19">Specification:  Return</a></li>
<li><a class="reference internal" href="#specification-generators-and-exception-propagation" id="id20">Specification:  Generators and Exception Propagation</a></li>
<li><a class="reference internal" href="#specification-try-except-finally" id="id21">Specification:  Try/Except/Finally</a></li>
<li><a class="reference internal" href="#example" id="id22">Example</a></li>
<li><a class="reference internal" href="#q-a" id="id23">Q &amp; A</a><ul>
<li><a class="reference internal" href="#why-not-a-new-keyword-instead-of-reusing-def" id="id24">Why not a new keyword instead of reusing <tt class="docutils literal">def</tt>?</a></li>
<li><a class="reference internal" href="#why-a-new-keyword-for-yield-why-not-a-builtin-function-instead" id="id25">Why a new keyword for <tt class="docutils literal">yield</tt>?  Why not a builtin function instead?</a></li>
<li><a class="reference internal" href="#then-why-not-some-other-special-syntax-without-a-new-keyword" id="id26">Then why not some other special syntax without a new keyword?</a></li>
<li><a class="reference internal" href="#why-allow-return-at-all-why-not-force-termination-to-be-spelled-raise-stopiteration" id="id27">Why allow <tt class="docutils literal">return</tt> at all?  Why not force termination to be spelled <tt class="docutils literal">raise StopIteration</tt>?</a></li>
<li><a class="reference internal" href="#then-why-not-allow-an-expression-on-return-too" id="id28">Then why not allow an expression on <tt class="docutils literal">return</tt> too?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bdfl-pronouncements" id="id29">BDFL Pronouncements</a><ul>
<li><a class="reference internal" href="#issue" id="id30">Issue</a></li>
<li><a class="reference internal" href="#con" id="id31">Con</a></li>
<li><a class="reference internal" href="#pro" id="id32">Pro</a></li>
<li><a class="reference internal" href="#bdfl" id="id33">BDFL</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference-implementation" id="id34">Reference Implementation</a></li>
<li><a class="reference internal" href="#footnotes-and-references" id="id35">Footnotes and References</a></li>
<li><a class="reference internal" href="#copyright" id="id36">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id16">Abstract</a></h1>
<p>This PEP introduces the concept of generators to Python, as well as a new
statement used in conjunction with them, the <tt class="docutils literal">yield</tt> statement.</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id17">Motivation</a></h1>
<p>When a producer function has a hard enough job that it requires maintaining
state between values produced, most programming languages offer no pleasant and
efficient solution beyond adding a callback function to the producer's argument
list, to be called with each value produced.</p>
<p>For example, <tt class="docutils literal">tokenize.py</tt> in the standard library takes this approach: the
caller must pass a <em>tokeneater</em> function to <tt class="docutils literal">tokenize()</tt>, called whenever
<tt class="docutils literal">tokenize()</tt> finds the next token.  This allows tokenize to be coded in a
natural way, but programs calling tokenize are typically convoluted by the need
to remember between callbacks which token(s) were seen last.  The <em>tokeneater</em>
function in <tt class="docutils literal">tabnanny.py</tt> is a good example of that, maintaining a state
machine in global variables, to remember across callbacks what it has already
seen and what it hopes to see next.  This was difficult to get working
correctly, and is still difficult for people to understand.  Unfortunately,
that's typical of this approach.</p>
<p>An alternative would have been for tokenize to produce an entire parse of the
Python program at once, in a large list.  Then tokenize clients could be
written in a natural way, using local variables and local control flow (such as
loops and nested if statements) to keep track of their state.  But this isn't
practical:  programs can be very large, so no a priori bound can be placed on
the memory needed to materialize the whole parse; and some tokenize clients
only want to see whether something specific appears early in the program (e.g.,
a future statement, or, as is done in IDLE, just the first indented statement),
and then parsing the whole program first is a severe waste of time.</p>
<p>Another alternative would be to make tokenize an iterator [1], delivering the
next token whenever its <tt class="docutils literal">.next()</tt> method is invoked.  This is pleasant for the
caller in the same way a large list of results would be, but without the memory
and &quot;what if I want to get out early?&quot; drawbacks.  However, this shifts the
burden on tokenize to remember <em>its</em> state between <tt class="docutils literal">.next()</tt> invocations, and
the reader need only glance at <tt class="docutils literal">tokenize.tokenize_loop()</tt> to realize what a
horrid chore that would be.  Or picture a recursive algorithm for producing the
nodes of a general tree structure:  to cast that into an iterator framework
requires removing the recursion manually and maintaining the state of the
traversal by hand.</p>
<p>A fourth option is to run the producer and consumer in separate threads.  This
allows both to maintain their states in natural ways, and so is pleasant for
both.  Indeed, Demo/threads/Generator.py in the Python source distribution
provides a usable synchronized-communication class for doing that in a general
way.  This doesn't work on platforms without threads, though, and is very slow
on platforms that do (compared to what is achievable without threads).</p>
<p>A final option is to use the Stackless [2] [3] variant implementation of Python
instead, which supports lightweight coroutines.  This has much the same
programmatic benefits as the thread option, but is much more efficient.
However, Stackless is a controversial rethinking of the Python core, and it may
not be possible for Jython to implement the same semantics.  This PEP isn't the
place to debate that, so suffice it to say here that generators provide a
useful subset of Stackless functionality in a way that fits easily into the
current CPython implementation, and is believed to be relatively
straightforward for other Python implementations.</p>
<p>That exhausts the current alternatives.  Some other high-level languages
provide pleasant solutions, notably iterators in Sather [4], which were
inspired by iterators in CLU; and generators in Icon [5], a novel language
where every expression <em>is a generator</em>.  There are differences among these,
but the basic idea is the same:  provide a kind of function that can return an
intermediate result (&quot;the next value&quot;) to its caller, but maintaining the
function's local state so that the function can be resumed again right where it
left off.  A very simple example:</p>
<pre class="literal-block">
def fib():
    a, b = 0, 1
    while 1:
       yield b
       a, b = b, a+b
</pre>
<p>When <tt class="docutils literal">fib()</tt> is first invoked, it sets <em>a</em> to 0 and <em>b</em> to 1, then yields <em>b</em>
back to its caller.  The caller sees 1.  When <tt class="docutils literal">fib</tt> is resumed, from its
point of view the <tt class="docutils literal">yield</tt> statement is really the same as, say, a <tt class="docutils literal">print</tt>
statement:  <tt class="docutils literal">fib</tt> continues after the yield with all local state intact. <em>a</em>
and <em>b</em> then become 1 and 1, and <tt class="docutils literal">fib</tt> loops back to the <tt class="docutils literal">yield</tt>, yielding
1 to its invoker.  And so on.  From <tt class="docutils literal">fib</tt>'s point of view it's just
delivering a sequence of results, as if via callback.  But from its caller's
point of view, the <tt class="docutils literal">fib</tt> invocation is an iterable object that can be resumed
at will.  As in the thread approach, this allows both sides to be coded in the
most natural ways; but unlike the thread approach, this can be done efficiently
and on all platforms.  Indeed, resuming a generator should be no more expensive
than a function call.</p>
<p>The same kind of approach applies to many producer/consumer functions. For
example, <tt class="docutils literal">tokenize.py</tt> could yield the next token instead of invoking a
callback function with it as argument, and tokenize clients could iterate over
the tokens in a natural way:  a Python generator is a kind of Python
iterator <a class="footnote-reference" href="#id7" id="id1">[1]</a>, but of an especially powerful kind.</p>
</div>
<div class="section" id="specification-yield">
<h1><a class="toc-backref" href="#id18">Specification:  Yield</a></h1>
<p>A new statement is introduced:</p>
<pre class="literal-block">
yield_stmt:    &quot;yield&quot; expression_list
</pre>
<p><tt class="docutils literal">yield</tt> is a new keyword, so a <tt class="docutils literal">future</tt> statement <a class="footnote-reference" href="#id14" id="id2">[8]</a> is needed to phase
this in: in the initial release, a module desiring to use generators must
include the line:</p>
<pre class="literal-block">
from __future__ import generators
</pre>
<p>near the top (see <a class="reference external" href="/dev/peps/pep-0236">PEP 236</a> <a class="footnote-reference" href="#id14" id="id3">[8]</a>) for details).  Modules using the identifier
<tt class="docutils literal">yield</tt> without a <tt class="docutils literal">future</tt> statement will trigger warnings. In the
following release, <tt class="docutils literal">yield</tt> will be a language keyword and the <tt class="docutils literal">future</tt>
statement will no longer be needed.</p>
<p>The <tt class="docutils literal">yield</tt> statement may only be used inside functions.  A function that
contains a <tt class="docutils literal">yield</tt> statement is called a generator function.  A generator
function is an ordinary function object in all respects, but has the new
<tt class="docutils literal">CO_GENERATOR</tt> flag set in the code object's co_flags member.</p>
<p>When a generator function is called, the actual arguments are bound to
function-local formal argument names in the usual way, but no code in the body
of the function is executed.  Instead a generator-iterator object is returned;
this conforms to the iterator protocol <a class="footnote-reference" href="#id12" id="id4">[6]</a>, so in particular can be used in
for-loops in a natural way.  Note that when the intent is clear from context,
the unqualified name &quot;generator&quot; may be used to refer either to a
generator-function or a generator-iterator.</p>
<p>Each time the <tt class="docutils literal">.next()</tt> method of a generator-iterator is invoked, the code
in the body of the generator-function is executed until a <tt class="docutils literal">yield</tt> or
<tt class="docutils literal">return</tt> statement (see below) is encountered, or until the end of the body
is reached.</p>
<p>If a <tt class="docutils literal">yield</tt> statement is encountered, the state of the function is frozen,
and the value of <em>expression_list</em> is returned to <tt class="docutils literal">.next()</tt>'s caller.  By
&quot;frozen&quot; we mean that all local state is retained, including the current
bindings of local variables, the instruction pointer, and the internal
evaluation stack:  enough information is saved so that the next time
<tt class="docutils literal">.next()</tt> is invoked, the function can proceed exactly as if the <tt class="docutils literal">yield</tt>
statement were just another external call.</p>
<p>Restriction:  A <tt class="docutils literal">yield</tt> statement is not allowed in the <tt class="docutils literal">try</tt> clause of a
<tt class="docutils literal">try/finally</tt> construct.  The difficulty is that there's no guarantee the
generator will ever be resumed, hence no guarantee that the finally block will
ever get executed; that's too much a violation of finally's purpose to bear.</p>
<p>Restriction:  A generator cannot be resumed while it is actively running:</p>
<pre class="literal-block">
&gt;&gt;&gt; def g():
...     i = me.next()
...     yield i
&gt;&gt;&gt; me = g()
&gt;&gt;&gt; me.next()
Traceback (most recent call last):
 ...
 File &quot;&lt;string&gt;&quot;, line 2, in g
ValueError: generator already executing
</pre>
</div>
<div class="section" id="specification-return">
<h1><a class="toc-backref" href="#id19">Specification:  Return</a></h1>
<p>A generator function can also contain return statements of the form:</p>
<pre class="literal-block">
return
</pre>
<p>Note that an <em>expression_list</em> is not allowed on return statements in the body
of a generator (although, of course, they may appear in the bodies of
non-generator functions nested within the generator).</p>
<p>When a return statement is encountered, control proceeds as in any function
return, executing the appropriate <tt class="docutils literal">finally</tt> clauses (if any exist).  Then a
<tt class="docutils literal">StopIteration</tt> exception is raised, signalling that the iterator is
exhausted.  A <tt class="docutils literal">StopIteration</tt> exception is also raised if control flows off
the end of the generator without an explicit return.</p>
<p>Note that return means &quot;I'm done, and have nothing interesting to return&quot;, for
both generator functions and non-generator functions.</p>
<p>Note that return isn't always equivalent to raising <tt class="docutils literal">StopIteration</tt>:  the
difference lies in how enclosing <tt class="docutils literal">try/except</tt> constructs are treated. For
example,:</p>
<pre class="literal-block">
&gt;&gt;&gt; def f1():
...     try:
...         return
...     except:
...        yield 1
&gt;&gt;&gt; print list(f1())
[]
</pre>
<p>because, as in any function, <tt class="docutils literal">return</tt> simply exits, but:</p>
<pre class="literal-block">
&gt;&gt;&gt; def f2():
...     try:
...         raise StopIteration
...     except:
...         yield 42
&gt;&gt;&gt; print list(f2())
[42]
</pre>
<p>because <tt class="docutils literal">StopIteration</tt> is captured by a bare <tt class="docutils literal">except</tt>, as is any
exception.</p>
</div>
<div class="section" id="specification-generators-and-exception-propagation">
<h1><a class="toc-backref" href="#id20">Specification:  Generators and Exception Propagation</a></h1>
<p>If an unhandled exception-- including, but not limited to, <tt class="docutils literal">StopIteration</tt>
--is raised by, or passes through, a generator function, then the exception is
passed on to the caller in the usual way, and subsequent attempts to resume the
generator function raise <tt class="docutils literal">StopIteration</tt>.  In other words, an unhandled
exception terminates a generator's useful life.</p>
<p>Example (not idiomatic but to illustrate the point):</p>
<pre class="literal-block">
&gt;&gt;&gt; def f():
...     return 1/0
&gt;&gt;&gt; def g():
...     yield f()  # the zero division exception propagates
...     yield 42   # and we'll never get here
&gt;&gt;&gt; k = g()
&gt;&gt;&gt; k.next()
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
  File &quot;&lt;stdin&gt;&quot;, line 2, in g
  File &quot;&lt;stdin&gt;&quot;, line 2, in f
ZeroDivisionError: integer division or modulo by zero
&gt;&gt;&gt; k.next()  # and the generator cannot be resumed
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
StopIteration
&gt;&gt;&gt;
</pre>
</div>
<div class="section" id="specification-try-except-finally">
<h1><a class="toc-backref" href="#id21">Specification:  Try/Except/Finally</a></h1>
<p>As noted earlier, <tt class="docutils literal">yield</tt> is not allowed in the <tt class="docutils literal">try</tt> clause of a
<tt class="docutils literal">try/finally</tt> construct.  A consequence is that generators should allocate
critical resources with great care.  There is no restriction on <tt class="docutils literal">yield</tt>
otherwise appearing in <tt class="docutils literal">finally</tt> clauses, <tt class="docutils literal">except</tt> clauses, or in the
<tt class="docutils literal">try</tt> clause of a <tt class="docutils literal">try/except</tt> construct:</p>
<pre class="literal-block">
&gt;&gt;&gt; def f():
...     try:
...         yield 1
...         try:
...             yield 2
...             1/0
...             yield 3  # never get here
...         except ZeroDivisionError:
...             yield 4
...             yield 5
...             raise
...         except:
...             yield 6
...         yield 7     # the &quot;raise&quot; above stops this
...     except:
...         yield 8
...     yield 9
...     try:
...         x = 12
...     finally:
...        yield 10
...     yield 11
&gt;&gt;&gt; print list(f())
[1, 2, 4, 5, 8, 9, 10, 11]
&gt;&gt;&gt;
</pre>
</div>
<div class="section" id="example">
<h1><a class="toc-backref" href="#id22">Example</a></h1>
<pre class="literal-block">
# A binary tree class.
class Tree:

    def __init__(self, label, left=None, right=None):
        self.label = label
        self.left = left
        self.right = right

    def __repr__(self, level=0, indent=&quot;    &quot;):
        s = level*indent + `self.label`
        if self.left:
            s = s + &quot;\n&quot; + self.left.__repr__(level+1, indent)
        if self.right:
            s = s + &quot;\n&quot; + self.right.__repr__(level+1, indent)
        return s

    def __iter__(self):
        return inorder(self)

# Create a Tree from a list.
def tree(list):
    n = len(list)
    if n == 0:
        return []
    i = n / 2
    return Tree(list[i], tree(list[:i]), tree(list[i+1:]))

# A recursive generator that generates Tree labels in in-order.
def inorder(t):
    if t:
        for x in inorder(t.left):
            yield x
        yield t.label
        for x in inorder(t.right):
            yield x

# Show it off: create a tree.
t = tree(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;)
# Print the nodes of the tree in in-order.
for x in t:
    print x,
print

# A non-recursive generator.
def inorder(node):
    stack = []
    while node:
        while node.left:
            stack.append(node)
            node = node.left
        yield node.label
        while not node.right:
            try:
                node = stack.pop()
            except IndexError:
                return
            yield node.label
        node = node.right

# Exercise the non-recursive generator.
for x in t:
    print x,
print
</pre>
<p>Both output blocks display:</p>
<pre class="literal-block">
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
</pre>
</div>
<div class="section" id="q-a">
<h1><a class="toc-backref" href="#id23">Q &amp; A</a></h1>
<div class="section" id="why-not-a-new-keyword-instead-of-reusing-def">
<h2><a class="toc-backref" href="#id24">Why not a new keyword instead of reusing <tt class="docutils literal">def</tt>?</a></h2>
<p>See BDFL Pronouncements section below.</p>
</div>
<div class="section" id="why-a-new-keyword-for-yield-why-not-a-builtin-function-instead">
<h2><a class="toc-backref" href="#id25">Why a new keyword for <tt class="docutils literal">yield</tt>?  Why not a builtin function instead?</a></h2>
<p>Control flow is much better expressed via keyword in Python, and yield is a
control construct.  It's also believed that efficient implementation in Jython
requires that the compiler be able to determine potential suspension points at
compile-time, and a new keyword makes that easy.  The CPython reference
implementation also exploits it heavily, to detect which functions <em>are</em>
generator-functions (although a new keyword in place of <tt class="docutils literal">def</tt> would solve
that for CPython -- but people asking the &quot;why a new keyword?&quot; question don't
want any new keyword).</p>
</div>
<div class="section" id="then-why-not-some-other-special-syntax-without-a-new-keyword">
<h2><a class="toc-backref" href="#id26">Then why not some other special syntax without a new keyword?</a></h2>
<p>For example, one of these instead of <tt class="docutils literal">yield 3</tt>:</p>
<pre class="literal-block">
return 3 and continue
return and continue 3
return generating 3
continue return 3
return &gt;&gt; , 3
from generator return 3
return &gt;&gt; 3
return &lt;&lt; 3
&gt;&gt; 3
&lt;&lt; 3
* 3
</pre>
<p>Did I miss one &lt;wink&gt;?  Out of hundreds of messages, I counted three
suggesting such an alternative, and extracted the above from them. It would be
nice not to need a new keyword, but nicer to make <tt class="docutils literal">yield</tt> very clear -- I
don't want to have to <em>deduce</em> that a yield is occurring from making sense of a
previously senseless sequence of keywords or operators.  Still, if this
attracts enough interest, proponents should settle on a single consensus
suggestion, and Guido will Pronounce on it.</p>
</div>
<div class="section" id="why-allow-return-at-all-why-not-force-termination-to-be-spelled-raise-stopiteration">
<h2><a class="toc-backref" href="#id27">Why allow <tt class="docutils literal">return</tt> at all?  Why not force termination to be spelled <tt class="docutils literal">raise StopIteration</tt>?</a></h2>
<p>The mechanics of <tt class="docutils literal">StopIteration</tt> are low-level details, much like the
mechanics of <tt class="docutils literal">IndexError</tt> in Python 2.1:  the implementation needs to do
<em>something</em> well-defined under the covers, and Python exposes these mechanisms
for advanced users.  That's not an argument for forcing everyone to work at
that level, though.  <tt class="docutils literal">return</tt> means &quot;I'm done&quot; in any kind of function, and
that's easy to explain and to use. Note that <tt class="docutils literal">return</tt> isn't always equivalent
to <tt class="docutils literal">raise StopIteration</tt> in try/except construct, either (see the
&quot;Specification: Return&quot; section).</p>
</div>
<div class="section" id="then-why-not-allow-an-expression-on-return-too">
<h2><a class="toc-backref" href="#id28">Then why not allow an expression on <tt class="docutils literal">return</tt> too?</a></h2>
<p>Perhaps we will someday.  In Icon, <tt class="docutils literal">return expr</tt> means both &quot;I'm done&quot;, and
&quot;but I have one final useful value to return too, and this is it&quot;.  At the
start, and in the absence of compelling uses for <tt class="docutils literal">return expr</tt>, it's simply
cleaner to use <tt class="docutils literal">yield</tt> exclusively for delivering values.</p>
</div>
</div>
<div class="section" id="bdfl-pronouncements">
<h1><a class="toc-backref" href="#id29">BDFL Pronouncements</a></h1>
<div class="section" id="issue">
<h2><a class="toc-backref" href="#id30">Issue</a></h2>
<p>Introduce another new keyword (say, <tt class="docutils literal">gen</tt> or <tt class="docutils literal">generator</tt>) in place
of <tt class="docutils literal">def</tt>, or otherwise alter the syntax, to distinguish generator-functions
from non-generator functions.</p>
</div>
<div class="section" id="con">
<h2><a class="toc-backref" href="#id31">Con</a></h2>
<p>In practice (how you think about them), generators <em>are</em> functions, but
with the twist that they're resumable.  The mechanics of how they're set up
is a comparatively minor technical issue, and introducing a new keyword would
unhelpfully overemphasize the mechanics of how generators get started (a vital
but tiny part of a generator's life).</p>
</div>
<div class="section" id="pro">
<h2><a class="toc-backref" href="#id32">Pro</a></h2>
<p>In reality (how you think about them), generator-functions are actually
factory functions that produce generator-iterators as if by magic.  In this
respect they're radically different from non-generator functions, acting more
like a constructor than a function, so reusing <tt class="docutils literal">def</tt> is at best confusing.
A <tt class="docutils literal">yield</tt> statement buried in the body is not enough warning that the
semantics are so different.</p>
</div>
<div class="section" id="bdfl">
<h2><a class="toc-backref" href="#id33">BDFL</a></h2>
<p><tt class="docutils literal">def</tt> it stays.  No argument on either side is totally convincing, so I
have consulted my language designer's intuition.  It tells me that the syntax
proposed in the PEP is exactly right - not too hot, not too cold.  But, like
the Oracle at Delphi in Greek mythology, it doesn't tell me why, so I don't
have a rebuttal for the arguments against the PEP syntax.  The best I can come
up with (apart from agreeing with the rebuttals ... already made) is &quot;FUD&quot;.
If this had been part of the language from day one, I very much doubt it would
have made Andrew Kuchling's &quot;Python Warts&quot; page.</p>
</div>
</div>
<div class="section" id="reference-implementation">
<h1><a class="toc-backref" href="#id34">Reference Implementation</a></h1>
<p>The current implementation, in a preliminary state (no docs, but well tested
and solid), is part of Python's CVS development tree <a class="footnote-reference" href="#id15" id="id5">[9]</a>.  Using this requires
that you build Python from source.</p>
<p>This was derived from an earlier patch by Neil Schemenauer <a class="footnote-reference" href="#id13" id="id6">[7]</a>.</p>
</div>
<div class="section" id="footnotes-and-references">
<h1><a class="toc-backref" href="#id35">Footnotes and References</a></h1>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="/dev/peps/pep-0234">PEP 234</a>, Iterators, Yee, Van Rossum
<a class="reference external" href="http://www.python.org/dev/peps/pep-0234/">http://www.python.org/dev/peps/pep-0234/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><a class="reference external" href="http://www.stackless.com/">http://www.stackless.com/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><a class="reference external" href="/dev/peps/pep-0219">PEP 219</a>, Stackless Python, McMillan
<a class="reference external" href="http://www.python.org/dev/peps/pep-0219/">http://www.python.org/dev/peps/pep-0219/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td>&quot;Iteration Abstraction in Sather&quot;
Murer, Omohundro, Stoutamire and Szyperski
<a class="reference external" href="http://www.icsi.berkeley.edu/~sather/Publications/toplas.html">http://www.icsi.berkeley.edu/~sather/Publications/toplas.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td><a class="reference external" href="http://www.cs.arizona.edu/icon/">http://www.cs.arizona.edu/icon/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[6]</a></td><td>The concept of iterators is described in <a class="reference external" href="/dev/peps/pep-0234">PEP 234</a>.  See [1] above.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[7]</a></td><td><a class="reference external" href="http://python.ca/nas/python/generator.diff">http://python.ca/nas/python/generator.diff</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[8]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id3">2</a>)</em> <a class="reference external" href="/dev/peps/pep-0236">PEP 236</a>, Back to the __future__, Peters
<a class="reference external" href="http://www.python.org/dev/peps/pep-0236/">http://www.python.org/dev/peps/pep-0236/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[9]</a></td><td>To experiment with this implementation, check out Python from CVS
according to the instructions at <a class="reference external" href="http://sf.net/cvs/?group_id=5470">http://sf.net/cvs/?group_id=5470</a>
Note that the std test <tt class="docutils literal">Lib/test/test_generators.py</tt> contains many
examples, including all those in this PEP.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id36">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

