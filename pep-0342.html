<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">342</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Coroutines via Enhanced Generators</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0342.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Guido van Rossum, Phillip J. Eby</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">10-May-2005</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.5</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id1">Introduction</a></li>
<li><a class="reference internal" href="#motivation" id="id2">Motivation</a></li>
<li><a class="reference internal" href="#specification-summary" id="id3">Specification Summary</a></li>
<li><a class="reference internal" href="#specification-sending-values-into-generators" id="id4">Specification: Sending Values into Generators</a><ul>
<li><a class="reference internal" href="#new-generator-method-send-value" id="id5">New generator method: <tt class="docutils literal">send(value)</tt></a></li>
<li><a class="reference internal" href="#new-syntax-yield-expressions" id="id6">New syntax: Yield Expressions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification-exceptions-and-cleanup" id="id7">Specification: Exceptions and Cleanup</a><ul>
<li><a class="reference internal" href="#new-syntax-yield-allowed-inside-try-finally" id="id8">New syntax: <tt class="docutils literal">yield</tt> allowed inside <tt class="docutils literal"><span class="pre">try-finally</span></tt></a></li>
<li><a class="reference internal" href="#new-generator-method-throw-type-value-none-traceback-none" id="id9">New generator method: <tt class="docutils literal">throw(type, value=None, traceback=None)</tt></a></li>
<li><a class="reference internal" href="#new-standard-exception-generatorexit" id="id10">New standard exception: <tt class="docutils literal">GeneratorExit</tt></a></li>
<li><a class="reference internal" href="#new-generator-method-close" id="id11">New generator method: <tt class="docutils literal">close()</tt></a></li>
<li><a class="reference internal" href="#new-generator-method-del" id="id12">New generator method: __del__()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#optional-extensions" id="id13">Optional Extensions</a><ul>
<li><a class="reference internal" href="#the-extended-continue-statement" id="id14">The Extended <tt class="docutils literal">continue</tt> Statement</a></li>
</ul>
</li>
<li><a class="reference internal" href="#open-issues" id="id15">Open Issues</a></li>
<li><a class="reference internal" href="#examples" id="id16">Examples</a></li>
<li><a class="reference internal" href="#reference-implementation" id="id17">Reference Implementation</a></li>
<li><a class="reference internal" href="#acknowledgements" id="id18">Acknowledgements</a></li>
<li><a class="reference internal" href="#references" id="id19">References</a></li>
<li><a class="reference internal" href="#copyright" id="id20">Copyright</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id1">Introduction</a></h1>
<p>This PEP proposes some enhancements to the API and syntax of generators, to
make them usable as simple coroutines.  It is basically a combination of ideas
from these two PEPs, which may be considered redundant if this PEP is
accepted:</p>
<ul class="simple">
<li><a class="reference external" href="/dev/peps/pep-0288">PEP 288</a>, Generators Attributes and Exceptions.  The current PEP covers its
second half, generator exceptions (in fact the <tt class="docutils literal">throw()</tt> method name was
taken from <a class="reference external" href="/dev/peps/pep-0288">PEP 288</a>).  <a class="reference external" href="/dev/peps/pep-0342">PEP 342</a> replaces generator attributes, however, with a
concept from an earlier revision of <a class="reference external" href="/dev/peps/pep-0288">PEP 288</a>, the <em>yield expression</em>.</li>
<li><a class="reference external" href="/dev/peps/pep-0325">PEP 325</a>, Resource-Release Support for Generators.  <a class="reference external" href="/dev/peps/pep-0342">PEP 342</a> ties up a few
loose ends in the <a class="reference external" href="/dev/peps/pep-0325">PEP 325</a> spec, to make it suitable for actual
implementation.</li>
</ul>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id2">Motivation</a></h1>
<p>Coroutines are a natural way of expressing many algorithms, such as
simulations, games, asynchronous I/O, and other forms of event-driven
programming or co-operative multitasking.  Python's generator functions are
almost coroutines -- but not quite -- in that they allow pausing execution to
produce a value, but do not provide for values or exceptions to be passed in
when execution resumes.  They also do not allow execution to be paused within
the <tt class="docutils literal">try</tt> portion of <tt class="docutils literal">try/finally</tt> blocks, and therefore make it difficult
for an aborted coroutine to clean up after itself.</p>
<p>Also, generators cannot yield control while other functions are executing,
unless those functions are themselves expressed as generators, and the outer
generator is written to yield in response to values yielded by the inner
generator.  This complicates the implementation of even relatively simple use
cases like asynchronous communications, because calling any functions either
requires the generator to <em>block</em> (i.e. be unable to yield control), or else a
lot of boilerplate looping code must be added around every needed function
call.</p>
<p>However, if it were possible to pass values or exceptions <em>into</em> a generator at
the point where it was suspended, a simple co-routine scheduler or <em>trampoline
function</em> would let coroutines <em>call</em> each other without blocking -- a
tremendous boon for asynchronous applications.  Such applications could then
write co-routines to do non-blocking socket I/O by yielding control to an I/O
scheduler until data has been sent or becomes available.  Meanwhile, code that
performs the I/O would simply do something like this:</p>
<pre class="literal-block">
data = (yield nonblocking_read(my_socket, nbytes))
</pre>
<p>in order to pause execution until the <tt class="docutils literal">nonblocking_read()</tt> coroutine produced
a value.</p>
<p>In other words, with a few relatively minor enhancements to the language and to
the implementation of the generator-iterator type, Python will be able to
support performing asynchronous operations without needing to write the entire
application as a series of callbacks, and without requiring the use of
resource-intensive threads for programs that need hundreds or even thousands of
co-operatively multitasking pseudothreads.  Thus, these enhancements will give
standard Python many of the benefits of the Stackless Python fork, without
requiring any significant modification to the CPython core or its APIs.  In
addition, these enhancements should be readily implementable by any Python
implementation (such as Jython) that already supports generators.</p>
</div>
<div class="section" id="specification-summary">
<h1><a class="toc-backref" href="#id3">Specification Summary</a></h1>
<p>By adding a few simple methods to the generator-iterator type, and with two
minor syntax adjustments, Python developers will be able to use generator
functions to implement co-routines and other forms of co-operative
multitasking.  These methods and adjustments are:</p>
<ol class="arabic simple">
<li>Redefine <tt class="docutils literal">yield</tt> to be an expression, rather than a statement. The current
yield statement would become a yield expression whose value is thrown away.
A yield expression's value is <tt class="docutils literal">None</tt> whenever the generator is resumed by
a normal <tt class="docutils literal">next()</tt> call.</li>
<li>Add a new <tt class="docutils literal">send()</tt> method for generator-iterators, which resumes the
generator and <em>sends</em> a value that becomes the result of the current
yield-expression.  The <tt class="docutils literal">send()</tt> method returns the next value yielded by
the generator, or raises <tt class="docutils literal">StopIteration</tt> if the generator exits without
yielding another value.</li>
<li>Add a new <tt class="docutils literal">throw()</tt> method for generator-iterators, which raises an
exception at the point where the generator was paused, and which returns the
next value yielded by the generator, raising <tt class="docutils literal">StopIteration</tt> if the
generator exits without yielding another value.  (If the generator does not
catch the passed-in exception, or raises a different exception, then that
exception propagates to the caller.)</li>
<li>Add a <tt class="docutils literal">close()</tt> method for generator-iterators, which raises
<tt class="docutils literal">GeneratorExit</tt> at the point where the generator was paused.  If the
generator then raises <tt class="docutils literal">StopIteration</tt> (by exiting normally, or due to
already being closed) or <tt class="docutils literal">GeneratorExit</tt> (by not catching the exception),
<tt class="docutils literal">close()</tt> returns to its caller.  If the generator yields a value, a
<tt class="docutils literal">RuntimeError</tt> is raised.  If the generator raises any other exception, it
is propagated to the caller. <tt class="docutils literal">close()</tt> does nothing if the generator has
already exited due to an exception or normal exit.</li>
<li>Add support to ensure that <tt class="docutils literal">close()</tt> is called when a generator iterator
is garbage-collected.</li>
<li>Allow <tt class="docutils literal">yield</tt> to be used in <tt class="docutils literal">try/finally</tt> blocks, since garbage
collection or an explicit <tt class="docutils literal">close()</tt> call would now allow the <tt class="docutils literal">finally</tt>
clause to execute.</li>
</ol>
<p>A prototype patch implementing all of these changes against the current Python
CVS HEAD is available as SourceForge patch #1223381
(<a class="reference external" href="http://python.org/sf/1223381">http://python.org/sf/1223381</a>).</p>
</div>
<div class="section" id="specification-sending-values-into-generators">
<h1><a class="toc-backref" href="#id4">Specification: Sending Values into Generators</a></h1>
<div class="section" id="new-generator-method-send-value">
<h2><a class="toc-backref" href="#id5">New generator method: <tt class="docutils literal">send(value)</tt></a></h2>
<p>A new method for generator-iterators is proposed, called <tt class="docutils literal">send()</tt>.  It
takes exactly one argument, which is the value that should be <em>sent in</em> to
the generator.  Calling <tt class="docutils literal">send(None)</tt> is exactly equivalent to calling a
generator's <tt class="docutils literal">next()</tt> method.  Calling <tt class="docutils literal">send()</tt> with any other value is
the same, except that the value produced by the generator's current
yield expression will be different.</p>
<p>Because generator-iterators begin execution at the top of the generator's
function body, there is no yield expression to receive a value when the
generator has just been created.  Therefore, calling <tt class="docutils literal">send()</tt> with a
non-<tt class="docutils literal">None</tt> argument is prohibited when the generator iterator has just
started, and a <tt class="docutils literal">TypeError</tt> is raised if this occurs (presumably due to a
logic error of some kind).  Thus, before you can communicate with a
coroutine you must first call <tt class="docutils literal">next()</tt> or <tt class="docutils literal">send(None)</tt> to advance its
execution to the first yield expression.</p>
<p>As with the <tt class="docutils literal">next()</tt> method, the <tt class="docutils literal">send()</tt> method returns the next value
yielded by the generator-iterator, or raises <tt class="docutils literal">StopIteration</tt> if the
generator exits normally, or has already exited.  If the generator raises an
uncaught exception, it is propagated to <tt class="docutils literal">send()</tt>'s caller.</p>
</div>
<div class="section" id="new-syntax-yield-expressions">
<h2><a class="toc-backref" href="#id6">New syntax: Yield Expressions</a></h2>
<p>The yield-statement will be allowed to be used on the right-hand side of an
assignment; in that case it is referred to as yield-expression.  The value
of this yield-expression is <tt class="docutils literal">None</tt> unless <tt class="docutils literal">send()</tt> was called with a
non-<tt class="docutils literal">None</tt> argument; see below.</p>
<p>A yield-expression must always be parenthesized except when it occurs at the
top-level expression on the right-hand side of an assignment.  So</p>
<pre class="literal-block">
x = yield 42
x = yield
x = 12 + (yield 42)
x = 12 + (yield)
foo(yield 42)
foo(yield)
</pre>
<p>are all legal, but</p>
<pre class="literal-block">
x = 12 + yield 42
x = 12 + yield
foo(yield 42, 12)
foo(yield, 12)
</pre>
<p>are all illegal.  (Some of the edge cases are motivated by the current
legality of <tt class="docutils literal">yield 12, 42</tt>.)</p>
<p>Note that a yield-statement or yield-expression without an expression is now
legal.  This makes sense: when the information flow in the <tt class="docutils literal">next()</tt> call
is reversed, it should be possible to yield without passing an explicit
value (<tt class="docutils literal">yield</tt> is of course equivalent to <tt class="docutils literal">yield None</tt>).</p>
<p>When <tt class="docutils literal">send(value)</tt> is called, the yield-expression that it resumes will
return the passed-in value.  When <tt class="docutils literal">next()</tt> is called, the resumed
yield-expression will return <tt class="docutils literal">None</tt>.  If the yield-expression is a
yield-statement, this returned value is ignored, similar to ignoring the
value returned by a function call used as a statement.</p>
<p>In effect, a yield-expression is like an inverted function call; the
argument to yield is in fact returned (yielded) from the currently executing
function, and the <em>return value</em> of yield is the argument passed in via
<tt class="docutils literal">send()</tt>.</p>
<p>Note: the syntactic extensions to yield make its use very similar to that in
Ruby.  This is intentional.  Do note that in Python the block passes a value
to the generator using <tt class="docutils literal">send(EXPR)</tt> rather than <tt class="docutils literal">return EXPR</tt>, and the
underlying mechanism whereby control is passed between the generator and the
block is completely different.  Blocks in Python are not compiled into
thunks; rather, <tt class="docutils literal">yield</tt> suspends execution of the generator's frame.  Some
edge cases work differently; in Python, you cannot save the block for later
use, and you cannot test whether there is a block or not. (XXX - this stuff
about blocks seems out of place now, perhaps Guido can edit to clarify.)</p>
</div>
</div>
<div class="section" id="specification-exceptions-and-cleanup">
<h1><a class="toc-backref" href="#id7">Specification: Exceptions and Cleanup</a></h1>
<p>Let a generator object be the iterator produced by calling a generator
function.  Below, <em>g</em> always refers to a generator object.</p>
<div class="section" id="new-syntax-yield-allowed-inside-try-finally">
<h2><a class="toc-backref" href="#id8">New syntax: <tt class="docutils literal">yield</tt> allowed inside <tt class="docutils literal"><span class="pre">try-finally</span></tt></a></h2>
<p>The syntax for generator functions is extended to allow a yield-statement
inside a <tt class="docutils literal"><span class="pre">try-finally</span></tt> statement.</p>
</div>
<div class="section" id="new-generator-method-throw-type-value-none-traceback-none">
<h2><a class="toc-backref" href="#id9">New generator method: <tt class="docutils literal">throw(type, value=None, traceback=None)</tt></a></h2>
<p><tt class="docutils literal">g.throw(type, value, traceback)</tt> causes the specified exception to be
thrown at the point where the generator <em>g</em> is currently suspended (i.e. at
a yield-statement, or at the start of its function body if <tt class="docutils literal">next()</tt> has
not been called yet).  If the generator catches the exception and yields
another value, that is the return value of <tt class="docutils literal">g.throw()</tt>.  If it doesn't
catch the exception, the <tt class="docutils literal">throw()</tt> appears to raise the same exception
passed it (it <em>falls through</em>).  If the generator raises another exception
(this includes the <tt class="docutils literal">StopIteration</tt> produced when it returns) that
exception is raised by the <tt class="docutils literal">throw()</tt> call.  In summary, <tt class="docutils literal">throw()</tt>
behaves like <tt class="docutils literal">next()</tt> or <tt class="docutils literal">send()</tt>, except it raises an exception at the
suspension point.  If the generator is already in the closed state,
<tt class="docutils literal">throw()</tt> just raises the exception it was passed without executing any of
the generator's code.</p>
<p>The effect of raising the exception is exactly as if the statement:</p>
<pre class="literal-block">
raise type, value, traceback
</pre>
<p>was executed at the suspension point.  The type argument must not be
<tt class="docutils literal">None</tt>, and the type and value must be compatible.  If the value is not an
instance of the type, a new exception instance is created using the value,
following the same rules that the <tt class="docutils literal">raise</tt> statement uses to create an
exception instance.  The traceback, if supplied, must be a valid Python
traceback object, or a <tt class="docutils literal">TypeError</tt> occurs.</p>
<p>Note: The name of the <tt class="docutils literal">throw()</tt> method was selected for several reasons.
<tt class="docutils literal">Raise</tt> is a keyword and so cannot be used as a method name.  Unlike
<tt class="docutils literal">raise</tt> (which immediately raises an exception from the current execution
point), <tt class="docutils literal">throw()</tt> first resumes the generator, and only then raises the
exception.  The word <em>throw</em> is suggestive of putting the exception in
another location, and is already associated with exceptions in other
languages.</p>
<p>Alternative method names were considered: <tt class="docutils literal">resolve()</tt>, <tt class="docutils literal">signal()</tt>,
<tt class="docutils literal">genraise()</tt>, <tt class="docutils literal">raiseinto()</tt>, and <tt class="docutils literal">flush()</tt>.  None of these seem to fit
as well as <tt class="docutils literal">throw()</tt>.</p>
</div>
<div class="section" id="new-standard-exception-generatorexit">
<h2><a class="toc-backref" href="#id10">New standard exception: <tt class="docutils literal">GeneratorExit</tt></a></h2>
<p>A new standard exception is defined, <tt class="docutils literal">GeneratorExit</tt>, inheriting from
<tt class="docutils literal">Exception</tt>.  A generator should handle this by re-raising it (or just not
catching it) or by raising <tt class="docutils literal">StopIteration</tt>.</p>
</div>
<div class="section" id="new-generator-method-close">
<h2><a class="toc-backref" href="#id11">New generator method: <tt class="docutils literal">close()</tt></a></h2>
<p><tt class="docutils literal">g.close()</tt> is defined by the following pseudo-code:</p>
<pre class="literal-block">
def close(self):
    try:
        self.throw(GeneratorExit)
    except (GeneratorExit, StopIteration):
        pass
    else:
        raise RuntimeError(&quot;generator ignored GeneratorExit&quot;)
    # Other exceptions are not caught
</pre>
</div>
<div class="section" id="new-generator-method-del">
<h2><a class="toc-backref" href="#id12">New generator method: __del__()</a></h2>
<p><tt class="docutils literal">g.__del__()</tt> is a wrapper for <tt class="docutils literal">g.close()</tt>.  This will be called when
the generator object is garbage-collected (in CPython, this is when its
reference count goes to zero).  If <tt class="docutils literal">close()</tt> raises an exception, a
traceback for the exception is printed to <tt class="docutils literal">sys.stderr</tt> and further
ignored; it is not propagated back to the place that triggered the garbage
collection.  This is consistent with the handling of exceptions in
<tt class="docutils literal">__del__()</tt> methods on class instances.</p>
<p>If the generator object participates in a cycle, <tt class="docutils literal">g.__del__()</tt> may not be
called.  This is the behavior of CPython's current garbage collector.  The
reason for the restriction is that the GC code needs to <em>break</em> a cycle at
an arbitrary point in order to collect it, and from then on no Python code
should be allowed to see the objects that formed the cycle, as they may be
in an invalid state.  Objects <em>hanging off</em> a cycle are not subject to this
restriction.</p>
<p>Note that it is unlikely to see a generator object participate in a cycle in
practice.  However, storing a generator object in a global variable creates
a cycle via the generator frame's <tt class="docutils literal">f_globals</tt> pointer.  Another way to
create a cycle would be to store a reference to the generator object in a
data structure that is passed to the generator as an argument (e.g., if an
object has a method that's a generator, and keeps a reference to a running
iterator created by that method).  Neither of these cases are very likely
given the typical patterns of generator use.</p>
<p>Also, in the CPython implementation of this PEP, the frame object used by
the generator should be released whenever its execution is terminated due to
an error or normal exit.  This will ensure that generators that cannot be
resumed do not remain part of an uncollectable reference cycle.  This allows
other code to potentially use <tt class="docutils literal">close()</tt> in a <tt class="docutils literal">try/finally</tt> or <tt class="docutils literal">with</tt>
block (per <a class="reference external" href="/dev/peps/pep-0343">PEP 343</a>) to ensure that a given generator is properly finalized.</p>
</div>
</div>
<div class="section" id="optional-extensions">
<h1><a class="toc-backref" href="#id13">Optional Extensions</a></h1>
<div class="section" id="the-extended-continue-statement">
<h2><a class="toc-backref" href="#id14">The Extended <tt class="docutils literal">continue</tt> Statement</a></h2>
<p>An earlier draft of this PEP proposed a new <tt class="docutils literal">continue EXPR</tt> syntax for use
in for-loops (carried over from <a class="reference external" href="/dev/peps/pep-0340">PEP 340</a>), that would pass the value of
<em>EXPR</em> into the iterator being looped over. This feature has been withdrawn
for the time being, because the scope of this PEP has been narrowed to focus
only on passing values into generator-iterators, and not other kinds of
iterators.  It was also felt by some on the Python-Dev list that adding new
syntax for this particular feature would be premature at best.</p>
</div>
</div>
<div class="section" id="open-issues">
<h1><a class="toc-backref" href="#id15">Open Issues</a></h1>
<p>Discussion on python-dev has revealed some open issues.  I list them here, with
my preferred resolution and its motivation.  The PEP as currently written
reflects this preferred resolution.</p>
<ol class="arabic">
<li><p class="first">What exception should be raised by <tt class="docutils literal">close()</tt> when the generator yields
another value as a response to the <tt class="docutils literal">GeneratorExit</tt> exception?</p>
<p>I originally chose <tt class="docutils literal">TypeError</tt> because it represents gross misbehavior of
the generator function, which should be fixed by changing the code.  But the
<tt class="docutils literal">with_template</tt> decorator class in <a class="reference external" href="/dev/peps/pep-0343">PEP 343</a> uses <tt class="docutils literal">RuntimeError</tt> for
similar offenses.  Arguably they should all use the same exception.  I'd
rather not introduce a new exception class just for this purpose, since it's
not an exception that I want people to catch: I want it to turn into a
traceback which is seen by the programmer who then fixes the code.  So now I
believe they should both raise <tt class="docutils literal">RuntimeError</tt>. There are some precedents
for that: it's raised by the core Python code in situations where endless
recursion is detected, and for uninitialized objects (and for a variety of
miscellaneous conditions).</p>
</li>
<li><p class="first">Oren Tirosh has proposed renaming the <tt class="docutils literal">send()</tt> method to <tt class="docutils literal">feed()</tt>, for
compatibility with the <em>consumer interface</em> (see
<a class="reference external" href="http://effbot.org/zone/consumer.htm">http://effbot.org/zone/consumer.htm</a> for the specification.)</p>
<p>However, looking more closely at the consumer interface, it seems that the
desired semantics for <tt class="docutils literal">feed()</tt> are different than for <tt class="docutils literal">send()</tt>, because
<tt class="docutils literal">send()</tt> can't be meaningfully called on a just-started generator.  Also,
the consumer interface as currently defined doesn't include handling for
<tt class="docutils literal">StopIteration</tt>.</p>
<p>Therefore, it seems like it would probably be more useful to create a simple
decorator that wraps a generator function to make it conform to the consumer
interface.  For example, it could <em>warm up</em> the generator with an initial
<tt class="docutils literal">next()</tt> call, trap StopIteration, and perhaps even provide <tt class="docutils literal">reset()</tt> by
re-invoking the generator function.</p>
</li>
</ol>
</div>
<div class="section" id="examples">
<h1><a class="toc-backref" href="#id16">Examples</a></h1>
<ol class="arabic">
<li><p class="first">A simple <em>consumer</em> decorator that makes a generator function automatically
advance to its first yield point when initially called:</p>
<pre class="literal-block">
def consumer(func):
    def wrapper(*args,**kw):
        gen = func(*args, **kw)
        gen.next()
        return gen
    wrapper.__name__ = func.__name__
    wrapper.__dict__ = func.__dict__
    wrapper.__doc__  = func.__doc__
    return wrapper
</pre>
</li>
<li><p class="first">An example of using the <em>consumer</em> decorator to create a <em>reverse generator</em>
that receives images and creates thumbnail pages, sending them on to another
consumer.  Functions like this can be chained together to form efficient
processing pipelines of <em>consumers</em> that each can have complex internal
state:</p>
<pre class="literal-block">
&#64;consumer
def thumbnail_pager(pagesize, thumbsize, destination):
    while True:
        page = new_image(pagesize)
        rows, columns = pagesize / thumbsize
        pending = False
        try:
            for row in xrange(rows):
                for column in xrange(columns):
                    thumb = create_thumbnail((yield), thumbsize)
                    page.write(
                        thumb, col*thumbsize.x, row*thumbsize.y )
                    pending = True
        except GeneratorExit:
            # close() was called, so flush any pending output
            if pending:
                destination.send(page)

            # then close the downstream consumer, and exit
            destination.close()
            return
        else:
            # we finished a page full of thumbnails, so send it
            # downstream and keep on looping
            destination.send(page)

&#64;consumer
def jpeg_writer(dirname)::
    fileno = 1
    while True:
        filename = os.path.join(dirname,&quot;page%04d.jpg&quot; % fileno)
        write_jpeg((yield), filename)
        fileno += 1


# Put them together to make a function that makes thumbnail
# pages from a list of images and other parameters.
#
def write_thumbnails(pagesize, thumbsize, images, output_dir):
    pipeline = thumbnail_pager(
        pagesize, thumbsize, jpeg_writer(output_dir)
    )

    for image in images:
        pipeline.send(image)

    pipeline.close()
</pre>
</li>
<li><p class="first">A simple co-routine scheduler or <em>trampoline</em> that lets coroutines <em>call</em>
other coroutines by yielding the coroutine they wish to invoke.  Any
non-generator value yielded by a coroutine is returned to the coroutine that
<em>called</em> the one yielding the value.  Similarly, if a coroutine raises an
exception, the exception is propagated to its <em>caller</em>.  In effect, this
example emulates simple tasklets as are used in Stackless Python, as long as
you use a yield expression to invoke routines that would otherwise <em>block</em>.
This is only a very simple example, and far more sophisticated schedulers
are possible.  (For example, the existing GTasklet framework for Python
(<a class="reference external" href="http://www.gnome.org/~gjc/gtasklet/gtasklets.html">http://www.gnome.org/~gjc/gtasklet/gtasklets.html</a>) and the peak.events
framework (<a class="reference external" href="http://peak.telecommunity.com/">http://peak.telecommunity.com/</a>) already implement similar
scheduling capabilities, but must currently use awkward workarounds for the
inability to pass values or exceptions into generators.)</p>
<pre class="literal-block">
import collections

class Trampoline:
    &quot;&quot;&quot;Manage communications between coroutines&quot;&quot;&quot;

    running = False

    def __init__(self):
        self.queue = collections.deque()

    def add(self, coroutine):
        &quot;&quot;&quot;Request that a coroutine be executed&quot;&quot;&quot;
        self.schedule(coroutine)

    def run(self):
        result = None
        self.running = True
        try:
            while self.running and self.queue::
               func = self.queue.popleft()
               result = func()
            return result
        finally:
            self.running = False

    def stop(self):
        self.running = False

    def schedule(self, coroutine, stack=(), val=None, *exc):
        def resume():
            value = val
            try:
                if exc:
                    value = coroutine.throw(value,*exc)
                else:
                    value = coroutine.send(value)
            except:
                if stack:
                    # send the error back to the &quot;caller&quot;
                    self.schedule(
                        stack[0], stack[1], *sys.exc_info()
                    )
                else:
                    # Nothing left in this pseudothread to
                    # handle it, let it propagate to the
                    # run loop
                    raise

            if isinstance(value, types.GeneratorType):
                # Yielded to a specific coroutine, push the
                # current one on the stack, and call the new
                # one with no args
                self.schedule(value, (coroutine,stack))

            elif stack:
                # Yielded a result, pop the stack and send the
                # value to the caller
                self.schedule(stack[0], stack[1], value)

            # else: this pseudothread has ended

        self.queue.append(resume)
</pre>
</li>
<li><p class="first">A simple <em>echo</em> server, and code to run it using a trampoline (presumes the
existence of <tt class="docutils literal">nonblocking_read</tt>, <tt class="docutils literal">nonblocking_write</tt>, and other I/O
coroutines, that e.g. raise <tt class="docutils literal">ConnectionLost</tt> if the connection is
closed):</p>
<pre class="literal-block">
# coroutine function that echos data back on a connected
# socket
#
def echo_handler(sock):
    while True:
        try:
            data = yield nonblocking_read(sock)
            yield nonblocking_write(sock, data)
        except ConnectionLost:
            pass  # exit normally if connection lost

# coroutine function that listens for connections on a
# socket, and then launches a service &quot;handler&quot; coroutine
# to service the connection
#
def listen_on(trampoline, sock, handler):
    while True:
        # get the next incoming connection
        connected_socket = yield nonblocking_accept(sock)

        # start another coroutine to handle the connection
        trampoline.add( handler(connected_socket) )

# Create a scheduler to manage all our coroutines
t = Trampoline()

# Create a coroutine instance to run the echo_handler on
# incoming connections
#
server = listen_on(
    t, listening_socket(&quot;localhost&quot;,&quot;echo&quot;), echo_handler
)

# Add the coroutine to the scheduler
t.add(server)

# loop forever, accepting connections and servicing them
# &quot;in parallel&quot;
#
t.run()
</pre>
</li>
</ol>
</div>
<div class="section" id="reference-implementation">
<h1><a class="toc-backref" href="#id17">Reference Implementation</a></h1>
<p>A prototype patch implementing all of the features described in this PEP is
available as SourceForge patch #1223381 (<a class="reference external" href="http://python.org/sf/1223381">http://python.org/sf/1223381</a>).</p>
<p>This patch was committed to CVS 01-02 August 2005.</p>
</div>
<div class="section" id="acknowledgements">
<h1><a class="toc-backref" href="#id18">Acknowledgements</a></h1>
<p>Raymond Hettinger (<a class="reference external" href="/dev/peps/pep-0288">PEP 288</a>) and Samuele Pedroni (<a class="reference external" href="/dev/peps/pep-0325">PEP 325</a>) first formally
proposed the ideas of communicating values or exceptions into generators, and
the ability to <em>close</em> generators.  Timothy Delaney suggested the title of this
PEP, and Steven Bethard helped edit a previous version.  See also the
Acknowledgements section of <a class="reference external" href="/dev/peps/pep-0340">PEP 340</a>.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id19">References</a></h1>
<p>TBD.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id20">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

