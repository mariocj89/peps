<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">456</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Secure and interchangeable hash algorithm</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0456.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Christian Heimes &lt;christian&#32;&#97;t&#32;python.org&gt;</td>
</tr>
<tr class="field"><th class="field-name">BDFL-Delegate:</th><td class="field-body">Nick Coghlan</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">27-Sep-2013</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.4</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">06-Oct-2013, 14-Nov-2013, 20-Nov-2013</td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2013-November/130400.html">https://mail.python.org/pipermail/python-dev/2013-November/130400.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id28">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id29">Rationale</a></li>
<li><a class="reference internal" href="#requirements-for-a-hash-function" id="id30">Requirements for a hash function</a></li>
<li><a class="reference internal" href="#current-implementation-with-modified-fnv" id="id31">Current implementation with modified FNV</a></li>
<li><a class="reference internal" href="#examined-hashing-algorithms" id="id32">Examined hashing algorithms</a><ul>
<li><a class="reference internal" href="#siphash" id="id33">SipHash</a></li>
<li><a class="reference internal" href="#murmurhash" id="id34">MurmurHash</a></li>
<li><a class="reference internal" href="#cityhash" id="id35">CityHash</a></li>
<li><a class="reference internal" href="#djbx33a" id="id36">DJBX33A</a></li>
<li><a class="reference internal" href="#other" id="id37">Other</a></li>
<li><a class="reference internal" href="#conclusion" id="id38">Conclusion</a></li>
</ul>
</li>
<li><a class="reference internal" href="#small-string-optimization" id="id39">Small string optimization</a></li>
<li><a class="reference internal" href="#c-api-additions" id="id40">C API additions</a><ul>
<li><a class="reference internal" href="#hash-secret" id="id41">hash secret</a></li>
<li><a class="reference internal" href="#hash-function-definition" id="id42">hash function definition</a></li>
<li><a class="reference internal" href="#autoconf" id="id43">autoconf</a></li>
<li><a class="reference internal" href="#hash-function-selection" id="id44">hash function selection</a></li>
</ul>
</li>
<li><a class="reference internal" href="#python-api-addition" id="id45">Python API addition</a><ul>
<li><a class="reference internal" href="#sys-module" id="id46">sys module</a></li>
</ul>
</li>
<li><a class="reference internal" href="#necessary-modifications-to-c-code" id="id47">Necessary modifications to C code</a><ul>
<li><a class="reference internal" href="#py-hashbytes-objects-object-c" id="id48">_Py_HashBytes() (Objects/object.c)</a></li>
<li><a class="reference internal" href="#bytes-hash-objects-bytesobject-c" id="id49">bytes_hash() (Objects/bytesobject.c)</a></li>
<li><a class="reference internal" href="#memory-hash-objects-memoryobject-c" id="id50">memory_hash() (Objects/memoryobject.c)</a></li>
<li><a class="reference internal" href="#unicode-hash-objects-unicodeobject-c" id="id51">unicode_hash() (Objects/unicodeobject.c)</a></li>
<li><a class="reference internal" href="#generic-hash-modules-datetimemodule-c" id="id52">generic_hash() (Modules/_datetimemodule.c)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#performance" id="id53">Performance</a><ul>
<li><a class="reference internal" href="#hash-value-distribution" id="id54">Hash value distribution</a></li>
<li><a class="reference internal" href="#typical-length" id="id55">Typical length</a></li>
<li><a class="reference internal" href="#grand-unified-python-benchmark-suite" id="id56">Grand Unified Python Benchmark Suite</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility" id="id57">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#alternative-counter-measures-against-hash-collision-dos" id="id58">Alternative counter measures against hash collision DoS</a></li>
<li><a class="reference internal" href="#discussion" id="id59">Discussion</a><ul>
<li><a class="reference internal" href="#pluggable" id="id60">Pluggable</a></li>
<li><a class="reference internal" href="#non-aligned-memory-access" id="id61">Non-aligned memory access</a></li>
<li><a class="reference internal" href="#ascii-str-bytes-hash-collision" id="id62">ASCII str / bytes hash collision</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references" id="id63">References</a></li>
<li><a class="reference internal" href="#copyright" id="id64">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id28">Abstract</a></h1>
<p>This PEP proposes SipHash as default string and bytes hash algorithm to properly
fix hash randomization once and for all. It also proposes modifications to
Python's C code in order to unify the hash code and to make it easily
interchangeable.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id29">Rationale</a></h1>
<p>Despite the last attempt <a class="citation-reference" href="#issue13703" id="id1">[issue13703]</a> CPython is still vulnerable to hash
collision DoS attacks <a class="citation-reference" href="#c3" id="id2">[29c3]</a> <a class="citation-reference" href="#issue14621" id="id3">[issue14621]</a>. The current hash algorithm and
its randomization is not resilient against attacks. Only a proper
cryptographic hash function prevents the extraction of secret randomization
keys. Although no practical attack against a Python-based service has been
seen yet, the weakness has to be fixed. Jean-Philippe Aumasson and Daniel
J. Bernstein have already shown how the seed for the current implementation
can be recovered <a class="citation-reference" href="#poc" id="id4">[poc]</a>.</p>
<p>Furthermore, the current hash algorithm is hard-coded and implemented multiple
times for bytes and three different Unicode representations UCS1, UCS2 and
UCS4. This makes it impossible for embedders to replace it with a different
implementation without patching and recompiling large parts of the interpreter.
Embedders may want to choose a more suitable hash function.</p>
<p>Finally the current implementation code does not perform well. In the common
case it only processes one or two bytes per cycle. On a modern 64-bit processor
the code can easily be adjusted to deal with eight bytes at once.</p>
<p>This PEP proposes three major changes to the hash code for strings and bytes:</p>
<ul class="simple">
<li>SipHash <a class="citation-reference" href="#sip" id="id5">[sip]</a> is introduced as default hash algorithm. It is fast and small
despite its cryptographic properties. Due to the fact that it was designed
by well known security and crypto experts, it is safe to assume that its
secure for the near future.</li>
<li>The existing FNV code is kept for platforms without a 64-bit data type. The
algorithm is optimized to process larger chunks per cycle.</li>
<li>Calculation of the hash of strings and bytes is moved into a single API
function instead of multiple specialized implementations in
<tt class="docutils literal">Objects/object.c</tt> and <tt class="docutils literal">Objects/unicodeobject.c</tt>. The function takes a
void pointer plus length and returns the hash for it.</li>
<li>The algorithm can be selected at compile time. FNV is guaranteed to exist
on all platforms. SipHash is available on the majority of modern systems.</li>
</ul>
</div>
<div class="section" id="requirements-for-a-hash-function">
<h1><a class="toc-backref" href="#id30">Requirements for a hash function</a></h1>
<ul class="simple">
<li>It MUST be able to hash arbitrarily large blocks of memory from 1 byte up
to the maximum <tt class="docutils literal">ssize_t</tt> value.</li>
<li>It MUST produce at least 32 bits on 32-bit platforms and at least 64 bits
on 64-bit platforms. (Note: Larger outputs can be compressed with e.g.
<tt class="docutils literal">v ^ (v &gt;&gt; 32)</tt>.)</li>
<li>It MUST support hashing of unaligned memory in order to support
hash(memoryview).</li>
<li>It is highly RECOMMENDED that the length of the input influences the
outcome, so that <tt class="docutils literal"><span class="pre">hash(b'\00')</span> != <span class="pre">hash(b'\x00\x00')</span></tt>.</li>
</ul>
<p>The internal interface code between the hash function and the tp_hash slots
implements special cases for zero length input and a return value of <tt class="docutils literal"><span class="pre">-1</span></tt>.
An input of length <tt class="docutils literal">0</tt> is mapped to hash value <tt class="docutils literal">0</tt>. The output <tt class="docutils literal"><span class="pre">-1</span></tt>
is mapped to <tt class="docutils literal"><span class="pre">-2</span></tt>.</p>
</div>
<div class="section" id="current-implementation-with-modified-fnv">
<h1><a class="toc-backref" href="#id31">Current implementation with modified FNV</a></h1>
<p>CPython currently uses a variant of the Fowler-Noll-Vo hash function
<a class="citation-reference" href="#fnv" id="id6">[fnv]</a>. The variant is has been modified to reduce the amount and cost of hash
collisions for common strings. The first character of the string is added
twice, the first time with a bit shift of 7. The length of the input
string is XOR-ed to the final value. Both deviations from the original FNV
algorithm reduce the amount of hash collisions for short strings.</p>
<p>Recently <a class="citation-reference" href="#issue13703" id="id7">[issue13703]</a> a random prefix and suffix were added as an attempt to
randomize the hash values. In order to protect the hash secret the code still
returns <tt class="docutils literal">0</tt> for zero length input.</p>
<p>C code:</p>
<pre class="literal-block">
Py_uhash_t x;
Py_ssize_t len;
/* p is either 1, 2 or 4 byte type */
unsigned char *p;
Py_UCS2 *p;
Py_UCS4 *p;

if (len == 0)
    return 0;
x = (Py_uhash_t) _Py_HashSecret.prefix;
x ^= (Py_uhash_t) *p &lt;&lt; 7;
for (i = 0; i &lt; len; i++)
    x = (1000003 * x) ^ (Py_uhash_t) *p++;
x ^= (Py_uhash_t) len;
x ^= (Py_uhash_t) _Py_HashSecret.suffix;
return x;
</pre>
<p>Which roughly translates to Python:</p>
<pre class="literal-block">
def fnv(p):
    if len(p) == 0:
        return 0

    # bit mask, 2**32-1 or 2**64-1
    mask = 2 * sys.maxsize + 1

    x = hashsecret.prefix
    x = (x ^ (ord(p[0]) &lt;&lt; 7)) &amp; mask
    for c in p:
        x = ((1000003 * x) ^ ord(c)) &amp; mask
    x = (x ^ len(p)) &amp; mask
    x = (x ^ hashsecret.suffix) &amp; mask

    if x == -1:
        x = -2

    return x
</pre>
<p>FNV is a simple multiply and XOR algorithm with no cryptographic properties.
The randomization was not part of the initial hash code, but was added as
counter measure against hash collision attacks as explained in oCERT-2011-003
<a class="citation-reference" href="#ocert" id="id8">[ocert]</a>. Because FNV is not a cryptographic hash algorithm and the dict
implementation is not fortified against side channel analysis, the
randomization secrets can be calculated by a remote attacker. The author of
this PEP strongly believes that the nature of a non-cryptographic hash
function makes it impossible to conceal the secrets.</p>
</div>
<div class="section" id="examined-hashing-algorithms">
<h1><a class="toc-backref" href="#id32">Examined hashing algorithms</a></h1>
<p>The author of this PEP has researched several hashing algorithms that are
considered modern, fast and state-of-the-art.</p>
<div class="section" id="siphash">
<h2><a class="toc-backref" href="#id33">SipHash</a></h2>
<p>SipHash <a class="citation-reference" href="#sip" id="id9">[sip]</a> is a cryptographic pseudo random function with a 128-bit seed
and 64-bit output. It was designed by Jean-Philippe Aumasson and Daniel J.
Bernstein as a fast and secure keyed hash algorithm. It's used by Ruby, Perl,
OpenDNS, Rust, Redis, FreeBSD and more. The C reference implementation has
been released under CC0 license (public domain).</p>
<p>Quote from SipHash's site:</p>
<blockquote>
SipHash is a family of pseudorandom functions (a.k.a. keyed hash
functions) optimized for speed on short messages. Target applications
include network traffic authentication and defense against hash-flooding
DoS attacks.</blockquote>
<p>siphash24 is the recommend variant with best performance. It uses 2 rounds per
message block and 4 finalization rounds. Besides the reference implementation
several other implementations are available. Some are single-shot functions,
others use a Merkle–Damgård construction-like approach with init, update and
finalize functions. Marek Majkowski C implementation csiphash <a class="citation-reference" href="#csiphash" id="id10">[csiphash]</a>
defines the prototype of the function. (Note: <tt class="docutils literal">k</tt> is split up into two
uint64_t):</p>
<pre class="literal-block">
uint64_t siphash24(const void *src, unsigned long src_sz, const char k[16])
</pre>
<p>SipHash requires a 64-bit data type and is not compatible with pure C89
platforms.</p>
</div>
<div class="section" id="murmurhash">
<h2><a class="toc-backref" href="#id34">MurmurHash</a></h2>
<p>MurmurHash <a class="citation-reference" href="#murmur" id="id11">[murmur]</a> is a family of non-cryptographic keyed hash function
developed by Austin Appleby. Murmur3 is the latest and fast variant of
MurmurHash. The C++ reference implementation has been released into public
domain. It features 32- or 128-bit output with a 32-bit seed. (Note: The out
parameter is a buffer with either 1 or 4 bytes.)</p>
<p>Murmur3's function prototypes are:</p>
<pre class="literal-block">
void MurmurHash3_x86_32(const void *key, int len, uint32_t seed, void *out)

void MurmurHash3_x86_128(const void *key, int len, uint32_t seed, void *out)

void MurmurHash3_x64_128(const void *key, int len, uint32_t seed, void *out)
</pre>
<p>The 128-bit variants requires a 64-bit data type and are not compatible with
pure C89 platforms. The 32-bit variant is fully C89-compatible.</p>
<p>Aumasson, Bernstein and Boßlet have shown <a class="citation-reference" href="#sip" id="id12">[sip]</a> <a class="citation-reference" href="#ocert-2012-001" id="id13">[ocert-2012-001]</a> that
Murmur3 is not resilient against hash collision attacks. Therefore, Murmur3
can no longer be considered as secure algorithm. It still may be an
alternative is hash collision attacks are of no concern.</p>
</div>
<div class="section" id="cityhash">
<h2><a class="toc-backref" href="#id35">CityHash</a></h2>
<p>CityHash <a class="citation-reference" href="#city" id="id14">[city]</a> is a family of non-cryptographic hash function developed by
Geoff Pike and Jyrki Alakuijala for Google. The C++ reference implementation
has been released under MIT license. The algorithm is partly based on
MurmurHash and claims to be faster. It supports 64- and 128-bit output with a
128-bit seed as well as 32-bit output without seed.</p>
<p>The relevant function prototype for 64-bit CityHash with 128-bit seed is:</p>
<pre class="literal-block">
uint64 CityHash64WithSeeds(const char *buf, size_t len, uint64 seed0,
                           uint64 seed1)
</pre>
<p>CityHash also offers SSE 4.2 optimizations with CRC32 intrinsic for long
inputs. All variants except CityHash32 require 64-bit data types. CityHash32
uses only 32-bit data types but it doesn't support seeding.</p>
<p>Like MurmurHash Aumasson, Bernstein and Boßlet have shown <a class="citation-reference" href="#sip" id="id15">[sip]</a> a similar
weakness in CityHash.</p>
</div>
<div class="section" id="djbx33a">
<h2><a class="toc-backref" href="#id36">DJBX33A</a></h2>
<p>DJBX33A is a very simple multiplication and addition algorithm by Daniel
J. Bernstein. It is fast and has low setup costs but it's not secure against
hash collision attacks. Its properties make it a viable choice for small
string hashing optimization.</p>
</div>
<div class="section" id="other">
<h2><a class="toc-backref" href="#id37">Other</a></h2>
<p>Crypto algorithms such as HMAC, MD5, SHA-1 or SHA-2 are too slow and have
high setup and finalization costs. For these reasons they are not considered
fit for this purpose. Modern AMD and Intel CPUs have AES-NI (AES instruction
set) <a class="citation-reference" href="#aes-ni" id="id16">[aes-ni]</a> to speed up AES encryption. CMAC with AES-NI might be a viable
option but it's probably too slow for daily operation. (testing required)</p>
</div>
<div class="section" id="conclusion">
<h2><a class="toc-backref" href="#id38">Conclusion</a></h2>
<p>SipHash provides the best combination of speed and security. Developers of
other prominent projects have came to the same conclusion.</p>
</div>
</div>
<div class="section" id="small-string-optimization">
<h1><a class="toc-backref" href="#id39">Small string optimization</a></h1>
<p>Hash functions like SipHash24 have a costly initialization and finalization
code that can dominate speed of the algorithm for very short strings. On the
other hand, Python calculates the hash value of short strings quite often. A
simple and fast function for especially for hashing of small strings can make
a measurable impact on performance. For example, these measurements were taken
during a run of Python's regression tests. Additional measurements of other
code have shown a similar distribution.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="50%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">bytes</th>
<th class="head">hash() calls</th>
<th class="head">portion</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td>18709</td>
<td>0.2%</td>
</tr>
<tr><td>2</td>
<td>737480</td>
<td>9.5%</td>
</tr>
<tr><td>3</td>
<td>636178</td>
<td>17.6%</td>
</tr>
<tr><td>4</td>
<td>1518313</td>
<td>36.7%</td>
</tr>
<tr><td>5</td>
<td>643022</td>
<td>44.9%</td>
</tr>
<tr><td>6</td>
<td>770478</td>
<td>54.6%</td>
</tr>
<tr><td>7</td>
<td>525150</td>
<td>61.2%</td>
</tr>
<tr><td>8</td>
<td>304873</td>
<td>65.1%</td>
</tr>
<tr><td>9</td>
<td>297272</td>
<td>68.8%</td>
</tr>
<tr><td>10</td>
<td>68191</td>
<td>69.7%</td>
</tr>
<tr><td>11</td>
<td>1388484</td>
<td>87.2%</td>
</tr>
<tr><td>12</td>
<td>480786</td>
<td>93.3%</td>
</tr>
<tr><td>13</td>
<td>52730</td>
<td>93.9%</td>
</tr>
<tr><td>14</td>
<td>65309</td>
<td>94.8%</td>
</tr>
<tr><td>15</td>
<td>44245</td>
<td>95.3%</td>
</tr>
<tr><td>16</td>
<td>85643</td>
<td>96.4%</td>
</tr>
<tr><td>Total</td>
<td>7921678</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>However a fast function like DJBX33A is not as secure as SipHash24. A cutoff
at about 5 to 7 bytes should provide a decent safety margin and speed up at
the same time. The PEP's reference implementation provides such a cutoff with
<tt class="docutils literal">Py_HASH_CUTOFF</tt>. The optimization is disabled by default for several
reasons. For one the security implications are unclear yet and should be
thoroughly studied before the optimization is enabled by default. Secondly
the performance benefits vary. On 64 bit Linux system with Intel Core i7
multiple runs of Python's benchmark suite <a class="citation-reference" href="#pybench" id="id17">[pybench]</a> show an average speedups
between 3% and 5% for benchmarks such as django_v2, mako and etree with a
cutoff of 7. Benchmarks with X86 binaries and Windows X86_64 builds on the
same machine are a bit slower with small string optimization.</p>
<p>The state of small string optimization will be assessed during the beta phase
of Python 3.4. The feature will either be enabled with appropriate values
or the code will be removed before beta 2 is released.</p>
</div>
<div class="section" id="c-api-additions">
<h1><a class="toc-backref" href="#id40">C API additions</a></h1>
<p>All C API extension modifications are not part of the stable API.</p>
<div class="section" id="hash-secret">
<h2><a class="toc-backref" href="#id41">hash secret</a></h2>
<p>The <tt class="docutils literal">_Py_HashSecret_t</tt> type of Python 2.6 to 3.3 has two members with either
32- or 64-bit length each. SipHash requires two 64-bit unsigned integers as
keys. The typedef will be changed to a union with a guaranteed size of 24
bytes on all architectures. The union provides a 128 bit random key for
SipHash24 and FNV as well as an additional value of 64 bit for the optional
small string optimization and pyexpat seed. The additional 64 bit seed ensures
that pyexpat or small string optimization cannot reveal bits of the SipHash24
seed.</p>
<p>memory layout on 64 bit systems:</p>
<pre class="literal-block">
cccccccc cccccccc cccccccc  uc -- unsigned char[24]
pppppppp ssssssss ........  fnv -- two Py_hash_t
k0k0k0k0 k1k1k1k1 ........  siphash -- two PY_UINT64_T
........ ........ ssssssss  djbx33a -- 16 bytes padding + one Py_hash_t
........ ........ eeeeeeee  pyexpat XML hash salt
</pre>
<p>memory layout on 32 bit systems:</p>
<pre class="literal-block">
cccccccc cccccccc cccccccc  uc -- unsigned char[24]
ppppssss ........ ........  fnv -- two Py_hash_t
k0k0k0k0 k1k1k1k1 ........  siphash -- two PY_UINT64_T (if available)
........ ........ ssss....  djbx33a -- 16 bytes padding + one Py_hash_t
........ ........ eeee....  pyexpat XML hash salt
</pre>
<p>new type definition:</p>
<pre class="literal-block">
typedef union {
    /* ensure 24 bytes */
    unsigned char uc[24];
    /* two Py_hash_t for FNV */
    struct {
        Py_hash_t prefix;
        Py_hash_t suffix;
    } fnv;
#ifdef PY_UINT64_T
    /* two uint64 for SipHash24 */
    struct {
        PY_UINT64_T k0;
        PY_UINT64_T k1;
    } siphash;
#endif
    /* a different (!) Py_hash_t for small string optimization */
    struct {
        unsigned char padding[16];
        Py_hash_t suffix;
    } djbx33a;
    struct {
        unsigned char padding[16];
        Py_hash_t hashsalt;
    } expat;
} _Py_HashSecret_t;
PyAPI_DATA(_Py_HashSecret_t) _Py_HashSecret;
</pre>
<p><tt class="docutils literal">_Py_HashSecret_t</tt> is initialized in <tt class="docutils literal">Python/random.c:_PyRandom_Init()</tt>
exactly once at startup.</p>
</div>
<div class="section" id="hash-function-definition">
<h2><a class="toc-backref" href="#id42">hash function definition</a></h2>
<p>Implementation:</p>
<pre class="literal-block">
typedef struct {
    /* function pointer to hash function, e.g. fnv or siphash24 */
    Py_hash_t (*const hash)(const void *, Py_ssize_t);
    const char *name;       /* name of the hash algorithm and variant */
    const int hash_bits;    /* internal size of hash value */
    const int seed_bits;    /* size of seed input */
} PyHash_FuncDef;

PyAPI_FUNC(PyHash_FuncDef*) PyHash_GetFuncDef(void);
</pre>
</div>
<div class="section" id="autoconf">
<h2><a class="toc-backref" href="#id43">autoconf</a></h2>
<p>A new test is added to the configure script. The test sets
<tt class="docutils literal">HAVE_ALIGNED_REQUIRED</tt>, when it detects a platform, that requires aligned
memory access for integers. Must current platforms such as X86, X86_64 and
modern ARM don't need aligned data.</p>
<p>A new option <tt class="docutils literal"><span class="pre">--with-hash-algorithm</span></tt> enables the user to select a hash
algorithm in the configure step.</p>
</div>
<div class="section" id="hash-function-selection">
<h2><a class="toc-backref" href="#id44">hash function selection</a></h2>
<p>The value of the macro <tt class="docutils literal">Py_HASH_ALGORITHM</tt> defines which hash algorithm is
used internally. It may be set to any of the three values <tt class="docutils literal">Py_HASH_SIPHASH24</tt>,
<tt class="docutils literal">Py_HASH_FNV</tt> or <tt class="docutils literal">Py_HASH_EXTERNAL</tt>. If <tt class="docutils literal">Py_HASH_ALGORITHM</tt> is not
defined at all, then the best available algorithm is selected. On platforms
wich don't require aligned memory access (<tt class="docutils literal">HAVE_ALIGNED_REQUIRED</tt> not
defined) and an unsigned 64 bit integer type <tt class="docutils literal">PY_UINT64_T</tt>, SipHash24 is
used. On strict C89 platforms without a 64 bit data type, or architectures such
as SPARC, FNV is selected as fallback. A hash algorithm can be selected with
an autoconf option, for example <tt class="docutils literal">./configure <span class="pre">--with-hash-algorithm=fnv</span></tt>.</p>
<p>The value <tt class="docutils literal">Py_HASH_EXTERNAL</tt> allows 3rd parties to provide their own
implementation at compile time.</p>
<p>Implementation:</p>
<pre class="literal-block">
#if Py_HASH_ALGORITHM == Py_HASH_EXTERNAL
extern PyHash_FuncDef PyHash_Func;
#elif Py_HASH_ALGORITHM == Py_HASH_SIPHASH24
static PyHash_FuncDef PyHash_Func = {siphash24, &quot;siphash24&quot;, 64, 128};
#elif Py_HASH_ALGORITHM == Py_HASH_FNV
static PyHash_FuncDef PyHash_Func = {fnv, &quot;fnv&quot;, 8 * sizeof(Py_hash_t),
                                     16 * sizeof(Py_hash_t)};
#endif
</pre>
</div>
</div>
<div class="section" id="python-api-addition">
<h1><a class="toc-backref" href="#id45">Python API addition</a></h1>
<div class="section" id="sys-module">
<h2><a class="toc-backref" href="#id46">sys module</a></h2>
<p>The sys module already has a hash_info struct sequence. More fields are added
to the object to reflect the active hash algorithm and its properties.</p>
<pre class="literal-block">
sys.hash_info(width=64,
              modulus=2305843009213693951,
              inf=314159,
              nan=0,
              imag=1000003,
              # new fields:
              algorithm='siphash24',
              hash_bits=64,
              seed_bits=128,
              cutoff=0)
</pre>
</div>
</div>
<div class="section" id="necessary-modifications-to-c-code">
<h1><a class="toc-backref" href="#id47">Necessary modifications to C code</a></h1>
<div class="section" id="py-hashbytes-objects-object-c">
<h2><a class="toc-backref" href="#id48">_Py_HashBytes() (Objects/object.c)</a></h2>
<p><tt class="docutils literal">_Py_HashBytes</tt> is an internal helper function that provides the hashing
code for bytes, memoryview and datetime classes. It currently implements FNV
for <tt class="docutils literal">unsigned char *</tt>.</p>
<p>The function is moved to Python/pyhash.c and modified to use the hash function
through PyHash_Func.hash(). The function signature is altered to take
a <tt class="docutils literal">const void *</tt> as first argument. <tt class="docutils literal">_Py_HashBytes</tt> also takes care of
special cases: it maps zero length input to <tt class="docutils literal">0</tt> and return value of <tt class="docutils literal"><span class="pre">-1</span></tt>
to <tt class="docutils literal"><span class="pre">-2</span></tt>.</p>
</div>
<div class="section" id="bytes-hash-objects-bytesobject-c">
<h2><a class="toc-backref" href="#id49">bytes_hash() (Objects/bytesobject.c)</a></h2>
<p><tt class="docutils literal">bytes_hash</tt> uses <tt class="docutils literal">_Py_HashBytes</tt> to provide the tp_hash slot function
for bytes objects. The function will continue to use <tt class="docutils literal">_Py_HashBytes</tt>
but withoht a type cast.</p>
</div>
<div class="section" id="memory-hash-objects-memoryobject-c">
<h2><a class="toc-backref" href="#id50">memory_hash() (Objects/memoryobject.c)</a></h2>
<p><tt class="docutils literal">memory_hash</tt> provides the tp_hash slot function for read-only memory
views if the original object is hashable, too. It's the only function that
has to support hashing of unaligned memory segments in the future. The
function will continue to use <tt class="docutils literal">_Py_HashBytes</tt> but withoht a type cast.</p>
</div>
<div class="section" id="unicode-hash-objects-unicodeobject-c">
<h2><a class="toc-backref" href="#id51">unicode_hash() (Objects/unicodeobject.c)</a></h2>
<p><tt class="docutils literal">unicode_hash</tt> provides the tp_hash slot function for unicode. Right now it
implements the FNV algorithm three times for <tt class="docutils literal">unsigned char*</tt>, <tt class="docutils literal">Py_UCS2</tt>
and <tt class="docutils literal">Py_UCS4</tt>. A reimplementation of the function must take care to use the
correct length. Since the macro <tt class="docutils literal">PyUnicode_GET_LENGTH</tt> returns the length
of the unicode string and not its size in octets, the length must be
multiplied with the size of the internal unicode kind:</p>
<pre class="literal-block">
if (PyUnicode_READY(u) == -1)
    return -1;
x = _Py_HashBytes(PyUnicode_DATA(u),
                  PyUnicode_GET_LENGTH(u) * PyUnicode_KIND(u));
</pre>
</div>
<div class="section" id="generic-hash-modules-datetimemodule-c">
<h2><a class="toc-backref" href="#id52">generic_hash() (Modules/_datetimemodule.c)</a></h2>
<p><tt class="docutils literal">generic_hash</tt> acts as a wrapper around <tt class="docutils literal">_Py_HashBytes</tt> for the tp_hash
slots of date, time and datetime types. timedelta objects are hashed by their
state (days, seconds, microseconds) and tzinfo objects are not hashable. The
data members of date, time and datetime types' struct are not <tt class="docutils literal">void*</tt> aligned.
This can easily by fixed with memcpy()ing four to ten bytes to an aligned
buffer.</p>
</div>
</div>
<div class="section" id="performance">
<h1><a class="toc-backref" href="#id53">Performance</a></h1>
<p>In general the <a class="reference external" href="/dev/peps/pep-0456">PEP 456</a> code with SipHash24 is about as fast as the old code
with FNV. SipHash24 seems to make better use of modern compilers, CPUs and
large L1 cache. Several benchmarks show a small speed improvement on 64 bit
CPUs such as Intel Core i5 and Intel Core i7 processes. 32 bit builds and
benchmarks on older CPUs such as an AMD Athlon X2 are slightly slower with
SipHash24. The performance increase or decrease are so small that they should
not affect any application code.</p>
<p>The benchmarks were conducted on CPython default branch revision b08868fd5994
and the PEP repository <a class="citation-reference" href="#pep-456-repos" id="id18">[pep-456-repos]</a>. All upstream changes were merged
into the <a class="reference external" href="/dev/peps/pep-0456">pep-456</a> branch. The &quot;performance&quot; CPU governor was configured and
almost all programs were stopped so the benchmarks were able to utilize
TurboBoost and the CPU caches as much as possible. The raw benchmark results
of multiple machines and platforms are made available at <a class="citation-reference" href="#benchmarks" id="id19">[benchmarks]</a>.</p>
<div class="section" id="hash-value-distribution">
<h2><a class="toc-backref" href="#id54">Hash value distribution</a></h2>
<p>A good distribution of hash values is important for dict and set performance.
Both SipHash24 and FNV take the length of the input into account, so that
strings made up entirely of NULL bytes don't have the same hash value. The
last bytes of the input tend to affect the least significant bits of the hash
value, too. That attribute reduces the amount of hash collisions for strings
with a common prefix.</p>
</div>
<div class="section" id="typical-length">
<h2><a class="toc-backref" href="#id55">Typical length</a></h2>
<p>Serhiy Storchaka has shown in <a class="citation-reference" href="#issue16427" id="id20">[issue16427]</a> that a modified FNV
implementation with 64 bits per cycle is able to process long strings several
times faster than the current FNV implementation.</p>
<p>However, according to statistics <a class="citation-reference" href="#issue19183" id="id21">[issue19183]</a> a typical Python program as
well as the Python test suite have a hash ratio of about 50% small strings
between 1 and 6 bytes. Only 5% of the strings are larger than 16 bytes.</p>
</div>
<div class="section" id="grand-unified-python-benchmark-suite">
<h2><a class="toc-backref" href="#id56">Grand Unified Python Benchmark Suite</a></h2>
<p>Initial tests with an experimental implementation and the Grand Unified Python
Benchmark Suite have shown minimal deviations. The summarized total runtime
of the benchmark is within 1% of the runtime of an unmodified Python 3.4
binary. The tests were run on an Intel i7-2860QM machine with a 64-bit Linux
installation. The interpreter was compiled with GCC 4.7 for 64- and 32-bit.</p>
<p>More benchmarks will be conducted.</p>
</div>
</div>
<div class="section" id="backwards-compatibility">
<h1><a class="toc-backref" href="#id57">Backwards Compatibility</a></h1>
<p>The modifications don't alter any existing API.</p>
<p>The output of <tt class="docutils literal">hash()</tt> for strings and bytes are going to be different. The
hash values for ASCII Unicode and ASCII bytes will stay equal.</p>
</div>
<div class="section" id="alternative-counter-measures-against-hash-collision-dos">
<h1><a class="toc-backref" href="#id58">Alternative counter measures against hash collision DoS</a></h1>
<p>Three alternative countermeasures against hash collisions were discussed in
the past, but are not subject of this PEP.</p>
<ol class="arabic simple">
<li>Marc-Andre Lemburg has suggested that dicts shall count hash collisions. In
case an insert operation causes too many collisions an exception shall be
raised.</li>
<li>Some applications (e.g. PHP) limit the amount of keys for GET and POST
HTTP requests. The approach effectively leverages the impact of a hash
collision attack. (XXX citation needed)</li>
<li>Hash maps have a worst case of O(n) for insertion and lookup of keys. This
results in a quadratic runtime during a hash collision attack. The
introduction of a new and additional data structure with O(log n)
worst case behavior would eliminate the root cause. A data structures like
red-black-tree or prefix trees (trie <a class="citation-reference" href="#trie" id="id22">[trie]</a>) would have other benefits,
too. Prefix trees with stringed keyed can reduce memory usage as common
prefixes are stored within the tree structure.</li>
</ol>
</div>
<div class="section" id="discussion">
<h1><a class="toc-backref" href="#id59">Discussion</a></h1>
<div class="section" id="pluggable">
<h2><a class="toc-backref" href="#id60">Pluggable</a></h2>
<p>The first draft of this PEP made the hash algorithm pluggable at runtime. It
supported multiple hash algorithms in one binary to give the user the
possibility to select a hash algorithm at startup. The approach was considered
an unnecessary complication by several core committers <a class="citation-reference" href="#id27" id="id23">[pluggable]</a>. Subsequent
versions of the PEP aim for compile time configuration.</p>
</div>
<div class="section" id="non-aligned-memory-access">
<h2><a class="toc-backref" href="#id61">Non-aligned memory access</a></h2>
<p>The implementation of SipHash24 were criticized because it ignores the issue
of non-aligned memory and therefore doesn't work on architectures that
requires alignment of integer types. The PEP deliberately neglects this
special case and doesn't support SipHash24 on such platforms. It's simply
not considered worth the trouble until proven otherwise. All major platforms
like X86, X86_64 and ARMv6+ can handle unaligned memory with minimal or even
no speed impact. <a class="citation-reference" href="#alignmentmyth" id="id24">[alignmentmyth]</a></p>
<p>Almost every block is properly aligned anyway. At present bytes' and str's
data are always aligned. Only memoryviews can point to unaligned blocks
under rare circumstances. The PEP implementation is optimized and simplified
for the common case.</p>
</div>
<div class="section" id="ascii-str-bytes-hash-collision">
<h2><a class="toc-backref" href="#id62">ASCII str / bytes hash collision</a></h2>
<p>Since the implementation of <a class="citation-reference" href="#pep-0393" id="id25">[pep-0393]</a> bytes and ASCII text have the same
memory layout. Because of this the new hashing API will keep the invariant:</p>
<pre class="literal-block">
hash(&quot;ascii string&quot;) == hash(b&quot;ascii string&quot;)
</pre>
<p>for ASCII string and ASCII bytes. Equal hash values result in a hash collision
and therefore cause a minor speed penalty for dicts and sets with mixed keys.
The cause of the collision could be removed by e.g. subtracting <tt class="docutils literal">2</tt> from
the hash value of bytes. <tt class="docutils literal"><span class="pre">-2</span></tt> because <tt class="docutils literal"><span class="pre">hash(b&quot;&quot;)</span> == 0</tt> and <tt class="docutils literal"><span class="pre">-1</span></tt> is
reserved. The PEP doesn't change the hash value.</p>
</div>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id63">References</a></h1>
<ul class="simple">
<li>Issue 19183 <a class="citation-reference" href="#issue19183" id="id26">[issue19183]</a> contains a reference implementation.</li>
</ul>
<table class="docutils citation" frame="void" id="c3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[29c3]</a></td><td><a class="reference external" href="http://events.ccc.de/congress/2012/Fahrplan/events/5152.en.html">http://events.ccc.de/congress/2012/Fahrplan/events/5152.en.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="fnv" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[fnv]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function">http://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="sip" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[sip]</td><td><em>(<a class="fn-backref" href="#id5">1</a>, <a class="fn-backref" href="#id9">2</a>, <a class="fn-backref" href="#id12">3</a>, <a class="fn-backref" href="#id15">4</a>)</em> <a class="reference external" href="https://131002.net/siphash/">https://131002.net/siphash/</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ocert" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[ocert]</a></td><td><a class="reference external" href="http://www.nruns.com/_downloads/advisory28122011.pdf">http://www.nruns.com/_downloads/advisory28122011.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ocert-2012-001" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[ocert-2012-001]</a></td><td><a class="reference external" href="http://www.ocert.org/advisories/ocert-2012-001.html">http://www.ocert.org/advisories/ocert-2012-001.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="poc" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[poc]</a></td><td><a class="reference external" href="https://131002.net/siphash/poc.py">https://131002.net/siphash/poc.py</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="issue13703" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[issue13703]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id7">2</a>)</em> <a class="reference external" href="http://bugs.python.org/issue13703">http://bugs.python.org/issue13703</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="issue14621" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[issue14621]</a></td><td><a class="reference external" href="http://bugs.python.org/issue14621">http://bugs.python.org/issue14621</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="issue16427" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id20">[issue16427]</a></td><td><a class="reference external" href="http://bugs.python.org/issue16427">http://bugs.python.org/issue16427</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="issue19183" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[issue19183]</td><td><em>(<a class="fn-backref" href="#id21">1</a>, <a class="fn-backref" href="#id26">2</a>)</em> <a class="reference external" href="http://bugs.python.org/issue19183">http://bugs.python.org/issue19183</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="trie" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id22">[trie]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Trie">http://en.wikipedia.org/wiki/Trie</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="city" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[city]</a></td><td><a class="reference external" href="http://code.google.com/p/cityhash/">http://code.google.com/p/cityhash/</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="murmur" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[murmur]</a></td><td><a class="reference external" href="http://code.google.com/p/smhasher/">http://code.google.com/p/smhasher/</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="csiphash" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[csiphash]</a></td><td><a class="reference external" href="https://github.com/majek/csiphash/">https://github.com/majek/csiphash/</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="pep-0393" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id25">[pep-0393]</a></td><td><a class="reference external" href="http://www.python.org/dev/peps/pep-0393/">http://www.python.org/dev/peps/pep-0393/</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="aes-ni" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[aes-ni]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/AES_instruction_set">http://en.wikipedia.org/wiki/AES_instruction_set</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="id27" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id23">[pluggable]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2013-October/129138.html">https://mail.python.org/pipermail/python-dev/2013-October/129138.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="alignmentmyth" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id24">[alignmentmyth]</a></td><td><a class="reference external" href="http://lemire.me/blog/archives/2012/05/31/data-alignment-for-speed-myth-or-reality/">http://lemire.me/blog/archives/2012/05/31/data-alignment-for-speed-myth-or-reality/</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="pybench" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[pybench]</a></td><td><a class="reference external" href="http://hg.python.org/benchmarks/">http://hg.python.org/benchmarks/</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="benchmarks" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id19">[benchmarks]</a></td><td><a class="reference external" href="https://bitbucket.org/tiran/pep-456-benchmarks/src">https://bitbucket.org/tiran/pep-456-benchmarks/src</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="pep-456-repos" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[pep-456-repos]</a></td><td><a class="reference external" href="http://hg.python.org/features/pep-456">http://hg.python.org/features/pep-456</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id64">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

