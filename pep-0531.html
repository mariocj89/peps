<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">531</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Existence checking operators</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0531.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Nick Coghlan &lt;ncoghlan&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Withdrawn</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">25-Oct-2016</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.7</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">28-Oct-2016</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id10">Abstract</a></li>
<li><a class="reference internal" href="#pep-withdrawal" id="id11">PEP Withdrawal</a></li>
<li><a class="reference internal" href="#relationship-with-other-peps" id="id12">Relationship with other PEPs</a></li>
<li><a class="reference internal" href="#rationale" id="id13">Rationale</a><ul>
<li><a class="reference internal" href="#existence-checking-expressions" id="id14">Existence checking expressions</a></li>
<li><a class="reference internal" href="#existence-checking-assignment" id="id15">Existence checking assignment</a></li>
<li><a class="reference internal" href="#existence-checking-protocol" id="id16">Existence checking protocol</a></li>
<li><a class="reference internal" href="#proposed-symbolic-notation" id="id17">Proposed symbolic notation</a></li>
<li><a class="reference internal" href="#proposed-keywords" id="id18">Proposed keywords</a></li>
</ul>
</li>
<li><a class="reference internal" href="#risks-and-concerns" id="id19">Risks and concerns</a><ul>
<li><a class="reference internal" href="#readability" id="id20">Readability</a></li>
<li><a class="reference internal" href="#magic-syntax" id="id21">Magic syntax</a></li>
<li><a class="reference internal" href="#conceptual-complexity" id="id22">Conceptual complexity</a></li>
</ul>
</li>
<li><a class="reference internal" href="#design-discussion" id="id23">Design Discussion</a><ul>
<li><a class="reference internal" href="#subtleties-in-chaining-existence-checking-expressions" id="id24">Subtleties in chaining existence checking expressions</a></li>
<li><a class="reference internal" href="#ambiguous-interaction-with-conditional-expressions" id="id25">Ambiguous interaction with conditional expressions</a></li>
<li><a class="reference internal" href="#existence-checking-in-other-truth-checking-contexts" id="id26">Existence checking in other truth-checking contexts</a></li>
<li><a class="reference internal" href="#defining-expected-invariant-relations-between-bool-and-exists" id="id27">Defining expected invariant relations between <tt class="docutils literal">__bool__</tt> and <tt class="docutils literal">__exists__</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#limitations" id="id28">Limitations</a><ul>
<li><a class="reference internal" href="#arbitrary-sentinel-objects" id="id29">Arbitrary sentinel objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification" id="id30">Specification</a></li>
<li><a class="reference internal" href="#implementation" id="id31">Implementation</a></li>
<li><a class="reference internal" href="#references" id="id32">References</a></li>
<li><a class="reference internal" href="#copyright" id="id33">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id10">Abstract</a></h1>
<p>Inspired by <a class="reference external" href="/dev/peps/pep-0505">PEP 505</a> and the related discussions, this PEP proposes the addition
of two new control flow operators to Python:</p>
<ul class="simple">
<li>Existence-checking precondition (&quot;exists-then&quot;): <tt class="docutils literal">expr1 <span class="pre">?then</span> expr2</tt></li>
<li>Existence-checking fallback (&quot;exists-else&quot;): <tt class="docutils literal">expr1 <span class="pre">?else</span> expr2</tt></li>
</ul>
<p>as well as the following abbreviations for common existence checking
expressions and statements:</p>
<ul class="simple">
<li>Existence-checking attribute access:
<tt class="docutils literal"><span class="pre">obj?.attr</span></tt> (for <tt class="docutils literal">obj <span class="pre">?then</span> obj.attr</tt>)</li>
<li>Existence-checking subscripting:
<tt class="docutils literal"><span class="pre">obj?[expr]</span></tt> (for <tt class="docutils literal">obj <span class="pre">?then</span> obj[expr]</tt>)</li>
<li>Existence-checking assignment:
<tt class="docutils literal">value <span class="pre">?=</span> expr</tt> (for <tt class="docutils literal">value = value <span class="pre">?else</span> expr</tt>)</li>
</ul>
<p>The common <tt class="docutils literal">?</tt> symbol in these new operator definitions indicates that they
use a new &quot;existence checking&quot; protocol rather than the established
truth-checking protocol used by if statements, while loops, comprehensions,
generator expressions, conditional expressions, logical conjunction, and
logical disjunction.</p>
<p>This new protocol would be made available as <tt class="docutils literal">operator.exists</tt>, with the
following characteristics:</p>
<ul class="simple">
<li>types can define a new <tt class="docutils literal">__exists__</tt> magic method (Python) or
<tt class="docutils literal">tp_exists</tt> slot (C) to override the default behaviour. This optional
method has the same signature and possible return values as <tt class="docutils literal">__bool__</tt>.</li>
<li><tt class="docutils literal">operator.exists(None)</tt> returns <tt class="docutils literal">False</tt></li>
<li><tt class="docutils literal">operator.exists(NotImplemented)</tt> returns <tt class="docutils literal">False</tt></li>
<li><tt class="docutils literal">operator.exists(Ellipsis)</tt> returns <tt class="docutils literal">False</tt></li>
<li><tt class="docutils literal">float</tt>, <tt class="docutils literal">complex</tt> and <tt class="docutils literal">decimal.Decimal</tt> will override the existence
check such that <tt class="docutils literal">NaN</tt> values return <tt class="docutils literal">False</tt> and other values (including
zero values) return <tt class="docutils literal">True</tt></li>
<li>for any other type, <tt class="docutils literal">operator.exists(obj)</tt> returns True by default. Most
importantly, values that evaluate to False in a truth checking context
(zeroes, empty containers) will still evaluate to True in an existence
checking context</li>
</ul>
</div>
<div class="section" id="pep-withdrawal">
<h1><a class="toc-backref" href="#id11">PEP Withdrawal</a></h1>
<p>When posting this PEP for discussion on python-ideas [<a class="reference internal" href="#id7">4</a>], I asked reviewers to
consider 3 high level design questions before moving on to considering the
specifics of this particular syntactic proposal:</p>
<p>1. Do we collectively agree that &quot;existence checking&quot; is a useful
general concept that exists in software development and is distinct
from the concept of &quot;truth checking&quot;?
2. Do we collectively agree that the Python ecosystem would benefit
from an existence checking protocol that permits generalisation of
algorithms (especially short circuiting ones) across different &quot;data
missing&quot; indicators, including those defined in the language
definition, the standard library, and custom user code?
3. Do we collectively agree that it would be easier to use such a
protocol effectively if existence-checking equivalents to the
truth-checking &quot;and&quot; and &quot;or&quot; control flow operators were available?</p>
<p>While the answers to the first question were generally positive, it quickly
became clear that the answer to the second question is &quot;No&quot;.</p>
<p>Steven D'Aprano articulated the counter-argument well in [<a class="reference internal" href="#id8">5</a>], but the general
idea is that when checking for &quot;missing data&quot; sentinels, we're almost always
looking for a <em>specific</em> sentinel value, rather than <em>any</em> sentinel value.</p>
<p><tt class="docutils literal">NotImplemented</tt> exists, for example, due to <tt class="docutils literal">None</tt> being a potentially
legitimate result from overloaded arithmetic operators and exception
handling imposing too much runtime overhead to be useful for operand coercion.</p>
<p>Similarly, <tt class="docutils literal">Ellipsis</tt> exists for multi-dimensional slicing support due to
<tt class="docutils literal">None</tt> already have another meaning in a slicing context (indicating the use
of the default start or stop indices, or the default step size).</p>
<p>In mathematics, the value of <tt class="docutils literal">NaN</tt> is that <em>programmatically</em> it behaves
like a normal value of its type (e.g. exposing all the usual attributes and
methods), while arithmetically it behaves according to the mathematical rules
for handling <tt class="docutils literal">NaN</tt> values.</p>
<p>With that core design concept invalidated, the proposal as a whole doesn't
make sense, and it is accordingly withdrawn.</p>
<p>However, the discussion of the proposal did prompt consideration of a potential
protocol based approach to make the existing <tt class="docutils literal">and</tt>, <tt class="docutils literal">or</tt> and <tt class="docutils literal"><span class="pre">if-else</span></tt>
operators more flexible [<a class="reference internal" href="#id9">6</a>] without introducing any new syntax, so I'll be
writing that up as another possible alternative to <a class="reference external" href="/dev/peps/pep-0505">PEP 505</a>.</p>
</div>
<div class="section" id="relationship-with-other-peps">
<h1><a class="toc-backref" href="#id12">Relationship with other PEPs</a></h1>
<p>While this PEP was inspired by and builds on Mark Haase's excellent work in
putting together <a class="reference external" href="/dev/peps/pep-0505">PEP 505</a>, it ultimately competes with that PEP due to
significant differences in the specifics of the proposed syntax and semantics
for the feature.</p>
<p>It also presents a different perspective on the rationale for the change by
focusing on the benefits to existing Python users as the typical demands of
application and service development activities are genuinely changing. It
isn't an accident that similar features are now appearing in multiple
programming languages, and while it's a good idea for us to learn from how other
language designers are handling the problem, precedents being set elsewhere
are more relevant to <em>how</em> we would go about tackling this problem than they
are to whether or not we think it's a problem we should address in the first
place.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id13">Rationale</a></h1>
<div class="section" id="existence-checking-expressions">
<h2><a class="toc-backref" href="#id14">Existence checking expressions</a></h2>
<p>An increasingly common requirement in modern software development is the need
to work with &quot;semi-structured data&quot;: data where the structure of the data is
known in advance, but pieces of it may be missing at runtime, and the software
manipulating that data is expected to degrade gracefully (e.g. by omitting
results that depend on the missing data) rather than failing outright.</p>
<p>Some particularly common cases where this issue arises are:</p>
<ul class="simple">
<li>handling optional application configuration settings and function parameters</li>
<li>handling external service failures in distributed systems</li>
<li>handling data sets that include some partial records</li>
</ul>
<p>It is the latter two cases that are the primary motivation for this PEP - while
needing to deal with optional configuration settings and parameters is a design
requirement at least as old as Python itself, the rise of public cloud
infrastructure, the development of software systems as collaborative networks
of distributed services, and the availability of large public and private data
sets for analysis means that the ability to degrade operations gracefully in
the face of partial service failures or partial data availability is becoming
an essential feature of modern programming environments.</p>
<p>At the moment, writing such software in Python can be genuinely awkward, as
your code ends up littered with expressions like:</p>
<ul class="simple">
<li><tt class="docutils literal">value1 = expr1.field.of.interest if expr1 is not None else None</tt></li>
<li><tt class="docutils literal">value2 = <span class="pre">expr2[&quot;field&quot;][&quot;of&quot;][&quot;interest&quot;]</span> if expr2 is not None else None</tt></li>
<li><tt class="docutils literal">value3 = expr3 if expr3 is not None else expr4 if expr4 is not None else expr5</tt></li>
</ul>
<p>If these are only occasional, then expanding out to full statement forms may
help improve readability, but if you have 4 or 5 of them in a row (which is a
fairly common situation in data transformation pipelines), then replacing them
with 16 or 20 lines of conditional logic really doesn't help matters.</p>
<p>Expanding the three examples above that way hopefully helps illustrate that:</p>
<pre class="literal-block">
if expr1 is not None:
    value1 = expr1.field.of.interest
else:
    value1 = None
if expr2 is not None:
    value2 = expr2[&quot;field&quot;][&quot;of&quot;][&quot;interest&quot;]
else:
    value2 = None
if expr3 is not None:
    value3 = expr3
else:
    if expr4 is not None:
        value3 = expr4
    else:
        value3 = expr5
</pre>
<p>The combined impact of the proposals in this PEP is to allow the above sample
expressions to instead be written as:</p>
<ul class="simple">
<li><tt class="docutils literal">value1 = <span class="pre">expr1?.field.of.interest</span></tt></li>
<li><tt class="docutils literal">value2 = <span class="pre">expr2?[&quot;field&quot;][&quot;of&quot;][&quot;interest&quot;]</span></tt></li>
<li><tt class="docutils literal">value3 = expr3 <span class="pre">?else</span> expr4 <span class="pre">?else</span> expr5</tt></li>
</ul>
<p>In these forms, almost all of the information presented to the reader is
immediately relevant to the question &quot;What does this code do?&quot;, while the
boilerplate code to handle missing data by passing it through to the output
or falling back to an alternative input, has shrunk to two uses of the <tt class="docutils literal">?</tt>
symbol and two uses of the <tt class="docutils literal"><span class="pre">?else</span></tt> keyword.</p>
<p>In the first two examples, the 31 character boilerplate clause
<tt class="docutils literal">if exprN is not None else None</tt> (minimally 27 characters for a single letter
variable name) has been replaced by a single <tt class="docutils literal">?</tt> character, substantially
improving the signal-to-pattern-noise ratio of the lines (especially if it
encourages the use of more meaningful variable and field names rather than
making them shorter purely for the sake of expression brevity).</p>
<p>In the last example, two instances of the 21 character boilerplate,
<tt class="docutils literal">if exprN is not None</tt> (minimally 17 characters) are replaced with single
characters, again substantially improving the signal-to-pattern-noise ratio.</p>
<p>Furthermore, each of our 5 &quot;subexpressions of potential interest&quot; is included
exactly once, rather than 4 of them needing to be duplicated or pulled out
to a named variable in order to first check if they exist.</p>
<p>The existence checking precondition operator is mainly defined to provide a
clear conceptual basis for the existence checking attribute access and
subscripting operators:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">obj?.attr</span></tt> is roughly equivalent to <tt class="docutils literal">obj <span class="pre">?then</span> obj.attr</tt></li>
<li><tt class="docutils literal"><span class="pre">obj?[expr]</span></tt> is roughly equivalent to <tt class="docutils literal">obj <span class="pre">?then</span> obj[expr]</tt></li>
</ul>
<p>The main semantic difference between the shorthand forms and their expanded
equivalents is that the common subexpression to the left of the existence
checking operator is evaluated only once in the shorthand form (similar to
the benefit offered by augmented assignment statements).</p>
</div>
<div class="section" id="existence-checking-assignment">
<h2><a class="toc-backref" href="#id15">Existence checking assignment</a></h2>
<p>Existence-checking assignment is proposed as a relatively straightforward
expansion of the concepts in this PEP to also cover the common configuration
handling idiom:</p>
<ul class="simple">
<li><tt class="docutils literal">value = value if value is not None else expensive_default()</tt></li>
</ul>
<p>by allowing that to instead be abbreviated as:</p>
<ul class="simple">
<li><tt class="docutils literal">value <span class="pre">?=</span> expensive_default()</tt></li>
</ul>
<p>This is mainly beneficial when the target is a subscript operation or
subattribute, as even without this specific change, the PEP would still
permit this idiom to be updated to:</p>
<ul class="simple">
<li><tt class="docutils literal">value = value <span class="pre">?else</span> expensive_default()</tt></li>
</ul>
<p>The main argument <em>against</em> adding this form is that it's arguably ambiguous
and could mean either:</p>
<ul class="simple">
<li><tt class="docutils literal">value = value <span class="pre">?else</span> expensive_default()</tt>; or</li>
<li><tt class="docutils literal">value = value <span class="pre">?then</span> value.subfield.of.interest</tt></li>
</ul>
<p>The second form isn't at all useful, but if this concern was deemed significant
enough to address while still keeping the augmented assignment feature,
the full keyword could be included in the syntax:</p>
<ul class="simple">
<li><tt class="docutils literal">value <span class="pre">?else=</span> expensive_default()</tt></li>
</ul>
<p>Alternatively, augmented assignment could just be dropped from the current
proposal entirely and potentially reconsidered at a later date.</p>
</div>
<div class="section" id="existence-checking-protocol">
<h2><a class="toc-backref" href="#id16">Existence checking protocol</a></h2>
<p>The existence checking protocol is including in this proposal primarily to
allow for proxy objects (e.g. local representations of remote resources) and
mock objects used in testing to correctly indicate non-existence of target
resources, even though the proxy or mock object itself is not None.</p>
<p>However, with that protocol defined, it then seems natural to expand it to
provide a type independent way of checking for <tt class="docutils literal">NaN</tt> values in numeric types
- at the moment you need to be aware of the exact data type you're working with
(e.g. builtin floats, builtin complex numbers, the decimal module) and use the
appropriate operation (e.g. <tt class="docutils literal">math.isnan</tt>, <tt class="docutils literal">cmath.isnan</tt>,
<tt class="docutils literal"><span class="pre">decimal.getcontext().is_nan()</span></tt>, respectively)</p>
<p>Similarly, it seems reasonable to declare that the other placeholder builtin
singletons, <tt class="docutils literal">Ellipsis</tt> and <tt class="docutils literal">NotImplemented</tt>, also qualify as objects that
represent the absence of data moreso than they represent data.</p>
</div>
<div class="section" id="proposed-symbolic-notation">
<h2><a class="toc-backref" href="#id17">Proposed symbolic notation</a></h2>
<p>Python has historically only had one kind of implied boolean context: truth
checking, which can be invoked directly via the <tt class="docutils literal">bool()</tt> builtin. As this PEP
proposes a new kind of control flow operation based on existence checking rather
than truth checking, it is considered valuable to have a reminder directly
in the code when existence checking is being used rather than truth checking.</p>
<p>The mathematical symbol for existence assertions is U+2203 'THERE EXISTS': <tt class="docutils literal">∃</tt></p>
<p>Accordingly, one possible approach to the syntactic additions proposed in this
PEP would be to use that already defined mathematical notation:</p>
<ul class="simple">
<li><tt class="docutils literal">expr1 ∃then expr2</tt></li>
<li><tt class="docutils literal">expr1 ∃else expr2</tt></li>
<li><tt class="docutils literal"><span class="pre">obj∃.attr</span></tt></li>
<li><tt class="docutils literal"><span class="pre">obj∃[expr]</span></tt></li>
<li><tt class="docutils literal">target ∃= expr</tt></li>
</ul>
<p>However, there are two major problems with that approach, one practical, and
one pedagogical.</p>
<p>The practical problem is the usual one that most keyboards don't offer any easy
way of entering mathematical symbols other than those used in basic arithmetic
(even the symbols appearing in this PEP were ultimately copied &amp; pasted
from <a class="footnote-reference" href="#id6" id="id1">[3]</a> rather than being entered directly).</p>
<p>The pedagogical problem is that the symbols for existence assertions (<tt class="docutils literal">∃</tt>)
and universal assertions (<tt class="docutils literal">∀</tt>) aren't going to be familiar to most people
the way basic arithmetic operators are, so we wouldn't actually be making the
proposed syntax easier to understand by adopting <tt class="docutils literal">∃</tt>.</p>
<p>By contrast, <tt class="docutils literal">?</tt> is one of the few remaining unused ASCII punctuation
characters in Python's syntax, making it available as a candidate syntactic
marker for &quot;this control flow operation is based on an existence check, not a
truth check&quot;.</p>
<p>Taking that path would also have the advantage of aligning Python's syntax
with corresponding syntax in other languages that offer similar features.</p>
<p>Drawing from the existing summary in <a class="reference external" href="/dev/peps/pep-0505">PEP 505</a> and the Wikipedia articles on
the &quot;safe navigation operator <a class="footnote-reference" href="#id4" id="id2">[1]</a> and the &quot;null coalescing operator&quot; <a class="footnote-reference" href="#id5" id="id3">[2]</a>,
we see:</p>
<ul class="simple">
<li>The <tt class="docutils literal"><span class="pre">?.</span></tt> existence checking attribute access syntax precisely aligns with:<ul>
<li>the &quot;safe navigation&quot; attribute access operator in C# (<tt class="docutils literal"><span class="pre">?.</span></tt>)</li>
<li>the &quot;optional chaining&quot; operator in Swift (<tt class="docutils literal"><span class="pre">?.</span></tt>)</li>
<li>the &quot;safe navigation&quot; attribute access operator in Groovy (<tt class="docutils literal"><span class="pre">?.</span></tt>)</li>
<li>the &quot;conditional member access&quot; operator in Dart (<tt class="docutils literal"><span class="pre">?.</span></tt>)</li>
</ul>
</li>
<li>The <tt class="docutils literal"><span class="pre">?[]</span></tt> existence checking attribute access syntax precisely aligns with:<ul>
<li>the &quot;safe navigation&quot; subscript operator in C# (<tt class="docutils literal"><span class="pre">?[]</span></tt>)</li>
<li>the &quot;optional subscript&quot; operator in Swift (<tt class="docutils literal"><span class="pre">?[].</span></tt>)</li>
</ul>
</li>
<li>The <tt class="docutils literal"><span class="pre">?else</span></tt> existence checking fallback syntax semantically aligns with:<ul>
<li>the &quot;null-coalescing&quot; operator in C# (<tt class="docutils literal"><span class="pre">??</span></tt>)</li>
<li>the &quot;null-coalescing&quot; operator in PHP (<tt class="docutils literal"><span class="pre">??</span></tt>)</li>
<li>the &quot;nil-coalescing&quot; operator in Swift (<tt class="docutils literal"><span class="pre">??</span></tt>)</li>
</ul>
</li>
</ul>
<p>To be clear, these aren't the only spelling of these operators used in other
languages, but they're the most common ones, and the <tt class="docutils literal">?</tt> symbol is the most
common syntactic marker by far (presumably prompted by the use of <tt class="docutils literal">?</tt> to
introduce the &quot;then&quot; clause in C-style conditional expressions, which many
of these languages also offer).</p>
</div>
<div class="section" id="proposed-keywords">
<h2><a class="toc-backref" href="#id18">Proposed keywords</a></h2>
<p>Given the symbolic marker <tt class="docutils literal">?</tt>, it would be syntactically unambiguous to spell
the existence checking precondition and fallback operations using the same
keywords as their truth checking counterparts:</p>
<ul class="simple">
<li><tt class="docutils literal">expr1 <span class="pre">?and</span> expr2</tt> (instead of <tt class="docutils literal">expr1 <span class="pre">?then</span> expr2</tt>)</li>
<li><tt class="docutils literal">expr1 <span class="pre">?or</span> expr2</tt> (instead of <tt class="docutils literal">expr1 <span class="pre">?else</span> expr2</tt>)</li>
</ul>
<p>However, while syntactically unambiguous when written, this approach makes
the code incredibly hard to <em>pronounce</em> (What's the pronunciation of &quot;?&quot;?) and
also hard to <em>describe</em> (given reused keywords, there's no obvious shorthand
terms for &quot;existence checking precondition (?and)&quot; and &quot;existence checking
fallback (?or)&quot; that would distinguish them from &quot;logical conjunction (and)&quot;
and &quot;logical disjunction (or)&quot;).</p>
<p>We could try to encourage folks to pronounce the <tt class="docutils literal">?</tt> symbol as &quot;exists&quot;,
making the shorthand names the &quot;exists-and expression&quot; and the
&quot;exists-or expression&quot;, but there'd be no way of guessing those names purely
from seeing them written in a piece of code.</p>
<p>Instead, this PEP takes advantage of the proposed symbolic syntax to introduce
a new keyword (<tt class="docutils literal"><span class="pre">?then</span></tt>) and borrow an existing one (<tt class="docutils literal"><span class="pre">?else</span></tt>) in a way
that allows people to refer to &quot;then expressions&quot; and &quot;else expressions&quot;
without ambiguity.</p>
<p>These keywords also align well with the conditional expressions that are
semantically equivalent to the proposed expressions.</p>
<p>For <tt class="docutils literal"><span class="pre">?else</span></tt> expressions, <tt class="docutils literal">expr1 <span class="pre">?else</span> expr2</tt> is equivalent to:</p>
<pre class="literal-block">
_lhs_result = expr1
_lhs_result if operator.exists(_lhs_result) else expr2
</pre>
<p>Here the parallel is clear, since the <tt class="docutils literal">else expr2</tt> appears at the end of
both the abbreviated and expanded forms.</p>
<p>For <tt class="docutils literal"><span class="pre">?then</span></tt> expressions, <tt class="docutils literal">expr1 <span class="pre">?then</span> expr2</tt> is equivalent to:</p>
<pre class="literal-block">
_lhs_result = expr1
expr2 if operator.exists(_lhs_result) else _lhs_result
</pre>
<p>Here the parallel isn't as immediately obvious due to Python's traditionally
anonymous &quot;then&quot; clauses (introduced by <tt class="docutils literal">:</tt> in <tt class="docutils literal">if</tt> statements and suffixed
by <tt class="docutils literal">if</tt> in conditional expressions), but it's still reasonably clear as long
as you're already familiar with the &quot;if-then-else&quot; explanation of conditional
control flow.</p>
</div>
</div>
<div class="section" id="risks-and-concerns">
<h1><a class="toc-backref" href="#id19">Risks and concerns</a></h1>
<div class="section" id="readability">
<h2><a class="toc-backref" href="#id20">Readability</a></h2>
<p>Learning to read and write the new syntax effectively mainly requires
internalising two concepts:</p>
<ul class="simple">
<li>expressions containing <tt class="docutils literal">?</tt> include an existence check and may short circuit</li>
<li>if <tt class="docutils literal">None</tt> or another &quot;non-existent&quot; value is an expected input, and the
correct handling is to propagate that to the result, then the existence
checking operators are likely what you want</li>
</ul>
<p>Currently, these concepts aren't explicitly represented at the language level,
so it's a matter of learning to recognise and use the various idiomatic
patterns based on conditional expressions and statements.</p>
</div>
<div class="section" id="magic-syntax">
<h2><a class="toc-backref" href="#id21">Magic syntax</a></h2>
<p>There's nothing about <tt class="docutils literal">?</tt> as a syntactic element that inherently suggests
<tt class="docutils literal">is not None</tt> or <tt class="docutils literal">operator.exists</tt>. The main current use of <tt class="docutils literal">?</tt> as a
symbol in Python code is as a trailing suffix in IPython environments to
request help information for the result of the preceding expression.</p>
<p>However, the notion of existence checking really does benefit from a pervasive
visual marker that distinguishes it from truth checking, and that calls for
a single-character symbolic syntax if we're going to do it at all.</p>
</div>
<div class="section" id="conceptual-complexity">
<h2><a class="toc-backref" href="#id22">Conceptual complexity</a></h2>
<p>This proposal takes the currently ad hoc and informal concept of &quot;existence
checking&quot; and elevates it to the status of being a syntactic language feature
with a clearly defined operator protocol.</p>
<p>In many ways, this should actually <em>reduce</em> the overall conceptual complexity
of the language, as many more expectations will map correctly between truth
checking with <tt class="docutils literal">bool(expr)</tt> and existence checking with
<tt class="docutils literal">operator.exists(expr)</tt> than currently map between truth checking and
existence checking with <tt class="docutils literal">expr is not None</tt> (or <tt class="docutils literal">expr is not NotImplemented</tt>
in the context of operand coercion, or the various NaN-checking operations
in mathematical libraries).</p>
<p>As a simple example of the new parallels introduced by this PEP, compare:</p>
<pre class="literal-block">
all_are_true = all(map(bool, iterable))
at_least_one_is_true = any(map(bool, iterable))
all_exist = all(map(operator.exists, iterable))
at_least_one_exists = any(map(operator.exists, iterable))
</pre>
</div>
</div>
<div class="section" id="design-discussion">
<h1><a class="toc-backref" href="#id23">Design Discussion</a></h1>
<div class="section" id="subtleties-in-chaining-existence-checking-expressions">
<h2><a class="toc-backref" href="#id24">Subtleties in chaining existence checking expressions</a></h2>
<p>Similar subtleties arise in chaining existence checking expressions as already
exist in chaining logical operators: the behaviour can be surprising if the
right hand side of one of the expressions in the chain itself returns a
value that doesn't exist.</p>
<p>As a result, <tt class="docutils literal">value = arg1 <span class="pre">?then</span> f(arg1) <span class="pre">?else</span> default()</tt> would be dubious for
essentially the same reason that <tt class="docutils literal">value = cond and expr1 or expr2</tt> is dubious:
the former will evaluate <tt class="docutils literal">default()</tt> if <tt class="docutils literal">f(arg1)</tt> returns <tt class="docutils literal">None</tt>, just
as the latter will evaluate <tt class="docutils literal">expr2</tt> if <tt class="docutils literal">expr1</tt> evaluates to <tt class="docutils literal">False</tt> in
a boolean context.</p>
</div>
<div class="section" id="ambiguous-interaction-with-conditional-expressions">
<h2><a class="toc-backref" href="#id25">Ambiguous interaction with conditional expressions</a></h2>
<p>In the proposal as currently written, the following is a syntax error:</p>
<ul class="simple">
<li><tt class="docutils literal">value = f(arg) if arg <span class="pre">?else</span> default</tt></li>
</ul>
<p>While the following is a valid operation that checks a second condition if the
first doesn't exist rather than merely being false:</p>
<ul class="simple">
<li><tt class="docutils literal">value = expr1 if cond1 <span class="pre">?else</span> cond2 else expr2</tt></li>
</ul>
<p>The expression chaining problem described above means that the argument can be
made that the first operation should instead be equivalent to:</p>
<ul class="simple">
<li><tt class="docutils literal">value = f(arg) if operator.exists(arg) else default</tt></li>
</ul>
<p>requiring the second to be written in the arguably clearer form:</p>
<ul class="simple">
<li><tt class="docutils literal">value = expr1 if (cond1 <span class="pre">?else</span> cond2) else expr2</tt></li>
</ul>
<p>Alternatively, the first form could remain a syntax error, and the existence
checking symbol could instead be attached to the <tt class="docutils literal">if</tt> keyword:</p>
<ul class="simple">
<li><tt class="docutils literal">value = expr1 if? cond else expr2</tt></li>
</ul>
</div>
<div class="section" id="existence-checking-in-other-truth-checking-contexts">
<h2><a class="toc-backref" href="#id26">Existence checking in other truth-checking contexts</a></h2>
<p>The truth-checking protocol is currently used in the following syntactic
constructs:</p>
<ul class="simple">
<li>logical conjunction (and-expressions)</li>
<li>logical disjunction (or-expressions)</li>
<li>conditional expressions (if-else expressions)</li>
<li>if statements</li>
<li>while loops</li>
<li>filter clauses in comprehensions and generator expressions</li>
</ul>
<p>In the current PEP, switching from truth-checking with <tt class="docutils literal">and</tt> and <tt class="docutils literal">or</tt> to
existence-checking is a matter of substituting in the new keywords, <tt class="docutils literal"><span class="pre">?then</span></tt>
and <tt class="docutils literal"><span class="pre">?else</span></tt> in the appropriate places.</p>
<p>For other truth-checking contexts, it proposes either importing and
using the <tt class="docutils literal">operator.exists</tt> API, or else continuing with the current idiom
of checking specifically for <tt class="docutils literal">expr is not None</tt> (or the context appropriate
equivalent).</p>
<p>The simplest possible enhancement in that regard would be to elevate the
proposed <tt class="docutils literal">exists()</tt> API from an operator module function to a new builtin
function.</p>
<p>Alternatively, the <tt class="docutils literal">?</tt> existence checking symbol could be supported as a
modifier on the <tt class="docutils literal">if</tt> and <tt class="docutils literal">while</tt> keywords to indicate the use of an
existence check rather than a truth check.</p>
<p>However, it isn't at all clear that the potential consistency benefits gained
for either suggestion would justify the additional disruption, so they've
currently been omitted from the proposal.</p>
</div>
<div class="section" id="defining-expected-invariant-relations-between-bool-and-exists">
<h2><a class="toc-backref" href="#id27">Defining expected invariant relations between <tt class="docutils literal">__bool__</tt> and <tt class="docutils literal">__exists__</tt></a></h2>
<p>The PEP currently leaves the definition of <tt class="docutils literal">__bool__</tt> on all existing types
unmodified, which ensures the entire proposal remains backwards compatible,
but results in the following cases where <tt class="docutils literal">bool(obj)</tt> returns <tt class="docutils literal">True</tt>, but
the proposed <tt class="docutils literal">operator.exists(obj)</tt> would return <tt class="docutils literal">False</tt>:</p>
<ul class="simple">
<li><tt class="docutils literal">NaN</tt> values for <tt class="docutils literal">float</tt>, <tt class="docutils literal">complex</tt>, and <tt class="docutils literal">decimal.Decimal</tt></li>
<li><tt class="docutils literal">Ellipsis</tt></li>
<li><tt class="docutils literal">NotImplemented</tt></li>
</ul>
<p>The main argument for potentially changing these is that it becomes easier to
reason about potential code behaviour if we have a recommended invariant in
place saying that values which indicate they don't exist in an existence
checking context should also report themselves as being <tt class="docutils literal">False</tt> in a truth
checking context.</p>
<p>Failing to define such an invariant would lead to arguably odd outcomes like
<tt class="docutils literal"><span class="pre">float(&quot;NaN&quot;)</span> <span class="pre">?else</span> 0.0</tt> returning <tt class="docutils literal">0.0</tt> while <tt class="docutils literal"><span class="pre">float(&quot;NaN&quot;)</span> or 0.0</tt>
returns <tt class="docutils literal">NaN</tt>.</p>
</div>
</div>
<div class="section" id="limitations">
<h1><a class="toc-backref" href="#id28">Limitations</a></h1>
<div class="section" id="arbitrary-sentinel-objects">
<h2><a class="toc-backref" href="#id29">Arbitrary sentinel objects</a></h2>
<p>This proposal doesn't attempt to provide syntactic support for the &quot;sentinel
object&quot; idiom, where <tt class="docutils literal">None</tt> is a permitted explicit value, so a
separate sentinel object is defined to indicate missing values:</p>
<pre class="literal-block">
_SENTINEL = object()
def f(obj=_SENTINEL):
    return obj if obj is not _SENTINEL else default_value()
</pre>
<p>This could potentially be supported at the expense of making the existence
protocol definition significantly more complex, both to define and to use:</p>
<ul class="simple">
<li>at the Python layer, <tt class="docutils literal">operator.exists</tt> and <tt class="docutils literal">__exists__</tt> implementations
would return the empty tuple to indicate non-existence, and otherwise return
a singleton tuple containing a reference to the object to be used as the
result of the existence check</li>
<li>at the C layer, <tt class="docutils literal">tp_exists</tt> implementations would return NULL to indicate
non-existence, and otherwise return a <cite>PyObject *</cite> pointer as the
result of the existence check</li>
</ul>
<p>Given that change, the sentinel object idiom could be rewritten as:</p>
<pre class="literal-block">
class Maybe:
  SENTINEL = object()
  def __init__(self, value):
      self._result = (value,) is value is not self.SENTINEL else ()
  def __exists__(self):
      return self._result

def f(obj=Maybe.SENTINEL):
    return Maybe(obj) ?else default_value()
</pre>
<p>However, I don't think cases where the 3 proposed standard sentinel values (i.e.
<tt class="docutils literal">None</tt>, <tt class="docutils literal">Ellipsis</tt> and <tt class="docutils literal">NotImplemented</tt>) can't be used are going to be
anywhere near common enough for the additional protocol complexity and the loss
of symmetry between <tt class="docutils literal">__bool__</tt> and <tt class="docutils literal">__exists__</tt> to be worth it.</p>
</div>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id30">Specification</a></h1>
<p>The Abstract already gives the gist of the proposal and the Rationale gives
some specific examples. If there's enough interest in the basic idea, then a
full specification will need to provide a precise correspondence between the
proposed syntactic sugar and the underlying conditional expressions that is
sufficient to guide the creation of a reference implementation.</p>
<p>...TBD...</p>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id31">Implementation</a></h1>
<p>As with <a class="reference external" href="/dev/peps/pep-0505">PEP 505</a>, actual implementation has been deferred pending in-principle
interest in the idea of adding these operators - the implementation isn't
the hard part of these proposals, the hard part is deciding whether or not
this is a change where the long term benefits for new and existing Python users
outweigh the short term costs involved in the wider ecosystem (including
developers of other implementations, language curriculum developers, and
authors of other Python related educational material) adjusting to the change.</p>
<p>...TBD...</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id32">References</a></h1>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>Wikipedia: Safe navigation operator
(<a class="reference external" href="https://en.wikipedia.org/wiki/Safe_navigation_operator">https://en.wikipedia.org/wiki/Safe_navigation_operator</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>Wikipedia: Null coalescing operator
(<a class="reference external" href="https://en.wikipedia.org/wiki/Null_coalescing_operator">https://en.wikipedia.org/wiki/Null_coalescing_operator</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[3]</a></td><td>FileFormat.info: Unicode Character 'THERE EXISTS' (U+2203)
(<a class="reference external" href="http://www.fileformat.info/info/unicode/char/2203/index.htm">http://www.fileformat.info/info/unicode/char/2203/index.htm</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td>python-ideas discussion thread
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2016-October/043415.html">https://mail.python.org/pipermail/python-ideas/2016-October/043415.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td>Steven D'Aprano's critique of the proposal
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2016-October/043453.html">https://mail.python.org/pipermail/python-ideas/2016-October/043453.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[6]</td><td>Considering a link to the idea of overloadable Boolean operators
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2016-October/043447.html">https://mail.python.org/pipermail/python-ideas/2016-October/043447.html</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id33">Copyright</a></h1>
<p>This document has been placed in the public domain under the terms of the
CC0 1.0 license: <a class="reference external" href="https://creativecommons.org/publicdomain/zero/1.0/">https://creativecommons.org/publicdomain/zero/1.0/</a></p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

