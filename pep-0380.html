<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">380</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Syntax for Delegating to a Subgenerator</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0380.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Gregory Ewing &lt;greg.ewing&#32;&#97;t&#32;canterbury.ac.nz&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">13-Feb-2009</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.3</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2011-June/112010.html">https://mail.python.org/pipermail/python-dev/2011-June/112010.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id8">Abstract</a></li>
<li><a class="reference internal" href="#pep-acceptance" id="id9">PEP Acceptance</a></li>
<li><a class="reference internal" href="#motivation" id="id10">Motivation</a></li>
<li><a class="reference internal" href="#proposal" id="id11">Proposal</a><ul>
<li><a class="reference internal" href="#enhancements-to-stopiteration" id="id12">Enhancements to StopIteration</a></li>
<li><a class="reference internal" href="#formal-semantics" id="id13">Formal Semantics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rationale" id="id14">Rationale</a><ul>
<li><a class="reference internal" href="#the-refactoring-principle" id="id15">The Refactoring Principle</a></li>
<li><a class="reference internal" href="#finalization" id="id16">Finalization</a></li>
<li><a class="reference internal" href="#generators-as-threads" id="id17">Generators as Threads</a></li>
<li><a class="reference internal" href="#syntax" id="id18">Syntax</a></li>
<li><a class="reference internal" href="#optimisations" id="id19">Optimisations</a></li>
<li><a class="reference internal" href="#use-of-stopiteration-to-return-values" id="id20">Use of StopIteration to return values</a></li>
<li><a class="reference internal" href="#rejected-ideas" id="id21">Rejected Ideas</a></li>
</ul>
</li>
<li><a class="reference internal" href="#criticisms" id="id22">Criticisms</a></li>
<li><a class="reference internal" href="#alternative-proposals" id="id23">Alternative Proposals</a></li>
<li><a class="reference internal" href="#additional-material" id="id24">Additional Material</a></li>
<li><a class="reference internal" href="#id1" id="id25">References</a></li>
<li><a class="reference internal" href="#copyright" id="id26">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id8">Abstract</a></h1>
<p>A syntax is proposed for a generator to delegate part of its
operations to another generator.  This allows a section of code
containing 'yield' to be factored out and placed in another generator.
Additionally, the subgenerator is allowed to return with a value, and
the value is made available to the delegating generator.</p>
<p>The new syntax also opens up some opportunities for optimisation when
one generator re-yields values produced by another.</p>
</div>
<div class="section" id="pep-acceptance">
<h1><a class="toc-backref" href="#id9">PEP Acceptance</a></h1>
<p>Guido officially <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2011-June/112010.html">accepted the PEP</a> <a class="footnote-reference" href="#id2" id="id3">[1]</a> on 26th June, 2011.</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id10">Motivation</a></h1>
<p>A Python generator is a form of coroutine, but has the limitation that
it can only yield to its immediate caller.  This means that a piece of
code containing a <tt class="docutils literal">yield</tt> cannot be factored out and put into a
separate function in the same way as other code.  Performing such a
factoring causes the called function to itself become a generator, and
it is necessary to explicitly iterate over this second generator and
re-yield any values that it produces.</p>
<p>If yielding of values is the only concern, this can be performed
without much difficulty using a loop such as</p>
<pre class="literal-block">
for v in g:
    yield v
</pre>
<p>However, if the subgenerator is to interact properly with the caller
in the case of calls to <tt class="docutils literal">send()</tt>, <tt class="docutils literal">throw()</tt> and <tt class="docutils literal">close()</tt>,
things become considerably more difficult.  As will be seen later, the
necessary code is very complicated, and it is tricky to handle all the
corner cases correctly.</p>
<p>A new syntax will be proposed to address this issue.  In the simplest
use cases, it will be equivalent to the above for-loop, but it will
also handle the full range of generator behaviour, and allow generator
code to be refactored in a simple and straightforward way.</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id11">Proposal</a></h1>
<p>The following new expression syntax will be allowed in the body of a
generator:</p>
<pre class="literal-block">
yield from &lt;expr&gt;
</pre>
<p>where &lt;expr&gt; is an expression evaluating to an iterable, from which an
iterator is extracted. The iterator is run to exhaustion, during which
time it yields and receives values directly to or from the caller of
the generator containing the <tt class="docutils literal">yield from</tt> expression (the
&quot;delegating generator&quot;).</p>
<p>Furthermore, when the iterator is another generator, the subgenerator
is allowed to execute a <tt class="docutils literal">return</tt> statement with a value, and that
value becomes the value of the <tt class="docutils literal">yield from</tt> expression.</p>
<p>The full semantics of the <tt class="docutils literal">yield from</tt> expression can be described
in terms of the generator protocol as follows:</p>
<ul class="simple">
<li>Any values that the iterator yields are passed directly to the
caller.</li>
<li>Any values sent to the delegating generator using <tt class="docutils literal">send()</tt> are
passed directly to the iterator.  If the sent value is None, the
iterator's <tt class="docutils literal">__next__()</tt> method is called.  If the sent value
is not None, the iterator's <tt class="docutils literal">send()</tt> method is called.  If the
call raises StopIteration, the delegating generator is resumed.
Any other exception is propagated to the delegating generator.</li>
<li>Exceptions other than GeneratorExit thrown into the delegating
generator are passed to the <tt class="docutils literal">throw()</tt> method of the iterator.
If the call raises StopIteration, the delegating generator is
resumed.  Any other exception is propagated to the delegating
generator.</li>
<li>If a GeneratorExit exception is thrown into the delegating
generator, or the <tt class="docutils literal">close()</tt> method of the delegating generator
is called, then the <tt class="docutils literal">close()</tt> method of the iterator is called
if it has one. If this call results in an exception, it is
propagated to the delegating generator.  Otherwise,
GeneratorExit is raised in the delegating generator.</li>
<li>The value of the <tt class="docutils literal">yield from</tt> expression is the first argument
to the <tt class="docutils literal">StopIteration</tt> exception raised by the iterator when
it terminates.</li>
<li><tt class="docutils literal">return expr</tt> in a generator causes <tt class="docutils literal">StopIteration(expr)</tt> to
be raised upon exit from the generator.</li>
</ul>
<div class="section" id="enhancements-to-stopiteration">
<h2><a class="toc-backref" href="#id12">Enhancements to StopIteration</a></h2>
<p>For convenience, the <tt class="docutils literal">StopIteration</tt> exception will be given a
<tt class="docutils literal">value</tt> attribute that holds its first argument, or None if there
are no arguments.</p>
</div>
<div class="section" id="formal-semantics">
<h2><a class="toc-backref" href="#id13">Formal Semantics</a></h2>
<p>Python 3 syntax is used in this section.</p>
<ol class="arabic">
<li><p class="first">The statement</p>
<pre class="literal-block">
RESULT = yield from EXPR
</pre>
<p>is semantically equivalent to</p>
<pre class="literal-block">
_i = iter(EXPR)
try:
    _y = next(_i)
except StopIteration as _e:
    _r = _e.value
else:
    while 1:
        try:
            _s = yield _y
        except GeneratorExit as _e:
            try:
                _m = _i.close
            except AttributeError:
                pass
            else:
                _m()
            raise _e
        except BaseException as _e:
            _x = sys.exc_info()
            try:
                _m = _i.throw
            except AttributeError:
                raise _e
            else:
                try:
                    _y = _m(*_x)
                except StopIteration as _e:
                    _r = _e.value
                    break
        else:
            try:
                if _s is None:
                    _y = next(_i)
                else:
                    _y = _i.send(_s)
            except StopIteration as _e:
                _r = _e.value
                break
RESULT = _r
</pre>
</li>
<li><p class="first">In a generator, the statement</p>
<pre class="literal-block">
return value
</pre>
<p>is semantically equivalent to</p>
<pre class="literal-block">
raise StopIteration(value)
</pre>
<p>except that, as currently, the exception cannot be caught by
<tt class="docutils literal">except</tt> clauses within the returning generator.</p>
</li>
<li><p class="first">The StopIteration exception behaves as though defined thusly:</p>
<pre class="literal-block">
class StopIteration(Exception):

    def __init__(self, *args):
        if len(args) &gt; 0:
            self.value = args[0]
        else:
            self.value = None
        Exception.__init__(self, *args)
</pre>
</li>
</ol>
</div>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id14">Rationale</a></h1>
<div class="section" id="the-refactoring-principle">
<h2><a class="toc-backref" href="#id15">The Refactoring Principle</a></h2>
<p>The rationale behind most of the semantics presented above stems from
the desire to be able to refactor generator code.  It should be
possible to take a section of code containing one or more <tt class="docutils literal">yield</tt>
expressions, move it into a separate function (using the usual
techniques to deal with references to variables in the surrounding
scope, etc.), and call the new function using a <tt class="docutils literal">yield from</tt>
expression.</p>
<p>The behaviour of the resulting compound generator should be, as far as
reasonably practicable, the same as the original unfactored generator
in all situations, including calls to <tt class="docutils literal">__next__()</tt>, <tt class="docutils literal">send()</tt>,
<tt class="docutils literal">throw()</tt> and <tt class="docutils literal">close()</tt>.</p>
<p>The semantics in cases of subiterators other than generators has been
chosen as a reasonable generalization of the generator case.</p>
<p>The proposed semantics have the following limitations with regard to
refactoring:</p>
<ul class="simple">
<li>A block of code that catches GeneratorExit without subsequently
re-raising it cannot be factored out while retaining exactly the
same behaviour.</li>
<li>Factored code may not behave the same way as unfactored code if a
StopIteration exception is thrown into the delegating generator.</li>
</ul>
<p>With use cases for these being rare to non-existent, it was not
considered worth the extra complexity required to support them.</p>
</div>
<div class="section" id="finalization">
<h2><a class="toc-backref" href="#id16">Finalization</a></h2>
<p>There was some debate as to whether explicitly finalizing the
delegating generator by calling its <tt class="docutils literal">close()</tt> method while it is
suspended at a <tt class="docutils literal">yield from</tt> should also finalize the subiterator.
An argument against doing so is that it would result in premature
finalization of the subiterator if references to it exist elsewhere.</p>
<p>Consideration of non-refcounting Python implementations led to the
decision that this explicit finalization should be performed, so that
explicitly closing a factored generator has the same effect as doing
so to an unfactored one in all Python implementations.</p>
<p>The assumption made is that, in the majority of use cases, the
subiterator will not be shared.  The rare case of a shared subiterator
can be accommodated by means of a wrapper that blocks <tt class="docutils literal">throw()</tt> and
<tt class="docutils literal">close()</tt> calls, or by using a means other than <tt class="docutils literal">yield from</tt> to
call the subiterator.</p>
</div>
<div class="section" id="generators-as-threads">
<h2><a class="toc-backref" href="#id17">Generators as Threads</a></h2>
<p>A motivation for generators being able to return values concerns the
use of generators to implement lightweight threads.  When using
generators in that way, it is reasonable to want to spread the
computation performed by the lightweight thread over many functions.
One would like to be able to call a subgenerator as though it were an
ordinary function, passing it parameters and receiving a returned
value.</p>
<p>Using the proposed syntax, a statement such as</p>
<pre class="literal-block">
y = f(x)
</pre>
<p>where f is an ordinary function, can be transformed into a delegation
call</p>
<pre class="literal-block">
y = yield from g(x)
</pre>
<p>where g is a generator.  One can reason about the behaviour of the
resulting code by thinking of g as an ordinary function that can be
suspended using a <tt class="docutils literal">yield</tt> statement.</p>
<p>When using generators as threads in this way, typically one is not
interested in the values being passed in or out of the yields.
However, there are use cases for this as well, where the thread is
seen as a producer or consumer of items.  The <tt class="docutils literal">yield from</tt>
expression allows the logic of the thread to be spread over as many
functions as desired, with the production or consumption of items
occurring in any subfunction, and the items are automatically routed to
or from their ultimate source or destination.</p>
<p>Concerning <tt class="docutils literal">throw()</tt> and <tt class="docutils literal">close()</tt>, it is reasonable to expect
that if an exception is thrown into the thread from outside, it should
first be raised in the innermost generator where the thread is
suspended, and propagate outwards from there; and that if the thread
is terminated from outside by calling <tt class="docutils literal">close()</tt>, the chain of active
generators should be finalised from the innermost outwards.</p>
</div>
<div class="section" id="syntax">
<h2><a class="toc-backref" href="#id18">Syntax</a></h2>
<p>The particular syntax proposed has been chosen as suggestive of its
meaning, while not introducing any new keywords and clearly standing
out as being different from a plain <tt class="docutils literal">yield</tt>.</p>
</div>
<div class="section" id="optimisations">
<h2><a class="toc-backref" href="#id19">Optimisations</a></h2>
<p>Using a specialised syntax opens up possibilities for optimisation
when there is a long chain of generators.  Such chains can arise, for
instance, when recursively traversing a tree structure.  The overhead
of passing <tt class="docutils literal">__next__()</tt> calls and yielded values down and up the
chain can cause what ought to be an O(n) operation to become, in the
worst case, O(n**2).</p>
<p>A possible strategy is to add a slot to generator objects to hold a
generator being delegated to.  When a <tt class="docutils literal">__next__()</tt> or <tt class="docutils literal">send()</tt>
call is made on the generator, this slot is checked first, and if it
is nonempty, the generator that it references is resumed instead.  If
it raises StopIteration, the slot is cleared and the main generator is
resumed.</p>
<p>This would reduce the delegation overhead to a chain of C function
calls involving no Python code execution.  A possible enhancement
would be to traverse the whole chain of generators in a loop and
directly resume the one at the end, although the handling of
StopIteration is more complicated then.</p>
</div>
<div class="section" id="use-of-stopiteration-to-return-values">
<h2><a class="toc-backref" href="#id20">Use of StopIteration to return values</a></h2>
<p>There are a variety of ways that the return value from the generator
could be passed back.  Some alternatives include storing it as an
attribute of the generator-iterator object, or returning it as the
value of the <tt class="docutils literal">close()</tt> call to the subgenerator.  However, the
proposed mechanism is attractive for a couple of reasons:</p>
<ul class="simple">
<li>Using a generalization of the StopIteration exception makes it easy
for other kinds of iterators to participate in the protocol without
having to grow an extra attribute or a close() method.</li>
<li>It simplifies the implementation, because the point at which the
return value from the subgenerator becomes available is the same
point at which the exception is raised.  Delaying until any later
time would require storing the return value somewhere.</li>
</ul>
</div>
<div class="section" id="rejected-ideas">
<h2><a class="toc-backref" href="#id21">Rejected Ideas</a></h2>
<p>Some ideas were discussed but rejected.</p>
<p>Suggestion: There should be some way to prevent the initial call to
__next__(), or substitute it with a send() call with a specified
value, the intention being to support the use of generators wrapped so
that the initial __next__() is performed automatically.</p>
<p>Resolution: Outside the scope of the proposal. Such generators should
not be used with <tt class="docutils literal">yield from</tt>.</p>
<p>Suggestion: If closing a subiterator raises StopIteration with a
value, return that value from the <tt class="docutils literal">close()</tt> call to the delegating
generator.</p>
<p>The motivation for this feature is so that the end of a stream of
values being sent to a generator can be signalled by closing the
generator.  The generator would catch GeneratorExit, finish its
computation and return a result, which would then become the return
value of the close() call.</p>
<p>Resolution: This usage of close() and GeneratorExit would be
incompatible with their current role as a bail-out and clean-up
mechanism.  It would require that when closing a delegating generator,
after the subgenerator is closed, the delegating generator be resumed
instead of re-raising GeneratorExit.  But this is not acceptable,
because it would fail to ensure that the delegating generator is
finalised properly in the case where close() is being called for
cleanup purposes.</p>
<p>Signalling the end of values to a consumer is better addressed by
other means, such as sending in a sentinel value or throwing in an
exception agreed upon by the producer and consumer.  The consumer can
then detect the sentinel or exception and respond by finishing its
computation and returning normally.  Such a scheme behaves correctly
in the presence of delegation.</p>
<p>Suggestion: If <tt class="docutils literal">close()</tt> is not to return a value, then raise an
exception if StopIteration with a non-None value occurs.</p>
<p>Resolution: No clear reason to do so. Ignoring a return value is not
considered an error anywhere else in Python.</p>
</div>
</div>
<div class="section" id="criticisms">
<h1><a class="toc-backref" href="#id22">Criticisms</a></h1>
<p>Under this proposal, the value of a <tt class="docutils literal">yield from</tt> expression would be
derived in a very different way from that of an ordinary <tt class="docutils literal">yield</tt>
expression.  This suggests that some other syntax not containing the
word <tt class="docutils literal">yield</tt> might be more appropriate, but no acceptable
alternative has so far been proposed.  Rejected alternatives include
<tt class="docutils literal">call</tt>, <tt class="docutils literal">delegate</tt> and <tt class="docutils literal">gcall</tt>.</p>
<p>It has been suggested that some mechanism other than <tt class="docutils literal">return</tt> in the
subgenerator should be used to establish the value returned by the
<tt class="docutils literal">yield from</tt> expression.  However, this would interfere with the
goal of being able to think of the subgenerator as a suspendable
function, since it would not be able to return values in the same way
as other functions.</p>
<p>The use of an exception to pass the return value has been criticised
as an &quot;abuse of exceptions&quot;, without any concrete justification of
this claim.  In any case, this is only one suggested implementation;
another mechanism could be used without losing any essential features
of the proposal.</p>
<p>It has been suggested that a different exception, such as
GeneratorReturn, should be used instead of StopIteration to return a
value.  However, no convincing practical reason for this has been put
forward, and the addition of a <tt class="docutils literal">value</tt> attribute to StopIteration
mitigates any difficulties in extracting a return value from a
StopIteration exception that may or may not have one.  Also, using a
different exception would mean that, unlike ordinary functions,
'return' without a value in a generator would not be equivalent to
'return None'.</p>
</div>
<div class="section" id="alternative-proposals">
<h1><a class="toc-backref" href="#id23">Alternative Proposals</a></h1>
<p>Proposals along similar lines have been made before, some using the
syntax <tt class="docutils literal">yield *</tt> instead of <tt class="docutils literal">yield from</tt>.  While <tt class="docutils literal">yield *</tt> is
more concise, it could be argued that it looks too similar to an
ordinary <tt class="docutils literal">yield</tt> and the difference might be overlooked when reading
code.</p>
<p>To the author's knowledge, previous proposals have focused only on
yielding values, and thereby suffered from the criticism that the
two-line for-loop they replace is not sufficiently tiresome to write
to justify a new syntax.  By dealing with the full generator protocol,
this proposal provides considerably more benefit.</p>
</div>
<div class="section" id="additional-material">
<h1><a class="toc-backref" href="#id24">Additional Material</a></h1>
<p>Some examples of the use of the proposed syntax are available, and
also a prototype implementation based on the first optimisation
outlined above.</p>
<p><a class="reference external" href="http://www.cosc.canterbury.ac.nz/greg.ewing/python/yield-from/">Examples and Implementation</a> <a class="footnote-reference" href="#id4" id="id5">[2]</a></p>
<p>A version of the implementation updated for Python 3.3 is available from
tracker <a class="reference external" href="http://bugs.python.org/issue11682">issue #11682</a> <a class="footnote-reference" href="#id6" id="id7">[3]</a></p>
</div>
<div class="section" id="id1">
<h1><a class="toc-backref" href="#id25">References</a></h1>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2011-June/112010.html">https://mail.python.org/pipermail/python-dev/2011-June/112010.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[2]</a></td><td><a class="reference external" href="http://www.cosc.canterbury.ac.nz/greg.ewing/python/yield-from/">http://www.cosc.canterbury.ac.nz/greg.ewing/python/yield-from/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[3]</a></td><td><a class="reference external" href="http://bugs.python.org/issue11682">http://bugs.python.org/issue11682</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id26">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

