<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">523</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Adding a frame evaluation API to CPython</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0523.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Brett Cannon &lt;brett&#32;&#97;t&#32;python.org&gt;,
Dino Viehland &lt;dinov&#32;&#97;t&#32;microsoft.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">16-May-2016</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">16-May-2016</td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2016-August/145937.html">https://mail.python.org/pipermail/python-dev/2016-August/145937.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id20">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id21">Rationale</a></li>
<li><a class="reference internal" href="#proposal" id="id22">Proposal</a><ul>
<li><a class="reference internal" href="#expanding-pycodeobject" id="id23">Expanding <tt class="docutils literal">PyCodeObject</tt></a></li>
<li><a class="reference internal" href="#expanding-pyinterpreterstate" id="id24">Expanding <tt class="docutils literal">PyInterpreterState</tt></a></li>
<li><a class="reference internal" href="#changes-to-python-ceval-c" id="id25">Changes to <tt class="docutils literal">Python/ceval.c</tt></a></li>
<li><a class="reference internal" href="#updating-python-gdb-py" id="id26">Updating <tt class="docutils literal"><span class="pre">python-gdb.py</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#performance-impact" id="id27">Performance impact</a></li>
<li><a class="reference internal" href="#example-usage" id="id28">Example Usage</a><ul>
<li><a class="reference internal" href="#a-jit-for-cpython" id="id29">A JIT for CPython</a><ul>
<li><a class="reference internal" href="#pyjion" id="id30">Pyjion</a></li>
<li><a class="reference internal" href="#other-jits" id="id31">Other JITs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#debugging" id="id32">Debugging</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation" id="id33">Implementation</a></li>
<li><a class="reference internal" href="#open-issues" id="id34">Open Issues</a><ul>
<li><a class="reference internal" href="#allow-eval-frame-to-be-null" id="id35">Allow <tt class="docutils literal">eval_frame</tt> to be <tt class="docutils literal">NULL</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#rejected-ideas" id="id36">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#a-jit-specific-c-api" id="id37">A JIT-specific C API</a></li>
<li><a class="reference internal" href="#is-co-extra-needed" id="id38">Is co_extra needed?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references" id="id39">References</a></li>
<li><a class="reference internal" href="#copyright" id="id40">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id20">Abstract</a></h1>
<p>This PEP proposes to expand CPython's C API <a class="footnote-reference" href="#c-api" id="id1">[2]</a> to allow for
the specification of a per-interpreter function pointer to handle the
evaluation of frames <a class="footnote-reference" href="#pyeval-evalframeex" id="id2">[5]</a>. This proposal also
suggests adding a new field to code objects <a class="footnote-reference" href="#pycodeobject" id="id3">[3]</a> to store
arbitrary data for use by the frame evaluation function.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id21">Rationale</a></h1>
<p>One place where flexibility has been lacking in Python is in the direct
execution of Python code. While CPython's C API <a class="footnote-reference" href="#c-api" id="id4">[2]</a> allows for
constructing the data going into a frame object and then evaluating it
via <tt class="docutils literal">PyEval_EvalFrameEx()</tt> <a class="footnote-reference" href="#pyeval-evalframeex" id="id5">[5]</a>, control over the
execution of Python code comes down to individual objects instead of a
holistic control of execution at the frame level.</p>
<p>While wanting to have influence over frame evaluation may seem a bit
too low-level, it does open the possibility for things such as a
method-level JIT to be introduced into CPython without CPython itself
having to provide one. By allowing external C code to control frame
evaluation, a JIT can participate in the execution of Python code at
the key point where evaluation occurs. This then allows for a JIT to
conditionally recompile Python bytecode to machine code as desired
while still allowing for executing regular CPython bytecode when
running the JIT is not desired. This can be accomplished by allowing
interpreters to specify what function to call to evaluate a frame. And
by placing the API at the frame evaluation level it allows for a
complete view of the execution environment of the code for the JIT.</p>
<p>This ability to specify a frame evaluation function also allows for
other use-cases beyond just opening CPython up to a JIT. For instance,
it would not be difficult to implement a tracing or profiling function
at the call level with this API. While CPython does provide the
ability to set a tracing or profiling function at the Python level,
this would be able to match the data collection of the profiler and
quite possibly be faster for tracing by simply skipping per-line
tracing support.</p>
<p>It also opens up the possibility of debugging where the frame
evaluation function only performs special debugging work when it
detects it is about to execute a specific code object. In that
instance the bytecode could be theoretically rewritten in-place to
inject a breakpoint function call at the proper point for help in
debugging while not having to do a heavy-handed approach as
required by <tt class="docutils literal">sys.settrace()</tt>.</p>
<p>To help facilitate these use-cases, we are also proposing the adding
of a &quot;scratch space&quot; on code objects via a new field. This will allow
per-code object data to be stored with the code object itself for easy
retrieval by the frame evaluation function as necessary. The field
itself will simply be a <tt class="docutils literal">PyObject *</tt> type so that any data stored in
the field will participate in normal object memory management.</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id22">Proposal</a></h1>
<p>All proposed C API changes below will not be part of the stable ABI.</p>
<div class="section" id="expanding-pycodeobject">
<h2><a class="toc-backref" href="#id23">Expanding <tt class="docutils literal">PyCodeObject</tt></a></h2>
<p>One field is to be added to the <tt class="docutils literal">PyCodeObject</tt> struct
<a class="footnote-reference" href="#pycodeobject" id="id6">[3]</a>:</p>
<pre class="literal-block">
typedef struct {
   ...
   void *co_extra;  /* &quot;Scratch space&quot; for the code object. */
} PyCodeObject;
</pre>
<p>The <tt class="docutils literal">co_extra</tt> will be <tt class="docutils literal">NULL</tt> by default and only filled in as
needed. Values stored in the field are expected to not be required
in order for the code object to function, allowing the loss of the
data of the field to be acceptable.</p>
<p>A private API has been introduced to work with the field:</p>
<pre class="literal-block">
PyAPI_FUNC(Py_ssize_t) _PyEval_RequestCodeExtraIndex(freefunc);
PyAPI_FUNC(int) _PyCode_GetExtra(PyObject *code, Py_ssize_t index,
                                 void **extra);
PyAPI_FUNC(int) _PyCode_SetExtra(PyObject *code, Py_ssize_t index,
                                 void *extra);
</pre>
<p>Users of the field are expected to call
<tt class="docutils literal">_PyEval_RequestCodeExtraIndex()</tt> to receive (what should be
considered) an opaque index value to adding data into <tt class="docutils literal"><span class="pre">co-extra</span></tt>.
With that index, users can set data using <tt class="docutils literal">_PyCode_SetExtra()</tt> and
later retrieve the data with <tt class="docutils literal">_PyCode_GetExtra()</tt>. The API is
purposefully listed as private to communicate the fact that there are
no semantic guarantees of the API between Python releases.</p>
<p>Using a list and tuple were considered but was found to be less
performant, and with a key use-case being JIT usage the performance
consideration won out for using a custom struct instead of a Python
object.</p>
<p>A dict was also considered, but once again performance was more
important. While a dict will have constant overhead in looking up
data, the overhead for the common case of a single object being stored
in the data structure leads to a tuple having better performance
characteristics (i.e. iterating a tuple of length 1 is faster than
the overhead of hashing and looking up an object in a dict).</p>
</div>
<div class="section" id="expanding-pyinterpreterstate">
<h2><a class="toc-backref" href="#id24">Expanding <tt class="docutils literal">PyInterpreterState</tt></a></h2>
<p>The entrypoint for the frame evaluation function is per-interpreter:</p>
<pre class="literal-block">
// Same type signature as PyEval_EvalFrameEx().
typedef PyObject* (*_PyFrameEvalFunction)(PyFrameObject*, int);

typedef struct {
    ...
    _PyFrameEvalFunction eval_frame;
} PyInterpreterState;
</pre>
<p>By default, the <tt class="docutils literal">eval_frame</tt> field will be initialized to a function
pointer that represents what <tt class="docutils literal">PyEval_EvalFrameEx()</tt> currently is
(called <tt class="docutils literal">_PyEval_EvalFrameDefault()</tt>, discussed later in this PEP).
Third-party code may then set their own frame evaluation function
instead to control the execution of Python code. A pointer comparison
can be used to detect if the field is set to
<tt class="docutils literal">_PyEval_EvalFrameDefault()</tt> and thus has not been mutated yet.</p>
</div>
<div class="section" id="changes-to-python-ceval-c">
<h2><a class="toc-backref" href="#id25">Changes to <tt class="docutils literal">Python/ceval.c</tt></a></h2>
<p><tt class="docutils literal">PyEval_EvalFrameEx()</tt> <a class="footnote-reference" href="#pyeval-evalframeex" id="id7">[5]</a> as it currently stands
will be renamed to <tt class="docutils literal">_PyEval_EvalFrameDefault()</tt>. The new
<tt class="docutils literal">PyEval_EvalFrameEx()</tt> will then become:</p>
<pre class="literal-block">
PyObject *
PyEval_EvalFrameEx(PyFrameObject *frame, int throwflag)
{
    PyThreadState *tstate = PyThreadState_GET();
    return tstate-&gt;interp-&gt;eval_frame(frame, throwflag);
}
</pre>
<p>This allows third-party code to place themselves directly in the path
of Python code execution while being backwards-compatible with code
already using the pre-existing C API.</p>
</div>
<div class="section" id="updating-python-gdb-py">
<h2><a class="toc-backref" href="#id26">Updating <tt class="docutils literal"><span class="pre">python-gdb.py</span></tt></a></h2>
<p>The generated <tt class="docutils literal"><span class="pre">python-gdb.py</span></tt> file used for Python support in GDB
makes some hard-coded assumptions about <tt class="docutils literal">PyEval_EvalFrameEx()</tt>, e.g.
the names of local variables. It will need to be updated to work with
the proposed changes.</p>
</div>
</div>
<div class="section" id="performance-impact">
<h1><a class="toc-backref" href="#id27">Performance impact</a></h1>
<p>As this PEP is proposing an API to add pluggability, performance
impact is considered only in the case where no third-party code has
made any changes.</p>
<p>Several runs of pybench <a class="footnote-reference" href="#pybench" id="id8">[14]</a> consistently showed no performance
cost from the API change alone.</p>
<p>A run of the Python benchmark suite <a class="footnote-reference" href="#py-benchmarks" id="id9">[9]</a> showed no
measurable cost in performance.</p>
<p>In terms of memory impact, since there are typically not many CPython
interpreters executing in a single process that means the impact of
<tt class="docutils literal">co_extra</tt> being added to <tt class="docutils literal">PyCodeObject</tt> is the only worry.
According to <a class="footnote-reference" href="#code-object-count" id="id10">[8]</a>, a run of the Python test suite
results in about 72,395 code objects being created. On a 64-bit
CPU that would result in 579,160 bytes of extra memory being used if
all code objects were alive at once and had nothing set in their
<tt class="docutils literal">co_extra</tt> fields.</p>
</div>
<div class="section" id="example-usage">
<h1><a class="toc-backref" href="#id28">Example Usage</a></h1>
<div class="section" id="a-jit-for-cpython">
<h2><a class="toc-backref" href="#id29">A JIT for CPython</a></h2>
<div class="section" id="pyjion">
<h3><a class="toc-backref" href="#id30">Pyjion</a></h3>
<p>The Pyjion project <a class="footnote-reference" href="#id19" id="id11">[1]</a> has used this proposed API to implement
a JIT for CPython using the CoreCLR's JIT <a class="footnote-reference" href="#coreclr" id="id12">[4]</a>. Each code
object has its <tt class="docutils literal">co_extra</tt> field set to a <tt class="docutils literal">PyjionJittedCode</tt> object
which stores four pieces of information:</p>
<ol class="arabic simple">
<li>Execution count</li>
<li>A boolean representing whether a previous attempt to JIT failed</li>
<li>A function pointer to a trampoline (which can be type tracing or not)</li>
<li>A void pointer to any JIT-compiled machine code</li>
</ol>
<p>The frame evaluation function has (roughly) the following algorithm:</p>
<pre class="literal-block">
def eval_frame(frame, throw_flag):
    pyjion_code = frame.code.co_extra
    if not pyjion_code:
        frame.code.co_extra = PyjionJittedCode()
    elif not pyjion_code.jit_failed:
        if not pyjion_code.jit_code:
            return pyjion_code.eval(pyjion_code.jit_code, frame)
        elif pyjion_code.exec_count &gt; 20_000:
            if jit_compile(frame):
                return pyjion_code.eval(pyjion_code.jit_code, frame)
            else:
                pyjion_code.jit_failed = True
    pyjion_code.exec_count += 1
    return _PyEval_EvalFrameDefault(frame, throw_flag)
</pre>
<p>The key point, though, is that all of this work and logic is separate
from CPython and yet with the proposed API changes it is able to
provide a JIT that is compliant with Python semantics (as of this
writing, performance is almost equivalent to CPython without the new
API). This means there's nothing technically preventing others from
implementing their own JITs for CPython by utilizing the proposed API.</p>
</div>
<div class="section" id="other-jits">
<h3><a class="toc-backref" href="#id31">Other JITs</a></h3>
<p>It should be mentioned that the Pyston team was consulted on an
earlier version of this PEP that was more JIT-specific and they were
not interested in utilizing the changes proposed because they want
control over memory layout they had no interest in directly supporting
CPython itself. An informal discusion with a developer on the PyPy
team led to a similar comment.</p>
<p>Numba <a class="footnote-reference" href="#numba" id="id13">[6]</a>, on the other hand, suggested that they would be
interested in the proposed change in a post-1.0 future for
themselves <a class="footnote-reference" href="#numba-interest" id="id14">[7]</a>.</p>
<p>The experimental Coconut JIT <a class="footnote-reference" href="#coconut" id="id15">[13]</a> could have benefitted from
this PEP. In private conversations with Coconut's creator we were told
that our API was probably superior to the one they developed for
Coconut to add JIT support to CPython.</p>
</div>
</div>
<div class="section" id="debugging">
<h2><a class="toc-backref" href="#id32">Debugging</a></h2>
<p>In conversations with the Python Tools for Visual Studio team (PTVS)
<a class="footnote-reference" href="#ptvs" id="id16">[12]</a>, they thought they would find these API changes useful for
implementing more performant debugging. As mentioned in the <a class="reference internal" href="#rationale">Rationale</a>
section, this API would allow for switching on debugging functionality
only in frames where it is needed. This could allow for either
skipping information that <tt class="docutils literal">sys.settrace()</tt> normally provides and
even go as far as to dynamically rewrite bytecode prior to execution
to inject e.g. breakpoints in the bytecode.</p>
<p>It also turns out that Google provides a very similar API
internally. It has been used for performant debugging purposes.</p>
</div>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id33">Implementation</a></h1>
<p>A set of patches implementing the proposed API is available through
the Pyjion project <a class="footnote-reference" href="#id19" id="id17">[1]</a>. In its current form it has more
changes to CPython than just this proposed API, but that is for ease
of development instead of strict requirements to accomplish its goals.</p>
</div>
<div class="section" id="open-issues">
<h1><a class="toc-backref" href="#id34">Open Issues</a></h1>
<div class="section" id="allow-eval-frame-to-be-null">
<h2><a class="toc-backref" href="#id35">Allow <tt class="docutils literal">eval_frame</tt> to be <tt class="docutils literal">NULL</tt></a></h2>
<p>Currently the frame evaluation function is expected to always be set.
It could very easily simply default to <tt class="docutils literal">NULL</tt> instead which would
signal to use <tt class="docutils literal">_PyEval_EvalFrameDefault()</tt>. The current proposal of
not special-casing the field seemed the most straightforward, but it
does require that the field not accidentally be cleared, else a crash
may occur.</p>
</div>
</div>
<div class="section" id="rejected-ideas">
<h1><a class="toc-backref" href="#id36">Rejected Ideas</a></h1>
<div class="section" id="a-jit-specific-c-api">
<h2><a class="toc-backref" href="#id37">A JIT-specific C API</a></h2>
<p>Originally this PEP was going to propose a much larger API change
which was more JIT-specific. After soliciting feedback from the Numba
team <a class="footnote-reference" href="#numba" id="id18">[6]</a>, though, it became clear that the API was unnecessarily
large. The realization was made that all that was truly needed was the
opportunity to provide a trampoline function to handle execution of
Python code that had been JIT-compiled and a way to attach that
compiled machine code along with other critical data to the
corresponding Python code object. Once it was shown that there was no
loss in functionality or in performance while minimizing the API
changes required, the proposal was changed to its current form.</p>
</div>
<div class="section" id="is-co-extra-needed">
<h2><a class="toc-backref" href="#id38">Is co_extra needed?</a></h2>
<p>While discussing this PEP at PyCon US 2016, some core developers
expressed their worry of the <tt class="docutils literal">co_extra</tt> field making code objects
mutable. The thinking seemed to be that having a field that was
mutated after the creation of the code object made the object seem
mutable, even though no other aspect of code objects changed.</p>
<p>The view of this PEP is that the <cite>co_extra</cite> field doesn't change the
fact that code objects are immutable. The field is specified in this
PEP to not contain information required to make the code object
usable, making it more of a caching field. It could be viewed as
similar to the UTF-8 cache that string objects have internally;
strings are still considered immutable even though they have a field
that is conditionally set.</p>
<p>Performance measurements were also made where the field was not
available for JIT workloads. The loss of the field was deemed too
costly to performance when using an unordered map from C++ or Python's
dict to associated a code object with JIT-specific data objects.</p>
</div>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id39">References</a></h1>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id11">1</a>, <a class="fn-backref" href="#id17">2</a>)</em> Pyjion project
(<a class="reference external" href="https://github.com/microsoft/pyjion">https://github.com/microsoft/pyjion</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="c-api" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id4">2</a>)</em> CPython's C API
(<a class="reference external" href="https://docs.python.org/3/c-api/index.html">https://docs.python.org/3/c-api/index.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="pycodeobject" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id6">2</a>)</em> <tt class="docutils literal">PyCodeObject</tt>
(<a class="reference external" href="https://docs.python.org/3/c-api/code.html#c.PyCodeObject">https://docs.python.org/3/c-api/code.html#c.PyCodeObject</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="coreclr" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[4]</a></td><td>.NET Core Runtime (CoreCLR)
(<a class="reference external" href="https://github.com/dotnet/coreclr">https://github.com/dotnet/coreclr</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="pyeval-evalframeex" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id5">2</a>, <a class="fn-backref" href="#id7">3</a>)</em> <tt class="docutils literal">PyEval_EvalFrameEx()</tt>
(<a class="reference external" href="https://docs.python.org/3/c-api/veryhigh.html?highlight=pyframeobject#c.PyEval_EvalFrameEx">https://docs.python.org/3/c-api/veryhigh.html?highlight=pyframeobject#c.PyEval_EvalFrameEx</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="numba" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[6]</td><td><em>(<a class="fn-backref" href="#id13">1</a>, <a class="fn-backref" href="#id18">2</a>)</em> Numba
(<a class="reference external" href="http://numba.pydata.org/">http://numba.pydata.org/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="numba-interest" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[7]</a></td><td>numba-users mailing list:
&quot;Would the C API for a JIT entrypoint being proposed by Pyjion help out Numba?&quot;
(<a class="reference external" href="https://groups.google.com/a/continuum.io/forum/#!topic/numba-users/yRl_0t8-m1g">https://groups.google.com/a/continuum.io/forum/#!topic/numba-users/yRl_0t8-m1g</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="code-object-count" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[8]</a></td><td>[Python-Dev] Opcode cache in ceval loop
(<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2016-February/143025.html">https://mail.python.org/pipermail/python-dev/2016-February/143025.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="py-benchmarks" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[9]</a></td><td>Python benchmark suite
(<a class="reference external" href="https://hg.python.org/benchmarks">https://hg.python.org/benchmarks</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="pyston" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[10]</td><td>Pyston
(<a class="reference external" href="http://pyston.org">http://pyston.org</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="pypy" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[11]</td><td>PyPy
(<a class="reference external" href="http://pypy.org/">http://pypy.org/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="ptvs" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[12]</a></td><td>Python Tools for Visual Studio
(<a class="reference external" href="http://microsoft.github.io/PTVS/">http://microsoft.github.io/PTVS/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="coconut" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[13]</a></td><td>Coconut
(<a class="reference external" href="https://github.com/davidmalcolm/coconut">https://github.com/davidmalcolm/coconut</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="pybench" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[14]</a></td><td>pybench
(<a class="reference external" href="https://hg.python.org/cpython/file/default/Tools/pybench">https://hg.python.org/cpython/file/default/Tools/pybench</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id40">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

