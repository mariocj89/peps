<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">568</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Generator-sensitivity for Context Variables</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Nathaniel J. Smith &lt;njs&#32;&#97;t&#32;pobox.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Deferred</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">04-Jan-2018</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.8</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id2">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id3">Rationale</a></li>
<li><a class="reference internal" href="#high-level-summary" id="id4">High-level summary</a></li>
<li><a class="reference internal" href="#specification" id="id5">Specification</a><ul>
<li><a class="reference internal" href="#review-of-pep-567" id="id6">Review of PEP 567</a></li>
<li><a class="reference internal" href="#changes-from-pep-567-to-this-pep" id="id7">Changes from PEP 567 to this PEP</a></li>
</ul>
</li>
<li><a class="reference internal" href="#comparison-to-pep-550" id="id8">Comparison to PEP 550</a></li>
<li><a class="reference internal" href="#implementation-notes" id="id9">Implementation notes</a></li>
<li><a class="reference internal" href="#copyright" id="id10">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id2">Abstract</a></h1>
<p>Context variables provide a generic mechanism for tracking dynamic,
context-local state, similar to thread-local storage but generalized
to cope work with other kinds of thread-like contexts, such as asyncio
Tasks. <a class="reference external" href="/dev/peps/pep-0550">PEP 550</a> proposed a mechanism for context-local state that was
also sensitive to generator context, but this was pretty complicated,
so the BDFL requested it be simplified. The result was <a class="reference external" href="/dev/peps/pep-0567">PEP 567</a>, which
is targeted for inclusion in 3.7. This PEP then extends <a class="reference external" href="/dev/peps/pep-0567">PEP 567</a>'s
machinery to add generator context sensitivity.</p>
<p>This PEP is starting out in the &quot;deferred&quot; status, because there isn't
enough time to give it proper consideration before the 3.7 feature
freeze. The only goal <em>right now</em> is to understand what would be
required to add generator context sensitivity in 3.8, so that we can
avoid shipping something in 3.7 that would rule it out by accident.
(Ruling it out on purpose can wait until 3.8 ;-).)</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id3">Rationale</a></h1>
<p>[Currently the point of this PEP is just to understand <em>how</em> this
would work, with discussion of <em>whether</em> it's a good idea deferred
until after the 3.7 feature freeze. So rationale is TBD.]</p>
</div>
<div class="section" id="high-level-summary">
<h1><a class="toc-backref" href="#id4">High-level summary</a></h1>
<p>Instead of holding a single <tt class="docutils literal">Context</tt>, the threadstate now holds a
<tt class="docutils literal">ChainMap</tt> of <tt class="docutils literal">Context</tt>s. <tt class="docutils literal">ContextVar.get</tt> and
<tt class="docutils literal">ContextVar.set</tt> are backed by the <tt class="docutils literal">ChainMap</tt>. Generators and
async generators each have an associated <tt class="docutils literal">Context</tt> that they push
onto the <tt class="docutils literal">ChainMap</tt> while they're running to isolate their
context-local changes from their callers, though this can be
overridden in cases like <tt class="docutils literal">&#64;contextlib.contextmanager</tt> where
&quot;leaking&quot; context changes from the generator into its caller is
desirable.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id5">Specification</a></h1>
<div class="section" id="review-of-pep-567">
<h2>Review of <a class="reference external" href="/dev/peps/pep-0567">PEP 567</a></h2>
<p>Let's start by reviewing how <a class="reference external" href="/dev/peps/pep-0567">PEP 567</a> works, and then in the next
section we'll describe the differences.</p>
<p>In <a class="reference external" href="/dev/peps/pep-0567">PEP 567</a>, a <tt class="docutils literal">Context</tt> is a <tt class="docutils literal">Mapping</tt> from <tt class="docutils literal">ContextVar</tt> objects
to arbitrary values. In our pseudo-code here we'll pretend that it
uses a <tt class="docutils literal">dict</tt> for backing storage. (The real implementation uses a
HAMT, which is semantically equivalent to a <tt class="docutils literal">dict</tt> but with
different performance trade-offs.):</p>
<pre class="literal-block">
class Context(collections.abc.Mapping):
    def __init__(self):
        self._data = {}
        self._in_use = False

    def __getitem__(self, key):
        return self._data[key]

    def __iter__(self):
        return iter(self._data)

    def __len__(self):
        return len(self._data)
</pre>
<p>At any given moment, the threadstate holds a current <tt class="docutils literal">Context</tt>
(initialized to an empty <tt class="docutils literal">Context</tt> when the threadstate is created);
we can use <tt class="docutils literal">Context.run</tt> to temporarily switch the current
<tt class="docutils literal">Context</tt>:</p>
<pre class="literal-block">
# Context.run
def run(self, fn, *args, **kwargs):
    if self._in_use:
        raise RuntimeError(&quot;Context already in use&quot;)
    tstate = get_thread_state()
    old_context = tstate.current_context
    tstate.current_context = self
    self._in_use = True
    try:
        return fn(*args, **kwargs)
    finally:
        state.current_context = old_context
        self._in_use = False
</pre>
<p>We can fetch a shallow copy of the current <tt class="docutils literal">Context</tt> by calling
<tt class="docutils literal">copy_context</tt>; this is commonly used when spawning a new task, so
that the child task can inherit context from its parent:</p>
<pre class="literal-block">
def copy_context():
    tstate = get_thread_state()
    new_context = Context()
    new_context._data = dict(tstate.current_context)
    return new_context
</pre>
<p>In practice, what end users generally work with is <tt class="docutils literal">ContextVar</tt>
objects, which also provide the only way to mutate a <tt class="docutils literal">Context</tt>. They
work with a utility class <tt class="docutils literal">Token</tt>, which can be used to restore a
<tt class="docutils literal">ContextVar</tt> to its previous value:</p>
<pre class="literal-block">
class Token:
    MISSING = sentinel_value()

    # Note: constructor is private
    def __init__(self, context, var, old_value):
        self._context = context
        self.var = var
        self.old_value = old_value

    # XX: PEP 567 currently makes this a method on ContextVar, but
    # I'm going to propose it switch to this API because it's simpler.
    def reset(self):
        # XX: should we allow token reuse?
        # XX: should we allow tokens to be used if the saved
        # context is no longer active?
        if self.old_value is self.MISSING:
            del self._context._data[self.context_var]
        else:
            self._context._data[self.context_var] = self.old_value

# XX: the handling of defaults here uses the simplified proposal from
# https://mail.python.org/pipermail/python-dev/2018-January/151596.html
# This can be updated to whatever we settle on, it was just less
# typing this way :-)
class ContextVar:
    def __init__(self, name, *, default=None):
        self.name = name
        self.default = default

    def get(self):
        context = get_thread_state().current_context
        return context.get(self, self.default)

    def set(self, new_value):
        context = get_thread_state().current_context
        token = Token(context, self, context.get(self, Token.MISSING))
        context._data[self] = new_value
        return token
</pre>
</div>
<div class="section" id="changes-from-pep-567-to-this-pep">
<h2>Changes from <a class="reference external" href="/dev/peps/pep-0567">PEP 567</a> to this PEP</h2>
<p>In general, <tt class="docutils literal">Context</tt> remains the same. However, now instead of
holding a single <tt class="docutils literal">Context</tt> object, the threadstate stores a stack of
them. This stack acts just like a <tt class="docutils literal">collections.ChainMap</tt>, so we'll
use that in our pseudocode. <tt class="docutils literal">Context.run</tt> then becomes:</p>
<pre class="literal-block">
# Context.run
def run(self, fn, *args, **kwargs):
    if self._in_use:
        raise RuntimeError(&quot;Context already in use&quot;)
    tstate = get_thread_state()
    old_context_stack = tstate.current_context_stack
    tstate.current_context_stack = ChainMap([self])     # changed
    self._in_use = True
    try:
        return fn(*args, **kwargs)
    finally:
        state.current_context_stack = old_context_stack
        self._in_use = False
</pre>
<p>Aside from some updated variables names (e.g.,
<tt class="docutils literal">tstate.current_context</tt> → <tt class="docutils literal">tstate.current_context_stack</tt>), the
only change here is on the marked line, which now wraps the context in
a <tt class="docutils literal">ChainMap</tt> before stashing it in the threadstate.</p>
<p>We also add a <tt class="docutils literal">Context.push</tt> method, which is almost exactly like
<tt class="docutils literal">Context.run</tt>, except that it temporarily pushes the <tt class="docutils literal">Context</tt>
onto the existing stack, instead of temporarily replacing the whole
stack:</p>
<pre class="literal-block">
# Context.push
def push(self, fn, *args, **kwargs):
    if self._in_use:
        raise RuntimeError(&quot;Context already in use&quot;)
    tstate = get_thread_state()
    tstate.current_context_stack.maps.insert(0, self)  # different from run
    self._in_use = True
    try:
        return fn(*args, **kwargs)
    finally:
        tstate.current_context_stack.maps.pop(0)       # different from run
        self._in_use = False
</pre>
<p>In most cases, we don't expect <tt class="docutils literal">push</tt> to be used directly; instead,
it will be used implicitly by generators. Specifically, every
generator object and async generator object gains a new attribute
<tt class="docutils literal">.context</tt>. When an (async) generator object is created, this
attribute is initialized to an empty <tt class="docutils literal">Context</tt> (<tt class="docutils literal">self.context =
Context()</tt>). This is a mutable attribute; it can be changed by user
code. But trying to set it to anything that isn't a <tt class="docutils literal">Context</tt> object
or <tt class="docutils literal">None</tt> will raise an error.</p>
<p>Whenever we enter an generator via <tt class="docutils literal">__next__</tt>, <tt class="docutils literal">send</tt>, <tt class="docutils literal">throw</tt>,
or <tt class="docutils literal">close</tt>, or enter an async generator by calling one of those
methods on its <tt class="docutils literal">__anext__</tt>, <tt class="docutils literal">asend</tt>, <tt class="docutils literal">athrow</tt>, or <tt class="docutils literal">aclose</tt>
coroutines, then its <tt class="docutils literal">.context</tt> attribute is checked, and if
non-<tt class="docutils literal">None</tt>, is automatically pushed:</p>
<pre class="literal-block">
# GeneratorType.__next__
def __next__(self):
    if self.context is not None:
        return self.context.push(self.__real_next__)
    else:
        return self.__real_next__()
</pre>
<p>While we don't expect people to use <tt class="docutils literal">Context.push</tt> often, making it
a public API preserves the principle that a generator can always be
rewritten as an explicit iterator class with equivalent semantics.</p>
<p>Also, we modify <tt class="docutils literal"><span class="pre">contextlib.(async)contextmanager</span></tt> to always set its
(async) generator objects' <tt class="docutils literal">.context</tt> attribute to <tt class="docutils literal">None</tt>:</p>
<pre class="literal-block">
# contextlib._GeneratorContextManagerBase.__init__
def __init__(self, func, args, kwds):
    self.gen = func(*args, **kwds)
    self.gen.context = None                  # added
    ...
</pre>
<p>This makes sure that code like this continues to work as expected:</p>
<pre class="literal-block">
&#64;contextmanager
def decimal_precision(prec):
    with decimal.localcontext() as ctx:
        ctx.prec = prec
        yield

with decimal_precision(2):
    ...
</pre>
<p>The general idea here is that by default, every generator object gets
its own local context, but if users want to explicitly get some other
behavior then they can do that.</p>
<p>Otherwise, things mostly work as before, except that we go through and
swap everything to use the threadstate <tt class="docutils literal">ChainMap</tt> instead of the
threadstate <tt class="docutils literal">Context</tt>. In full detail:</p>
<p>The <tt class="docutils literal">copy_context</tt> function now returns a flattened copy of the
&quot;effective&quot; context. (As an optimization, the implementation might
choose to do this flattening lazily, but if so this will be made
invisible to the user.) Compared to our previous implementation above,
the only change here is that <tt class="docutils literal">tstate.current_context</tt> has been
replaced with <tt class="docutils literal">tstate.current_context_stack</tt>:</p>
<pre class="literal-block">
def copy_context() -&gt; Context:
    tstate = get_thread_state()
    new_context = Context()
    new_context._data = dict(tstate.current_context_stack)
    return new_context
</pre>
<p><tt class="docutils literal">Token</tt> is unchanged, and the changes to <tt class="docutils literal">ContextVar.get</tt> are
trivial:</p>
<pre class="literal-block">
# ContextVar.get
def get(self):
    context_stack = get_thread_state().current_context_stack
    return context_stack.get(self, self.default)
</pre>
<p><tt class="docutils literal">ContextVar.set</tt> is a little more interesting: instead of going
through the <tt class="docutils literal">ChainMap</tt> machinery like everything else, it always
mutates the top <tt class="docutils literal">Context</tt> in the stack, and – crucially! – sets up
the returned <tt class="docutils literal">Token</tt> to restore <em>its</em> state later. This allows us to
avoid accidentally &quot;promoting&quot; values between different levels in the
stack, as would happen if we did <tt class="docutils literal">old = <span class="pre">var.get();</span> <span class="pre">...;</span>
var.set(old)</tt>:</p>
<pre class="literal-block">
# ContextVar.set
def set(self, new_value):
    top_context = get_thread_state().current_context_stack.maps[0]
    token = Token(top_context, self, top_context.get(self, Token.MISSING))
    top_context._data[self] = new_value
    return token
</pre>
<p>And finally, to allow for introspection of the full context stack, we
provide a new function <tt class="docutils literal">contextvars.get_context_stack</tt>:</p>
<pre class="literal-block">
def get_context_stack() -&gt; List[Context]:
    return list(get_thread_state().current_context_stack.maps)
</pre>
<p>That's all.</p>
</div>
</div>
<div class="section" id="comparison-to-pep-550">
<h1>Comparison to <a class="reference external" href="/dev/peps/pep-0550">PEP 550</a></h1>
<p>The main difference from <a class="reference external" href="/dev/peps/pep-0550">PEP 550</a> is that it reified what we're calling
&quot;contexts&quot; and &quot;context stacks&quot; as two different concrete types
(<tt class="docutils literal">LocalContext</tt> and <tt class="docutils literal">ExecutionContext</tt> respectively). This led to
lots of confusion about what the differences were, and which object
should be used in which places. This proposal simplifies things by
only reifying the <tt class="docutils literal">Context</tt>, which is &quot;just a dict&quot;, and makes the
&quot;context stack&quot; an unnamed feature of the interpreter's runtime state
– though it is still possible to introspect it using
<tt class="docutils literal">get_context_stack</tt>, for debugging and other purposes.</p>
</div>
<div class="section" id="implementation-notes">
<h1><a class="toc-backref" href="#id9">Implementation notes</a></h1>
<p><tt class="docutils literal">Context</tt> will continue to use a HAMT-based mapping structure under
the hood instead of <tt class="docutils literal">dict</tt>, since we expect that calls to
<tt class="docutils literal">copy_context</tt> are much more common than <tt class="docutils literal">ContextVar.set</tt>. In
almost all cases, <tt class="docutils literal">copy_context</tt> will find that there's only one
<tt class="docutils literal">Context</tt> in the stack (because it's rare for generators to spawn
new tasks), and can simply re-use it directly; in other cases HAMTs
are cheap to merge and this can be done lazily.</p>
<p>Rather than using an actual <tt class="docutils literal">ChainMap</tt> object, we'll represent the
context stack using some appropriate structure – the most appropriate
options are probably either a bare <tt class="docutils literal">list</tt> with the &quot;top&quot; of the
stack being the end of the list so we can use <tt class="docutils literal">push</tt>/<tt class="docutils literal">pop</tt>, or
else an intrusive linked list (<tt class="docutils literal">PyThreadState</tt> → <tt class="docutils literal">Context</tt> →
<tt class="docutils literal">Context</tt> → ...), with the &quot;top&quot; of the stack at the beginning of
the list to allow efficient push/pop.</p>
<p>A critical optimization in <a class="reference external" href="/dev/peps/pep-0567">PEP 567</a> is the caching of values inside
<tt class="docutils literal">ContextVar</tt>. Switching from a single context to a context stack
makes this a little bit more complicated, but not too much. Currently,
we invalidate the cache whenever the threadstate's current <tt class="docutils literal">Context</tt>
changes (on thread switch, and when entering/exiting <tt class="docutils literal">Context.run</tt>).
The simplest approach here would be to invalidate the cache whenever
stack changes (on thread switch, when entering/exiting
<tt class="docutils literal">Context.run</tt>, and when entering/leaving <tt class="docutils literal">Context.push</tt>). The main
effect of this is that iterating a generator will invalidate the
cache. It seems unlikely that this will cause serious problems, but if
it does, then I think it can be avoided with a cleverer cache key that
recognizes that pushing and then popping a <tt class="docutils literal">Context</tt> returns the
threadstate to its previous state. (Idea: store the cache key for a
particular stack configuration in the topmost <tt class="docutils literal">Context</tt>.)</p>
<p>It seems unavoidable in this design that uncached <tt class="docutils literal">get</tt> will be
O(n), where n is the size of the context stack. However, n will
generally be very small – it's roughly the number of nested
generators, so usually n=1, and it will be extremely rare to see n
greater than, say, 5. At worst, n is bounded by the recursion limit.
In addition, we can expect that in most cases of deep generator
recursion, most of the <tt class="docutils literal">Context</tt>s in the stack will be empty, and
thus can be skipped extremely quickly during lookup. And for repeated
lookups the caching mechanism will kick in. So it's probably possible
to construct some extreme case where this causes performance problems,
but ordinary code should be essentially unaffected.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id10">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
indent-tabs-mode: nil
coding: utf-8
End: -->
</div>

