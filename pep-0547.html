<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">547</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Running extension modules using the -m option</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0547.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Marcel Plch &lt;gmarcel.plch&#32;&#97;t&#32;gmail.com&gt;,
Petr Viktorin &lt;encukou&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Draft</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">25-May-2017</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.7</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id5">Abstract</a></li>
<li><a class="reference internal" href="#motivation" id="id6">Motivation</a></li>
<li><a class="reference internal" href="#rationale" id="id7">Rationale</a></li>
<li><a class="reference internal" href="#background" id="id8">Background</a></li>
<li><a class="reference internal" href="#proposal" id="id9">Proposal</a></li>
<li><a class="reference internal" href="#specification" id="id10">Specification</a><ul>
<li><a class="reference internal" href="#extensionfileloader-changes" id="id11">ExtensionFileLoader Changes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility" id="id12">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#reference-implementation" id="id13">Reference Implementation</a></li>
<li><a class="reference internal" href="#references" id="id14">References</a></li>
<li><a class="reference internal" href="#copyright" id="id15">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id5">Abstract</a></h1>
<p>This PEP proposes implementation that allows built-in and extension
modules to be executed in the <tt class="docutils literal">__main__</tt> namespace using
the <a class="reference external" href="/dev/peps/pep-0489">PEP 489</a> multi-phase initialization.</p>
<p>With this, a multi-phase initialization enabled module can be run
using following command:</p>
<pre class="literal-block">
$ python3 -m _testmultiphase
This is a test module named __main__.
</pre>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id6">Motivation</a></h1>
<p>Currently, extension modules do not support all functionality of
Python source modules.
Specifically, it is not possible to run extension modules as scripts using
Python's <tt class="docutils literal"><span class="pre">-m</span></tt> option.</p>
<p>The technical groundwork to make this possible has been done for <a class="reference external" href="/dev/peps/pep-0489">PEP 489</a>,
and enabling the <tt class="docutils literal"><span class="pre">-m</span></tt> option is listed in that PEP's
“Possible Future Extensions” section.
Technically, the additional changes proposed here are relatively small.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id7">Rationale</a></h1>
<p>Extension modules' lack of support for the <tt class="docutils literal"><span class="pre">-m</span></tt> option has traditionally
been worked around by providing a Python wrapper.
For example, the <tt class="docutils literal">_pickle</tt> module's command line interface is in the
pure-Python <tt class="docutils literal">pickle</tt> module (along with a pure-Python reimplementation).</p>
<p>This works well for standard library modules, as building command line
interfaces using the C API is cumbersome.
However, other users may want to create executable extension modules directly.</p>
<p>An important use case is Cython, a Python-like language that compiles to
C extension modules.
Cython is a (near) superset of Python, meaning that compiling a Python module
with Cython will typically not change the module's functionality, allowing
Cython-specific features to be added gradually.
This PEP will allow Cython extension modules to behave the same as their Python
counterparts when run using the <tt class="docutils literal"><span class="pre">-m</span></tt> option.
Cython developers consider the feature worth implementing (see
<a class="reference external" href="https://github.com/cython/cython/issues/1715">Cython issue 1715</a> <a class="footnote-reference" href="#id3" id="id4">[2]</a>).</p>
</div>
<div class="section" id="background">
<h1><a class="toc-backref" href="#id8">Background</a></h1>
<p>Python's <tt class="docutils literal"><span class="pre">-m</span></tt> option is handled by the function
<tt class="docutils literal">runpy._run_module_as_main</tt>.</p>
<p>The module specified by <tt class="docutils literal"><span class="pre">-m</span></tt> is not imported normally.
Instead, it is executed in the namespace of the <tt class="docutils literal">__main__</tt> module,
which is created quite early in interpreter initialization.</p>
<p>For Python source modules, running in another module's namespace is not
a problem: the code is executed with <tt class="docutils literal">locals</tt> and <tt class="docutils literal">globals</tt> set to the
existing module's <tt class="docutils literal">__dict__</tt>.
This is not the case for extension modules, whose <tt class="docutils literal">PyInit_*</tt> entry point
traditionally both created a new module object (using <tt class="docutils literal">PyModule_Create</tt>),
and initialized it.</p>
<p>Since Python 3.5, extension modules can use <a class="reference external" href="/dev/peps/pep-0489">PEP 489</a> multi-phase initialization.
In this scenario, the <tt class="docutils literal">PyInit_*</tt> entry point returns a <tt class="docutils literal">PyModuleDef</tt>
structure: a description of how the module should be created and initialized.
The extension can choose to customize creation of the module object using
the <tt class="docutils literal">Py_mod_create</tt> callback, or opt to use a normal module object by not
specifying <tt class="docutils literal">Py_mod_create</tt>.
Another callback, <tt class="docutils literal">Py_mod_exec</tt>, is then called to initialize the module
object, e.g. by populating it with methods and classes.</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id9">Proposal</a></h1>
<p>Multi-phase initialization makes it possible to execute an extension module in
another module's namespace: if a <tt class="docutils literal">Py_mod_create</tt> callback is not specified,
the <tt class="docutils literal">__main__</tt> module can be passed to the <tt class="docutils literal">Py_mod_exec</tt> callback to be
initialized, as if <tt class="docutils literal">__main__</tt> was a freshly constructed module object.</p>
<p>One complication in this scheme is C-level module state.
Each module has a <tt class="docutils literal">md_state</tt> pointer that points to a region of memory
allocated when an extension module is created.
The <tt class="docutils literal">PyModuleDef</tt> specifies how much memory is to be allocated.</p>
<p>The implementation must take care that <tt class="docutils literal">md_state</tt> memory is allocated at most
once.
Also, the <tt class="docutils literal">Py_mod_exec</tt> callback should only be called once per module.
The implications of multiply-initialized modules are too subtle to require
expecting extension authors to reason about them.
The <tt class="docutils literal">md_state</tt> pointer itself will serve as a guard: allocating the memory
and calling <tt class="docutils literal">Py_mod_exec</tt> will always be done together, and initializing an
extension module will fail if <tt class="docutils literal">md_state</tt> is already non-NULL.</p>
<p>Since the <tt class="docutils literal">__main__</tt> module is not created as an extension module,
its <tt class="docutils literal">md_state</tt> is normally <tt class="docutils literal">NULL</tt>.
Before initializing an extension module in <tt class="docutils literal">__main__</tt>'s context, its module
state will be allocated according to the <tt class="docutils literal">PyModuleDef</tt> of that module.</p>
<p>While <a class="reference external" href="/dev/peps/pep-0489">PEP 489</a> was designed to make these changes generally possible,
it's necessary to decouple module discovery, creation, and initialization
steps for extension modules, so that another module can be used instead of
a newly initialized one, and the functionality needs to be added to
<tt class="docutils literal">runpy</tt> and <tt class="docutils literal">importlib</tt>.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id10">Specification</a></h1>
<p>A new optional method for importlib loaders will be added.
This method will be called <tt class="docutils literal">exec_in_module</tt> and will take two
positional arguments: module spec and an already existing module.
Any import-related attributes, such as <tt class="docutils literal">__spec__</tt> or <tt class="docutils literal">__name__</tt>,
already set on the module will be ignored.</p>
<p>The <tt class="docutils literal">runpy._run_module_as_main</tt> function will look for this new
loader method.
If it is present, <tt class="docutils literal">runpy</tt> will execute it instead of trying to load and
run the module's Python code.
Otherwise, <tt class="docutils literal">runpy</tt> will act as before.</p>
<div class="section" id="extensionfileloader-changes">
<h2><a class="toc-backref" href="#id11">ExtensionFileLoader Changes</a></h2>
<p>importlib's <tt class="docutils literal">ExtensionFileLoader</tt> will get an implementation of
<tt class="docutils literal">exec_in_module</tt> that will call a new function, <tt class="docutils literal">_imp.exec_in_module</tt>.</p>
<p><tt class="docutils literal">_imp.exec_in_module</tt> will use existing machinery to find and call an
extension module's <tt class="docutils literal">PyInit_*</tt> function.</p>
<p>The <tt class="docutils literal">PyInit_*</tt> function can return either a fully initialized module
(single-phase initialization) or a <tt class="docutils literal">PyModuleDef</tt> (for <a class="reference external" href="/dev/peps/pep-0489">PEP 489</a> multi-phase
initialization).</p>
<p>In the single-phase initialization case, <tt class="docutils literal">_imp.exec_in_module</tt> will raise
<tt class="docutils literal">ImportError</tt>.</p>
<p>In the multi-phase initialization case, the <tt class="docutils literal">PyModuleDef</tt> and the module to
be initialized will be passed to a new function, <tt class="docutils literal">PyModule_ExecInModule</tt>.</p>
<p>This function raises <tt class="docutils literal">ImportError</tt> if the <tt class="docutils literal">PyModuleDef</tt> specifies
a <tt class="docutils literal">Py_mod_create</tt> slot, or if the module has already been initialized
(i.e. its <tt class="docutils literal">md_state</tt> pointer is not <tt class="docutils literal">NULL</tt>).
Otherwise, the function will initialize the module according to the
<tt class="docutils literal">PyModuleDef</tt>.</p>
</div>
</div>
<div class="section" id="backwards-compatibility">
<h1><a class="toc-backref" href="#id12">Backwards Compatibility</a></h1>
<p>This PEP maintains backwards compatibility.
It only adds new functions, and a new loader method that is added for
a loader that previously did not support running modules as <tt class="docutils literal">__main__</tt>.</p>
</div>
<div class="section" id="reference-implementation">
<h1><a class="toc-backref" href="#id13">Reference Implementation</a></h1>
<p>The reference implementation of this PEP is available at <a class="reference external" href="https://github.com/python/cpython/pull/1761">GitHub</a> <a class="footnote-reference" href="#id1" id="id2">[1]</a>.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id14">References</a></h1>
<table class="docutils footnote" frame="void" id="id1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td><a class="reference external" href="https://github.com/python/cpython/pull/1761">https://github.com/python/cpython/pull/1761</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[2]</a></td><td><a class="reference external" href="https://github.com/cython/cython/issues/1715">https://github.com/cython/cython/issues/1715</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id15">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

