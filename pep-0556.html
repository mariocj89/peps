<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">556</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Threaded garbage collection</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Antoine Pitrou &lt;solipsis&#32;&#97;t&#32;pitrou.net&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Draft</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">2017-09-08</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.7</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">2017-09-08</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id3">Abstract</a></li>
<li><a class="reference internal" href="#terminology" id="id4">Terminology</a></li>
<li><a class="reference internal" href="#rationale" id="id5">Rationale</a></li>
<li><a class="reference internal" href="#proposal" id="id6">Proposal</a><ul>
<li><a class="reference internal" href="#new-public-apis" id="id7">New public APIs</a></li>
<li><a class="reference internal" href="#intended-use" id="id8">Intended use</a></li>
<li><a class="reference internal" href="#non-goals" id="id9">Non-goals</a></li>
</ul>
</li>
<li><a class="reference internal" href="#internal-details" id="id10">Internal details</a><ul>
<li><a class="reference internal" href="#gc-module" id="id11"><tt class="docutils literal">gc</tt> module</a></li>
<li><a class="reference internal" href="#threading-module" id="id12"><tt class="docutils literal">threading</tt> module</a></li>
<li><a class="reference internal" href="#pseudo-code" id="id13">Pseudo-code</a></li>
</ul>
</li>
<li><a class="reference internal" href="#discussion" id="id14">Discussion</a><ul>
<li><a class="reference internal" href="#default-mode" id="id15">Default mode</a></li>
<li><a class="reference internal" href="#explicit-collections" id="id16">Explicit collections</a></li>
<li><a class="reference internal" href="#impact-on-memory-use" id="id17">Impact on memory use</a></li>
<li><a class="reference internal" href="#impact-on-cpu-consumption" id="id18">Impact on CPU consumption</a></li>
<li><a class="reference internal" href="#impact-on-gc-pauses" id="id19">Impact on GC pauses</a></li>
</ul>
</li>
<li><a class="reference internal" href="#open-issues" id="id20">Open issues</a></li>
<li><a class="reference internal" href="#implementation" id="id21">Implementation</a></li>
<li><a class="reference internal" href="#references" id="id22">References</a></li>
<li><a class="reference internal" href="#copyright" id="id23">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id3">Abstract</a></h1>
<p>This PEP proposes a new optional mode of operation for CPython's cyclic
garbage collector (GC) where implicit (i.e. opportunistic) collections
happen in a dedicated thread rather than synchronously.</p>
</div>
<div class="section" id="terminology">
<h1><a class="toc-backref" href="#id4">Terminology</a></h1>
<p>An &quot;implicit&quot; GC run (or &quot;implicit&quot; collection) is one that is triggered
opportunistically based on a certain heuristic computed over allocation
statistics, whenever a new allocation is requested.  Details of the
heuristic are not relevant to this PEP, as it does not propose to change it.</p>
<p>An &quot;explicit&quot; GC run (or &quot;explicit&quot; collection) is one that is requested
programmatically by an API call such as <tt class="docutils literal">gc.collect</tt>.</p>
<p>&quot;Threaded&quot; refers to the fact that GC runs happen in a dedicated thread
separate from sequential execution of application code.  It does not mean
&quot;concurrent&quot; (the Global Interpreter Lock, or GIL, still serializes
execution among Python threads <em>including</em> the dedicated GC thread)
nor &quot;parallel&quot; (the GC is not able to distribute its work onto several
threads at once to lower wall-clock latencies of GC runs).</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id5">Rationale</a></h1>
<p>The mode of operation for the GC has always been to perform implicit
collections synchronously.  That is, whenever the aforementioned heuristic
is activated, execution of application code in the current thread is
suspended and the GC is launched in order to reclaim dead reference
cycles.</p>
<p>There is a catch, though.  Over the course of reclaiming dead reference
cycles (and any ancillary objects hanging at those cycles), the GC can
execute arbitrary finalization code in the form of <tt class="docutils literal">__del__</tt> methods
and <tt class="docutils literal">weakref</tt> callbacks.  Over the years, Python has been used for more
and more sophisticated purposes, and it is increasingly common for
finalization code to perform complex tasks, for example in distributed
systems where loss of an object may require notifying other (logical
or physical) nodes.</p>
<p>Interrupting application code at arbitrary points to execute finalization
code that may rely on a consistent internal state and/or on acquiring
synchronization primitives give rise to reentrancy issues that even the
most seasoned experts have trouble fixing properly <a class="footnote-reference" href="#id2" id="id1">[1]</a>.</p>
<p>This PEP bases itself on the observation that, despite the apparent
similarities, same-thread reentrancy is a fundamentally harder
problem than multi-thread synchronization.  Instead of letting each
developer or library author struggle with extremely hard reentrancy
issues, one by one, this PEP proposes to allow the GC to run in a
separate thread where well-known multi-thread synchronization practices
are sufficient.</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id6">Proposal</a></h1>
<p>Under this PEP, the GC has two modes of operation:</p>
<ul class="simple">
<li>&quot;serial&quot;, which is the default and legacy mode, where an implicit GC
run is performed immediately in the thread that detects such an implicit
run is desired (based on the aforementioned allocation heuristic).</li>
<li>&quot;threaded&quot;, which can be explicitly enabled at runtime on a per-process
basis, where implicit GC runs are <em>scheduled</em> whenever the allocation
heuristic is triggered, but run in a dedicated background thread.</li>
</ul>
<p>Hard reentrancy problems which plague sophisticated uses of finalization
callbacks in the &quot;serial&quot; mode become relatively easy multi-thread
synchronization problems in the &quot;threaded&quot; mode of operation.</p>
<p>The GC also traditionally allows for explicit GC runs, using the Python
API <tt class="docutils literal">gc.collect</tt> and the C API <tt class="docutils literal">PyGC_Collect</tt>.  The visible semantics
of these two APIs are left unchanged: they perform a GC run immediately
when called, and only return when the GC run is finished.</p>
<div class="section" id="new-public-apis">
<h2><a class="toc-backref" href="#id7">New public APIs</a></h2>
<p>Two new Python APIs are added to the <tt class="docutils literal">gc</tt> module:</p>
<ul class="simple">
<li><tt class="docutils literal">gc.set_mode(mode)</tt> sets the current mode of operation (either &quot;serial&quot;
or &quot;threaded&quot;).  If setting to &quot;serial&quot; and the current mode is
&quot;threaded&quot;, then the function also waits for the GC thread to end.</li>
<li><tt class="docutils literal">gc.get_mode()</tt> returns the current mode of operation.</li>
</ul>
<p>It is allowed to switch back and forth between modes of operation.</p>
</div>
<div class="section" id="intended-use">
<h2><a class="toc-backref" href="#id8">Intended use</a></h2>
<p>Given the per-process nature of the switch and its repercussions on
semantics of all finalization callbacks, it is recommended that it is
set at the beginning of an application's code (and/or in initializers
for child processes e.g. when using <tt class="docutils literal">multiprocessing</tt>).  Library functions
should probably not mess with this setting, just as they shouldn't call
<tt class="docutils literal">gc.enable</tt> or <tt class="docutils literal">gc.disable</tt>, but there's nothing to prevent them from
doing so.</p>
</div>
<div class="section" id="non-goals">
<h2><a class="toc-backref" href="#id9">Non-goals</a></h2>
<p>This PEP does not address reentrancy issues with other kinds of
asynchronous code execution (for example signal handlers registered
with the <tt class="docutils literal">signal</tt> module).  The author believes that the overwhelming
majority of painful reentrancy issues occur with finalizers.  Most of the
time, signal handlers are able to set a single flag and/or wake up a
file descriptor for the main program to notice.  As for those signal
handlers which raise an exception, they <em>have</em> to execute in-thread.</p>
<p>This PEP also does not change the execution of finalization callbacks
when they are called as part of regular reference counting, i.e. when
releasing a visible reference drops an object's reference count to zero.
Since such execution happens at deterministic points in code, it is usually
not a problem.</p>
</div>
</div>
<div class="section" id="internal-details">
<h1><a class="toc-backref" href="#id10">Internal details</a></h1>
<div class="section" id="gc-module">
<h2><a class="toc-backref" href="#id11"><tt class="docutils literal">gc</tt> module</a></h2>
<p>An internal flag <tt class="docutils literal">gc_is_threaded</tt> is added, telling whether GC is serial
or threaded.</p>
<p>An internal structure <tt class="docutils literal">gc_mutex</tt> is added to avoid two GC runs at once:</p>
<pre class="code literal-block">
static struct {
    PyThread_type_lock lock;  /* taken when collecting */
    PyThreadState *owner;  /* whichever thread is currently collecting
                              (NULL if no collection is taking place) */
} gc_mutex;
</pre>
<p>An internal structure <tt class="docutils literal">gc_thread</tt> is added to handle synchronization with
the GC thread:</p>
<pre class="code literal-block">
static struct {
   PyThread_type_lock wakeup; /* acts as an event
                                 to wake up the GC thread */
   int collection_requested; /* non-zero if collection requested */
   PyThread_type_lock done; /* acts as an event signaling
                               the GC thread has exited */
} gc_thread;
</pre>
</div>
<div class="section" id="threading-module">
<h2><a class="toc-backref" href="#id12"><tt class="docutils literal">threading</tt> module</a></h2>
<p>Two private functions are added to the <tt class="docutils literal">threading</tt> module:</p>
<ul class="simple">
<li><tt class="docutils literal">threading._ensure_dummy_thread(name)</tt> creates and registers a <tt class="docutils literal">Thread</tt>
instance for the current thread with the given <em>name</em>, and returns it.</li>
<li><tt class="docutils literal">threading._remove_dummy_thread(thread)</tt> removes the given <em>thread</em>
(as returned by <tt class="docutils literal">_ensure_dummy_thread</tt>) from the threading module's
internal state.</li>
</ul>
<p>The purpose of these two functions is to improve debugging and introspection
by letting <tt class="docutils literal">threading.current_thread()</tt> return a more meaningfully-named
object when called inside a finalization callback in the GC thread.</p>
</div>
<div class="section" id="pseudo-code">
<h2><a class="toc-backref" href="#id13">Pseudo-code</a></h2>
<p>Here is a proposed pseudo-code for the main primitives, public and internal,
required for implementing this PEP.  All of them will be implemented in C
and live inside the <tt class="docutils literal">gc</tt> module, unless otherwise noted:</p>
<pre class="code literal-block">
def collect_with_callback(generation):
    &quot;&quot;&quot;
    Collect up to the given *generation*.
    &quot;&quot;&quot;
    # Same code as currently (see collect_with_callback() in gcmodule.c)


def collect_generations():
    &quot;&quot;&quot;
    Collect as many generations as desired by the heuristic.
    &quot;&quot;&quot;
    # Same code as currently (see collect_generations() in gcmodule.c)


def lock_and_collect(generation=-1):
    &quot;&quot;&quot;
    Perform a collection with thread safety.
    &quot;&quot;&quot;
    me = PyThreadState_GET()
    if gc_mutex.owner == me:
        # reentrant GC collection request, bail out
        return
    Py_BEGIN_ALLOW_THREADS
    gc_mutex.lock.acquire()
    Py_END_ALLOW_THREADS
    gc_mutex.owner = me
    try:
        if generation &gt;= 0:
            return collect_with_callback(generation)
        else:
            return collect_generations()
    finally:
        gc_mutex.owner = NULL
        gc_mutex.lock.release()


def schedule_gc_request():
    &quot;&quot;&quot;
    Ask the GC thread to run an implicit collection.
    &quot;&quot;&quot;
    assert gc_is_threaded == True
    # Note this is extremely fast if a collection is already requested
    if gc_thread.collection_requested == False:
        gc_thread.collection_requested = True
        gc_thread.wakeup.release()


def is_implicit_gc_desired():
    &quot;&quot;&quot;
    Whether an implicit GC run is currently desired based on allocation
    stats.  Return a generation number, or -1 if none desired.
    &quot;&quot;&quot;
    # Same heuristic as currently (see _PyObject_GC_Alloc in gcmodule.c)


def PyGC_Malloc():
    &quot;&quot;&quot;
    Allocate a GC-enabled object.
    &quot;&quot;&quot;
    # Update allocation statistics (same code as currently, omitted for brievity)
    if is_implicit_gc_desired():
        if gc_is_threaded:
            schedule_gc_request()
        else:
            lock_and_collect()
    # Go ahead with allocation (same code as currently, omitted for brievity)


def gc_thread(interp_state):
    &quot;&quot;&quot;
    Dedicated loop for threaded GC.
    &quot;&quot;&quot;
    # Init Python thread state (omitted, see t_bootstrap in _threadmodule.c)
    # Optional: init thread in Python threading module, for better introspection
    me = threading._ensure_dummy_thread(name=&quot;GC thread&quot;)

    while gc_is_threaded == True:
        Py_BEGIN_ALLOW_THREADS
        gc_thread.wakeup.acquire()
        Py_END_ALLOW_THREADS
        if gc_thread.collection_requested != 0:
            gc_thread.collection_requested = 0
            lock_and_collect(generation=-1)

    threading._remove_dummy_thread(me)
    # Signal we're exiting
    gc_thread.done.release()
    # Free Python thread state (omitted)


def gc.set_mode(mode):
    &quot;&quot;&quot;
    Set current GC mode.  This is a process-global setting.
    &quot;&quot;&quot;
    if mode == &quot;threaded&quot;:
        if not gc_is_threaded == False:
            # Launch thread
            gc_thread.done.acquire(block=False)  # should not fail
            gc_is_threaded = True
            PyThread_start_new_thread(gc_thread)
    elif mode == &quot;serial&quot;:
        if gc_is_threaded == True:
            # Wake up thread, asking it to end
            gc_is_threaded = False
            gc_thread.wakeup.release()
            # Wait for thread exit
            Py_BEGIN_ALLOW_THREADS
            gc_thread.done.acquire()
            Py_END_ALLOW_THREADS
            gc_thread.done.release()
    else:
        raise ValueError(&quot;unsupported mode %r&quot; % (mode,))


def gc.get_mode(mode):
    &quot;&quot;&quot;
    Get current GC mode.
    &quot;&quot;&quot;
    return &quot;threaded&quot; if gc_is_threaded else &quot;serial&quot;


def gc.collect(generation=2):
    &quot;&quot;&quot;
    Schedule collection of the given generation and wait for it to
    finish.
    &quot;&quot;&quot;
    return lock_and_collect(generation)
</pre>
</div>
</div>
<div class="section" id="discussion">
<h1><a class="toc-backref" href="#id14">Discussion</a></h1>
<div class="section" id="default-mode">
<h2><a class="toc-backref" href="#id15">Default mode</a></h2>
<p>One may wonder whether the default mode should simply be changed to &quot;threaded&quot;.
For multi-threaded applications, it would probably not be a problem:
those applications must already be prepared for finalization handlers to
be run in arbitrary threads.  In single-thread applications, however, it
is currently guaranteed that finalizers will always be called in the main
thread.  Breaking this property may induce subtle behaviour changes or bugs,
for example if finalizers rely on some thread-local values.</p>
<p>Another problem is when a program uses <tt class="docutils literal">fork()</tt> for concurrency.
Calling <tt class="docutils literal">fork()</tt> from a single-threaded program is safe,
but it's fragile (to say the least) if the program is multi-threaded.</p>
</div>
<div class="section" id="explicit-collections">
<h2><a class="toc-backref" href="#id16">Explicit collections</a></h2>
<p>One may ask whether explicit collections should also be delegated to the
background thread.  The answer is it doesn't really matter: since
<tt class="docutils literal">gc.collect</tt> and <tt class="docutils literal">PyGC_Collect</tt> actually <em>wait</em> for the collection to
end (breaking this property would break compatibility), delegating the
actual work to a background thread wouldn't ease synchronization with the
thread requesting an explicit collection.</p>
<p>In the end, this PEP choses the behaviour that seems simpler to implement
based on the pseudo-code above.</p>
</div>
<div class="section" id="impact-on-memory-use">
<h2><a class="toc-backref" href="#id17">Impact on memory use</a></h2>
<p>The &quot;threaded&quot; mode incurs a slight delay in implicit collections compared
to the default &quot;serial&quot; mode.  This obviously may change the memory profile
of certain applications.  By how much remains to be measured in real-world
use, but we expect the impact to remain minor and bearable.  First because
implicit collections are based on a <em>heuristic</em> whose effect does not result
in deterministic visible behaviour anyway.  Second because the GC deals
with reference cycles while many objects are reclaimed immediately when their
last visible reference disappears.</p>
</div>
<div class="section" id="impact-on-cpu-consumption">
<h2><a class="toc-backref" href="#id18">Impact on CPU consumption</a></h2>
<p>The pseudo-code above adds two lock operations for each implicit collection
request in &quot;threaded&quot; mode: one in the thread making the request (a
<tt class="docutils literal">release</tt> call) and one in the GC thread (an <tt class="docutils literal">acquire</tt> call).
It also adds two other lock operations, regardless of the current mode,
around each actual collection.</p>
<p>We expect the cost of those lock operations to be very small, on modern
systems, compared to the actual cost of crawling through the chains of
pointers during the collection itself (&quot;pointer chasing&quot; being one of
the hardest workloads on modern CPUs, as it lends itself poorly to
speculation and superscalar execution).</p>
<p>Actual measurements on worst-case mini-benchmarks may help provide
reassuring upper bounds.</p>
</div>
<div class="section" id="impact-on-gc-pauses">
<h2><a class="toc-backref" href="#id19">Impact on GC pauses</a></h2>
<p>While this PEP does not concern itself with GC pauses, there is a
practical chance that releasing the GIL at some point during an implicit
collection (for example by virtue of executing a pure Python finalizer)
will allow application code to run in-between, lowering the <em>visible</em> GC
pause time for some applications.</p>
<p>If this PEP is accepted, future work may try to better realize this potential
by speculatively releasing the GIL during collections, though it is unclear
how doable that is.</p>
</div>
</div>
<div class="section" id="open-issues">
<h1><a class="toc-backref" href="#id20">Open issues</a></h1>
<ul class="simple">
<li><tt class="docutils literal">gc.set_mode</tt> should probably be protected against multiple concurrent
invocations.  Also, it should raise when called from <em>inside</em> a GC run
(i.e. from a finalizer).</li>
<li>What happens at shutdown?  Does the GC thread run until <tt class="docutils literal">_PyGC_Fini()</tt>
is called?</li>
</ul>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id21">Implementation</a></h1>
<p>No actual implementation exists as of yet.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id22">References</a></h1>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="https://bugs.python.org/issue14976">https://bugs.python.org/issue14976</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id23">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

