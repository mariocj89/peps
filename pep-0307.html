<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">307</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Extensions to the pickle protocol</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0307.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Guido van Rossum, Tim Peters</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">31-Jan-2003</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">7-Feb-2003</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id4">Introduction</a></li>
<li><a class="reference internal" href="#motivation" id="id5">Motivation</a></li>
<li><a class="reference internal" href="#protocol-versions" id="id6">Protocol versions</a></li>
<li><a class="reference internal" href="#security-issues" id="id7">Security issues</a></li>
<li><a class="reference internal" href="#extended-reduce-api" id="id8">Extended <tt class="docutils literal">__reduce__</tt> API</a></li>
<li><a class="reference internal" href="#the-reduce-ex-api" id="id9">The <tt class="docutils literal">__reduce_ex__</tt> API</a></li>
<li><a class="reference internal" href="#customizing-pickling-absent-a-reduce-implementation" id="id10">Customizing pickling absent a <tt class="docutils literal">__reduce__</tt> implementation</a><ul>
<li><a class="reference internal" href="#case-1-pickling-classic-class-instances" id="id11">Case 1: pickling classic class instances</a><ul>
<li><a class="reference internal" href="#the-getstate-method" id="id12">The <tt class="docutils literal">__getstate__</tt> method</a></li>
<li><a class="reference internal" href="#the-setstate-method" id="id13">The <tt class="docutils literal">__setstate__</tt> method</a></li>
<li><a class="reference internal" href="#the-getinitargs-method" id="id14">The <tt class="docutils literal">__getinitargs__</tt> method</a></li>
</ul>
</li>
<li><a class="reference internal" href="#case-2-pickling-new-style-class-instances-using-protocols-0-or-1" id="id15">Case 2: pickling new-style class instances using protocols 0 or 1</a></li>
<li><a class="reference internal" href="#case-3-pickling-new-style-class-instances-using-protocol-2" id="id16">Case 3: pickling new-style class instances using protocol 2</a><ul>
<li><a class="reference internal" href="#id1" id="id17">The <tt class="docutils literal">__getstate__</tt> method</a></li>
<li><a class="reference internal" href="#id2" id="id18">The <tt class="docutils literal">__setstate__</tt> method</a></li>
<li><a class="reference internal" href="#the-getnewargs-method" id="id19">The <tt class="docutils literal">__getnewargs__</tt> method</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#the-newobj-unpickling-function" id="id20">The <tt class="docutils literal">__newobj__</tt> unpickling function</a></li>
<li><a class="reference internal" href="#the-extension-registry" id="id21">The extension registry</a><ul>
<li><a class="reference internal" href="#extension-registry-api" id="id22">Extension registry API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-copy-module" id="id23">The copy module</a></li>
<li><a class="reference internal" href="#pickling-python-longs" id="id24">Pickling Python longs</a></li>
<li><a class="reference internal" href="#pickling-bools" id="id25">Pickling bools</a></li>
<li><a class="reference internal" href="#pickling-small-tuples" id="id26">Pickling small tuples</a></li>
<li><a class="reference internal" href="#protocol-identification" id="id27">Protocol identification</a></li>
<li><a class="reference internal" href="#pickling-of-large-lists-and-dicts" id="id28">Pickling of large lists and dicts</a></li>
<li><a class="reference internal" href="#copyright" id="id29">Copyright</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id4">Introduction</a></h1>
<p>Pickling new-style objects in Python 2.2 is done somewhat clumsily
and causes pickle size to bloat compared to classic class
instances.  This PEP documents a new pickle protocol in Python 2.3
that takes care of this and many other pickle issues.</p>
<p>There are two sides to specifying a new pickle protocol: the byte
stream constituting pickled data must be specified, and the
interface between objects and the pickling and unpickling engines
must be specified.  This PEP focuses on API issues, although it
may occasionally touch on byte stream format details to motivate a
choice.  The pickle byte stream format is documented formally by
the standard library module <tt class="docutils literal">pickletools.py</tt> (already checked into
CVS for Python 2.3).</p>
<p>This PEP attempts to fully document the interface between pickled
objects and the pickling process, highlighting additions by
specifying &quot;new in this PEP&quot;.  (The interface to invoke pickling
or unpickling is not covered fully, except for the changes to the
API for specifying the pickling protocol to picklers.)</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id5">Motivation</a></h1>
<p>Pickling new-style objects causes serious pickle bloat.  For
example:</p>
<pre class="literal-block">
class C(object): # Omit &quot;(object)&quot; for classic class
    pass
x = C()
x.foo = 42
print len(pickle.dumps(x, 1))
</pre>
<p>The binary pickle for the classic object consumed 33 bytes, and for
the new-style object 86 bytes.</p>
<p>The reasons for the bloat are complex, but are mostly caused by
the fact that new-style objects use <tt class="docutils literal">__reduce__</tt> in order to be
picklable at all.  After ample consideration we've concluded that
the only way to reduce pickle sizes for new-style objects is to
add new opcodes to the pickle protocol.  The net result is that
with the new protocol, the pickle size in the above example is 35
(two extra bytes are used at the start to indicate the protocol
version, although this isn't strictly necessary).</p>
</div>
<div class="section" id="protocol-versions">
<h1><a class="toc-backref" href="#id6">Protocol versions</a></h1>
<p>Previously, pickling (but not unpickling) distinguished between
text mode and binary mode.  By design, binary mode is a
superset of text mode, and unpicklers don't need to know in
advance whether an incoming pickle uses text mode or binary mode.
The virtual machine used for unpickling is the same regardless of
the mode; certain opcodes simply aren't used in text mode.</p>
<p>Retroactively, text mode is now called protocol 0, and binary mode
protocol 1.  The new protocol is called protocol 2.  In the
tradition of pickling protocols, protocol 2 is a superset of
protocol 1.  But just so that future pickling protocols aren't
required to be supersets of the oldest protocols, a new opcode is
inserted at the start of a protocol 2 pickle indicating that it is
using protocol 2.  To date, each release of Python has been able to
read pickles written by all previous releases.  Of course pickles
written under protocol <em>N</em> can't be read by versions of Python
earlier than the one that introduced protocol <em>N</em>.</p>
<p>Several functions, methods and constructors used for pickling used
to take a positional argument named 'bin' which was a flag,
defaulting to 0, indicating binary mode.  This argument is renamed
to 'protocol' and now gives the protocol number, still defaulting
to 0.</p>
<p>It so happens that passing 2 for the 'bin' argument in previous
Python versions had the same effect as passing 1.  Nevertheless, a
special case is added here:  passing a negative number selects the
highest protocol version supported by a particular implementation.
This works in previous Python versions, too, and so can be used to
select the highest protocol available in a way that's both backward
and forward compatible.  In addition, a new module constant
<tt class="docutils literal">HIGHEST_PROTOCOL</tt> is supplied by both <tt class="docutils literal">pickle</tt> and <tt class="docutils literal">cPickle</tt>, equal to
the highest protocol number the module can read.  This is cleaner
than passing -1, but cannot be used before Python 2.3.</p>
<p>The <tt class="docutils literal">pickle.py</tt> module has supported passing the 'bin' value as a
keyword argument rather than a positional argument.  (This is not
recommended, since <tt class="docutils literal">cPickle</tt> only accepts positional arguments, but
it works...)  Passing 'bin' as a keyword argument is deprecated,
and a <tt class="docutils literal">PendingDeprecationWarning</tt> is issued in this case.  You have
to invoke the Python interpreter with <tt class="docutils literal"><span class="pre">-Wa</span></tt> or a variation on that
to see <tt class="docutils literal">PendingDeprecationWarning</tt> messages.  In Python 2.4, the
warning class may be upgraded to <tt class="docutils literal">DeprecationWarning</tt>.</p>
</div>
<div class="section" id="security-issues">
<h1><a class="toc-backref" href="#id7">Security issues</a></h1>
<p>In previous versions of Python, unpickling would do a &quot;safety
check&quot; on certain operations, refusing to call functions or
constructors that weren't marked as &quot;safe for unpickling&quot; by
either having an attribute <tt class="docutils literal">__safe_for_unpickling__</tt> set to 1, or by
being registered in a global registry, <tt class="docutils literal">copy_reg.safe_constructors</tt>.</p>
<p>This feature gives a false sense of security: nobody has ever done
the necessary, extensive, code audit to prove that unpickling
untrusted pickles cannot invoke unwanted code, and in fact bugs in
the Python 2.2 <tt class="docutils literal">pickle.py</tt> module make it easy to circumvent these
security measures.</p>
<p>We firmly believe that, on the Internet, it is better to know that
you are using an insecure protocol than to trust a protocol to be
secure whose implementation hasn't been thoroughly checked.  Even
high quality implementations of widely used protocols are
routinely found flawed; Python's pickle implementation simply
cannot make such guarantees without a much larger time investment.
Therefore, as of Python 2.3, all safety checks on unpickling are
officially removed, and replaced with this warning:</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Do not unpickle data received from an untrusted or
unauthenticated source.</p>
</div>
<p>The same warning applies to previous Python versions, despite the
presence of safety checks there.</p>
</div>
<div class="section" id="extended-reduce-api">
<h1><a class="toc-backref" href="#id8">Extended <tt class="docutils literal">__reduce__</tt> API</a></h1>
<p>There are several APIs that a class can use to control pickling.
Perhaps the most popular of these are <tt class="docutils literal">__getstate__</tt> and
<tt class="docutils literal">__setstate__</tt>; but the most powerful one is <tt class="docutils literal">__reduce__</tt>.  (There's
also <tt class="docutils literal">__getinitargs__</tt>, and we're adding <tt class="docutils literal">__getnewargs__</tt> below.)</p>
<p>There are several ways to provide <tt class="docutils literal">__reduce__</tt> functionality: a
class can implement a <tt class="docutils literal">__reduce__</tt> method or a <tt class="docutils literal">__reduce_ex__</tt> method
(see next section), or a reduce function can be declared in
<tt class="docutils literal">copy_reg</tt> (<tt class="docutils literal">copy_reg.dispatch_table</tt> maps classes to functions).  The
return values are interpreted exactly the same, though, and we'll
refer to these collectively as <tt class="docutils literal">__reduce__</tt>.</p>
<p><strong>Important:</strong> pickling of classic class instances does not look for a
<tt class="docutils literal">__reduce__</tt> or <tt class="docutils literal">__reduce_ex__</tt> method or a reduce function in the
<tt class="docutils literal">copy_reg</tt> dispatch table, so that a classic class cannot provide
<tt class="docutils literal">__reduce__</tt> functionality in the sense intended here.  A classic
class must use <tt class="docutils literal">__getinitargs__</tt> and/or <tt class="docutils literal">__getstate__</tt> to customize
pickling.  These are described below.</p>
<p><tt class="docutils literal">__reduce__</tt> must return either a string or a tuple.  If it returns
a string, this is an object whose state is not to be pickled, but
instead a reference to an equivalent object referenced by name.
Surprisingly, the string returned by <tt class="docutils literal">__reduce__</tt> should be the
object's local name (relative to its module); the <tt class="docutils literal">pickle</tt> module
searches the module namespace to determine the object's module.</p>
<p>The rest of this section is concerned with the tuple returned by
<tt class="docutils literal">__reduce__</tt>.  It is a variable size tuple, of length 2 through 5.
The first two items (function and arguments) are required.  The
remaining items are optional and may be left off from the end;
giving <tt class="docutils literal">None</tt> for the value of an optional item acts the same as
leaving it off.  The last two items are new in this PEP.  The items
are, in order:</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="85%" />
</colgroup>
<tbody valign="top">
<tr><td>function</td>
<td><p class="first">Required.</p>
<p class="last">A callable object (not necessarily a function) called
to create the initial version of the object; state
may be added to the object later to fully reconstruct
the pickled state.  This function must itself be
picklable.  See the section about <tt class="docutils literal">__newobj__</tt> for a
special case (new in this PEP) here.</p>
</td>
</tr>
<tr><td>arguments</td>
<td><p class="first">Required.</p>
<p class="last">A tuple giving the argument list for the function.
As a special case, designed for Zope 2's
<tt class="docutils literal">ExtensionClass</tt>, this may be <tt class="docutils literal">None</tt>; in that case,
function should be a class or type, and
<tt class="docutils literal">function.__basicnew__()</tt> is called to create the
initial version of the object.  This exception is
deprecated.</p>
</td>
</tr>
</tbody>
</table>
<p>Unpickling invokes <tt class="docutils literal"><span class="pre">function(*arguments)</span></tt> to create an initial object,
called <em>obj</em> below.  If the remaining items are left off, that's the end
of unpickling for this object and <em>obj</em> is the result.    Else <em>obj</em> is
modified at unpickling time by each item specified, as follows.</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="85%" />
</colgroup>
<tbody valign="top">
<tr><td>state</td>
<td><p class="first">Optional.</p>
<p>Additional state.  If this is not <tt class="docutils literal">None</tt>, the state is
pickled, and <tt class="docutils literal">obj.__setstate__(state)</tt> will be called
when unpickling.  If no <tt class="docutils literal">__setstate__</tt> method is
defined, a default implementation is provided, which
assumes that state is a dictionary mapping instance
variable names to their values.  The default
implementation calls</p>
<pre class="literal-block">
obj.__dict__.update(state)
</pre>
<p>or, if the <tt class="docutils literal">update()</tt> call fails,</p>
<pre class="last literal-block">
for k, v in state.items():
    setattr(obj, k, v)
</pre>
</td>
</tr>
<tr><td>listitems</td>
<td><p class="first">Optional, and new in this PEP.</p>
<p class="last">If this is not <tt class="docutils literal">None</tt>, it should be an iterator (not a
sequence!) yielding successive list items.  These list
items will be pickled, and appended to the object using
either <tt class="docutils literal">obj.append(item)</tt> or <tt class="docutils literal">obj.extend(list_of_items)</tt>.
This is primarily used for <tt class="docutils literal">list</tt> subclasses, but may
be used by other classes as long as they have <tt class="docutils literal">append()</tt>
and <tt class="docutils literal">extend()</tt> methods with the appropriate signature.
(Whether <tt class="docutils literal">append()</tt> or <tt class="docutils literal">extend()</tt> is used depends on which
pickle protocol version is used as well as the number
of items to append, so both must be supported.)</p>
</td>
</tr>
<tr><td>dictitems</td>
<td><p class="first">Optional, and new in this PEP.</p>
<p class="last">If this is not <tt class="docutils literal">None</tt>, it should be an iterator (not a
sequence!) yielding successive dictionary items, which
should be tuples of the form <tt class="docutils literal">(key, value)</tt>.  These items
will be pickled, and stored to the object using
<tt class="docutils literal">obj[key] = value</tt>.  This is primarily used for <tt class="docutils literal">dict</tt>
subclasses, but may be used by other classes as long
as they implement <tt class="docutils literal">__setitem__</tt>.</p>
</td>
</tr>
</tbody>
</table>
<p>Note: in Python 2.2 and before, when using <tt class="docutils literal">cPickle</tt>, state would be
pickled if present even if it is <tt class="docutils literal">None</tt>; the only safe way to avoid
the <tt class="docutils literal">__setstate__</tt> call was to return a two-tuple from <tt class="docutils literal">__reduce__</tt>.
(But <tt class="docutils literal">pickle.py</tt> would not pickle state if it was <tt class="docutils literal">None</tt>.)  In Python
2.3, <tt class="docutils literal">__setstate__</tt> will never be called at unpickling time when
<tt class="docutils literal">__reduce__</tt> returns a state with value <tt class="docutils literal">None</tt> at pickling time.</p>
<p>A <tt class="docutils literal">__reduce__</tt> implementation that needs to work both under Python
2.2 and under Python 2.3 could check the variable
<tt class="docutils literal">pickle.format_version</tt> to determine whether to use the <em>listitems</em>
and <em>dictitems</em> features.  If this value is <tt class="docutils literal">&gt;= &quot;2.0&quot;</tt> then they are
supported.  If not, any list or dict items should be incorporated
somehow in the 'state' return value, and the <tt class="docutils literal">__setstate__</tt> method
should be prepared to accept list or dict items as part of the
state (how this is done is up to the application).</p>
</div>
<div class="section" id="the-reduce-ex-api">
<h1><a class="toc-backref" href="#id9">The <tt class="docutils literal">__reduce_ex__</tt> API</a></h1>
<p>It is sometimes useful to know the protocol version when
implementing <tt class="docutils literal">__reduce__</tt>.  This can be done by implementing a
method named <tt class="docutils literal">__reduce_ex__</tt> instead of <tt class="docutils literal">__reduce__</tt>.  <tt class="docutils literal">__reduce_ex__</tt>,
when it exists, is called in preference over <tt class="docutils literal">__reduce__</tt> (you may
still provide <tt class="docutils literal">__reduce__</tt> for backwards compatibility).  The
<tt class="docutils literal">__reduce_ex__</tt> method will be called with a single integer
argument, the protocol version.</p>
<p>The 'object' class implements both <tt class="docutils literal">__reduce__</tt> and <tt class="docutils literal">__reduce_ex__</tt>;
however, if a subclass overrides <tt class="docutils literal">__reduce__</tt> but not <tt class="docutils literal">__reduce_ex__</tt>,
the <tt class="docutils literal">__reduce_ex__</tt> implementation detects this and calls
<tt class="docutils literal">__reduce__</tt>.</p>
</div>
<div class="section" id="customizing-pickling-absent-a-reduce-implementation">
<h1><a class="toc-backref" href="#id10">Customizing pickling absent a <tt class="docutils literal">__reduce__</tt> implementation</a></h1>
<p>If no <tt class="docutils literal">__reduce__</tt> implementation is available for a particular
class, there are three cases that need to be considered
separately, because they are handled differently:</p>
<ol class="arabic simple">
<li>classic class instances, all protocols</li>
<li>new-style class instances, protocols 0 and 1</li>
<li>new-style class instances, protocol 2</li>
</ol>
<p>Types implemented in C are considered new-style classes.  However,
except for the common built-in types, these need to provide a
<tt class="docutils literal">__reduce__</tt> implementation in order to be picklable with protocols
0 or 1.  Protocol 2 supports built-in types providing
<tt class="docutils literal">__getnewargs__</tt>, <tt class="docutils literal">__getstate__</tt> and <tt class="docutils literal">__setstate__</tt> as well.</p>
<div class="section" id="case-1-pickling-classic-class-instances">
<h2><a class="toc-backref" href="#id11">Case 1: pickling classic class instances</a></h2>
<p>This case is the same for all protocols, and is unchanged from
Python 2.1.</p>
<p>For classic classes, <tt class="docutils literal">__reduce__</tt> is not used.  Instead, classic
classes can customize their pickling by providing methods named
<tt class="docutils literal">__getstate__</tt>, <tt class="docutils literal">__setstate__</tt> and <tt class="docutils literal">__getinitargs__</tt>.  Absent these, a
default pickling strategy for classic class instances is
implemented that works as long as all instance variables are
picklable.  This default strategy is documented in terms of
default implementations of <tt class="docutils literal">__getstate__</tt> and <tt class="docutils literal">__setstate__</tt>.</p>
<p>The primary ways to customize pickling of classic class instances
is by specifying <tt class="docutils literal">__getstate__</tt> and/or <tt class="docutils literal">__setstate__</tt> methods.  It is
fine if a class implements one of these but not the other, as long
as it is compatible with the default version.</p>
<div class="section" id="the-getstate-method">
<h3><a class="toc-backref" href="#id12">The <tt class="docutils literal">__getstate__</tt> method</a></h3>
<p>The <tt class="docutils literal">__getstate__</tt> method should return a picklable value
representing the object's state without referencing the object
itself.  If no <tt class="docutils literal">__getstate__</tt> method exists, a default
implementation is used that returns <tt class="docutils literal">self.__dict__</tt>.</p>
</div>
<div class="section" id="the-setstate-method">
<h3><a class="toc-backref" href="#id13">The <tt class="docutils literal">__setstate__</tt> method</a></h3>
<p>The <tt class="docutils literal">__setstate__</tt> method should take one argument; it will be
called with the value returned by <tt class="docutils literal">__getstate__</tt> (or its default
implementation).</p>
<p>If no <tt class="docutils literal">__setstate__</tt> method exists, a default implementation is
provided that assumes the state is a dictionary mapping instance
variable names to values.  The default implementation tries two
things:</p>
<ul class="simple">
<li>First, it tries to call <tt class="docutils literal">self.__dict__.update(state)</tt>.</li>
<li>If the <tt class="docutils literal">update()</tt> call fails with a <tt class="docutils literal">RuntimeError</tt> exception, it
calls <tt class="docutils literal">setattr(self, key, value)</tt> for each <tt class="docutils literal">(key, value)</tt> pair in
the state dictionary.  This only happens when unpickling in
restricted execution mode (see the <tt class="docutils literal">rexec</tt> standard library
module).</li>
</ul>
</div>
<div class="section" id="the-getinitargs-method">
<h3><a class="toc-backref" href="#id14">The <tt class="docutils literal">__getinitargs__</tt> method</a></h3>
<p>The <tt class="docutils literal">__setstate__</tt> method (or its default implementation) requires
that a new object already exists so that its <tt class="docutils literal">__setstate__</tt> method
can be called.  The point is to create a new object that isn't
fully initialized; in particular, the class's <tt class="docutils literal">__init__</tt> method
should not be called if possible.</p>
<p>These are the possibilities:</p>
<ul class="simple">
<li>Normally, the following trick is used: create an instance of a
trivial classic class (one without any methods or instance
variables) and then use <tt class="docutils literal">__class__</tt> assignment to change its
class to the desired class.  This creates an instance of the
desired class with an empty <tt class="docutils literal">__dict__</tt> whose <tt class="docutils literal">__init__</tt> has not
been called.</li>
<li>However, if the class has a method named <tt class="docutils literal">__getinitargs__</tt>, the
above trick is not used, and a class instance is created by
using the tuple returned by <tt class="docutils literal">__getinitargs__</tt> as an argument
list to the class constructor.  This is done even if
<tt class="docutils literal">__getinitargs__</tt> returns an empty tuple --- a <tt class="docutils literal">__getinitargs__</tt>
method that returns <tt class="docutils literal">()</tt> is not equivalent to not having
<tt class="docutils literal">__getinitargs__</tt> at all.  <tt class="docutils literal">__getinitargs__</tt> <em>must</em> return a
tuple.</li>
<li>In restricted execution mode, the trick from the first bullet
doesn't work; in this case, the class constructor is called
with an empty argument list if no <tt class="docutils literal">__getinitargs__</tt> method
exists.  This means that in order for a classic class to be
unpicklable in restricted execution mode, it must either
implement <tt class="docutils literal">__getinitargs__</tt> or its constructor (i.e., its
<tt class="docutils literal">__init__</tt> method) must be callable without arguments.</li>
</ul>
</div>
</div>
<div class="section" id="case-2-pickling-new-style-class-instances-using-protocols-0-or-1">
<h2><a class="toc-backref" href="#id15">Case 2: pickling new-style class instances using protocols 0 or 1</a></h2>
<p>This case is unchanged from Python 2.2.  For better pickling of
new-style class instances when backwards compatibility is not an
issue, protocol 2 should be used; see case 3 below.</p>
<p>New-style classes, whether implemented in C or in Python, inherit
a default <tt class="docutils literal">__reduce__</tt> implementation from the universal base class
'object'.</p>
<p>This default <tt class="docutils literal">__reduce__</tt> implementation is not used for those
built-in types for which the <tt class="docutils literal">pickle</tt> module has built-in support.
Here's a full list of those types:</p>
<ul class="simple">
<li>Concrete built-in types: <tt class="docutils literal">NoneType</tt>, <tt class="docutils literal">bool</tt>, <tt class="docutils literal">int</tt>, <tt class="docutils literal">float</tt>, <tt class="docutils literal">complex</tt>,
<tt class="docutils literal">str</tt>, <tt class="docutils literal">unicode</tt>, <tt class="docutils literal">tuple</tt>, <tt class="docutils literal">list</tt>, <tt class="docutils literal">dict</tt>.  (Complex is supported by
virtue of a <tt class="docutils literal">__reduce__</tt> implementation registered in <tt class="docutils literal">copy_reg</tt>.)
In Jython, <tt class="docutils literal">PyStringMap</tt> is also included in this list.</li>
<li>Classic instances.</li>
<li>Classic class objects, Python function objects, built-in
function and method objects, and new-style type objects (==
new-style class objects).  These are pickled by name, not by
value: at unpickling time, a reference to an object with the
same name (the fully qualified module name plus the variable
name in that module) is substituted.</li>
</ul>
<p>The default <tt class="docutils literal">__reduce__</tt> implementation will fail at pickling time
for built-in types not mentioned above, and for new-style classes
implemented in C:  if they want to be picklable, they must supply
a custom <tt class="docutils literal">__reduce__</tt> implementation under protocols 0 and 1.</p>
<p>For new-style classes implemented in Python, the default
<tt class="docutils literal">__reduce__</tt> implementation (<tt class="docutils literal">copy_reg._reduce</tt>) works as follows:</p>
<p>Let <tt class="docutils literal">D</tt> be the class on the object to be pickled.  First, find the
nearest base class that is implemented in C (either as a
built-in type or as a type defined by an extension class).  Call
this base class <tt class="docutils literal">B</tt>, and the class of the object to be pickled <tt class="docutils literal">D</tt>.
Unless <tt class="docutils literal">B</tt> is the class 'object', instances of class <tt class="docutils literal">B</tt> must be
picklable, either by having built-in support (as defined in the
above three bullet points), or by having a non-default
<tt class="docutils literal">__reduce__</tt> implementation.  <tt class="docutils literal">B</tt> must not be the same class as <tt class="docutils literal">D</tt>
(if it were, it would mean that <tt class="docutils literal">D</tt> is not implemented in Python).</p>
<p>The callable produced by the default <tt class="docutils literal">__reduce__</tt> is
<tt class="docutils literal">copy_reg._reconstructor</tt>, and its arguments tuple is
<tt class="docutils literal">(D, B, basestate)</tt>, where <tt class="docutils literal">basestate</tt> is <tt class="docutils literal">None</tt> if <tt class="docutils literal">B</tt> is the builtin
object class, and <tt class="docutils literal">basestate</tt> is</p>
<pre class="literal-block">
basestate = B(obj)
</pre>
<p>if <tt class="docutils literal">B</tt> is not the builtin object class.  This is geared toward
pickling subclasses of builtin types, where, for example,
<tt class="docutils literal">list(some_list_subclass_instance)</tt> produces &quot;the list part&quot; of
the <tt class="docutils literal">list</tt> subclass instance.</p>
<p>The object is recreated at unpickling time by
<tt class="docutils literal">copy_reg._reconstructor</tt>, like so:</p>
<pre class="literal-block">
obj = B.__new__(D, basestate)
B.__init__(obj, basestate)
</pre>
<p>Objects using the default <tt class="docutils literal">__reduce__</tt> implementation can customize
it by defining <tt class="docutils literal">__getstate__</tt> and/or <tt class="docutils literal">__setstate__</tt> methods.  These
work almost the same as described for classic classes above, except
that if <tt class="docutils literal">__getstate__</tt> returns an object (of any type) whose value is
considered false (e.g. <tt class="docutils literal">None</tt>, or a number that is zero, or an empty
sequence or mapping), this state is not pickled and <tt class="docutils literal">__setstate__</tt>
will not be called at all.  If <tt class="docutils literal">__getstate__</tt> exists and returns a
true value, that value becomes the third element of the tuple
returned by the default <tt class="docutils literal">__reduce__</tt>, and at unpickling time the
value is passed to <tt class="docutils literal">__setstate__</tt>.  If <tt class="docutils literal">__getstate__</tt> does not exist,
but <tt class="docutils literal">obj.__dict__</tt> exists, then  <tt class="docutils literal">obj.__dict__</tt> becomes the third
element of the tuple returned by  <tt class="docutils literal">__reduce__</tt>, and again at
unpickling time the value is passed to <tt class="docutils literal">obj.__setstate__</tt>.  The
default <tt class="docutils literal">__setstate__</tt> is the same as that for classic classes,
described above.</p>
<p>Note that this strategy ignores slots.  Instances of new-style
classes that have slots but no <tt class="docutils literal">__getstate__</tt> method cannot be
pickled by protocols 0 and 1; the code explicitly checks for
this condition.</p>
<p>Note that pickling new-style class instances ignores <tt class="docutils literal">__getinitargs__</tt>
if it exists (and under all protocols).  <tt class="docutils literal">__getinitargs__</tt> is
useful only for classic classes.</p>
</div>
<div class="section" id="case-3-pickling-new-style-class-instances-using-protocol-2">
<h2><a class="toc-backref" href="#id16">Case 3: pickling new-style class instances using protocol 2</a></h2>
<p>Under protocol 2, the default <tt class="docutils literal">__reduce__</tt> implementation inherited
from the 'object' base class is <em>ignored</em>.  Instead, a different
default implementation is used, which allows more efficient
pickling of new-style class instances than possible with protocols
0 or 1, at the cost of backward incompatibility with Python 2.2
(meaning no more than that a protocol 2 pickle cannot be unpickled
before Python 2.3).</p>
<p>The customization uses three special methods: <tt class="docutils literal">__getstate__</tt>,
<tt class="docutils literal">__setstate__</tt> and <tt class="docutils literal">__getnewargs__</tt> (note that <tt class="docutils literal">__getinitargs__</tt> is again
ignored).  It is fine if a class implements one or more but not all
of these, as long as it is compatible with the default
implementations.</p>
<div class="section" id="id1">
<h3><a class="toc-backref" href="#id17">The <tt class="docutils literal">__getstate__</tt> method</a></h3>
<p>The <tt class="docutils literal">__getstate__</tt> method should return a picklable value
representing the object's state without referencing the object
itself.  If no <tt class="docutils literal">__getstate__</tt> method exists, a default
implementation is used which is described below.</p>
<p>There's a subtle difference between classic and new-style
classes here: if a classic class's <tt class="docutils literal">__getstate__</tt> returns <tt class="docutils literal">None</tt>,
<tt class="docutils literal">self.__setstate__(None)</tt> will be called as part of unpickling.
But if a new-style class's <tt class="docutils literal">__getstate__</tt> returns <tt class="docutils literal">None</tt>, its
<tt class="docutils literal">__setstate__</tt> won't be called at all as part of unpickling.</p>
<p>If no <tt class="docutils literal">__getstate__</tt> method exists, a default state is computed.
There are several cases:</p>
<ul class="simple">
<li>For a new-style class that has no instance <tt class="docutils literal">__dict__</tt> and no
<tt class="docutils literal">__slots__</tt>, the default state is <tt class="docutils literal">None</tt>.</li>
<li>For a new-style class that has an instance <tt class="docutils literal">__dict__</tt> and no
<tt class="docutils literal">__slots__</tt>, the default state is <tt class="docutils literal">self.__dict__</tt>.</li>
<li>For a new-style class that has an instance <tt class="docutils literal">__dict__</tt> and
<tt class="docutils literal">__slots__</tt>, the default state is a tuple consisting of two
dictionaries:  <tt class="docutils literal">self.__dict__</tt>, and a dictionary mapping slot
names to slot values.  Only slots that have a value are
included in the latter.</li>
<li>For a new-style class that has <tt class="docutils literal">__slots__</tt> and no instance
<tt class="docutils literal">__dict__</tt>, the default state is a tuple whose first item is
<tt class="docutils literal">None</tt> and whose second item is a dictionary mapping slot names
to slot values described in the previous bullet.</li>
</ul>
</div>
<div class="section" id="id2">
<h3><a class="toc-backref" href="#id18">The <tt class="docutils literal">__setstate__</tt> method</a></h3>
<p>The <tt class="docutils literal">__setstate__</tt> method should take one argument; it will be
called with the value returned by <tt class="docutils literal">__getstate__</tt> or with the
default state described above if no <tt class="docutils literal">__getstate__</tt> method is
defined.</p>
<p>If no <tt class="docutils literal">__setstate__</tt> method exists, a default implementation is
provided that can handle the state returned by the default
<tt class="docutils literal">__getstate__</tt>, described above.</p>
</div>
<div class="section" id="the-getnewargs-method">
<h3><a class="toc-backref" href="#id19">The <tt class="docutils literal">__getnewargs__</tt> method</a></h3>
<p>Like for classic classes, the <tt class="docutils literal">__setstate__</tt> method (or its
default implementation) requires that a new object already
exists so that its <tt class="docutils literal">__setstate__</tt> method can be called.</p>
<p>In protocol 2, a new pickling opcode is used that causes a new
object to be created as follows:</p>
<pre class="literal-block">
obj = C.__new__(C, *args)
</pre>
<p>where <tt class="docutils literal">C</tt> is the class of the pickled object, and <tt class="docutils literal">args</tt> is either
the empty tuple, or the tuple returned by the <tt class="docutils literal">__getnewargs__</tt>
method, if defined.  <tt class="docutils literal">__getnewargs__</tt> must return a tuple.  The
absence of a <tt class="docutils literal">__getnewargs__</tt> method is equivalent to the existence
of one that returns <tt class="docutils literal">()</tt>.</p>
</div>
</div>
</div>
<div class="section" id="the-newobj-unpickling-function">
<h1><a class="toc-backref" href="#id20">The <tt class="docutils literal">__newobj__</tt> unpickling function</a></h1>
<p>When the unpickling function returned by <tt class="docutils literal">__reduce__</tt> (the first
item of the returned tuple) has the name <tt class="docutils literal">__newobj__</tt>, something
special happens for pickle protocol 2.  An unpickling function
named <tt class="docutils literal">__newobj__</tt> is assumed to have the following semantics:</p>
<pre class="literal-block">
def __newobj__(cls, *args):
    return cls.__new__(cls, *args)
</pre>
<p>Pickle protocol 2 special-cases an unpickling function with this
name, and emits a pickling opcode that, given 'cls' and 'args',
will return <tt class="docutils literal">cls.__new__(cls, *args)</tt> without also pickling a
reference to <tt class="docutils literal">__newobj__</tt> (this is the same pickling opcode used by
protocol 2 for a new-style class instance when no <tt class="docutils literal">__reduce__</tt>
implementation exists).  This is the main reason why protocol 2
pickles are much smaller than classic pickles.  Of course, the
pickling code cannot verify that a function named <tt class="docutils literal">__newobj__</tt>
actually has the expected semantics.  If you use an unpickling
function named <tt class="docutils literal">__newobj__</tt> that returns something different, you
deserve what you get.</p>
<p>It is safe to use this feature under Python 2.2; there's nothing
in the recommended implementation of <tt class="docutils literal">__newobj__</tt> that depends on
Python 2.3.</p>
</div>
<div class="section" id="the-extension-registry">
<h1><a class="toc-backref" href="#id21">The extension registry</a></h1>
<p>Protocol 2 supports a new mechanism to reduce the size of pickles.</p>
<p>When class instances (classic or new-style) are pickled, the full
name of the class (module name including package name, and class
name) is included in the pickle.  Especially for applications that
generate many small pickles, this is a lot of overhead that has to
be repeated in each pickle.  For large pickles, when using
protocol 1, repeated references to the same class name are
compressed using the &quot;memo&quot; feature; but each class name must be
spelled in full at least once per pickle, and this causes a lot of
overhead for small pickles.</p>
<p>The extension registry allows one to represent the most frequently
used names by small integers, which are pickled very efficiently:
an extension code in the range 1--255 requires only two bytes
including the opcode, one in the range 256--65535 requires only
three bytes including the opcode.</p>
<p>One of the design goals of the pickle protocol is to make pickles
&quot;context-free&quot;: as long as you have installed the modules
containing the classes referenced by a pickle, you can unpickle
it, without needing to import any of those classes ahead of time.</p>
<p>Unbridled use of extension codes could jeopardize this desirable
property of pickles.  Therefore, the main use of extension codes
is reserved for a set of codes to be standardized by some
standard-setting body.  This being Python, the standard-setting
body is the PSF.  From time to time, the PSF will decide on a
table mapping extension codes to class names (or occasionally
names of other global objects; functions are also eligible).  This
table will be incorporated in the next Python release(s).</p>
<p>However, for some applications, like Zope, context-free pickles
are not a requirement, and waiting for the PSF to standardize
some codes may not be practical.  Two solutions are offered for
such applications.</p>
<p>First, a few ranges of extension codes are reserved for private
use.  Any application can register codes in these ranges.
Two applications exchanging pickles using codes in these ranges
need to have some out-of-band mechanism to agree on the mapping
between extension codes and names.</p>
<p>Second, some large Python projects (e.g. Zope) can be assigned a
range of extension codes outside the &quot;private use&quot; range that they
can assign as they see fit.</p>
<p>The extension registry is defined as a mapping between extension
codes and names.  When an extension code is unpickled, it ends up
producing an object, but this object is gotten by interpreting the
name as a module name followed by a class (or function) name.  The
mapping from names to objects is cached.  It is quite possible
that certain names cannot be imported; that should not be a
problem as long as no pickle containing a reference to such names
has to be unpickled.  (The same issue already exists for direct
references to such names in pickles that use protocols 0 or 1.)</p>
<p>Here is the proposed initial assignment of extension code ranges:</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="8%" />
<col width="8%" />
<col width="77%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">First</th>
<th class="head">Last</th>
<th class="head">Count</th>
<th class="head">Purpose</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td>0</td>
<td>1</td>
<td>Reserved --- will never be used</td>
</tr>
<tr><td>1</td>
<td>127</td>
<td>127</td>
<td>Reserved for Python standard library</td>
</tr>
<tr><td>128</td>
<td>191</td>
<td>64</td>
<td>Reserved for Zope</td>
</tr>
<tr><td>192</td>
<td>239</td>
<td>48</td>
<td>Reserved for 3rd parties</td>
</tr>
<tr><td>240</td>
<td>255</td>
<td>16</td>
<td>Reserved for private use (will never be assigned)</td>
</tr>
<tr><td>256</td>
<td><em>MAX</em></td>
<td><em>MAX</em></td>
<td>Reserved for future assignment</td>
</tr>
</tbody>
</table>
<p><em>MAX</em> stands for 2147483647, or <tt class="docutils literal"><span class="pre">2**31-1</span></tt>.  This is a hard limitation
of the protocol as currently defined.</p>
<p>At the moment, no specific extension codes have been assigned yet.</p>
<div class="section" id="extension-registry-api">
<h2><a class="toc-backref" href="#id22">Extension registry API</a></h2>
<p>The extension registry is maintained as private global variables
in the <tt class="docutils literal">copy_reg</tt> module.  The following three functions are defined
in this module to manipulate the registry:</p>
<dl class="docutils">
<dt><tt class="docutils literal">add_extension(module, name, code)</tt></dt>
<dd>Register an extension code.  The <em>module</em> and <em>name</em> arguments
must be strings; <em>code</em> must be an <tt class="docutils literal">int</tt> in the inclusive range 1
through <em>MAX</em>.  This must either register a new <tt class="docutils literal">(module, name)</tt>
pair to a new code, or be a redundant repeat of a previous
call that was not canceled by a <tt class="docutils literal">remove_extension()</tt> call; a
<tt class="docutils literal">(module, name)</tt> pair may not be mapped to more than one code,
nor may a code be mapped to more than one <tt class="docutils literal">(module, name)</tt>
pair.<!-- XXX Aliasing may actually cause a problem for this
requirement; we'll see as we go. -->
</dd>
<dt><tt class="docutils literal">remove_extension(module, name, code)</tt></dt>
<dd>Arguments are as for <tt class="docutils literal">add_extension()</tt>.  Remove a previously
registered mapping between <tt class="docutils literal">(module, name)</tt> and <em>code</em>.</dd>
<dt><tt class="docutils literal">clear_extension_cache()</tt></dt>
<dd>The implementation of extension codes may use a cache to speed
up loading objects that are named frequently.  This cache can
be emptied (removing references to cached objects) by calling
this method.</dd>
</dl>
<p>Note that the API does not enforce the standard range assignments.
It is up to applications to respect these.</p>
</div>
</div>
<div class="section" id="the-copy-module">
<h1><a class="toc-backref" href="#id23">The copy module</a></h1>
<p>Traditionally, the <tt class="docutils literal">copy</tt> module has supported an extended subset of
the pickling APIs for customizing the <tt class="docutils literal">copy()</tt> and <tt class="docutils literal">deepcopy()</tt>
operations.</p>
<p>In particular, besides checking for a <tt class="docutils literal">__copy__</tt> or <tt class="docutils literal">__deepcopy__</tt>
method, <tt class="docutils literal">copy()</tt> and <tt class="docutils literal">deepcopy()</tt> have always looked for <tt class="docutils literal">__reduce__</tt>,
and for classic classes, have looked for <tt class="docutils literal">__getinitargs__</tt>,
<tt class="docutils literal">__getstate__</tt> and <tt class="docutils literal">__setstate__</tt>.</p>
<p>In Python 2.2, the default <tt class="docutils literal">__reduce__</tt> inherited from 'object' made
copying simple new-style classes possible, but slots and various
other special cases were not covered.</p>
<p>In Python 2.3, several changes are made to the <tt class="docutils literal">copy</tt> module:</p>
<ul class="simple">
<li><tt class="docutils literal">__reduce_ex__</tt> is supported (and always called with 2 as the
protocol version argument).</li>
<li>The four- and five-argument return values of <tt class="docutils literal">__reduce__</tt> are
supported.</li>
<li>Before looking for a <tt class="docutils literal">__reduce__</tt> method, the
<tt class="docutils literal">copy_reg.dispatch_table</tt> is consulted, just like for pickling.</li>
<li>When the <tt class="docutils literal">__reduce__</tt> method is inherited from object, it is
(unconditionally) replaced by a better one that uses the same
APIs as pickle protocol 2: <tt class="docutils literal">__getnewargs__</tt>, <tt class="docutils literal">__getstate__</tt>, and
<tt class="docutils literal">__setstate__</tt>, handling <tt class="docutils literal">list</tt> and <tt class="docutils literal">dict</tt> subclasses, and handling
slots.</li>
</ul>
<p>As a consequence of the latter change, certain new-style classes
that were copyable under Python 2.2 are not copyable under Python
2.3.  (These classes are also not picklable using pickle protocol
2.)  A minimal example of such a class:</p>
<pre class="literal-block">
class C(object):
    def __new__(cls, a):
        return object.__new__(cls)
</pre>
<p>The problem only occurs when <tt class="docutils literal">__new__</tt> is overridden and has at
least one mandatory argument in addition to the class argument.</p>
<p>To fix this, a <tt class="docutils literal">__getnewargs__</tt> method should be added that returns
the appropriate argument tuple (excluding the class).</p>
</div>
<div class="section" id="pickling-python-longs">
<h1><a class="toc-backref" href="#id24">Pickling Python longs</a></h1>
<p>Pickling and unpickling Python longs takes time quadratic in
the number of digits, in protocols 0 and 1.  Under protocol 2,
new opcodes support linear-time pickling and unpickling of longs.</p>
</div>
<div class="section" id="pickling-bools">
<h1><a class="toc-backref" href="#id25">Pickling bools</a></h1>
<p>Protocol 2 introduces new opcodes for pickling <tt class="docutils literal">True</tt> and <tt class="docutils literal">False</tt>
directly.  Under protocols 0 and 1, bools are pickled as integers,
using a trick in the representation of the integer in the pickle
so that an unpickler can recognize that a bool was intended.  That
trick consumed 4 bytes per bool pickled.  The new bool opcodes
consume 1 byte per bool.</p>
</div>
<div class="section" id="pickling-small-tuples">
<h1><a class="toc-backref" href="#id26">Pickling small tuples</a></h1>
<p>Protocol 2 introduces new opcodes for more-compact pickling of
tuples of lengths 1, 2 and 3.  Protocol 1 previously introduced
an opcode for more-compact pickling of empty tuples.</p>
</div>
<div class="section" id="protocol-identification">
<h1><a class="toc-backref" href="#id27">Protocol identification</a></h1>
<p>Protocol 2 introduces a new opcode, with which all protocol 2
pickles begin, identifying that the pickle is protocol 2.
Attempting to unpickle a protocol 2 pickle under older versions
of Python will therefore raise an &quot;unknown opcode&quot; exception
immediately.</p>
</div>
<div class="section" id="pickling-of-large-lists-and-dicts">
<h1><a class="toc-backref" href="#id28">Pickling of large lists and dicts</a></h1>
<p>Protocol 1 pickles large lists and dicts &quot;in one piece&quot;, which
minimizes pickle size, but requires that unpickling create a temp
object as large as the object being unpickled.  Part of the
protocol 2 changes break large lists and dicts into pieces of no
more than 1000 elements each, so that unpickling needn't create
a temp object larger than needed to hold 1000 elements.  This
isn't part of protocol 2, however:  the opcodes produced are still
part of protocol 1.  <tt class="docutils literal">__reduce__</tt> implementations that return the
optional new listitems or dictitems iterators also benefit from
this unpickling temp-space optimization.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id29">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>

