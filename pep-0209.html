<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">209</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Multi-dimensional Arrays</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0209.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">barrett&#32;&#97;t&#32;stsci.edu (Paul Barrett), oliphant&#32;&#97;t&#32;ee.byu.edu (Travis Oliphant)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Withdrawn</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">03-Jan-2001</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.2</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id3">Abstract</a></li>
<li><a class="reference internal" href="#motivation" id="id4">Motivation</a></li>
<li><a class="reference internal" href="#proposal" id="id5">Proposal</a></li>
<li><a class="reference internal" href="#design-and-implementation" id="id6">Design and Implementation</a></li>
<li><a class="reference internal" href="#open-issues" id="id7">Open Issues</a></li>
<li><a class="reference internal" href="#implementation-steps" id="id8">Implementation Steps</a></li>
<li><a class="reference internal" href="#incompatibilities" id="id9">Incompatibilities</a></li>
<li><a class="reference internal" href="#appendices" id="id10">Appendices</a></li>
<li><a class="reference internal" href="#copyright" id="id11">Copyright</a></li>
<li><a class="reference internal" href="#related-peps" id="id12">Related PEPs</a></li>
<li><a class="reference internal" href="#references" id="id13">References</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id3">Abstract</a></h1>
<p>This PEP proposes a redesign and re-implementation of the multi-
dimensional array module, Numeric, to make it easier to add new
features and functionality to the module.  Aspects of Numeric 2
that will receive special attention are efficient access to arrays
exceeding a gigabyte in size and composed of inhomogeneous data
structures or records.  The proposed design uses four Python
classes: ArrayType, UFunc, Array, and ArrayView; and a low-level
C-extension module, _ufunc, to handle the array operations
efficiently.  In addition, each array type has its own C-extension
module which defines the coercion rules, operations, and methods
for that type.  This design enables new types, features, and
functionality to be added in a modular fashion.  The new version
will introduce some incompatibilities with the current Numeric.</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id4">Motivation</a></h1>
<p>Multi-dimensional arrays are commonly used to store and manipulate
data in science, engineering, and computing.  Python currently has
an extension module, named Numeric (henceforth called Numeric 1),
which provides a satisfactory set of functionality for users
manipulating homogeneous arrays of data of moderate size (of order
10 MB).  For access to larger arrays (of order 100 MB or more) of
possibly inhomogeneous data, the implementation of Numeric 1 is
inefficient and cumbersome.  In the future, requests by the
Numerical Python community for additional functionality is also
likely as PEPs 211: Adding New Linear Operators to Python, and
225: Elementwise/Objectwise Operators illustrate.</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id5">Proposal</a></h1>
<p>This proposal recommends a re-design and re-implementation of
Numeric 1, henceforth called Numeric 2, which will enable new
types, features, and functionality to be added in an easy and
modular manner.  The initial design of Numeric 2 should focus on
providing a generic framework for manipulating arrays of various
types and should enable a straightforward mechanism for adding new
array types and UFuncs.  Functional methods that are more specific
to various disciplines can then be layered on top of this core.
This new module will still be called Numeric and most of the
behavior found in Numeric 1 will be preserved.</p>
<p>The proposed design uses four Python classes: ArrayType, UFunc,
Array, and ArrayView; and a low-level C-extension module to handle
the array operations efficiently.  In addition, each array type
has its own C-extension module which defines the coercion rules,
operations, and methods for that type.  At a later date, when core
functionality is stable, some Python classes can be converted to
C-extension types.</p>
<p>Some planned features are:</p>
<ol class="arabic">
<li><p class="first">Improved memory usage</p>
<p>This feature is particularly important when handling large arrays
and can produce significant improvements in performance as well as
memory usage.  We have identified several areas where memory usage
can be improved:</p>
<ol class="loweralpha">
<li><p class="first">Use a local coercion model</p>
<p>Instead of using Python's global coercion model which creates
temporary arrays, Numeric 2, like Numeric 1, will implement a
local coercion model as described in <a class="reference external" href="/dev/peps/pep-0208">PEP 208</a> which defers the
responsibility of coercion to the operator.  By using internal
buffers, a coercion operation can be done for each array
(including output arrays), if necessary, at the time of the
operation.  Benchmarks <a class="footnote-reference" href="#id2" id="id1">[1]</a> have shown that performance is at
most degraded only slightly and is improved in cases where the
internal buffers are less than the L2 cache size and the
processor is under load.  To avoid array coercion altogether,
C functions having arguments of mixed type are allowed in
Numeric 2.</p>
</li>
<li><p class="first">Avoid creation of temporary arrays</p>
<p>In complex array expressions (i.e. having more than one
operation), each operation will create a temporary array which
will be used and then deleted by the succeeding operation.  A
better approach would be to identify these temporary arrays
and reuse their data buffers when possible, namely when the
array shape and type are the same as the temporary array being
created.  This can be done by checking the temporary array's
reference count.  If it is 1, then it will be deleted once the
operation is done and is a candidate for reuse.</p>
</li>
<li><p class="first">Optional use of memory-mapped files</p>
<p>Numeric users sometimes need to access data from very large
files or to handle data that is greater than the available
memory.  Memory-mapped arrays provide a mechanism to do this
by storing the data on disk while making it appear to be in
memory.  Memory- mapped arrays should improve access to all
files by eliminating one of two copy steps during a file
access.  Numeric should be able to access in-memory and
memory-mapped arrays transparently.</p>
</li>
<li><p class="first">Record access</p>
<p>In some fields of science, data is stored in files as binary
records.  For example, in astronomy, photon data is stored as a
1 dimensional list of photons in order of arrival time.  These
records or C-like structures contain information about the
detected photon, such as its arrival time, its position on the
detector, and its energy.  Each field may be of a different
type, such as char, int, or float.  Such arrays introduce new
issues that must be dealt with, in particular byte alignment
or byte swapping may need to be performed for the numeric
values to be properly accessed (though byte swapping is also
an issue for memory mapped data).  Numeric 2 is designed to
automatically handle alignment and representational issues
when data is accessed or operated on.  There are two
approaches to implementing records; as either a derived array
class or a special array type, depending on your point-of-
view.  We defer this discussion to the Open Issues section.</p>
</li>
</ol>
</li>
<li><p class="first">Additional array types</p>
<p>Numeric 1 has 11 defined types: char, ubyte, sbyte, short, int,
long, float, double, cfloat, cdouble, and object.  There are no
ushort, uint, or ulong types, nor are there more complex types
such as a bit type which is of use to some fields of science and
possibly for implementing masked-arrays.  The design of Numeric 1
makes the addition of these and other types a difficult and
error-prone process.  To enable the easy addition (and deletion)
of new array types such as a bit type described below, a re-design
of Numeric is necessary.</p>
<ol class="loweralpha">
<li><p class="first">Bit type</p>
<p>The result of a rich comparison between arrays is an array of
boolean values.  The result can be stored in an array of type
char, but this is an unnecessary waste of memory.  A better
implementation would use a bit or boolean type, compressing
the array size by a factor of eight.  This is currently being
implemented for Numeric 1 (by Travis Oliphant) and should be
included in Numeric 2.</p>
</li>
</ol>
</li>
<li><p class="first">Enhanced array indexing syntax</p>
<p>The extended slicing syntax was added to Python to provide greater
flexibility when manipulating Numeric arrays by allowing
step-sizes greater than 1.  This syntax works well as a shorthand
for a list of regularly spaced indices.  For those situations
where a list of irregularly spaced indices are needed, an enhanced
array indexing syntax would allow 1-D arrays to be arguments.</p>
</li>
<li><p class="first">Rich comparisons</p>
<p>The implementation of <a class="reference external" href="/dev/peps/pep-0207">PEP 207</a>: Rich Comparisons in Python 2.1
provides additional flexibility when manipulating arrays.  We
intend to implement this feature in Numeric 2.</p>
</li>
<li><p class="first">Array broadcasting rules</p>
<p>When an operation between a scalar and an array is done, the
implied behavior is to create a new array having the same shape as
the array operand containing the scalar value.  This is called
array broadcasting.  It also works with arrays of lesser rank,
such as vectors.  This implicit behavior is implemented in Numeric
1 and will also be implemented in Numeric 2.</p>
</li>
</ol>
</div>
<div class="section" id="design-and-implementation">
<h1><a class="toc-backref" href="#id6">Design and Implementation</a></h1>
<p>The design of Numeric 2 has four primary classes:</p>
<ol class="arabic">
<li><p class="first">ArrayType:</p>
<p>This is a simple class that describes the fundamental properties
of an array-type, e.g. its name, its size in bytes, its coercion
relations with respect to other types, etc., e.g.</p>
<pre class="literal-block">
Int32 = ArrayType('Int32', 4, 'doc-string')
</pre>
<p>Its relation to the other types is defined when the C-extension
module for that type is imported.  The corresponding Python code
is:</p>
<pre class="literal-block">
Int32.astype[Real64] = Real64
</pre>
<p>This says that the Real64 array-type has higher priority than the
Int32 array-type.</p>
<p>The following attributes and methods are proposed for the core
implementation.  Additional attributes can be added on an
individual basis, e.g. .bitsize or .bitstrides for the bit type.</p>
<p>Attributes:</p>
<pre class="literal-block">
.name:                  e.g. &quot;Int32&quot;, &quot;Float64&quot;, etc.
.typecode:              e.g. 'i', 'f', etc.
                        (for backward compatibility)
.size (in bytes):       e.g. 4, 8, etc.
.array_rules (mapping): rules between array types
.pyobj_rules (mapping): rules between array and python types
.doc:                   documentation string
</pre>
<p>Methods:</p>
<pre class="literal-block">
__init__():             initialization
__del__():              destruction
__repr__():             representation
</pre>
<p>C-API: This still needs to be fleshed-out.</p>
</li>
<li><p class="first">UFunc:</p>
<p>This class is the heart of Numeric 2.  Its design is similar to
that of ArrayType in that the UFunc creates a singleton callable
object whose attributes are name, total and input number of
arguments, a document string, and an empty CFunc dictionary; e.g.</p>
<pre class="literal-block">
add = UFunc('add', 3, 2, 'doc-string')
</pre>
<p>When defined the add instance has no C functions associated with
it and therefore can do no work.  The CFunc dictionary is
populated or registered later when the C-extension module for an
array-type is imported.  The arguments of the register method are:
function name, function descriptor, and the CUFunc object.  The
corresponding Python code is</p>
<pre class="literal-block">
add.register('add', (Int32, Int32, Int32), cfunc-add)
</pre>
<p>In the initialization function of an array type module, e.g.
Int32, there are two C API functions: one to initialize the
coercion rules and the other to register the CFunc objects.</p>
<p>When an operation is applied to some arrays, the <tt class="docutils literal">__call__</tt> method
is invoked.  It gets the type of each array (if the output array
is not given, it is created from the coercion rules) and checks
the CFunc dictionary for a key that matches the argument types.
If it exists the operation is performed immediately, otherwise the
coercion rules are used to search for a related operation and set
of conversion functions.  The <tt class="docutils literal">__call__</tt> method then invokes a
compute method written in C to iterate over slices of each array,
namely:</p>
<pre class="literal-block">
_ufunc.compute(slice, data, func, swap, conv)
</pre>
<p>The 'func' argument is a CFuncObject, while the 'swap' and 'conv'
arguments are lists of CFuncObjects for those arrays needing pre-
or post-processing, otherwise None is used.  The data argument is
a list of buffer objects, and the slice argument gives the number
of iterations for each dimension along with the buffer offset and
step size for each array and each dimension.</p>
<p>We have predefined several UFuncs for use by the <tt class="docutils literal">__call__</tt> method:
cast, swap, getobj, and setobj.  The cast and swap functions do
coercion and byte-swapping, respectively and the getobj and setobj
functions do coercion between Numeric arrays and Python sequences.</p>
<p>The following attributes and methods are proposed for the core
implementation.</p>
<p>Attributes:</p>
<pre class="literal-block">
.name:                  e.g. &quot;add&quot;, &quot;subtract&quot;, etc.
.nargs:                 number of total arguments
.iargs:                 number of input arguments
.cfuncs (mapping):      the set C functions
.doc:                   documentation string
</pre>
<p>Methods:</p>
<pre class="literal-block">
__init__():             initialization
__del__():              destruction
__repr__():             representation
__call__():             look-up and dispatch method
initrule():             initialize coercion rule
uninitrule():           uninitialize coercion rule
register():             register a CUFunc
unregister():           unregister a CUFunc
</pre>
<p>C-API: This still needs to be fleshed-out.</p>
</li>
<li><p class="first">Array:</p>
<p>This class contains information about the array, such as shape,
type, endian-ness of the data, etc..  Its operators, '+', '-',
etc. just invoke the corresponding UFunc function, e.g.</p>
<pre class="literal-block">
def __add__(self, other):
    return ufunc.add(self, other)
</pre>
<p>The following attributes, methods, and functions are proposed for
the core implementation.</p>
<p>Attributes:</p>
<pre class="literal-block">
.shape:                 shape of the array
.format:                type of the array
.real (only complex):   real part of a complex array
.imag (only complex):   imaginary part of a complex array
</pre>
<p>Methods:</p>
<pre class="literal-block">
__init__():             initialization
__del__():              destruction
__repr_():              representation
__str__():              pretty representation
__cmp__():              rich comparison
__len__():
__getitem__():
__setitem__():
__getslice__():
__setslice__():
numeric methods:
copy():                 copy of array
aslist():               create list from array
asstring():             create string from array
</pre>
<p>Functions:</p>
<pre class="literal-block">
fromlist():             create array from sequence
fromstring():           create array from string
array():                create array with shape and value
concat():               concatenate two arrays
resize():               resize array
</pre>
<p>C-API: This still needs to be fleshed-out.</p>
</li>
<li><p class="first">ArrayView</p>
<p>This class is similar to the Array class except that the reshape
and flat methods will raise exceptions, since non-contiguous
arrays cannot be reshaped or flattened using just pointer and
step-size information.</p>
<p>C-API: This still needs to be fleshed-out.</p>
</li>
<li><p class="first">C-extension modules:</p>
<p>Numeric2 will have several C-extension modules.</p>
<ol class="loweralpha">
<li><p class="first">_ufunc:</p>
<p>The primary module of this set is the _ufuncmodule.c.  The
intention of this module is to do the bare minimum,
i.e. iterate over arrays using a specified C function.  The
interface of these functions is the same as Numeric 1, i.e.</p>
<pre class="literal-block">
int (*CFunc)(char *data, int *steps, int repeat, void *func);
</pre>
<p>and their functionality is expected to be the same, i.e. they
iterate over the inner-most dimension.</p>
<p>The following attributes and methods are proposed for the core
implementation.</p>
<p>Attributes:</p>
<p>Methods:</p>
<pre class="literal-block">
compute():
</pre>
<p>C-API: This still needs to be fleshed-out.</p>
</li>
<li><p class="first">_int32, _real64, etc.:</p>
<p>There will also be C-extension modules for each array type,
e.g. _int32module.c, _real64module.c, etc.  As mentioned
previously, when these modules are imported by the UFunc
module, they will automatically register their functions and
coercion rules.  New or improved versions of these modules can
be easily implemented and used without affecting the rest of
Numeric 2.</p>
</li>
</ol>
</li>
</ol>
</div>
<div class="section" id="open-issues">
<h1><a class="toc-backref" href="#id7">Open Issues</a></h1>
<ol class="arabic">
<li><p class="first">Does slicing syntax default to copy or view behavior?</p>
<p>The default behavior of Python is to return a copy of a sub-list
or tuple when slicing syntax is used, whereas Numeric 1 returns a
view into the array.  The choice made for Numeric 1 is apparently
for reasons of performance: the developers wish to avoid the
penalty of allocating and copying the data buffer during each
array operation and feel that the need for a deep copy of an array
to be rare.  Yet, some have argued that Numeric's slice notation
should also have copy behavior to be consistent with Python lists.
In this case the performance penalty associated with copy behavior
can be minimized by implementing copy-on-write.  This scheme has
both arrays sharing one data buffer (as in view behavior) until
either array is assigned new data at which point a copy of the
data buffer is made.  View behavior would then be implemented by
an ArrayView class, whose behavior be similar to Numeric 1 arrays,
i.e. .shape is not settable for non-contiguous arrays.  The use of
an ArrayView class also makes explicit what type of data the array
contains.</p>
</li>
<li><p class="first">Does item syntax default to copy or view behavior?</p>
<p>A similar question arises with the item syntax.  For example, if
<tt class="docutils literal">a = [[0,1,2], [3,4,5]]</tt> and <tt class="docutils literal">b = a[0]</tt>, then changing <tt class="docutils literal">b[0]</tt> also changes
<tt class="docutils literal"><span class="pre">a[0][0]</span></tt>, because <tt class="docutils literal">a[0]</tt> is a reference or view of the first row of a.
Therefore, if c is a 2-d array, it would appear that <tt class="docutils literal">c[i]</tt>
should return a 1-d array which is a view into, instead of a copy
of, c for consistency.  Yet, <tt class="docutils literal">c[i]</tt> can be considered just a
shorthand for <tt class="docutils literal"><span class="pre">c[i,:]</span></tt> which would imply copy behavior assuming
slicing syntax returns a copy.  Should Numeric 2 behave the same
way as lists and return a view or should it return a copy.</p>
</li>
<li><p class="first">How is scalar coercion implemented?</p>
<p>Python has fewer numeric types than Numeric which can cause
coercion problems.  For example, when multiplying a Python scalar
of type float and a Numeric array of type float, the Numeric array
is converted to a double, since the Python float type is actually
a double.  This is often not the desired behavior, since the
Numeric array will be doubled in size which is likely to be
annoying, particularly for very large arrays.  We prefer that the
array type trumps the python type for the same type class, namely
integer, float, and complex.  Therefore, an operation between a
Python integer and an Int16 (short) array will return an Int16
array.  Whereas an operation between a Python float and an Int16
array would return a Float64 (double) array.  Operations between
two arrays use normal coercion rules.</p>
</li>
<li><p class="first">How is integer division handled?</p>
<p>In a future version of Python, the behavior of integer division
will change.  The operands will be converted to floats, so the
result will be a float.  If we implement the proposed scalar
coercion rules where arrays have precedence over Python scalars,
then dividing an array by an integer will return an integer array
and will not be consistent with a future version of Python which
would return an array of type double.  Scientific programmers are
familiar with the distinction between integer and float-point
division, so should Numeric 2 continue with this behavior?</p>
</li>
<li><p class="first">How should records be implemented?</p>
<p>There are two approaches to implementing records depending on your
point-of-view.  The first is two divide arrays into separate
classes depending on the behavior of their types.  For example,
numeric arrays are one class, strings a second, and records a
third, because the range and type of operations of each class
differ.  As such, a record array is not a new type, but a
mechanism for a more flexible form of array.  To easily access and
manipulate such complex data, the class is comprised of numeric
arrays having different byte offsets into the data buffer.  For
example, one might have a table consisting of an array of Int16,
Real32 values.  Two numeric arrays, one with an offset of 0 bytes
and a stride of 6 bytes to be interpreted as Int16, and one with an
offset of 2 bytes and a stride of 6 bytes to be interpreted as
Real32 would represent the record array.  Both numeric arrays
would refer to the same data buffer, but have different offset and
stride attributes, and a different numeric type.</p>
<p>The second approach is to consider a record as one of many array
types, albeit with fewer, and possibly different, array operations
than for numeric arrays.  This approach considers an array type to
be a mapping of a fixed-length string.  The mapping can either be
simple, like integer and floating-point numbers, or complex, like
a complex number, a byte string, and a C-structure.  The record
type effectively merges the struct and Numeric modules into a
multi-dimensional struct array.  This approach implies certain
changes to the array interface.  For example, the 'typecode'
keyword argument should probably be changed to the more
descriptive 'format' keyword.</p>
<ol class="loweralpha">
<li><p class="first">How are record semantics defined and implemented?</p>
<p>Which ever implementation approach is taken for records, the
syntax and semantics of how they are to be accessed and
manipulated must be decided, if one wishes to have access to
sub-fields of records.  In this case, the record type can
essentially be considered an inhomogeneous list, like a tuple
returned by the unpack method of the struct module; and a 1-d
array of records may be interpreted as a 2-d array with the
second dimension being the index into the list of fields.
This enhanced array semantics makes access to an array of one
or more of the fields easy and straightforward.  It also
allows a user to do array operations on a field in a natural
and intuitive way.  If we assume that records are implemented
as an array type, then last dimension defaults to 0 and can
therefore be neglected for arrays comprised of simple types,
like numeric.</p>
</li>
</ol>
</li>
<li><p class="first">How are masked-arrays implemented?</p>
<p>Masked-arrays in Numeric 1 are implemented as a separate array
class.  With the ability to add new array types to Numeric 2, it
is possible that masked-arrays in Numeric 2 could be implemented
as a new array type instead of an array class.</p>
</li>
<li><p class="first">How are numerical errors handled (IEEE floating-point errors in
particular)?</p>
<p>It is not clear to the proposers (Paul Barrett and Travis
Oliphant) what is the best or preferred way of handling errors.
Since most of the C functions that do the operation, iterate over
the inner-most (last) dimension of the array.  This dimension
could contain a thousand or more items having one or more errors
of differing type, such as divide-by-zero, underflow, and
overflow.  Additionally, keeping track of these errors may come at
the expense of performance.  Therefore, we suggest several
options:</p>
<ol class="loweralpha simple">
<li>Print a message of the most severe error, leaving it to
the user to locate the errors.</li>
<li>Print a message of all errors that occurred and the number
of occurrences, leaving it to the user to locate the errors.</li>
<li>Print a message of all errors that occurred and a list of
where they occurred.</li>
<li>Or use a hybrid approach, printing only the most severe
error, yet keeping track of what and where the errors
occurred.  This would allow the user to locate the errors
while keeping the error message brief.</li>
</ol>
</li>
<li><p class="first">What features are needed to ease the integration of FORTRAN
libraries and code?</p>
</li>
</ol>
<p>It would be a good idea at this stage to consider how to ease the
integration of FORTRAN libraries and user code in Numeric 2.</p>
</div>
<div class="section" id="implementation-steps">
<h1><a class="toc-backref" href="#id8">Implementation Steps</a></h1>
<ol class="arabic">
<li><p class="first">Implement basic UFunc capability</p>
<ol class="loweralpha">
<li><p class="first">Minimal Array class:</p>
<p>Necessary class attributes and methods, e.g. .shape, .data,
.type, etc.</p>
</li>
<li><p class="first">Minimal ArrayType class:</p>
<p>Int32, Real64, Complex64, Char, Object</p>
</li>
<li><p class="first">Minimal UFunc class:</p>
<p>UFunc instantiation, CFunction registration, UFunc call for
1-D arrays including the rules for doing alignment,
byte-swapping, and coercion.</p>
</li>
<li><p class="first">Minimal C-extension module:</p>
<p>_UFunc, which does the innermost array loop in C.</p>
<p>This step implements whatever is needed to do: 'c = add(a, b)'
where a, b, and c are 1-D arrays.  It teaches us how to add
new UFuncs, to coerce the arrays, to pass the necessary
information to a C iterator method and to do the actually
computation.</p>
</li>
</ol>
</li>
<li><p class="first">Continue enhancing the UFunc iterator and Array class</p>
<ol class="loweralpha simple">
<li>Implement some access methods for the Array class:
print, repr, getitem, setitem, etc.</li>
<li>Implement multidimensional arrays</li>
<li>Implement some of basic Array methods using UFuncs:
+, -, *, /, etc.</li>
<li>Enable UFuncs to use Python sequences.</li>
</ol>
</li>
<li><p class="first">Complete the standard UFunc and Array class behavior</p>
<ol class="loweralpha simple">
<li>Implement getslice and setslice behavior</li>
<li>Work on Array broadcasting rules</li>
<li>Implement Record type</li>
</ol>
</li>
<li><p class="first">Add additional functionality</p>
<ol class="loweralpha simple">
<li>Add more UFuncs</li>
<li>Implement buffer or mmap access</li>
</ol>
</li>
</ol>
</div>
<div class="section" id="incompatibilities">
<h1><a class="toc-backref" href="#id9">Incompatibilities</a></h1>
<p>The following is a list of incompatibilities in behavior between
Numeric 1 and Numeric 2.</p>
<ol class="arabic">
<li><p class="first">Scalar coercion rules</p>
<p>Numeric 1 has single set of coercion rules for array and Python
numeric types.  This can cause unexpected and annoying problems
during the calculation of an array expression.  Numeric 2 intends
to overcome these problems by having two sets of coercion rules:
one for arrays and Python numeric types, and another just for
arrays.</p>
</li>
<li><p class="first">No savespace attribute</p>
<p>The savespace attribute in Numeric 1 makes arrays with this
attribute set take precedence over those that do not have it set.
Numeric 2 will not have such an attribute and therefore normal
array coercion rules will be in effect.</p>
</li>
<li><p class="first">Slicing syntax returns a copy</p>
<p>The slicing syntax in Numeric 1 returns a view into the original
array.  The slicing behavior for Numeric 2 will be a copy.  You
should use the ArrayView class to get a view into an array.</p>
</li>
<li><p class="first">Boolean comparisons return a boolean array</p>
<p>A comparison between arrays in Numeric 1 results in a Boolean
scalar, because of current limitations in Python.  The advent of
Rich Comparisons in Python 2.1 will allow an array of Booleans to
be returned.</p>
</li>
<li><p class="first">Type characters are deprecated</p>
<p>Numeric 2 will have an ArrayType class composed of Type instances,
for example Int8, Int16, Int32, and Int for signed integers.  The
typecode scheme in Numeric 1 will be available for backward
compatibility, but will be deprecated.</p>
</li>
</ol>
</div>
<div class="section" id="appendices">
<h1><a class="toc-backref" href="#id10">Appendices</a></h1>
<ol class="upperalpha">
<li><p class="first">Implicit sub-arrays iteration</p>
<p>A computer animation is composed of a number of 2-D images or
frames of identical shape.  By stacking these images into a single
block of memory, a 3-D array is created.  Yet the operations to be
performed are not meant for the entire 3-D array, but on the set
of 2-D sub-arrays.  In most array languages, each frame has to be
extracted, operated on, and then reinserted into the output array
using a for-like loop.  The J language allows the programmer to
perform such operations implicitly by having a rank for the frame
and array.  By default these ranks will be the same during the
creation of the array.  It was the intention of the Numeric 1
developers to implement this feature, since it is based on the
language J.  The Numeric 1 code has the required variables for
implementing this behavior, but was never implemented.  We intend
to implement implicit sub-array iteration in Numeric 2, if the
array broadcasting rules found in Numeric 1 do not fully support
this behavior.</p>
</li>
</ol>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id11">Copyright</a></h1>
<p>This document is placed in the public domain.</p>
</div>
<div class="section" id="related-peps">
<h1><a class="toc-backref" href="#id12">Related PEPs</a></h1>
<ul class="simple">
<li><a class="reference external" href="/dev/peps/pep-0207">PEP 207</a>: Rich Comparisons
by Guido van Rossum and David Ascher</li>
<li><a class="reference external" href="/dev/peps/pep-0208">PEP 208</a>: Reworking the Coercion Model
by Neil Schemenauer and Marc-Andre' Lemburg</li>
<li><a class="reference external" href="/dev/peps/pep-0211">PEP 211</a>: Adding New Linear Algebra Operators to Python
by Greg Wilson</li>
<li><a class="reference external" href="/dev/peps/pep-0225">PEP 225</a>: Elementwise/Objectwise Operators
by Huaiyu Zhu</li>
<li><a class="reference external" href="/dev/peps/pep-0228">PEP 228</a>: Reworking Python's Numeric Model
by Moshe Zadka</li>
</ul>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id13">References</a></h1>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><ol class="first last upperalpha simple" start="16">
<li>Greenfield 2000. private communication.</li>
</ol>
</td></tr>
</tbody>
</table>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

