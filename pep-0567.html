<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">567</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Context Variables</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0567.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Yury Selivanov &lt;yury&#32;&#97;t&#32;magic.io&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Draft</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">12-Dec-2017</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.7</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">12-Dec-2017, 28-Dec-2017, 16-Jan-2018</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id7">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id8">Rationale</a></li>
<li><a class="reference internal" href="#introduction" id="id9">Introduction</a></li>
<li><a class="reference internal" href="#specification" id="id10">Specification</a><ul>
<li><a class="reference internal" href="#contextvars-contextvar" id="id11">contextvars.ContextVar</a></li>
<li><a class="reference internal" href="#contextvars-token" id="id12">contextvars.Token</a></li>
<li><a class="reference internal" href="#contextvars-context" id="id13">contextvars.Context</a></li>
<li><a class="reference internal" href="#asyncio" id="id14">asyncio</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation" id="id15">Implementation</a></li>
<li><a class="reference internal" href="#summary-of-the-new-apis" id="id16">Summary of the New APIs</a><ul>
<li><a class="reference internal" href="#python-api" id="id17">Python API</a></li>
<li><a class="reference internal" href="#c-api" id="id18">C API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rejected-ideas" id="id19">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#replicating-threading-local-interface" id="id20">Replicating threading.local() interface</a></li>
<li><a class="reference internal" href="#replacing-token-with-contextvar-unset" id="id21">Replacing Token with ContextVar.unset()</a></li>
<li><a class="reference internal" href="#having-token-reset-instead-of-contextvar-reset" id="id22">Having Token.reset() instead of ContextVar.reset()</a></li>
<li><a class="reference internal" href="#making-context-objects-picklable" id="id23">Making Context objects picklable</a></li>
<li><a class="reference internal" href="#making-context-a-mutablemapping" id="id24">Making Context a MutableMapping</a></li>
<li><a class="reference internal" href="#having-initial-values-for-contextvars" id="id25">Having initial values for ContextVars</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility" id="id26">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#examples" id="id27">Examples</a><ul>
<li><a class="reference internal" href="#converting-code-that-uses-threading-local" id="id28">Converting code that uses threading.local()</a></li>
<li><a class="reference internal" href="#offloading-execution-to-other-threads" id="id29">Offloading execution to other threads</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference-implementation" id="id30">Reference Implementation</a></li>
<li><a class="reference internal" href="#references" id="id31">References</a></li>
<li><a class="reference internal" href="#acknowledgments" id="id32">Acknowledgments</a></li>
<li><a class="reference internal" href="#copyright" id="id33">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id7">Abstract</a></h1>
<p>This PEP proposes a new <tt class="docutils literal">contextvars</tt> module and a set of new
CPython C APIs to support context variables.  This concept is
similar to thread-local storage (TLS), but, unlike TLS, it also allows
correctly keeping track of values per asynchronous task, e.g.
<tt class="docutils literal">asyncio.Task</tt>.</p>
<p>This proposal is a simplified version of <a class="reference external" href="/dev/peps/pep-0550">PEP 550</a>.  The key
difference is that this PEP is concerned only with solving the case
for asynchronous tasks, not for generators.  There are no proposed
modifications to any built-in types or to the interpreter.</p>
<p>This proposal is not strictly related to Python Context Managers.
Although it does provide a mechanism that can be used by Context
Managers to store their state.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id8">Rationale</a></h1>
<p>Thread-local variables are insufficient for asynchronous tasks that
execute concurrently in the same OS thread.  Any context manager that
saves and restores a context value using <tt class="docutils literal">threading.local()</tt> will
have its context values bleed to other code unexpectedly when used
in async/await code.</p>
<p>A few examples where having a working context local storage for
asynchronous code is desirable:</p>
<ul class="simple">
<li>Context managers like <tt class="docutils literal">decimal</tt> contexts and <tt class="docutils literal">numpy.errstate</tt>.</li>
<li>Request-related data, such as security tokens and request
data in web applications, language context for <tt class="docutils literal">gettext</tt>, etc.</li>
<li>Profiling, tracing, and logging in large code bases.</li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id9">Introduction</a></h1>
<p>The PEP proposes a new mechanism for managing context variables.
The key classes involved in this mechanism are <tt class="docutils literal">contextvars.Context</tt>
and <tt class="docutils literal">contextvars.ContextVar</tt>.  The PEP also proposes some policies
for using the mechanism around asynchronous tasks.</p>
<p>The proposed mechanism for accessing context variables uses the
<tt class="docutils literal">ContextVar</tt> class.  A module (such as <tt class="docutils literal">decimal</tt>) that wishes to
use the new mechanism should:</p>
<ul class="simple">
<li>declare a module-global variable holding a <tt class="docutils literal">ContextVar</tt> to
serve as a key;</li>
<li>access the current value via the <tt class="docutils literal">get()</tt> method on the
key variable;</li>
<li>modify the current value via the <tt class="docutils literal">set()</tt> method on the
key variable.</li>
</ul>
<p>The notion of &quot;current value&quot; deserves special consideration:
different asynchronous tasks that exist and execute concurrently
may have different values for the same key.  This idea is well-known
from thread-local storage but in this case the locality of the value is
not necessarily bound to a thread.  Instead, there is the notion of the
&quot;current <tt class="docutils literal">Context</tt>&quot; which is stored in thread-local storage.
Manipulation of the current context is the responsibility of the
task framework, e.g. asyncio.</p>
<p>A <tt class="docutils literal">Context</tt> is a mapping of <tt class="docutils literal">ContextVar</tt> objects to their values.
The <tt class="docutils literal">Context</tt> itself exposes the <tt class="docutils literal">abc.Mapping</tt> interface
(not <tt class="docutils literal">abc.MutableMapping</tt>!), so it cannot be modified directly.
To set a new value for a context variable in a <tt class="docutils literal">Context</tt> object,
the user needs to:</p>
<ul class="simple">
<li>make the <tt class="docutils literal">Context</tt> object &quot;current&quot; using the <tt class="docutils literal">Context.run()</tt>
method;</li>
<li>use <tt class="docutils literal">ContextVar.set()</tt> to set a new value for the context
variable.</li>
</ul>
<p>The <tt class="docutils literal">ContextVar.get()</tt> method looks for the variable in the current
<tt class="docutils literal">Context</tt> object using <tt class="docutils literal">self</tt> as a key.</p>
<p>It is not possible to get a direct reference to the current <tt class="docutils literal">Context</tt>
object, but it is possible to obtain a shallow copy of it using the
<tt class="docutils literal">contextvars.copy_context()</tt> function.  This ensures that the
<em>caller</em> of <tt class="docutils literal">Context.run()</tt> is the sole owner of its <tt class="docutils literal">Context</tt>
object.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id10">Specification</a></h1>
<p>A new standard library module <tt class="docutils literal">contextvars</tt> is added with the
following APIs:</p>
<ol class="arabic simple">
<li>The <tt class="docutils literal">copy_context() <span class="pre">-&gt;</span> Context</tt> function is used to get a copy of
the current <tt class="docutils literal">Context</tt> object for the current OS thread.</li>
<li>The <tt class="docutils literal">ContextVar</tt> class to declare and access context variables.</li>
<li>The <tt class="docutils literal">Context</tt> class encapsulates context state.  Every OS thread
stores a reference to its current <tt class="docutils literal">Context</tt> instance.
It is not possible to control that reference directly.
Instead, the <tt class="docutils literal">Context.run(callable, *args, **kwargs)</tt> method is
used to run Python code in another context.</li>
</ol>
<div class="section" id="contextvars-contextvar">
<h2><a class="toc-backref" href="#id11">contextvars.ContextVar</a></h2>
<p>The <tt class="docutils literal">ContextVar</tt> class has the following constructor signature:
<tt class="docutils literal">ContextVar(name, *, default=_NO_DEFAULT)</tt>.  The <tt class="docutils literal">name</tt> parameter
is used for introspection and debug purposes, and is exposed
as a read-only <tt class="docutils literal">ContextVar.name</tt> attribute.  The <tt class="docutils literal">default</tt>
parameter is optional.  Example:</p>
<pre class="literal-block">
# Declare a context variable 'var' with the default value 42.
var = ContextVar('var', default=42)
</pre>
<p>(The <tt class="docutils literal">_NO_DEFAULT</tt> is an internal sentinel object used to
detect if the default value was provided.)</p>
<p><tt class="docutils literal">ContextVar.get(default=_NO_DEFAULT)</tt> returns a value for
the context variable for the current <tt class="docutils literal">Context</tt>:</p>
<pre class="literal-block">
# Get the value of `var`.
var.get()
</pre>
<p>If there is no value for the variable in the current context,
<tt class="docutils literal">ContextVar.get()</tt> will:</p>
<ul class="simple">
<li>return the value of the <em>default</em> argument of the <tt class="docutils literal">get()</tt> method,
if provided; or</li>
<li>return the default value for the context variable, if provided; or</li>
<li>raise a <tt class="docutils literal">LookupError</tt>.</li>
</ul>
<p><tt class="docutils literal">ContextVar.set(value) <span class="pre">-&gt;</span> Token</tt> is used to set a new value for
the context variable in the current <tt class="docutils literal">Context</tt>:</p>
<pre class="literal-block">
# Set the variable 'var' to 1 in the current context.
var.set(1)
</pre>
<p><tt class="docutils literal">ContextVar.reset(token)</tt> is used to reset the variable in the
current context to the value it had before the <tt class="docutils literal">set()</tt> operation
that created the <tt class="docutils literal">token</tt> (or to remove the variable if it was
not set):</p>
<pre class="literal-block">
# Assume: var.get(None) is None

# Set 'var' to 1:
token = var.set(1)
try:
    # var.get() == 1
finally:
    var.reset(token)

# After reset: var.get(None) is None,
# i.e. 'var' was removed from the current context.
</pre>
<p>The <tt class="docutils literal">ContextVar.reset()</tt> method raises:</p>
<ul class="simple">
<li>a <tt class="docutils literal">ValueError</tt> if it is called with a token object created
by another variable;</li>
<li>a <tt class="docutils literal">ValueError</tt> if the current <tt class="docutils literal">Context</tt> object does not match
the one where the token object was created;</li>
<li>a <tt class="docutils literal">RuntimeError</tt> if the token object has already been used once
to reset the variable.</li>
</ul>
</div>
<div class="section" id="contextvars-token">
<h2><a class="toc-backref" href="#id12">contextvars.Token</a></h2>
<p><tt class="docutils literal">contextvars.Token</tt> is an opaque object that should be used to
restore the <tt class="docutils literal">ContextVar</tt> to its previous value, or to remove it from
the context if the variable was not set before.  It can be created
only by calling <tt class="docutils literal">ContextVar.set()</tt>.</p>
<p>For debug and introspection purposes it has:</p>
<ul class="simple">
<li>a read-only attribute <tt class="docutils literal">Token.var</tt> pointing to the variable
that created the token;</li>
<li>a read-only attribute <tt class="docutils literal">Token.old_value</tt> set to the value the
variable had before the <tt class="docutils literal">set()</tt> call, or to <tt class="docutils literal">Token.MISSING</tt>
if the variable wasn't set before.</li>
</ul>
</div>
<div class="section" id="contextvars-context">
<h2><a class="toc-backref" href="#id13">contextvars.Context</a></h2>
<p><tt class="docutils literal">Context</tt> object is a mapping of context variables to values.</p>
<p><tt class="docutils literal">Context()</tt> creates an empty context.  To get a copy of the current
<tt class="docutils literal">Context</tt> for the current OS thread, use the
<tt class="docutils literal">contextvars.copy_context()</tt> method:</p>
<pre class="literal-block">
ctx = contextvars.copy_context()
</pre>
<p>To run Python code in some <tt class="docutils literal">Context</tt>, use <tt class="docutils literal">Context.run()</tt>
method:</p>
<pre class="literal-block">
ctx.run(function)
</pre>
<p>Any changes to any context variables that <tt class="docutils literal">function</tt> causes will
be contained in the <tt class="docutils literal">ctx</tt> context:</p>
<pre class="literal-block">
var = ContextVar('var')
var.set('spam')

def main():
    # 'var' was set to 'spam' before
    # calling 'copy_context()' and 'ctx.run(main)', so:
    # var.get() == ctx[var] == 'spam'

    var.set('ham')

    # Now, after setting 'var' to 'ham':
    # var.get() == ctx[var] == 'ham'

ctx = copy_context()

# Any changes that the 'main' function makes to 'var'
# will be contained in 'ctx'.
ctx.run(main)

# The 'main()' function was run in the 'ctx' context,
# so changes to 'var' are contained in it:
# ctx[var] == 'ham'

# However, outside of 'ctx', 'var' is still set to 'spam':
# var.get() == 'spam'
</pre>
<p><tt class="docutils literal">Context.run()</tt> raises a <tt class="docutils literal">RuntimeError</tt> when called on the same
context object from more than one OS thread, or when called
recursively.</p>
<p><tt class="docutils literal">Context.copy()</tt> returns a shallow copy of the context object.</p>
<p><tt class="docutils literal">Context</tt> objects implement the <tt class="docutils literal">collections.abc.Mapping</tt> ABC.
This can be used to introspect contexts:</p>
<pre class="literal-block">
ctx = contextvars.copy_context()

# Print all context variables and their values in 'ctx':
print(ctx.items())

# Print the value of 'some_variable' in context 'ctx':
print(ctx[some_variable])
</pre>
<p>Note that all Mapping methods, including <tt class="docutils literal">Context.__getitem__</tt> and
<tt class="docutils literal">Context.get</tt>, ignore default values for context variables
(i.e. <tt class="docutils literal">ContextVar.default</tt>).  This means that for a variable <em>var</em>
that was created with a default value and was not set in the
<em>context</em>:</p>
<ul class="simple">
<li><tt class="docutils literal">context[var]</tt> raises a <tt class="docutils literal">KeyError</tt>,</li>
<li><tt class="docutils literal">var in context</tt> returns <tt class="docutils literal">False</tt>,</li>
<li>the variable isn't included in <tt class="docutils literal">context.items()</tt>, etc.</li>
</ul>
</div>
<div class="section" id="asyncio">
<h2><a class="toc-backref" href="#id14">asyncio</a></h2>
<p><tt class="docutils literal">asyncio</tt> uses <tt class="docutils literal">Loop.call_soon()</tt>, <tt class="docutils literal">Loop.call_later()</tt>,
and <tt class="docutils literal">Loop.call_at()</tt> to schedule the asynchronous execution of a
function.  <tt class="docutils literal">asyncio.Task</tt> uses <tt class="docutils literal">call_soon()</tt> to run the
wrapped coroutine.</p>
<p>We modify <tt class="docutils literal">Loop.call_{at,later,soon}</tt> and
<tt class="docutils literal">Future.add_done_callback()</tt> to accept the new optional <em>context</em>
keyword-only argument, which defaults to the current context:</p>
<pre class="literal-block">
def call_soon(self, callback, *args, context=None):
    if context is None:
        context = contextvars.copy_context()

    # ... some time later
    context.run(callback, *args)
</pre>
<p>Tasks in asyncio need to maintain their own context that they inherit
from the point they were created at.  <tt class="docutils literal">asyncio.Task</tt> is modified
as follows:</p>
<pre class="literal-block">
class Task:
    def __init__(self, coro):
        ...
        # Get the current context snapshot.
        self._context = contextvars.copy_context()
        self._loop.call_soon(self._step, context=self._context)

    def _step(self, exc=None):
        ...
        # Every advance of the wrapped coroutine is done in
        # the task's context.
        self._loop.call_soon(self._step, context=self._context)
        ...
</pre>
</div>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id15">Implementation</a></h1>
<p>This section explains high-level implementation details in
pseudo-code.  Some optimizations are omitted to keep this section
short and clear.</p>
<p>The <tt class="docutils literal">Context</tt> mapping is implemented using an immutable dictionary.
This allows for a O(1) implementation of the <tt class="docutils literal">copy_context()</tt>
function.  The reference implementation implements the immutable
dictionary using Hash Array Mapped Tries (HAMT); see <a class="reference external" href="/dev/peps/pep-0550">PEP 550</a>
for analysis of HAMT performance <a class="footnote-reference" href="#id4" id="id1">[1]</a>.</p>
<p>For the purposes of this section, we implement an immutable dictionary
using a copy-on-write approach and the built-in dict type:</p>
<pre class="literal-block">
class _ContextData:

    def __init__(self):
        self._mapping = dict()

    def __getitem__(self, key):
        return self._mapping[key]

    def __contains__(self, key):
        return key in self._mapping

    def __len__(self):
        return len(self._mapping)

    def __iter__(self):
        return iter(self._mapping)

    def set(self, key, value):
        copy = _ContextData()
        copy._mapping = self._mapping.copy()
        copy._mapping[key] = value
        return copy

    def delete(self, key):
        copy = _ContextData()
        copy._mapping = self._mapping.copy()
        del copy._mapping[key]
        return copy
</pre>
<p>Every OS thread has a reference to the current <tt class="docutils literal">Context</tt> object:</p>
<pre class="literal-block">
class PyThreadState:
    context: Context
</pre>
<p><tt class="docutils literal">contextvars.Context</tt> is a wrapper around <tt class="docutils literal">_ContextData</tt>:</p>
<pre class="literal-block">
class Context(collections.abc.Mapping):

    _data: _ContextData
    _prev_context: Optional[Context]

    def __init__(self):
        self._data = _ContextData()
        self._prev_context = None

    def run(self, callable, *args, **kwargs):
        if self._prev_context is not None:
            raise RuntimeError(
                f'cannot enter context: {self} is already entered')

        ts: PyThreadState = PyThreadState_Get()
        self._prev_context = ts.context
        try:
            ts.context = self
            return callable(*args, **kwargs)
        finally:
            ts.context = self._prev_context
            self._prev_context = None

    def copy(self):
        new = Context()
        new._data = self._data
        return new

    # Implement abstract Mapping.__getitem__
    def __getitem__(self, var):
        return self._data[var]

    # Implement abstract Mapping.__contains__
    def __contains__(self, var):
        return var in self._data

    # Implement abstract Mapping.__len__
    def __len__(self):
        return len(self._data)

    # Implement abstract Mapping.__iter__
    def __iter__(self):
        return iter(self._data)

    # The rest of the Mapping methods are implemented
    # by collections.abc.Mapping.
</pre>
<p><tt class="docutils literal">contextvars.copy_context()</tt> is implemented as follows:</p>
<pre class="literal-block">
def copy_context():
    ts: PyThreadState = PyThreadState_Get()
    return ts.context.copy()
</pre>
<p><tt class="docutils literal">contextvars.ContextVar</tt> interacts with <tt class="docutils literal">PyThreadState.context</tt>
directly:</p>
<pre class="literal-block">
class ContextVar:

    def __init__(self, name, *, default=_NO_DEFAULT):
        self._name = name
        self._default = default

    &#64;property
    def name(self):
        return self._name

    def get(self, default=_NO_DEFAULT):
        ts: PyThreadState = PyThreadState_Get()
        try:
            return ts.context[self]
        except KeyError:
            pass

        if default is not _NO_DEFAULT:
            return default

        if self._default is not _NO_DEFAULT:
            return self._default

        raise LookupError

    def set(self, value):
        ts: PyThreadState = PyThreadState_Get()

        data: _ContextData = ts.context._data
        try:
            old_value = data[self]
        except KeyError:
            old_value = Token.MISSING

        updated_data = data.set(self, value)
        ts.context._data = updated_data
        return Token(ts.context, self, old_value)

    def reset(self, token):
        if token._used:
            raise RuntimeError(&quot;Token has already been used once&quot;)

        if token._var is not self:
            raise ValueError(
                &quot;Token was created by a different ContextVar&quot;)

        ts: PyThreadState = PyThreadState_Get()
        if token._context is not ts.context:
            raise ValueError(
                &quot;Token was created in a different Context&quot;)

        if token._old_value is Token.MISSING:
            ts.context._data = data.delete(token._var)
        else:
            ts.context._data = data.set(token._var,
                                        token._old_value)

        token._used = True
</pre>
<p>Note that the in the reference implementation, <tt class="docutils literal">ContextVar.get()</tt>
has an internal cache for the most recent value, which allows to
bypass a hash lookup.  This is similar to the optimization the
<tt class="docutils literal">decimal</tt> module implements to retrieve its context from
<tt class="docutils literal">PyThreadState_GetDict()</tt>.  See <a class="reference external" href="/dev/peps/pep-0550">PEP 550</a> which explains the
implementation of the cache in great detail.</p>
<p>The <tt class="docutils literal">Token</tt> class is implemented as follows:</p>
<pre class="literal-block">
class Token:

    MISSING = object()

    def __init__(self, context, var, old_value):
        self._context = context
        self._var = var
        self._old_value = old_value
        self._used = False

    &#64;property
    def var(self):
        return self._var

    &#64;property
    def old_value(self):
        return self._old_value
</pre>
</div>
<div class="section" id="summary-of-the-new-apis">
<h1><a class="toc-backref" href="#id16">Summary of the New APIs</a></h1>
<div class="section" id="python-api">
<h2><a class="toc-backref" href="#id17">Python API</a></h2>
<ol class="arabic simple">
<li>A new <tt class="docutils literal">contextvars</tt> module with <tt class="docutils literal">ContextVar</tt>, <tt class="docutils literal">Context</tt>,
and <tt class="docutils literal">Token</tt> classes, and a <tt class="docutils literal">copy_context()</tt> function.</li>
<li><tt class="docutils literal">asyncio.Loop.call_at()</tt>, <tt class="docutils literal">asyncio.Loop.call_later()</tt>,
<tt class="docutils literal">asyncio.Loop.call_soon()</tt>, and
<tt class="docutils literal">asyncio.Future.add_done_callback()</tt> run callback functions in
the context they were called in.  A new <em>context</em> keyword-only
parameter can be used to specify a custom context.</li>
<li><tt class="docutils literal">asyncio.Task</tt> is modified internally to maintain its own
context.</li>
</ol>
</div>
<div class="section" id="c-api">
<h2><a class="toc-backref" href="#id18">C API</a></h2>
<ol class="arabic">
<li><p class="first"><tt class="docutils literal">PyContextVar * PyContextVar_New(char *name, PyObject *default)</tt>:
create a <tt class="docutils literal">ContextVar</tt> object.  The <em>default</em> argument can be
<tt class="docutils literal">NULL</tt>, which means that the variable has no default value.</p>
</li>
<li><p class="first"><tt class="docutils literal">int PyContextVar_Get(PyContextVar *, PyObject *default_value, PyObject **value)</tt>:
return <tt class="docutils literal"><span class="pre">-1</span></tt> if an error occurs during the lookup, <tt class="docutils literal">0</tt> otherwise.
If a value for the context variable is found, it will be set to the
<tt class="docutils literal">value</tt> pointer.  Otherwise, <tt class="docutils literal">value</tt> will be set to
<tt class="docutils literal">default_value</tt> when it is not <tt class="docutils literal">NULL</tt>.  If <tt class="docutils literal">default_value</tt> is
<tt class="docutils literal">NULL</tt>, <tt class="docutils literal">value</tt> will be set to the default value of the
variable, which can be <tt class="docutils literal">NULL</tt> too.  <tt class="docutils literal">value</tt> is always a new
reference.</p>
</li>
<li><p class="first"><tt class="docutils literal">PyContextToken * PyContextVar_Set(PyContextVar *, PyObject *)</tt>:
set the value of the variable in the current context.</p>
</li>
<li><p class="first"><tt class="docutils literal">PyContextVar_Reset(PyContextVar *, PyContextToken *)</tt>:
reset the value of the context variable.</p>
</li>
<li><p class="first"><tt class="docutils literal">PyContext * PyContext_New()</tt>: create a new empty context.</p>
</li>
<li><p class="first"><tt class="docutils literal">PyContext * PyContext_Copy()</tt>: get a copy of the current context.</p>
</li>
<li><p class="first"><tt class="docutils literal">int PyContext_Enter(PyContext *)</tt> and
<tt class="docutils literal">int PyContext_Exit(PyContext *)</tt> allow to set and restore
the context for the current OS thread.  It is required to always
restore the previous context:</p>
<pre class="literal-block">
PyContext *old_ctx = PyContext_Copy();
if (old_ctx == NULL) goto error;

if (PyContext_Enter(new_ctx)) goto error;

// run some code

if (PyContext_Exit(old_ctx)) goto error;
</pre>
</li>
</ol>
</div>
</div>
<div class="section" id="rejected-ideas">
<h1><a class="toc-backref" href="#id19">Rejected Ideas</a></h1>
<div class="section" id="replicating-threading-local-interface">
<h2><a class="toc-backref" href="#id20">Replicating threading.local() interface</a></h2>
<p>Please refer to <a class="reference external" href="/dev/peps/pep-0550">PEP 550</a> where this topic is covered in detail: <a class="footnote-reference" href="#id5" id="id2">[2]</a>.</p>
</div>
<div class="section" id="replacing-token-with-contextvar-unset">
<h2><a class="toc-backref" href="#id21">Replacing Token with ContextVar.unset()</a></h2>
<p>The Token API allows to get around having a <tt class="docutils literal">ContextVar.unset()</tt>
method, which is incompatible with chained contexts design of
<a class="reference external" href="/dev/peps/pep-0550">PEP 550</a>.  Future compatibility with <a class="reference external" href="/dev/peps/pep-0550">PEP 550</a> is desired
in case there is demand to support context variables in generators
and asynchronous generators.</p>
<p>The Token API also offers better usability: the user does not have
to special-case absence of a value. Compare:</p>
<pre class="literal-block">
token = cv.set(new_value)
try:
    # cv.get() is new_value
finally:
    cv.reset(token)
</pre>
<p>with:</p>
<pre class="literal-block">
_deleted = object()
old = cv.get(default=_deleted)
try:
    cv.set(blah)
    # code
finally:
    if old is _deleted:
        cv.unset()
    else:
        cv.set(old)
</pre>
</div>
<div class="section" id="having-token-reset-instead-of-contextvar-reset">
<h2><a class="toc-backref" href="#id22">Having Token.reset() instead of ContextVar.reset()</a></h2>
<p>Nathaniel Smith suggested to implement the <tt class="docutils literal">ContextVar.reset()</tt>
method directly on the <tt class="docutils literal">Token</tt> class, so instead of:</p>
<pre class="literal-block">
token = var.set(value)
# ...
var.reset(token)
</pre>
<p>we would write:</p>
<pre class="literal-block">
token = var.set(value)
# ...
token.reset()
</pre>
<p>Having <tt class="docutils literal">Token.reset()</tt> would make it impossible for a user to
attempt to reset a variable with a token object created by another
variable.</p>
<p>This proposal was rejected for the reason of <tt class="docutils literal">ContextVar.reset()</tt>
being clearer to the human reader of the code which variable is
being reset.</p>
</div>
<div class="section" id="making-context-objects-picklable">
<h2><a class="toc-backref" href="#id23">Making Context objects picklable</a></h2>
<p>Proposed by Antoine Pitrou, this could enable transparent
cross-process use of <tt class="docutils literal">Context</tt> objects, so the
<a class="reference internal" href="#offloading-execution-to-other-threads">Offloading execution to other threads</a> example would work with
a <tt class="docutils literal">ProcessPoolExecutor</tt> too.</p>
<p>Enabling this is problematic because of the following reasons:</p>
<ol class="arabic simple">
<li><tt class="docutils literal">ContextVar</tt> objects do not have <tt class="docutils literal">__module__</tt> and
<tt class="docutils literal">__qualname__</tt> attributes, making straightforward pickling
of <tt class="docutils literal">Context</tt> objects impossible.  This is solvable by modifying
the API to either auto detect the module where a context variable
is defined, or by adding a new keyword-only &quot;module&quot; parameter
to <tt class="docutils literal">ContextVar</tt> constructor.</li>
<li>Not all context variables refer to picklable objects.  Making a
<tt class="docutils literal">ContextVar</tt> picklable must be an opt-in.</li>
</ol>
<p>Given the time frame of the Python 3.7 release schedule it was decided
to defer this proposal to Python 3.8.</p>
</div>
<div class="section" id="making-context-a-mutablemapping">
<h2><a class="toc-backref" href="#id24">Making Context a MutableMapping</a></h2>
<p>Making the <tt class="docutils literal">Context</tt> class implement the <tt class="docutils literal">abc.MutableMapping</tt>
interface would mean that it is possible to set and unset variables
using <tt class="docutils literal">Context[var] = value</tt> and <tt class="docutils literal">del Context[var]</tt> operations.</p>
<p>This proposal was deferred to Python 3.8+ because of the following:</p>
<ol class="arabic">
<li><p class="first">If in Python 3.8 it is decided that generators should support
context variables (see <a class="reference external" href="/dev/peps/pep-0550">PEP 550</a> and <a class="reference external" href="/dev/peps/pep-0568">PEP 568</a>), then <tt class="docutils literal">Context</tt>
would be transformed into a chain-map of context variables mappings
(as every generator would have its own mapping).  That would make
mutation operations like <tt class="docutils literal">Context.__delitem__</tt> confusing, as
they would operate only on the topmost mapping of the chain.</p>
</li>
<li><p class="first">Having a single way of mutating the context
(<tt class="docutils literal">ContextVar.set()</tt> and <tt class="docutils literal">ContextVar.reset()</tt> methods) makes
the API more straightforward.</p>
<p>For example, it would be non-obvious why the below code fragment
does not work as expected:</p>
<pre class="literal-block">
var = ContextVar('var')

ctx = copy_context()
ctx[var] = 'value'
print(ctx[var])  # Prints 'value'

print(var.get())  # Raises a LookupError
</pre>
<p>While the following code would work:</p>
<pre class="literal-block">
ctx = copy_context()

def func():
    ctx[var] = 'value'

    # Contrary to the previous example, this would work
    # because 'func()' is running within 'ctx'.
    print(ctx[var])
    print(var.get())

ctx.run(func)
</pre>
</li>
</ol>
</div>
<div class="section" id="having-initial-values-for-contextvars">
<h2><a class="toc-backref" href="#id25">Having initial values for ContextVars</a></h2>
<p>Nathaniel Smith proposed to have a required <tt class="docutils literal">initial_value</tt>
keyword-only argument for the <tt class="docutils literal">ContextVar</tt> constructor.</p>
<p>The main argument against this proposal is that for some types
there is simply no sensible &quot;initial value&quot; except <tt class="docutils literal">None</tt>.
E.g. consider a web framework that stores the current HTTP
request object in a context variable.  With the current semantics
it is possible to create a context variable without a default value:</p>
<pre class="literal-block">
# Framework:
current_request: ContextVar[Request] = \
    ContextVar('current_request')


# Later, while handling an HTTP request:
request: Request = current_request.get()

# Work with the 'request' object:
return request.method
</pre>
<p>Note that in the above example there is no need to check if
<tt class="docutils literal">request</tt> is <tt class="docutils literal">None</tt>.  It is simply expected that the framework
always sets the <tt class="docutils literal">current_request</tt> variable, or it is a bug (in
which case <tt class="docutils literal">current_request.get()</tt> would raise a <tt class="docutils literal">LookupError</tt>).</p>
<p>If, however, we had a required initial value, we would have
to guard against <tt class="docutils literal">None</tt> values explicitly:</p>
<pre class="literal-block">
# Framework:
current_request: ContextVar[Optional[Request]] = \
    ContextVar('current_request', initial_value=None)


# Later, while handling an HTTP request:
request: Optional[Request] = current_request.get()

# Check if the current request object was set:
if request is None:
    raise RuntimeError

# Work with the 'request' object:
return request.method
</pre>
<p>Moreover, we can loosely compare context variables to regular
Python variables and to <tt class="docutils literal">threading.local()</tt> objects.  Both
of them raise errors on failed lookups (<tt class="docutils literal">NameError</tt> and
<tt class="docutils literal">AttributeError</tt> respectively).</p>
</div>
</div>
<div class="section" id="backwards-compatibility">
<h1><a class="toc-backref" href="#id26">Backwards Compatibility</a></h1>
<p>This proposal preserves 100% backwards compatibility.</p>
<p>Libraries that use <tt class="docutils literal">threading.local()</tt> to store context-related
values, currently work correctly only for synchronous code.  Switching
them to use the proposed API will keep their behavior for synchronous
code unmodified, but will automatically enable support for
asynchronous code.</p>
</div>
<div class="section" id="examples">
<h1><a class="toc-backref" href="#id27">Examples</a></h1>
<div class="section" id="converting-code-that-uses-threading-local">
<h2><a class="toc-backref" href="#id28">Converting code that uses threading.local()</a></h2>
<p>A typical code fragment that uses <tt class="docutils literal">threading.local()</tt> usually
looks like the following:</p>
<pre class="literal-block">
class PrecisionStorage(threading.local):
    # Subclass threading.local to specify a default value.
    value = 0.0

precision = PrecisionStorage()

# To set a new precision:
precision.value = 0.5

# To read the current precision:
print(precision.value)
</pre>
<p>Such code can be converted to use the <tt class="docutils literal">contextvars</tt> module:</p>
<pre class="literal-block">
precision = contextvars.ContextVar('precision', default=0.0)

# To set a new precision:
precision.set(0.5)

# To read the current precision:
print(precision.get())
</pre>
</div>
<div class="section" id="offloading-execution-to-other-threads">
<h2><a class="toc-backref" href="#id29">Offloading execution to other threads</a></h2>
<p>It is possible to run code in a separate OS thread using a copy
of the current thread context:</p>
<pre class="literal-block">
executor = ThreadPoolExecutor()
current_context = contextvars.copy_context()

executor.submit(current_context.run, some_function)
</pre>
</div>
</div>
<div class="section" id="reference-implementation">
<h1><a class="toc-backref" href="#id30">Reference Implementation</a></h1>
<p>The reference implementation can be found here: <a class="footnote-reference" href="#id6" id="id3">[3]</a>.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id31">References</a></h1>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="https://www.python.org/dev/peps/pep-0550/#appendix-hamt-performance-analysis">https://www.python.org/dev/peps/pep-0550/#appendix-hamt-performance-analysis</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="https://www.python.org/dev/peps/pep-0550/#replication-of-threading-local-interface">https://www.python.org/dev/peps/pep-0550/#replication-of-threading-local-interface</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="https://github.com/python/cpython/pull/5027">https://github.com/python/cpython/pull/5027</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="acknowledgments">
<h1><a class="toc-backref" href="#id32">Acknowledgments</a></h1>
<p>I thank Guido van Rossum, Nathaniel Smith, Victor Stinner,
Elvis Pranskevichus, Nick Coghlan, Antoine Pitrou, INADA Naoki,
Paul Moore, Eric Snow, Greg Ewing, and many others for their feedback,
ideas, edits, criticism, code reviews, and discussions around
this PEP.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id33">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

