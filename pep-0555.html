<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">555</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Context-local variables (contextvars)</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0555.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Koos Zevenhoven</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Withdrawn</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">06-Sep-2017</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.7</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">06-Sep-2017</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id1">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id2">Rationale</a></li>
<li><a class="reference internal" href="#proposal" id="id3">Proposal</a><ul>
<li><a class="reference internal" href="#semantics-and-higher-level-api" id="id4">Semantics and higher-level API</a><ul>
<li><a class="reference internal" href="#core-concept" id="id5">Core concept</a></li>
<li><a class="reference internal" href="#refactoring-into-subroutines" id="id6">Refactoring into subroutines</a></li>
<li><a class="reference internal" href="#semantics-for-generators-and-generator-based-coroutines" id="id7">Semantics for generators and generator-based coroutines</a></li>
</ul>
</li>
<li><a class="reference internal" href="#special-functionality-for-framework-authors" id="id8">Special functionality for framework authors</a><ul>
<li><a class="reference internal" href="#leaking-yields" id="id9">Leaking yields</a></li>
<li><a class="reference internal" href="#capturing-contextvar-assignments" id="id10">Capturing contextvar assignments</a></li>
<li><a class="reference internal" href="#getting-a-snapshot-of-context-state" id="id11">Getting a snapshot of context state</a></li>
<li><a class="reference internal" href="#running-code-in-a-clean-state" id="id12">Running code in a clean state</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation" id="id13">Implementation</a><ul>
<li><a class="reference internal" href="#data-structures-and-implementation-of-the-core-concept" id="id14">Data structures and implementation of the core concept</a></li>
<li><a class="reference internal" href="#implementation-of-generator-and-coroutine-semantics" id="id15">Implementation of generator and coroutine semantics</a></li>
<li><a class="reference internal" href="#more-on-implementation" id="id16">More on implementation</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility" id="id17">Backwards compatibility</a></li>
<li><a class="reference internal" href="#open-issues" id="id18">Open Issues</a><ul>
<li><a class="reference internal" href="#out-of-order-de-assignments" id="id19">Out-of-order de-assignments</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rejected-ideas" id="id20">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#dynamic-scoping-linked-to-subroutine-scopes" id="id21">Dynamic scoping linked to subroutine scopes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#acknowledgements" id="id22">Acknowledgements</a></li>
<li><a class="reference internal" href="#references" id="id23">References</a></li>
<li><a class="reference internal" href="#copyright" id="id24">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id1">Abstract</a></h1>
<p>Sometimes, in special cases, it is desired that code can pass information down the function call chain to the callees without having to explicitly pass the information as arguments to each function in the call chain. This proposal describes a construct which allows code to explicitly switch in and out of a context where a certain context variable has a given value assigned to it. This is a modern alternative to some uses of things like global variables in traditional single-threaded (or thread-unsafe) code and of thread-local storage in traditional <em>concurrency-unsafe</em> code (single- or multi-threaded). In particular, the proposed mechanism can also be used with more modern concurrent execution mechanisms such as asynchronously executed coroutines, without the concurrently executed call chains interfering with each other's contexts.</p>
<p>The &quot;call chain&quot; can consist of normal functions, awaited coroutines, or generators. The semantics of context variable scope are equivalent in all cases, allowing code to be refactored freely into <em>subroutines</em> (which here refers to functions, sub-generators or sub-coroutines) without affecting the semantics of context variables. Regarding implementation, this proposal aims at simplicity and minimum changes to the CPython interpreter and to other Python interpreters.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id2">Rationale</a></h1>
<p>Consider a modern Python <em>call chain</em> (or call tree), which in this proposal refers to any chained (nested) execution of <em>subroutines</em>, using any possible combinations of normal function calls, or expressions using <tt class="docutils literal">await</tt> or <tt class="docutils literal">yield from</tt>. In some cases, passing necessary <em>information</em> down the call chain as arguments can substantially complicate the required function signatures, or it can even be impossible to achieve in practice. In these cases, one may search for another place to store this information. Let us look at some historical examples.</p>
<p>The most naive option is to assign the value to a global variable or similar, where the code down the call chain can access it. However, this immediately makes the code thread-unsafe, because with multiple threads, all threads assign to the same global variable, and another thread can interfere at any point in the call chain. Sooner or later, someone will probably find a reason to run the same code in parallel threads.</p>
<p>A somewhat less naive option is to store the information as per-thread information in thread-local storage, where each thread has its own &quot;copy&quot; of the variable which other threads cannot interfere with. Although non-ideal, this has been the best solution in many cases. However, thanks to generators and coroutines, the execution of the call chain can be suspended and resumed, allowing code in other contexts to run concurrently. Therefore, using thread-local storage is <em>concurrency-unsafe</em>, because other call chains in other contexts may interfere with the thread-local variable.</p>
<p>Note that in the above two historical approaches, the stored information has the <em>widest</em> available scope without causing problems. For a third solution along the same path, one would first define an equivalent of a &quot;thread&quot; for asynchronous execution and concurrency. This could be seen as the largest amount of code and nested calls that is guaranteed to be executed sequentially without ambiguity in execution order. This might be referred to as concurrency-local or task-local storage. In this meaning of &quot;task&quot;, there is no ambiguity in the order of execution of the code within one task. (This concept of a task is close to equivalent to a <tt class="docutils literal">Task</tt> in <tt class="docutils literal">asyncio</tt>, but not exactly.) In such concurrency-locals, it is possible to pass information down the call chain to callees without another code path interfering with the value in the background.</p>
<p>Common to the above approaches is that they indeed use variables with a wide but just-narrow-enough scope. Thread-locals could also be called thread-wide globals---in single-threaded code, they are indeed truly global. And task-locals could be called task-wide globals, because tasks can be very big.</p>
<p>The issue here is that neither global variables, thread-locals nor task-locals are really meant to be used for this purpose of passing information of the execution context down the call chain. Instead of the widest possible variable scope, the scope of the variables should be controlled by the programmer, typically of a library, to have the desired scope---not wider. In other words, task-local variables (and globals and thread-locals) have nothing to do with the kind of context-bound information passing that this proposal intends to enable, even if task-locals can be used to emulate the desired semantics. Therefore, in the following, this proposal describes the semantics and the outlines of an implementation for <em>context-local variables</em> (or context variables, contextvars). In fact, as a side effect of this PEP, an async framework can use the proposed feature to implement task-local variables.</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id3">Proposal</a></h1>
<p>Because the proposed semantics are not a direct extension to anything already available in Python, this proposal is first described in terms of semantics and API at a fairly high level. In particular, Python <tt class="docutils literal">with</tt> statements are heavily used in the description, as they are a good match with the proposed semantics. However, the underlying <tt class="docutils literal">__enter__</tt> and <tt class="docutils literal">__exit__</tt> methods correspond to functions in the lower-level speed-optimized (C) API. For clarity of this document, the lower-level functions are not explicitly named in the definition of the semantics. After describing the semantics and high-level API, the implementation is described, going to a lower level.</p>
<div class="section" id="semantics-and-higher-level-api">
<h2><a class="toc-backref" href="#id4">Semantics and higher-level API</a></h2>
<div class="section" id="core-concept">
<h3><a class="toc-backref" href="#id5">Core concept</a></h3>
<p>A context-local variable is represented by a single instance of <tt class="docutils literal">contextvars.Var</tt>, say <tt class="docutils literal">cvar</tt>. Any code that has access to the <tt class="docutils literal">cvar</tt> object can ask for its value with respect to the current context. In the high-level API, this value is given by the <tt class="docutils literal">cvar.value</tt> property:</p>
<pre class="literal-block">
cvar = contextvars.Var(default=&quot;the default value&quot;,
                       description=&quot;example context variable&quot;)

assert cvar.value == &quot;the default value&quot;  # default still applies

# In code examples, all ``assert`` statements should
# succeed according to the proposed semantics.
</pre>
<p>No assignments to <tt class="docutils literal">cvar</tt> have been applied for this context, so <tt class="docutils literal">cvar.value</tt> gives the default value. Assigning new values to contextvars is done in a highly scope-aware manner:</p>
<pre class="literal-block">
with cvar.assign(new_value):
    assert cvar.value is new_value
    # Any code here, or down the call chain from here, sees:
    #     cvar.value is new_value
    # unless another value has been assigned in a
    # nested context
    assert cvar.value is new_value
# the assignment of ``cvar`` to ``new_value`` is no longer visible
assert cvar.value == &quot;the default value&quot;
</pre>
<p>Here, <tt class="docutils literal">cvar.assign(value)</tt> returns another object, namely <tt class="docutils literal">contextvars.Assignment(cvar, new_value)</tt>. The essential part here is that applying a context variable assignment (<tt class="docutils literal">Assignment.__enter__</tt>) is paired with a de-assignment (<tt class="docutils literal">Assignment.__exit__</tt>). These operations set the bounds for the scope of the assigned value.</p>
<p>Assignments to the same context variable can be nested to override the outer assignment in a narrower context:</p>
<pre class="literal-block">
assert cvar.value == &quot;the default value&quot;
with cvar.assign(&quot;outer&quot;):
    assert cvar.value == &quot;outer&quot;
    with cvar.assign(&quot;inner&quot;):
        assert cvar.value == &quot;inner&quot;
    assert cvar.value == &quot;outer&quot;
assert cvar.value == &quot;the default value&quot;
</pre>
<p>Also multiple variables can be assigned to in a nested manner without affecting each other:</p>
<pre class="literal-block">
cvar1 = contextvars.Var()
cvar2 = contextvars.Var()

assert cvar1.value is None # default is None by default
assert cvar2.value is None

with cvar1.assign(value1):
    assert cvar1.value is value1
    assert cvar2.value is None
    with cvar2.assign(value2):
        assert cvar1.value is value1
        assert cvar2.value is value2
    assert cvar1.value is value1
    assert cvar2.value is None
assert cvar1.value is None
assert cvar2.value is None
</pre>
<p>Or with more convenient Python syntax:</p>
<pre class="literal-block">
with cvar1.assign(value1), cvar2.assign(value2):
    assert cvar1.value is value1
    assert cvar2.value is value2
</pre>
<p>In another <em>context</em>, in another thread or otherwise concurrently executed task or code path, the context variables can have a completely different state. The programmer thus only needs to worry about the context at hand.</p>
</div>
<div class="section" id="refactoring-into-subroutines">
<h3><a class="toc-backref" href="#id6">Refactoring into subroutines</a></h3>
<p>Code using contextvars can be refactored into subroutines without affecting the semantics.  For instance:</p>
<pre class="literal-block">
assi = cvar.assign(new_value)
def apply():
    assi.__enter__()
assert cvar.value == &quot;the default value&quot;
apply()
assert cvar.value is new_value
assi.__exit__()
assert cvar.value == &quot;the default value&quot;
</pre>
<p>Or similarly in an asynchronous context where <tt class="docutils literal">await</tt> expressions are used. The subroutine can now be a coroutine:</p>
<pre class="literal-block">
assi = cvar.assign(new_value)
async def apply():
    assi.__enter__()
assert cvar.value == &quot;the default value&quot;
await apply()
assert cvar.value is new_value
assi.__exit__()
assert cvar.value == &quot;the default value&quot;
</pre>
<p>Or when the subroutine is a generator:</p>
<pre class="literal-block">
def apply():
    yield
    assi.__enter__()
</pre>
<p>which is called using <tt class="docutils literal">yield from apply()</tt> or with calls to <tt class="docutils literal">next</tt> or <tt class="docutils literal">.send</tt>. This is discussed further in later sections.</p>
</div>
<div class="section" id="semantics-for-generators-and-generator-based-coroutines">
<h3><a class="toc-backref" href="#id7">Semantics for generators and generator-based coroutines</a></h3>
<p>Generators, coroutines and async generators act as subroutines in much the same way that normal functions do. However, they have the additional possibility of being suspended by <tt class="docutils literal">yield</tt> expressions. Assignment contexts entered inside a generator are normally preserved across yields:</p>
<pre class="literal-block">
def genfunc():
    with cvar.assign(new_value):
        assert cvar.value is new_value
        yield
        assert cvar.value is new_value
g = genfunc()
next(g)
assert cvar.value == &quot;the default value&quot;
with cvar.assign(another_value):
    next(g)
</pre>
<p>However, the outer context visible to the generator may change state across yields:</p>
<pre class="literal-block">
def genfunc():
    assert cvar.value is value2
    yield
    assert cvar.value is value1
    yield
    with cvar.assign(value3):
        assert cvar.value is value3

with cvar.assign(value1):
    g = genfunc()
    with cvar.assign(value2):
        next(g)
    next(g)
    next(g)
    assert cvar.value is value1
</pre>
<p>Similar semantics apply to async generators defined by <tt class="docutils literal">async def ... yield ...</tt> ).</p>
<p>By default, values assigned inside a generator do not leak through yields to the code that drives the generator. However, the assignment contexts entered and left open inside the generator <em>do</em> become visible outside the generator after the generator has finished with a <tt class="docutils literal">StopIteration</tt> or another exception:</p>
<pre class="literal-block">
assi = cvar.assign(new_value)
def genfunc():
    yield
    assi.__enter__():
    yield

g = genfunc()
assert cvar.value == &quot;the default value&quot;
next(g)
assert cvar.value == &quot;the default value&quot;
next(g)  # assi.__enter__() is called here
assert cvar.value == &quot;the default value&quot;
next(g)
assert cvar.value is new_value
assi.__exit__()
</pre>
</div>
</div>
<div class="section" id="special-functionality-for-framework-authors">
<h2><a class="toc-backref" href="#id8">Special functionality for framework authors</a></h2>
<p>Frameworks, such as <tt class="docutils literal">asyncio</tt> or third-party libraries, can use additional functionality in <tt class="docutils literal">contextvars</tt> to achieve the desired semantics in cases which are not determined by the Python interpreter. Some of the semantics described in this section are also afterwards used to describe the internal implementation.</p>
<div class="section" id="leaking-yields">
<h3><a class="toc-backref" href="#id9">Leaking yields</a></h3>
<p>Using the <tt class="docutils literal">contextvars.leaking_yields</tt> decorator, one can choose to leak the context through <tt class="docutils literal">yield</tt> expressions into the outer context that drives the generator:</p>
<pre class="literal-block">
&#64;contextvars.leaking_yields
def genfunc():
    assert cvar.value == &quot;outer&quot;
    with cvar.assign(&quot;inner&quot;):
        yield
        assert cvar.value == &quot;inner&quot;
    assert cvar.value == &quot;outer&quot;

g = genfunc():
with cvar.assign(&quot;outer&quot;):
    assert cvar.value == &quot;outer&quot;
    next(g)
    assert cvar.value == &quot;inner&quot;
    next(g)
    assert cvar.value == &quot;outer&quot;
</pre>
</div>
<div class="section" id="capturing-contextvar-assignments">
<h3><a class="toc-backref" href="#id10">Capturing contextvar assignments</a></h3>
<p>Using <tt class="docutils literal">contextvars.capture()</tt>, one can capture the assignment contexts that are entered by a block of code. The changes applied by the block of code can then be reverted and subsequently reapplied, even in another context:</p>
<pre class="literal-block">
assert cvar1.value is None # default
assert cvar2.value is None # default
assi1 = cvar1.assign(value1)
assi2 = cvar1.assign(value2)
with contextvars.capture() as delta:
    assi1.__enter__()
    with cvar2.assign(&quot;not captured&quot;):
        assert cvar2.value is &quot;not captured&quot;
    assi2.__enter__()
assert cvar1.value is value2
delta.revert()
assert cvar1.value is None
assert cvar2.value is None
...
with cvar1.assign(1), cvar2.assign(2):
    delta.reapply()
    assert cvar1.value is value2
    assert cvar2.value == 2
</pre>
<p>However, reapplying the &quot;delta&quot; if its net contents include deassignments may not be possible (see also Implementation and Open Issues).</p>
</div>
<div class="section" id="getting-a-snapshot-of-context-state">
<h3><a class="toc-backref" href="#id11">Getting a snapshot of context state</a></h3>
<p>The function <tt class="docutils literal">contextvars.get_local_state()</tt> returns an object representing the applied assignments to all context-local variables in the context where the function is called. This can be seen as equivalent to using <tt class="docutils literal">contextvars.capture()</tt> to capture all context changes from the beginning of execution. The returned object supports methods <tt class="docutils literal">.revert()</tt> and <tt class="docutils literal">reapply()</tt> as above.</p>
</div>
<div class="section" id="running-code-in-a-clean-state">
<h3><a class="toc-backref" href="#id12">Running code in a clean state</a></h3>
<p>Although it is possible to revert all applied context changes using the above primitives, a more convenient way to run a block of code in a clean context is provided:</p>
<pre class="literal-block">
with context_vars.clean_context():
    # here, all context vars start off with their default values
# here, the state is back to what it was before the with block.
</pre>
</div>
</div>
<div class="section" id="implementation">
<h2><a class="toc-backref" href="#id13">Implementation</a></h2>
<p>This section describes to a variable level of detail how the described semantics can be implemented. At present, an implementation aimed at simplicity but sufficient features is described. More details will be added later.</p>
<p>Alternatively, a somewhat more complicated implementation offers minor additional features while adding some performance overhead and requiring more code in the implementation.</p>
<div class="section" id="data-structures-and-implementation-of-the-core-concept">
<h3><a class="toc-backref" href="#id14">Data structures and implementation of the core concept</a></h3>
<p>Each thread of the Python interpreter keeps its own stack of <tt class="docutils literal">contextvars.Assignment</tt> objects, each having a pointer to the previous (outer) assignment like in a linked list. The local state (also returned by <tt class="docutils literal">contextvars.get_local_state()</tt>) then consists of a reference to the top of the stack and a pointer/weak reference to the bottom of the stack. This allows efficient stack manipulations. An object produced by <tt class="docutils literal">contextvars.capture()</tt> is similar, but refers to only a part of the stack with the bottom reference pointing to the top of the stack as it was in the beginning of the capture block.</p>
<p>Now, the stack evolves according to the assignment <tt class="docutils literal">__enter__</tt> and <tt class="docutils literal">__exit__</tt> methods. For example:</p>
<pre class="literal-block">
cvar1 = contextvars.Var()
cvar2 = contextvars.Var()
# stack: []
assert cvar1.value is None
assert cvar2.value is None

with cvar1.assign(&quot;outer&quot;):
    # stack: [Assignment(cvar1, &quot;outer&quot;)]
    assert cvar1.value == &quot;outer&quot;

    with cvar1.assign(&quot;inner&quot;):
        # stack: [Assignment(cvar1, &quot;outer&quot;),
        #         Assignment(cvar1, &quot;inner&quot;)]
        assert cvar1.value == &quot;inner&quot;

        with cvar2.assign(&quot;hello&quot;):
            # stack: [Assignment(cvar1, &quot;outer&quot;),
            #         Assignment(cvar1, &quot;inner&quot;),
            #         Assignment(cvar2, &quot;hello&quot;)]
            assert cvar2.value == &quot;hello&quot;

        # stack: [Assignment(cvar1, &quot;outer&quot;),
        #         Assignment(cvar1, &quot;inner&quot;)]
        assert cvar1.value == &quot;inner&quot;
        assert cvar2.value is None

    # stack: [Assignment(cvar1, &quot;outer&quot;)]
    assert cvar1.value == &quot;outer&quot;

# stack: []
assert cvar1.value is None
assert cvar2.value is None
</pre>
<p>Getting a value from the context using <tt class="docutils literal">cvar1.value</tt> can be implemented as finding the topmost occurrence of a <tt class="docutils literal">cvar1</tt> assignment on the stack and returning the value there, or the default value if no assignment is found on the stack. However, this can be optimized to instead be an O(1) operation in most cases. Still, even searching through the stack may be reasonably fast since these stacks are not intended to grow very large.</p>
<p>The above description is already sufficient for implementing the core concept. Suspendable frames require some additional attention, as explained in the following.</p>
</div>
<div class="section" id="implementation-of-generator-and-coroutine-semantics">
<h3><a class="toc-backref" href="#id15">Implementation of generator and coroutine semantics</a></h3>
<p>Within generators, coroutines and async generators, assignments and deassignments are handled in exactly the same way as anywhere else. However, some changes are needed in the builtin generator methods <tt class="docutils literal">send</tt>, <tt class="docutils literal">__next__</tt>, <tt class="docutils literal">throw</tt> and <tt class="docutils literal">close</tt>. Here is the Python equivalent of the changes needed in <tt class="docutils literal">send</tt> for a generator (here <tt class="docutils literal">_old_send</tt> refers to the behavior in Python 3.6):</p>
<pre class="literal-block">
def send(self, value):
    if self.gi_contextvars is LEAK:
        # If decorated with contextvars.leaking_yields.
        # Nothing needs to be done to leak context through yields :)
        return self._old_send(value)
    try:
        with contextvars.capture() as delta:
            if self.gi_contextvars:
                # non-zero captured content from previous iteration
                self.gi_contextvars.reapply()
            ret = self._old_send(value)
    except Exception:
        raise  # back to the calling frame (e.g. StopIteration)
    else:
        # suspending, revert context changes but save them for later
        delta.revert()
        self.gi_contextvars = delta
    return ret
</pre>
<p>The corresponding modifications to the other methods is essentially identical. The same applies to coroutines and async generators.</p>
<p>For code that does not use <tt class="docutils literal">contextvars</tt>, the additions are O(1) and essentially reduce to a couple of pointer comparisons. For code that does use <tt class="docutils literal">contextvars</tt>, the additions are still O(1) in most cases.</p>
</div>
<div class="section" id="more-on-implementation">
<h3><a class="toc-backref" href="#id16">More on implementation</a></h3>
<p>The rest of the functionality, including <tt class="docutils literal">contextvars.leaking_yields</tt>, contextvars.capture()``, <tt class="docutils literal">contextvars.get_local_state()</tt> and <tt class="docutils literal">contextvars.clean_context()</tt> are in fact quite straightforward to implement, but their implementation will be discussed further in later versions of this proposal. Caching of assigned values is somewhat more complicated, and will be discussed later, but it seems that most cases should achieve O(1) complexity.</p>
</div>
</div>
</div>
<div class="section" id="backwards-compatibility">
<h1><a class="toc-backref" href="#id17">Backwards compatibility</a></h1>
<p>There are no <em>direct</em> backwards-compatibility concerns, since a completely new feature is proposed.</p>
<p>However, various traditional uses of thread-local storage may need a smooth transition to <tt class="docutils literal">contextvars</tt> so they can be concurrency-safe. There are several approaches to this, including emulating task-local storage with a little bit of help from async frameworks. A fully general implementation cannot be provided, because the desired semantics may depend on the design of the framework.</p>
<p>Another way to deal with the transition is for code to first look for a context created using <tt class="docutils literal">contextvars</tt>. If that fails because a new-style context has not been set or because the code runs on an older Python version, a fallback to thread-local storage is used.</p>
</div>
<div class="section" id="open-issues">
<h1><a class="toc-backref" href="#id18">Open Issues</a></h1>
<div class="section" id="out-of-order-de-assignments">
<h2><a class="toc-backref" href="#id19">Out-of-order de-assignments</a></h2>
<p>In this proposal, all variable deassignments are made in the opposite order compared to the preceding assignments. This has two useful properties: it encourages using <tt class="docutils literal">with</tt> statements to define assignment scope and has a tendency to catch errors early (forgetting a <tt class="docutils literal">.__exit__()</tt> call often results in a meaningful error. To have this as a requirement requirement is beneficial also in terms of implementation simplicity and performance. Nevertheless, allowing out-of-order context exits is not completely out of the question, and reasonable implementation strategies for that do exist.</p>
</div>
</div>
<div class="section" id="rejected-ideas">
<h1><a class="toc-backref" href="#id20">Rejected Ideas</a></h1>
<div class="section" id="dynamic-scoping-linked-to-subroutine-scopes">
<h2><a class="toc-backref" href="#id21">Dynamic scoping linked to subroutine scopes</a></h2>
<p>The scope of value visibility should not be determined by the way the code is refactored into subroutines. It is necessary to have per-variable control of the assignment scope.</p>
</div>
</div>
<div class="section" id="acknowledgements">
<h1><a class="toc-backref" href="#id22">Acknowledgements</a></h1>
<p>To be added.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id23">References</a></h1>
<p>To be added.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id24">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

