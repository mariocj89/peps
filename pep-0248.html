<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">248</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Python Database API Specification v1.0</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0248.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">mal&#32;&#97;t&#32;lemburg.com (Marc-Andr√© Lemburg)</td>
</tr>
<tr class="field"><th class="field-name">Discussions-To:</th><td class="field-body"><a class="reference external" href="mailto:db-sig&#64;python.org?subject=PEP%20248">db-sig&#32;&#97;t&#32;python.org</a></td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Informational</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name">Superseded-By:</th><td class="field-body">249</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id2">Introduction</a></li>
<li><a class="reference internal" href="#module-interface" id="id3">Module Interface</a></li>
<li><a class="reference internal" href="#connection-objects" id="id4">Connection Objects</a></li>
<li><a class="reference internal" href="#cursor-objects" id="id5">Cursor Objects</a></li>
<li><a class="reference internal" href="#dbi-helper-objects" id="id6">DBI Helper Objects</a></li>
<li><a class="reference internal" href="#acknowledgements" id="id7">Acknowledgements</a></li>
<li><a class="reference internal" href="#copyright" id="id8">Copyright</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id2">Introduction</a></h1>
<p>This API has been defined to encourage similarity between the
Python modules that are used to access databases.  By doing this,
we hope to achieve a consistency leading to more easily understood
modules, code that is generally more portable across databases,
and a broader reach of database connectivity from Python.</p>
<p>This interface specification consists of several items:</p>
<ul class="simple">
<li>Module Interface</li>
<li>Connection Objects</li>
<li>Cursor Objects</li>
<li>DBI Helper Objects</li>
</ul>
<p>Comments and questions about this specification may be directed to
the SIG on Tabular Databases in Python
(<a class="reference external" href="http://www.python.org/sigs/db-sig">http://www.python.org/sigs/db-sig</a>).</p>
<p>This specification document was last updated on: April 9, 1996.
It will be known as Version 1.0 of this specification.</p>
</div>
<div class="section" id="module-interface">
<h1><a class="toc-backref" href="#id3">Module Interface</a></h1>
<p>The database interface modules should typically be named with
something terminated by <tt class="docutils literal">db</tt>.  Existing examples are: <tt class="docutils literal">oracledb</tt>,
<tt class="docutils literal">informixdb</tt>, and <tt class="docutils literal">pg95db</tt>.  These modules should export several
names:</p>
<dl class="docutils">
<dt><tt class="docutils literal">modulename(connection_string)</tt></dt>
<dd>Constructor for creating a connection to the database.
Returns a Connection Object.</dd>
<dt><tt class="docutils literal">error</tt></dt>
<dd>Exception raised for errors from the database module.</dd>
</dl>
</div>
<div class="section" id="connection-objects">
<h1><a class="toc-backref" href="#id4">Connection Objects</a></h1>
<p>Connection Objects should respond to the following methods:</p>
<dl class="docutils">
<dt><tt class="docutils literal">close()</tt></dt>
<dd>Close the connection now (rather than whenever <tt class="docutils literal">__del__</tt> is
called).  The connection will be unusable from this point
forward; an exception will be raised if any operation is
attempted with the connection.</dd>
<dt><tt class="docutils literal">commit()</tt></dt>
<dd>Commit any pending transaction to the database.</dd>
<dt><tt class="docutils literal">rollback()</tt></dt>
<dd>Roll the database back to the start of any pending
transaction.</dd>
<dt><tt class="docutils literal">cursor()</tt></dt>
<dd>Return a new Cursor Object.  An exception may be thrown if
the database does not support a cursor concept.</dd>
<dt><tt class="docutils literal"><span class="pre">callproc([params])</span></tt></dt>
<dd>(Note: this method is not well-defined yet.)  Call a
stored database procedure with the given (optional)
parameters.  Returns the result of the stored procedure.</dd>
<dt>(all Cursor Object attributes and methods)</dt>
<dd>For databases that do not have cursors and for simple
applications that do not require the complexity of a
cursor, a Connection Object should respond to each of the
attributes and methods of the Cursor Object.  Databases
that have cursor can implement this by using an implicit,
internal cursor.</dd>
</dl>
</div>
<div class="section" id="cursor-objects">
<h1><a class="toc-backref" href="#id5">Cursor Objects</a></h1>
<p>These objects represent a database cursor, which is used to manage
the context of a fetch operation.</p>
<p>Cursor Objects should respond to the following methods and
attributes:</p>
<dl class="docutils">
<dt><tt class="docutils literal">arraysize</tt></dt>
<dd><p class="first">This read/write attribute specifies the number of rows to
fetch at a time with <tt class="docutils literal">fetchmany()</tt>.  This value is also used
when inserting multiple rows at a time (passing a
tuple/list of tuples/lists as the params value to
<tt class="docutils literal">execute()</tt>).  This attribute will default to a single row.</p>
<p class="last">Note that the arraysize is optional and is merely provided
for higher performance database interactions.
Implementations should observe it with respect to the
<tt class="docutils literal">fetchmany()</tt> method, but are free to interact with the
database a single row at a time.</p>
</dd>
<dt><tt class="docutils literal">description</tt></dt>
<dd><p class="first">This read-only attribute is a tuple of 7-tuples.  Each
7-tuple contains information describing each result
column: (name, type_code, display_size, internal_size,
precision, scale, null_ok). This attribute will be <tt class="docutils literal">None</tt>
for operations that do not return rows or if the cursor
has not had an operation invoked via the <tt class="docutils literal">execute()</tt> method
yet.</p>
<p>The 'type_code' is one of the 'dbi' values specified in
the section below.</p>
<p class="last">Note: this is a bit in flux. Generally, the first two
items of the 7-tuple will always be present; the others
may be database specific.</p>
</dd>
<dt><tt class="docutils literal">close()</tt></dt>
<dd>Close the cursor now (rather than whenever <tt class="docutils literal">__del__</tt> is
called).  The cursor will be unusable from this point
forward; an exception will be raised if any operation is
attempted with the cursor.</dd>
<dt><tt class="docutils literal">execute(operation [,params])</tt></dt>
<dd><p class="first">Execute (prepare) a database operation (query or command).
Parameters may be provided (as a sequence
(e.g. tuple/list)) and will be bound to variables in the
operation.  Variables are specified in a database-specific
notation that is based on the index in the parameter tuple
(position-based rather than name-based).</p>
<p>The parameters may also be specified as a sequence of
sequences (e.g. a list of tuples) to insert multiple rows
in a single operation.</p>
<p>A reference to the operation will be retained by the
cursor.  If the same operation object is passed in again,
then the cursor can optimize its behavior.  This is most
effective for algorithms where the same operation is used,
but different parameters are bound to it (many times).</p>
<p>For maximum efficiency when reusing an operation, it is
best to use the <tt class="docutils literal">setinputsizes()</tt> method to specify the
parameter types and sizes ahead of time.  It is legal for
a parameter to not match the predefined information; the
implementation should compensate, possibly with a loss of
efficiency.</p>
<p>Using SQL terminology, these are the possible result
values from the <tt class="docutils literal">execute()</tt> method:</p>
<ul class="last simple">
<li>If the statement is DDL (e.g. <tt class="docutils literal">CREATE TABLE</tt>), then 1 is
returned.</li>
<li>If the statement is DML (e.g. <tt class="docutils literal">UPDATE</tt> or <tt class="docutils literal">INSERT</tt>), then the
number of rows affected is returned (0 or a positive
integer).</li>
<li>If the statement is DQL (e.g. <tt class="docutils literal">SELECT</tt>), <tt class="docutils literal">None</tt> is returned,
indicating that the statement is not really complete until
you use one of the  'fetch' methods.</li>
</ul>
</dd>
<dt><tt class="docutils literal">fetchone()</tt></dt>
<dd>Fetch the next row of a query result, returning a single
tuple.</dd>
<dt><tt class="docutils literal"><span class="pre">fetchmany([size])</span></tt></dt>
<dd><p class="first">Fetch the next set of rows of a query result, returning as
a list of tuples. An empty list is returned when no more
rows are available. The number of rows to fetch is
specified by the parameter.  If it is <tt class="docutils literal">None</tt>, then the
cursor's arraysize determines the number of rows to be
fetched.</p>
<p class="last">Note there are performance considerations involved with
the size parameter.  For optimal performance, it is
usually best to use the arraysize attribute.  If the size
parameter is used, then it is best for it to retain the
same value from one <tt class="docutils literal">fetchmany()</tt> call to the next.</p>
</dd>
<dt><tt class="docutils literal">fetchall()</tt></dt>
<dd>Fetch all rows of a query result, returning as a list of
tuples.  Note that the cursor's arraysize attribute can
affect the performance of this operation.</dd>
<dt><tt class="docutils literal">setinputsizes(sizes)</tt></dt>
<dd><p class="first">(Note: this method is not well-defined yet.)  This can be
used before a call to <tt class="docutils literal">execute()</tt> to predefine memory
areas for the operation's parameters.  sizes is specified
as a tuple -- one item for each input parameter.  The item
should be a Type object that corresponds to the input that
will be used, or it should be an integer specifying the
maximum length of a string parameter.  If the item is
<tt class="docutils literal">None</tt>, then no predefined memory area will be reserved
for that column (this is useful to avoid predefined areas
for large inputs).</p>
<p>This method would be used before the <tt class="docutils literal">execute()</tt> method is
invoked.</p>
<p class="last">Note that this method is optional and is merely provided
for higher performance database interaction.
Implementations are free to do nothing and users are free
to not use it.</p>
</dd>
<dt><tt class="docutils literal">setoutputsize(size [,col])</tt></dt>
<dd><p class="first">(Note: this method is not well-defined yet.)</p>
<p>Set a column buffer size for fetches of large columns
(e.g. LONG).  The column is specified as an index into the
result tuple.  Using a column of <tt class="docutils literal">None</tt> will set the default
size for all large columns in the cursor.</p>
<p>This method would be used before the <tt class="docutils literal">execute()</tt> method is
invoked.</p>
<p class="last">Note that this method is optional and is merely provided
for higher performance database interaction.
Implementations are free to do nothing and users are free
to not use it.</p>
</dd>
</dl>
</div>
<div class="section" id="dbi-helper-objects">
<h1><a class="toc-backref" href="#id6">DBI Helper Objects</a></h1>
<p>Many databases need to have the input in a particular format for
binding to an operation's input parameters.  For example, if an
input is destined for a <tt class="docutils literal">DATE</tt> column, then it must be bound to the
database in a particular string format.  Similar problems exist
for &quot;Row ID&quot; columns or large binary items (e.g. blobs or <tt class="docutils literal">RAW</tt>
columns).  This presents problems for Python since the parameters
to the <tt class="docutils literal">execute()</tt> method are untyped.  When the database module
sees a Python string object, it doesn't know if it should be bound
as a simple CHAR column, as a raw binary item, or as a <tt class="docutils literal">DATE</tt>.</p>
<p>To overcome this problem, the 'dbi' module was created.  This
module specifies some basic database interface types for working
with databases.  There are two classes: 'dbiDate' and 'dbiRaw'.
These are simple container classes that wrap up a value.  When
passed to the database modules, the module can then detect that
the input parameter is intended as a <tt class="docutils literal">DATE</tt> or a <tt class="docutils literal">RAW</tt>.  For symmetry,
the database modules will return <tt class="docutils literal">DATE</tt> and <tt class="docutils literal">RAW</tt> columns as instances
of these classes.</p>
<p>A Cursor Object's 'description' attribute returns information
about each of the result columns of a query.  The 'type_code' is
defined to be one of five types exported by this module: <tt class="docutils literal">STRING</tt>,
<tt class="docutils literal">RAW</tt>, <tt class="docutils literal">NUMBER</tt>, <tt class="docutils literal">DATE</tt>, or <tt class="docutils literal">ROWID</tt>.</p>
<p>The module exports the following names:</p>
<dl class="docutils">
<dt><tt class="docutils literal">dbiDate(value)</tt></dt>
<dd>This function constructs a 'dbiDate' instance that holds a
date value.  The value should be specified as an integer
number of seconds since the &quot;epoch&quot; (e.g. <tt class="docutils literal">time.time()</tt>).</dd>
<dt><tt class="docutils literal">dbiRaw(value)</tt></dt>
<dd>This function constructs a 'dbiRaw' instance that holds a
raw (binary) value.  The value should be specified as a
Python string.</dd>
<dt><tt class="docutils literal">STRING</tt></dt>
<dd>This object is used to describe columns in a database that
are string-based (e.g. CHAR).</dd>
<dt><tt class="docutils literal">RAW</tt></dt>
<dd>This object is used to describe (large) binary columns in
a database (e.g. LONG RAW, blobs).</dd>
<dt><tt class="docutils literal">NUMBER</tt></dt>
<dd>This object is used to describe numeric columns in a
database.</dd>
<dt><tt class="docutils literal">DATE</tt></dt>
<dd>This object is used to describe date columns in a
database.</dd>
<dt><tt class="docutils literal">ROWID</tt></dt>
<dd>This object is used to describe the &quot;Row ID&quot; column in a
database.</dd>
</dl>
</div>
<div class="section" id="acknowledgements">
<h1><a class="toc-backref" href="#id7">Acknowledgements</a></h1>
<p>Many thanks go to Andrew Kuchling who converted the Python
Database API Specification 1.0 from the original HTML format into
the PEP format.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id8">Copyright</a></h1>
<p>This document has been placed in the Public Domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

