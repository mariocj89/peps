<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">539</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">A New C-API for Thread-Local Storage in CPython</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0539.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Erik M. Bray, Masayuki Yamamoto</td>
</tr>
<tr class="field"><th class="field-name">BDFL-Delegate:</th><td class="field-body">Nick Coghlan</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Accepted</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">20-Dec-2016</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">16-Dec-2016, 31-Aug-2017, 08-Sep-2017</td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2017-September/149358.html">https://mail.python.org/pipermail/python-dev/2017-September/149358.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id36">Abstract</a></li>
<li><a class="reference internal" href="#specification" id="id37">Specification</a><ul>
<li><a class="reference internal" href="#comparison-of-api-specification" id="id38">Comparison of API Specification</a></li>
<li><a class="reference internal" href="#example" id="id39">Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#platform-support-changes" id="id40">Platform Support Changes</a></li>
<li><a class="reference internal" href="#motivation" id="id41">Motivation</a></li>
<li><a class="reference internal" href="#rationale-for-proposed-solution" id="id42">Rationale for Proposed Solution</a></li>
<li><a class="reference internal" href="#rejected-ideas" id="id43">Rejected Ideas</a></li>
<li><a class="reference internal" href="#implementation" id="id44">Implementation</a></li>
<li><a class="reference internal" href="#copyright" id="id45">Copyright</a></li>
<li><a class="reference internal" href="#references-and-footnotes" id="id46">References and Footnotes</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id36">Abstract</a></h1>
<p>The proposal is to add a new Thread Local Storage (TLS) API to CPython which
would supersede use of the existing TLS API within the CPython interpreter,
while deprecating the existing API.  The new API is named the &quot;Thread
Specific Storage (TSS) API&quot; (see <a class="reference internal" href="#rationale-for-proposed-solution">Rationale for Proposed Solution</a> for the
origin of the name).</p>
<p>Because the existing TLS API is only used internally (it is not mentioned in
the documentation, and the header that defines it, <tt class="docutils literal">pythread.h</tt>, is not
included in <tt class="docutils literal">Python.h</tt> either directly or indirectly), this proposal
probably only affects CPython, but might also affect other interpreter
implementations (PyPy?) that implement parts of the CPython API.</p>
<p>This is motivated primarily by the fact that the old API uses <tt class="docutils literal">int</tt> to
represent TLS keys across all platforms, which is neither POSIX-compliant,
nor portable in any practical sense <a class="footnote-reference" href="#id20" id="id1">[1]</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Throughout this document the acronym &quot;TLS&quot; refers to Thread Local
Storage and should not be confused with &quot;Transportation Layer Security&quot;
protocols.</p>
</div>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id37">Specification</a></h1>
<p>The current API for TLS used inside the CPython interpreter consists of 6
functions:</p>
<pre class="literal-block">
PyAPI_FUNC(int) PyThread_create_key(void)
PyAPI_FUNC(void) PyThread_delete_key(int key)
PyAPI_FUNC(int) PyThread_set_key_value(int key, void *value)
PyAPI_FUNC(void *) PyThread_get_key_value(int key)
PyAPI_FUNC(void) PyThread_delete_key_value(int key)
PyAPI_FUNC(void) PyThread_ReInitTLS(void)
</pre>
<p>These would be superseded by a new set of analogous functions:</p>
<pre class="literal-block">
PyAPI_FUNC(int) PyThread_tss_create(Py_tss_t *key)
PyAPI_FUNC(void) PyThread_tss_delete(Py_tss_t *key)
PyAPI_FUNC(int) PyThread_tss_set(Py_tss_t *key, void *value)
PyAPI_FUNC(void *) PyThread_tss_get(Py_tss_t *key)
</pre>
<p>The specification also adds a few new features:</p>
<ul>
<li><p class="first">A new type <tt class="docutils literal">Py_tss_t</tt>--an opaque type the definition of which may
depend on the underlying TLS implementation.  It is defined:</p>
<pre class="literal-block">
typedef struct {
    int _is_initialized;
    NATIVE_TSS_KEY_T _key;
} Py_tss_t;
</pre>
<p>where <tt class="docutils literal">NATIVE_TSS_KEY_T</tt> is a macro whose value depends on the
underlying native TLS implementation (e.g. <tt class="docutils literal">pthread_key_t</tt>).</p>
</li>
<li><p class="first">An initializer for <tt class="docutils literal">Py_tss_t</tt> variables, <tt class="docutils literal">Py_tss_NEEDS_INIT</tt>.</p>
</li>
<li><p class="first">Three new functions:</p>
<pre class="literal-block">
PyAPI_FUNC(Py_tss_t *) PyThread_tss_alloc(void)
PyAPI_FUNC(void) PyThread_tss_free(Py_tss_t *key)
PyAPI_FUNC(int) PyThread_tss_is_created(Py_tss_t *key)
</pre>
<p>The first two are needed for dynamic (de-)allocation of a <tt class="docutils literal">Py_tss_t</tt>,
particularly in extension modules built with <tt class="docutils literal">Py_LIMITED_API</tt>, where
static allocation of this type is not possible due to its implementation
being opaque at build time.  A value returned by <tt class="docutils literal">PyThread_tss_alloc</tt> is
in the same state as a value initialized with <tt class="docutils literal">Py_tss_NEEDS_INIT</tt>, or
<tt class="docutils literal">NULL</tt> in the case of dynamic allocation failure.  The behavior of
<tt class="docutils literal">PyThread_tss_free</tt> involves calling <tt class="docutils literal">PyThread_tss_delete</tt>
preventively, or is a no-op if the value pointed to by the <tt class="docutils literal">key</tt>
argument is <tt class="docutils literal">NULL</tt>.  <tt class="docutils literal">PyThread_tss_is_created</tt> returns non-zero if the
given <tt class="docutils literal">Py_tss_t</tt> has been initialized (i.e. by <tt class="docutils literal">PyThread_tss_create</tt>).</p>
</li>
</ul>
<p>The new TSS API does not provide functions which correspond to
<tt class="docutils literal">PyThread_delete_key_value</tt> and <tt class="docutils literal">PyThread_ReInitTLS</tt>, because these
functions were needed only for CPython's now defunct built-in TLS
implementation; that is the existing behavior of these functions is treated
as follows: <tt class="docutils literal">PyThread_delete_key_value(key)</tt> is equalivalent to
<tt class="docutils literal">PyThread_set_key_value(key, NULL)</tt>, and <tt class="docutils literal">PyThread_ReInitTLS()</tt> is a
no-op <a class="footnote-reference" href="#id27" id="id2">[8]</a>.</p>
<p>The new <tt class="docutils literal">PyThread_tss_</tt> functions are almost exactly analogous to their
original counterparts with a few minor differences:  Whereas
<tt class="docutils literal">PyThread_create_key</tt> takes no arguments and returns a TLS key as an
<tt class="docutils literal">int</tt>, <tt class="docutils literal">PyThread_tss_create</tt> takes a <tt class="docutils literal">Py_tss_t*</tt> as an argument and
returns an <tt class="docutils literal">int</tt> status code. The behavior of <tt class="docutils literal">PyThread_tss_create</tt> is
undefined if the value pointed to by the <tt class="docutils literal">key</tt> argument is not initialized
by <tt class="docutils literal">Py_tss_NEEDS_INIT</tt>. The returned status code is zero on success
and non-zero on failure.  The meanings of non-zero status codes are not
otherwise defined by this specification.</p>
<p>Similarly the other <tt class="docutils literal">PyThread_tss_</tt> functions are passed a <tt class="docutils literal">Py_tss_t*</tt>
whereas previously the key was passed by value.  This change is necessary, as
being an opaque type, the <tt class="docutils literal">Py_tss_t</tt> type could hypothetically be almost
any size.  This is especially necessary for extension modules built with
<tt class="docutils literal">Py_LIMITED_API</tt>, where the size of the type is not known.  Except for
<tt class="docutils literal">PyThread_tss_free</tt>, the behaviors of <tt class="docutils literal">PyThread_tss_</tt> are undefined if the
value pointed to by the <tt class="docutils literal">key</tt> argument is <tt class="docutils literal">NULL</tt>.</p>
<p>Moreover, because of the use of <tt class="docutils literal">Py_tss_t</tt> instead of <tt class="docutils literal">int</tt>, there are
behaviors in the new API which differ from the existing API with regard to
key creation and deletion.  <tt class="docutils literal">PyThread_tss_create</tt> can be called repeatedly
on the same key--calling it on an already initialized key is a no-op and
immediately returns success. Similarly for calling <tt class="docutils literal">PyThread_tss_delete</tt>
with an uninitialized key.</p>
<p>The behavior of <tt class="docutils literal">PyThread_tss_delete</tt> is defined to change the key's
initialization state to &quot;uninitialized&quot;--this allows, for example,
statically allocated keys to be reset to a sensible state when restarting
the CPython interpreter without terminating the process (e.g. embedding
Python in an application) <a class="footnote-reference" href="#id31" id="id3">[12]</a>.</p>
<p>The old <tt class="docutils literal">PyThread_*_key*</tt> functions will be marked as deprecated in the
documentation, but will not generate runtime deprecation warnings.</p>
<p>Additionally, on platforms where <tt class="docutils literal">sizeof(pthread_key_t) != sizeof(int)</tt>,
<tt class="docutils literal">PyThread_create_key</tt> will return immediately with a failure status, and
the other TLS functions will all be no-ops on such platforms.</p>
<div class="section" id="comparison-of-api-specification">
<h2><a class="toc-backref" href="#id38">Comparison of API Specification</a></h2>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="39%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">API</th>
<th class="head">Thread Local Storage (TLS)</th>
<th class="head">Thread Specific Storage (TSS)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Version</td>
<td>Existing</td>
<td>New</td>
</tr>
<tr><td>Key Type</td>
<td><tt class="docutils literal">int</tt></td>
<td><tt class="docutils literal">Py_tss_t</tt> (opaque type)</td>
</tr>
<tr><td>Handle Native Key</td>
<td>cast to <tt class="docutils literal">int</tt></td>
<td>conceal into internal field</td>
</tr>
<tr><td>Function Argument</td>
<td><tt class="docutils literal">int</tt></td>
<td><tt class="docutils literal">Py_tss_t *</tt></td>
</tr>
<tr><td>Features</td>
<td><ul class="first last simple">
<li>create key</li>
<li>delete key</li>
<li>set value</li>
<li>get value</li>
<li>delete value</li>
<li>reinitialize keys (after
fork)</li>
</ul>
</td>
<td><ul class="first last simple">
<li>create key</li>
<li>delete key</li>
<li>set value</li>
<li>get value</li>
<li>(set <tt class="docutils literal">NULL</tt> instead) <a class="footnote-reference" href="#id27" id="id4">[8]</a></li>
<li>(unnecessary) <a class="footnote-reference" href="#id27" id="id5">[8]</a></li>
<li>dynamically (de-)allocate
key</li>
<li>check key's initialization
state</li>
</ul>
</td>
</tr>
<tr><td>Key Initializer</td>
<td>(<tt class="docutils literal"><span class="pre">-1</span></tt> as key creation
failure)</td>
<td><tt class="docutils literal">Py_tss_NEEDS_INIT</tt></td>
</tr>
<tr><td>Requirement</td>
<td>native threads
(since CPython 3.7 <a class="footnote-reference" href="#id28" id="id6">[9]</a>)</td>
<td>native threads</td>
</tr>
<tr><td>Restriction</td>
<td>No support for platforms
where native TLS key is
defined in a way that cannot
be safely cast to <tt class="docutils literal">int</tt>.</td>
<td>Unable to statically allocate
keys when <tt class="docutils literal">Py_LIMITED_API</tt>
is defined.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="example">
<h2><a class="toc-backref" href="#id39">Example</a></h2>
<p>With the proposed changes, a TSS key is initialized like:</p>
<pre class="literal-block">
static Py_tss_t tss_key = Py_tss_NEEDS_INIT;
if (PyThread_tss_create(&amp;tss_key)) {
    /* ... handle key creation failure ... */
}
</pre>
<p>The initialization state of the key can then be checked like:</p>
<pre class="literal-block">
assert(PyThread_tss_is_created(&amp;tss_key));
</pre>
<p>The rest of the API is used analogously to the old API:</p>
<pre class="literal-block">
int the_value = 1;
if (PyThread_tss_get(&amp;tss_key) == NULL) {
    PyThread_tss_set(&amp;tss_key, (void *)&amp;the_value);
    assert(PyThread_tss_get(&amp;tss_key) != NULL);
}
/* ... once done with the key ... */
PyThread_tss_delete(&amp;tss_key);
assert(!PyThread_tss_is_created(&amp;tss_key));
</pre>
<p>When <tt class="docutils literal">Py_LIMITED_API</tt> is defined, a TSS key must be dynamically allocated:</p>
<pre class="literal-block">
static Py_tss_t *ptr_key = PyThread_tss_alloc();
if (ptr_key == NULL) {
    /* ... handle key allocation failure ... */
}
assert(!PyThread_tss_is_created(ptr_key));
/* ... once done with the key ... */
PyThread_tss_free(ptr_key);
ptr_key = NULL;
</pre>
</div>
</div>
<div class="section" id="platform-support-changes">
<h1><a class="toc-backref" href="#id40">Platform Support Changes</a></h1>
<p>A new &quot;Native Thread Implementation&quot; section will be added to <a class="reference external" href="/dev/peps/pep-0011">PEP 11</a> that
states:</p>
<ul class="simple">
<li>As of CPython 3.7, all platforms are required to provide a native thread
implementation (such as pthreads or Windows) to implement the TSS
API.  Any TSS API problems that occur in an implementation without native
threads will be closed as &quot;won't fix&quot;.</li>
</ul>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id41">Motivation</a></h1>
<p>The primary problem at issue here is the type of the keys (<tt class="docutils literal">int</tt>) used for
TLS values, as defined by the original PyThread TLS API.</p>
<p>The original TLS API was added to Python by GvR back in 1997, and at the
time the key used to represent a TLS value was an <tt class="docutils literal">int</tt>, and so it has
been to the time of writing.  This used CPython's own TLS implementation
which long remained unused, largely unchanged, in Python/thread.c.  Support
for implementation of the API on top of native thread implementations
(pthreads and Windows) was added much later, and the built-in implementation
has been deemed no longer necessary and has since been removed <a class="footnote-reference" href="#id28" id="id7">[9]</a>.</p>
<p>The problem with the choice of <tt class="docutils literal">int</tt> to represent a TLS key, is that while
it was fine for CPython's own TLS implementation, and happens to be
compatible with Windows (which uses <tt class="docutils literal">DWORD</tt> for the analogous data), it is
not compatible with the POSIX standard for the pthreads API, which defines
<tt class="docutils literal">pthread_key_t</tt> as an opaque type not further defined by the standard (as
with <tt class="docutils literal">Py_tss_t</tt> described above) <a class="footnote-reference" href="#id33" id="id8">[14]</a>.  This leaves it up to the underlying
implementation how a <tt class="docutils literal">pthread_key_t</tt> value is used to look up
thread-specific data.</p>
<p>This has not generally been a problem for Python's API, as it just happens
that on Linux <tt class="docutils literal">pthread_key_t</tt> is defined as an <tt class="docutils literal">unsigned int</tt>, and so is
fully compatible with Python's TLS API--<tt class="docutils literal">pthread_key_t</tt>'s created by
<tt class="docutils literal">pthread_create_key</tt> can be freely cast to <tt class="docutils literal">int</tt> and back (well, not
exactly, even this has some limitations as pointed out by issue #22206).</p>
<p>However, as issue #25658 points out, there are at least some platforms
(namely Cygwin, CloudABI, but likely others as well) which have otherwise
modern and POSIX-compliant pthreads implementations, but are not compatible
with Python's API because their <tt class="docutils literal">pthread_key_t</tt> is defined in a way that
cannot be safely cast to <tt class="docutils literal">int</tt>.  In fact, the possibility of running into
this problem was raised by MvL at the time pthreads TLS was added <a class="footnote-reference" href="#id21" id="id9">[2]</a>.</p>
<p>It could be argued that PEP-11 makes specific requirements for supporting a
new, not otherwise officially-support platform (such as CloudABI), and that
the status of Cygwin support is currently dubious.  However, this creates a
very high barrier to supporting platforms that are otherwise Linux- and/or
POSIX-compatible and where CPython might otherwise &quot;just work&quot; except for
this one hurdle.  CPython itself imposes this implementation barrier by way
of an API that is not compatible with POSIX (and in fact makes invalid
assumptions about pthreads).</p>
</div>
<div class="section" id="rationale-for-proposed-solution">
<h1><a class="toc-backref" href="#id42">Rationale for Proposed Solution</a></h1>
<p>The use of an opaque type (<tt class="docutils literal">Py_tss_t</tt>) to key TLS values allows the API to
be compatible with all present (POSIX and Windows) and future (C11?) native
TLS implementations supported by CPython, as it allows the definition of
<tt class="docutils literal">Py_tss_t</tt> to depend on the underlying implementation.</p>
<p>Since the existing TLS API has been available in <em>the limited API</em> <a class="footnote-reference" href="#id32" id="id10">[13]</a> for
some platforms (e.g. Linux), CPython makes an effort to provide the new TSS
API at that level likewise.  Note, however, that the <tt class="docutils literal">Py_tss_t</tt> definition
becomes to be an opaque struct when <tt class="docutils literal">Py_LIMITED_API</tt> is defined, because
exposing <tt class="docutils literal">NATIVE_TSS_KEY_T</tt> as part of the limited API would prevent us
from switching native thread implementation without rebuilding extension
modules.</p>
<p>A new API must be introduced, rather than changing the function signatures of
the current API, in order to maintain backwards compatibility.  The new API
also more clearly groups together these related functions under a single name
prefix, <tt class="docutils literal">PyThread_tss_</tt>.  The &quot;tss&quot; in the name stands for &quot;thread-specific
storage&quot;, and was influenced by the naming and design of the &quot;tss&quot; API that is
part of the C11 threads API <a class="footnote-reference" href="#id34" id="id11">[15]</a>.  However, this is in no way meant to imply
compatibility with or support for the C11 threads API, or signal any future
intention of supporting C11--it's just the influence for the naming and design.</p>
<p>The inclusion of the special initializer <tt class="docutils literal">Py_tss_NEEDS_INIT</tt> is required
by the fact that not all native TLS implementations define a sentinel value
for uninitialized TLS keys.  For example, on Windows a TLS key is
represented by a <tt class="docutils literal">DWORD</tt> (<tt class="docutils literal">unsigned int</tt>) and its value must be treated
as opaque <a class="footnote-reference" href="#id22" id="id12">[3]</a>.  So there is no unsigned integer value that can be safely
used to represent an uninitialized TLS key on Windows.  Likewise, POSIX
does not specify a sentinel for an uninitialized <tt class="docutils literal">pthread_key_t</tt>, instead
relying on the <tt class="docutils literal">pthread_once</tt> interface to ensure that a given TLS key is
initialized only once per-process.  Therefore, the <tt class="docutils literal">Py_tss_t</tt> type
contains an explicit <tt class="docutils literal">._is_initialized</tt> that can indicate the key's
initialization state independent of the underlying implementation.</p>
<p>Changing <tt class="docutils literal">PyThread_create_key</tt> to immediately return a failure status on
systems using pthreads where <tt class="docutils literal">sizeof(int) != sizeof(pthread_key_t)</tt> is
intended as a sanity check:  Currently, <tt class="docutils literal">PyThread_create_key</tt> may report
initial success on such systems, but attempts to use the returned key are
likely to fail.  Although in practice this failure occurs earlier in the
interpreter initialization, it's better to fail immediately at the source of
problem (<tt class="docutils literal">PyThread_create_key</tt>) rather than sometime later when use of an
invalid key is attempted.  In other words, this indicates clearly that the
old API is not supported on platforms where it cannot be used reliably, and
that no effort will be made to add such support.</p>
</div>
<div class="section" id="rejected-ideas">
<h1><a class="toc-backref" href="#id43">Rejected Ideas</a></h1>
<ul class="simple">
<li>Do nothing: The status quo is fine because it works on Linux, and platforms
wishing to be supported by CPython should follow the requirements of
PEP-11.  As explained above, while this would be a fair argument if
CPython were being to asked to make changes to support particular quirks
or features of a specific platform, in this case it is a quirk of CPython
that prevents it from being used to its full potential on otherwise
POSIX-compliant platforms.  The fact that the current implementation
happens to work on Linux is a happy accident, and there's no guarantee
that this will never change.</li>
<li>Affected platforms should just configure Python <tt class="docutils literal"><span class="pre">--without-threads</span></tt>:
this is no longer an option as the <tt class="docutils literal"><span class="pre">--without-threads</span></tt> option has
been removed for Python 3.7 <a class="footnote-reference" href="#id35" id="id13">[16]</a>.</li>
<li>Affected platforms should use CPython's built-in TLS implementation
instead of a native TLS implementation: This is a more acceptable
alternative to the previous idea, and in fact there had been a patch to do
just that <a class="footnote-reference" href="#id23" id="id14">[4]</a>.  However, the built-in implementation being &quot;slower and
clunkier&quot; in general than native implementations still needlessly hobbles
performance on affected platforms.  At least one other module
(<tt class="docutils literal">tracemalloc</tt>) is also broken if Python is built without a native TLS
implementation.  This idea also cannot be adopted because the built-in
implementation has since been removed.</li>
<li>Keep the existing API, but work around the issue by providing a mapping from
<tt class="docutils literal">pthread_key_t</tt> values to <tt class="docutils literal">int</tt> values.  A couple attempts were made at
this (<a class="footnote-reference" href="#id24" id="id15">[5]</a>, <a class="footnote-reference" href="#id25" id="id16">[6]</a>), but this injects needless complexity and overhead
into performance-critical code on platforms that are not currently affected
by this issue (such as Linux).  Even if use of this workaround were made
conditional on platform compatibility, it introduces platform-specific code
to maintain, and still has the problem of the previous rejected ideas of
needlessly hobbling performance on affected platforms.</li>
</ul>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id44">Implementation</a></h1>
<p>An initial version of a patch <a class="footnote-reference" href="#id26" id="id17">[7]</a> is available on the bug tracker for this
issue.  Since the migration to GitHub, its development has continued in the
<tt class="docutils literal"><span class="pre">pep539-tss-api</span></tt> feature branch <a class="footnote-reference" href="#id29" id="id18">[10]</a> in Masayuki Yamamoto's fork of the
CPython repository on GitHub. A work-in-progress PR is available at <a class="footnote-reference" href="#id30" id="id19">[11]</a>.</p>
<p>This reference implementation covers not only the new API implementation
features, but also the client code updates needed to replace the existing
TLS API with the new TSS API.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id45">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
</div>
<div class="section" id="references-and-footnotes">
<h1><a class="toc-backref" href="#id46">References and Footnotes</a></h1>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://bugs.python.org/issue25658">http://bugs.python.org/issue25658</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[2]</a></td><td><a class="reference external" href="https://bugs.python.org/msg116292">https://bugs.python.org/msg116292</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[3]</a></td><td><a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms686801(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms686801(v=vs.85).aspx</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id23" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[4]</a></td><td><a class="reference external" href="http://bugs.python.org/file45548/configure-pthread_key_t.patch">http://bugs.python.org/file45548/configure-pthread_key_t.patch</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id24" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[5]</a></td><td><a class="reference external" href="http://bugs.python.org/file44269/issue25658-1.patch">http://bugs.python.org/file44269/issue25658-1.patch</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id25" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[6]</a></td><td><a class="reference external" href="http://bugs.python.org/file44303/key-constant-time.diff">http://bugs.python.org/file44303/key-constant-time.diff</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id26" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[7]</a></td><td><a class="reference external" href="http://bugs.python.org/file46379/pythread-tss-3.patch">http://bugs.python.org/file46379/pythread-tss-3.patch</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id27" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[8]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id4">2</a>, <a class="fn-backref" href="#id5">3</a>)</em> <a class="reference external" href="https://bugs.python.org/msg298342">https://bugs.python.org/msg298342</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id28" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[9]</td><td><em>(<a class="fn-backref" href="#id6">1</a>, <a class="fn-backref" href="#id7">2</a>)</em> <a class="reference external" href="http://bugs.python.org/issue30832">http://bugs.python.org/issue30832</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id29" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[10]</a></td><td><a class="reference external" href="https://github.com/python/cpython/compare/master...ma8ma:pep539-tss-api">https://github.com/python/cpython/compare/master...ma8ma:pep539-tss-api</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id30" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id19">[11]</a></td><td><a class="reference external" href="https://github.com/python/cpython/pull/1362">https://github.com/python/cpython/pull/1362</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id31" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[12]</a></td><td><a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.Py_FinalizeEx">https://docs.python.org/3/c-api/init.html#c.Py_FinalizeEx</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id32" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[13]</a></td><td>It is also called as &quot;stable ABI&quot;
(<a class="reference external" href="https://www.python.org/dev/peps/pep-0384/">https://www.python.org/dev/peps/pep-0384/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id33" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[14]</a></td><td><a class="reference external" href="http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_key_create.html">http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_key_create.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id34" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[15]</a></td><td><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf#page=404">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf#page=404</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id35" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[16]</a></td><td><a class="reference external" href="https://bugs.python.org/issue31370">https://bugs.python.org/issue31370</a></td></tr>
</tbody>
</table>
</div>

