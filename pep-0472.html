<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">472</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Support for indexing with keyword arguments</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0472.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Stefano Borini, Joseph Martinot-Lagarde</td>
</tr>
<tr class="field"><th class="field-name">Discussions-To:</th><td class="field-body"><a class="reference external" href="mailto:python-ideas&#64;python.org?subject=PEP%20472">python-ideas&#32;&#97;t&#32;python.org</a></td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Draft</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">24-Jun-2014</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.6</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">02-Jul-2014</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id13">Abstract</a></li>
<li><a class="reference internal" href="#motivation" id="id14">Motivation</a></li>
<li><a class="reference internal" href="#use-cases" id="id15">Use cases</a></li>
<li><a class="reference internal" href="#current-implementation" id="id16">Current implementation</a></li>
<li><a class="reference internal" href="#specifications" id="id17">Specifications</a><ul>
<li><a class="reference internal" href="#strategy-strict-dictionary" id="id18">Strategy &quot;Strict dictionary&quot;</a><ul>
<li><a class="reference internal" href="#pros" id="id19">Pros</a></li>
<li><a class="reference internal" href="#neutral" id="id20">Neutral</a></li>
<li><a class="reference internal" href="#cons" id="id21">Cons</a></li>
</ul>
</li>
<li><a class="reference internal" href="#strategy-mixed-dictionary" id="id22">Strategy &quot;mixed dictionary&quot;</a><ul>
<li><a class="reference internal" href="#id2" id="id23">Pros</a></li>
<li><a class="reference internal" href="#id3" id="id24">Cons</a></li>
</ul>
</li>
<li><a class="reference internal" href="#strategy-named-tuple" id="id25">Strategy &quot;named tuple&quot;</a><ul>
<li><a class="reference internal" href="#id4" id="id26">Pros</a></li>
<li><a class="reference internal" href="#id5" id="id27">Cons</a></li>
</ul>
</li>
<li><a class="reference internal" href="#strategy-new-argument-contents" id="id28">Strategy &quot;New argument contents&quot;</a><ul>
<li><a class="reference internal" href="#id8" id="id29">Pros</a></li>
<li><a class="reference internal" href="#id9" id="id30">Cons</a></li>
</ul>
</li>
<li><a class="reference internal" href="#strategy-kwargs-argument" id="id31">Strategy &quot;kwargs argument&quot;</a><ul>
<li><a class="reference internal" href="#id10" id="id32">Pros</a></li>
<li><a class="reference internal" href="#id11" id="id33">Cons</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#c-interface" id="id34">C interface</a></li>
<li><a class="reference internal" href="#alternative-solutions" id="id35">Alternative Solutions</a><ul>
<li><a class="reference internal" href="#use-a-method" id="id36">Use a method</a></li>
<li><a class="reference internal" href="#emulate-requested-behavior-by-abusing-the-slice-object" id="id37">Emulate requested behavior by abusing the slice object</a></li>
<li><a class="reference internal" href="#pass-a-dictionary-as-an-additional-index" id="id38">Pass a dictionary as an additional index</a></li>
</ul>
</li>
<li><a class="reference internal" href="#additional-comments" id="id39">Additional Comments</a><ul>
<li><a class="reference internal" href="#relevance-of-ordering-of-keyword-arguments" id="id40">Relevance of ordering of keyword arguments</a></li>
<li><a class="reference internal" href="#need-for-homogeneity-of-behavior" id="id41">Need for homogeneity of behavior</a></li>
<li><a class="reference internal" href="#having-get-become-obsolete-for-indexing-with-default-fallback" id="id42">Having .get() become obsolete for indexing with default fallback</a></li>
<li><a class="reference internal" href="#on-degeneracy-of-notation" id="id43">On degeneracy of notation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references" id="id44">References</a></li>
<li><a class="reference internal" href="#copyright" id="id45">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id13">Abstract</a></h1>
<p>This PEP proposes an extension of the indexing operation to support keyword
arguments. Notations in the form <tt class="docutils literal">a[K=3,R=2]</tt> would become legal syntax.
For future-proofing considerations, <tt class="docutils literal">a[1:2, K=3, R=4]</tt> are considered and
may be allowed as well, depending on the choice for implementation. In addition
to a change in the parser, the index protocol (<tt class="docutils literal">__getitem__</tt>, <tt class="docutils literal">__setitem__</tt>
and <tt class="docutils literal">__delitem__</tt>) will also potentially require adaptation.</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id14">Motivation</a></h1>
<p>The indexing syntax carries a strong semantic content, differentiating it from
a method call: it implies referring to a subset of data. We believe this
semantic association to be important, and wish to expand the strategies allowed
to refer to this data.</p>
<p>As a general observation, the number of indices needed by an indexing operation
depends on the dimensionality of the data: one-dimensional data (e.g. a list)
requires one index (e.g. <tt class="docutils literal">a[3]</tt>), two-dimensional data (e.g. a matrix) requires
two indices (e.g. <tt class="docutils literal">a[2,3]</tt>) and so on. Each index is a selector along one of the
axes of the dimensionality, and the position in the index tuple is the
metainformation needed to associate each index to the corresponding axis.</p>
<p>The current python syntax focuses exclusively on position to express the
association to the axes, and also contains syntactic sugar to refer to
non-punctiform selection (slices)</p>
<pre class="literal-block">
&gt;&gt;&gt; a[3]       # returns the fourth element of a
&gt;&gt;&gt; a[1:10:2]  # slice notation (extract a non-trivial data subset)
&gt;&gt;&gt; a[3,2]     # multiple indexes (for multidimensional arrays)
</pre>
<p>The additional notation proposed in this PEP would allow notations involving
keyword arguments in the indexing operation, e.g.</p>
<pre class="literal-block">
&gt;&gt;&gt; a[K=3, R=2]
</pre>
<p>which would allow to refer to axes by conventional names.</p>
<p>One must additionally consider the extended form that allows both positional
and keyword specification</p>
<pre class="literal-block">
&gt;&gt;&gt; a[3,R=3,K=4]
</pre>
<p>This PEP will explore different strategies to enable the use of these notations.</p>
</div>
<div class="section" id="use-cases">
<h1><a class="toc-backref" href="#id15">Use cases</a></h1>
<p>The following practical use cases present two broad categories of usage of a
keyworded specification: Indexing and contextual option. For indexing:</p>
<ol class="arabic">
<li><p class="first">To provide a more communicative meaning to the index, preventing e.g. accidental
inversion of indexes</p>
<pre class="literal-block">
&gt;&gt;&gt; gridValues[x=3, y=5, z=8]
&gt;&gt;&gt; rain[time=0:12, location=location]
</pre>
</li>
<li><p class="first">In some domain, such as computational physics and chemistry, the use of a
notation such as <tt class="docutils literal">Basis[Z=5]</tt> is a Domain Specific Language notation to represent
a level of accuracy</p>
<pre class="literal-block">
&gt;&gt;&gt; low_accuracy_energy = computeEnergy(molecule, BasisSet[Z=3])
</pre>
<p>In this case, the index operation would return a basis set at the chosen level
of accuracy (represented by the parameter Z). The reason behind an indexing is that
the BasisSet object could be internally represented as a numeric table, where
rows (the &quot;coefficient&quot; axis, hidden to the user in this example) are associated
to individual elements (e.g. row 0:5 contains coefficients for element 1,
row 5:8 coefficients for element 2) and each column is associated to a given
degree of accuracy (&quot;accuracy&quot; or &quot;Z&quot; axis) so that first column is low
accuracy, second column is medium accuracy and so on. With that indexing,
the user would obtain another object representing the contents of the column
of the internal table for accuracy level 3.</p>
</li>
</ol>
<p>Additionally, the keyword specification can be used as an option contextual to
the indexing. Specifically:</p>
<ol class="arabic">
<li><p class="first">A &quot;default&quot; option allows to specify a default return value when the index
is not present</p>
<pre class="literal-block">
&gt;&gt;&gt; lst = [1, 2, 3]
&gt;&gt;&gt; value = lst[5, default=0]  # value is 0
</pre>
</li>
<li><p class="first">For a sparse dataset, to specify an interpolation strategy
to infer a missing point from e.g. its surrounding data.</p>
<pre class="literal-block">
&gt;&gt;&gt; value = array[1, 3, interpolate=spline_interpolator]
</pre>
</li>
<li><p class="first">A unit could be specified with the same mechanism</p>
<pre class="literal-block">
&gt;&gt;&gt; value = array[1, 3, unit=&quot;degrees&quot;]
</pre>
</li>
</ol>
<p>How the notation is interpreted is up to the implementing class.</p>
</div>
<div class="section" id="current-implementation">
<h1><a class="toc-backref" href="#id16">Current implementation</a></h1>
<p>Currently, the indexing operation is handled by methods <tt class="docutils literal">__getitem__</tt>,
<tt class="docutils literal">__setitem__</tt> and <tt class="docutils literal">__delitem__</tt>. These methods' signature accept one argument
for the index (with <tt class="docutils literal">__setitem__</tt> accepting an additional argument for the set
value). In the following, we will analyze <tt class="docutils literal">__getitem__(self, idx)</tt> exclusively,
with the same considerations implied for the remaining two methods.</p>
<p>When an indexing operation is performed, <tt class="docutils literal">__getitem__(self, idx)</tt> is called.
Traditionally, the full content between square brackets is turned into a single
object passed to argument <tt class="docutils literal">idx</tt>:</p>
<ul class="simple">
<li>When a single element is passed, e.g. <tt class="docutils literal">a[2]</tt>, <tt class="docutils literal">idx</tt> will be <tt class="docutils literal">2</tt>.</li>
<li>When multiple elements are passed, they must be separated by commas: <tt class="docutils literal">a[2, 3]</tt>.
In this case, <tt class="docutils literal">idx</tt> will be a tuple <tt class="docutils literal">(2, 3)</tt>. With <tt class="docutils literal">a[2, 3, &quot;hello&quot;, {}]</tt>
<tt class="docutils literal">idx</tt> will be <tt class="docutils literal">(2, 3, &quot;hello&quot;, {})</tt>.</li>
<li>A slicing notation e.g. <tt class="docutils literal">a[2:10]</tt> will produce a slice object, or a tuple
containing slice objects if multiple values were passed.</li>
</ul>
<p>Except for its unique ability to handle slice notation, the indexing operation
has similarities to a plain method call: it acts like one when invoked with
only one element; If the number of elements is greater than one, the <tt class="docutils literal">idx</tt>
argument behaves like a <tt class="docutils literal">*args</tt>. However, as stated in the Motivation section,
an indexing operation has the strong semantic implication of extraction of a
subset out of a larger set, which is not automatically associated to a regular
method call unless appropriate naming is chosen. Moreover, its different visual
style is important for readability.</p>
</div>
<div class="section" id="specifications">
<h1><a class="toc-backref" href="#id17">Specifications</a></h1>
<p>The implementation should try to preserve the current signature for
<tt class="docutils literal">__getitem__</tt>, or modify it in a backward-compatible way. We will present
different alternatives, taking into account the possible cases that need
to be addressed</p>
<pre class="literal-block">
C0. a[1]; a[1,2]         # Traditional indexing
C1. a[Z=3]
C2. a[Z=3, R=4]
C3. a[1, Z=3]
C4. a[1, Z=3, R=4]
C5. a[1, 2, Z=3]
C6. a[1, 2, Z=3, R=4]
C7. a[1, Z=3, 2, R=4]    # Interposed ordering
</pre>
<div class="section" id="strategy-strict-dictionary">
<h2><a class="toc-backref" href="#id18">Strategy &quot;Strict dictionary&quot;</a></h2>
<p>This strategy acknowledges that <tt class="docutils literal">__getitem__</tt> is special in accepting only
one object, and the nature of that object must be non-ambiguous in its
specification of the axes: it can be either by order, or by name. As a result
of this assumption, in presence of keyword arguments, the passed entity is a
dictionary and all labels must be specified.</p>
<pre class="literal-block">
C0. a[1]; a[1,2]      -&gt; idx = 1; idx = (1, 2)
C1. a[Z=3]            -&gt; idx = {&quot;Z&quot;: 3}
C2. a[Z=3, R=4]       -&gt; idx = {&quot;Z&quot;: 3, &quot;R&quot;: 4}
C3. a[1, Z=3]         -&gt; raise SyntaxError
C4. a[1, Z=3, R=4]    -&gt; raise SyntaxError
C5. a[1, 2, Z=3]      -&gt; raise SyntaxError
C6. a[1, 2, Z=3, R=4] -&gt; raise SyntaxError
C7. a[1, Z=3, 2, R=4] -&gt; raise SyntaxError
</pre>
<div class="section" id="pros">
<h3><a class="toc-backref" href="#id19">Pros</a></h3>
<ul class="simple">
<li>Strong conceptual similarity between the tuple case and the dictionary case.
In the first case, we are specifying a tuple, so we are naturally defining
a plain set of values separated by commas. In the second, we are specifying a
dictionary, so we are specifying a homogeneous set of key/value pairs, as
in <tt class="docutils literal">dict(Z=3, R=4)</tt>;</li>
<li>Simple and easy to parse on the <tt class="docutils literal">__getitem__</tt> side: if it gets a tuple,
determine the axes using positioning. If it gets a dictionary, use
the keywords.</li>
<li>C interface does not need changes.</li>
</ul>
</div>
<div class="section" id="neutral">
<h3><a class="toc-backref" href="#id20">Neutral</a></h3>
<ul class="simple">
<li>Degeneracy of <tt class="docutils literal"><span class="pre">a[{&quot;Z&quot;:</span> 3, &quot;R&quot;: 4}]</tt> with <tt class="docutils literal">a[Z=3, R=4]</tt> means the notation
is syntactic sugar.</li>
</ul>
</div>
<div class="section" id="cons">
<h3><a class="toc-backref" href="#id21">Cons</a></h3>
<ul class="simple">
<li>Very strict.</li>
<li>Destroys ordering of the passed arguments. Preserving the
order would be possible with an OrderedDict as drafted by PEP-468 <a class="footnote-reference" href="#pep-468" id="id1">[5]</a>.</li>
<li>Does not allow use cases with mixed positional/keyword arguments such as
<tt class="docutils literal">a[1, 2, default=5]</tt>.</li>
</ul>
</div>
</div>
<div class="section" id="strategy-mixed-dictionary">
<h2><a class="toc-backref" href="#id22">Strategy &quot;mixed dictionary&quot;</a></h2>
<p>This strategy relaxes the above constraint to return a dictionary containing
both numbers and strings as keys.</p>
<pre class="literal-block">
C0. a[1]; a[1,2]      -&gt; idx = 1; idx = (1, 2)
C1. a[Z=3]            -&gt; idx = {&quot;Z&quot;: 3}
C2. a[Z=3, R=4]       -&gt; idx = {&quot;Z&quot;: 3, &quot;R&quot;: 4}
C3. a[1, Z=3]         -&gt; idx = { 0: 1, &quot;Z&quot;: 3}
C4. a[1, Z=3, R=4]    -&gt; idx = { 0: 1, &quot;Z&quot;: 3, &quot;R&quot;: 4}
C5. a[1, 2, Z=3]      -&gt; idx = { 0: 1, 1: 2, &quot;Z&quot;: 3}
C6. a[1, 2, Z=3, R=4] -&gt; idx = { 0: 1, 1: 2, &quot;Z&quot;: 3, &quot;R&quot;: 4}
C7. a[1, Z=3, 2, R=4] -&gt; idx = { 0: 1, &quot;Z&quot;: 3, 2: 2, &quot;R&quot;: 4}
</pre>
<div class="section" id="id2">
<h3><a class="toc-backref" href="#id23">Pros</a></h3>
<ul class="simple">
<li>Opens for mixed cases.</li>
</ul>
</div>
<div class="section" id="id3">
<h3><a class="toc-backref" href="#id24">Cons</a></h3>
<ul class="simple">
<li>Destroys ordering information for string keys. We have no way of saying if
<tt class="docutils literal">&quot;Z&quot;</tt> in C7 was in position 1 or 3.</li>
<li>Implies switching from a tuple to a dict as soon as one specified index
has a keyword argument. May be confusing to parse.</li>
</ul>
</div>
</div>
<div class="section" id="strategy-named-tuple">
<h2><a class="toc-backref" href="#id25">Strategy &quot;named tuple&quot;</a></h2>
<p>Return a named tuple for <tt class="docutils literal">idx</tt> instead of a tuple.  Keyword arguments would
obviously have their stated name as key, and positional argument would have an
underscore followed by their order:</p>
<pre class="literal-block">
C0. a[1]; a[1,2]      -&gt; idx = 1; idx = (_0=1, _1=2)
C1. a[Z=3]            -&gt; idx = (Z=3)
C2. a[Z=3, R=2]       -&gt; idx = (Z=3, R=2)
C3. a[1, Z=3]         -&gt; idx = (_0=1, Z=3)
C4. a[1, Z=3, R=2]    -&gt; idx = (_0=1, Z=3, R=2)
C5. a[1, 2, Z=3]      -&gt; idx = (_0=1, _2=2, Z=3)
C6. a[1, 2, Z=3, R=4] -&gt; (_0=1, _1=2, Z=3, R=4)
C7. a[1, Z=3, 2, R=4] -&gt; (_0=1, Z=3, _1=2, R=4)
                      or (_0=1, Z=3, _2=2, R=4)
                      or raise SyntaxError
</pre>
<p>The required typename of the namedtuple could be <tt class="docutils literal">Index</tt> or the name of the
argument in the function definition, it keeps the ordering and is easy to
analyse by using the <tt class="docutils literal">_fields</tt> attribute. It is backward compatible, provided
that C0 with more than one entry now passes a namedtuple instead of a plain
tuple.</p>
<div class="section" id="id4">
<h3><a class="toc-backref" href="#id26">Pros</a></h3>
<ul class="simple">
<li>Looks nice. namedtuple transparently replaces tuple and gracefully
degrades to the old behavior.</li>
<li>Does not require a change in the C interface</li>
</ul>
</div>
<div class="section" id="id5">
<h3><a class="toc-backref" href="#id27">Cons</a></h3>
<ul class="simple">
<li>According to some sources <a class="footnote-reference" href="#namedtuple" id="id6">[4]</a> namedtuple is not well developed.
To include it as such important object would probably require rework
and improvement;</li>
<li>The namedtuple fields, and thus the type, will have to change according
to the passed arguments. This can be a performance bottleneck, and makes
it impossible to guarantee that two subsequent index accesses get the same
Index class;</li>
<li>the <tt class="docutils literal">_n</tt> &quot;magic&quot; fields are a bit unusual, but ipython already uses them
for result history.</li>
<li>Python currently has no builtin namedtuple. The current one is available
in the &quot;collections&quot; module in the standard library.</li>
<li>Differently from a function, the two notations <tt class="docutils literal">gridValues[x=3, y=5, z=8]</tt>
and <tt class="docutils literal">gridValues[3,5,8]</tt> would not gracefully match if the order is modified
at call time (e.g. we ask for <tt class="docutils literal">gridValues[y=5, z=8, x=3])</tt>. In a function,
we can pre-define argument names so that keyword arguments are properly
matched. Not so in <tt class="docutils literal">__getitem__</tt>, leaving the task for interpreting and
matching to <tt class="docutils literal">__getitem__</tt> itself.</li>
</ul>
</div>
</div>
<div class="section" id="strategy-new-argument-contents">
<h2><a class="toc-backref" href="#id28">Strategy &quot;New argument contents&quot;</a></h2>
<p>In the current implementation, when many arguments are passed to <tt class="docutils literal">__getitem__</tt>,
they are grouped in a tuple and this tuple is passed to <tt class="docutils literal">__getitem__</tt> as the
single argument <tt class="docutils literal">idx</tt>. This strategy keeps the current signature, but expands the
range of variability in type and contents of <tt class="docutils literal">idx</tt> to more complex representations.</p>
<p>We identify four possible ways to implement this strategy:</p>
<ul class="simple">
<li><strong>P1</strong>: uses a single dictionary for the keyword arguments.</li>
<li><strong>P2</strong>: uses individual single-item dictionaries.</li>
<li><strong>P3</strong>: similar to <strong>P2</strong>, but replaces single-item dictionaries with a <tt class="docutils literal">(key, value)</tt> tuple.</li>
<li><strong>P4</strong>: similar to <strong>P2</strong>, but uses a special and additional new object: <tt class="docutils literal">keyword()</tt></li>
</ul>
<p>Some of these possibilities lead to degenerate notations, i.e. indistinguishable
from an already possible representation. Once again, the proposed notation
becomes syntactic sugar for these representations.</p>
<p>Under this strategy, the old behavior for C0 is unchanged.</p>
<pre class="literal-block">
C0: a[1]        -&gt; idx = 1                    # integer
    a[1,2]      -&gt; idx = (1,2)                # tuple
</pre>
<p>In C1, we can use either a dictionary or a tuple to represent key and value pair
for the specific indexing entry. We need to have a tuple with a tuple in C1
because otherwise we cannot differentiate <tt class="docutils literal"><span class="pre">a[&quot;Z&quot;,</span> 3]</tt> from <tt class="docutils literal">a[Z=3]</tt>.</p>
<pre class="literal-block">
C1: a[Z=3]      -&gt; idx = {&quot;Z&quot;: 3}             # P1/P2 dictionary with single key
                or idx = ((&quot;Z&quot;, 3),)          # P3 tuple of tuples
                or idx = keyword(&quot;Z&quot;, 3)      # P4 keyword object
</pre>
<p>As you can see, notation P1/P2 implies that <tt class="docutils literal">a[Z=3]</tt> and <tt class="docutils literal"><span class="pre">a[{&quot;Z&quot;:</span> 3}]</tt> will
call <tt class="docutils literal">__getitem__</tt> passing the exact same value, and is therefore syntactic
sugar for the latter. Same situation occurs, although with different index, for
P3. Using a keyword object as in P4 would remove this degeneracy.</p>
<p>For the C2 case:</p>
<pre class="literal-block">
C2. a[Z=3, R=4] -&gt; idx = {&quot;Z&quot;: 3, &quot;R&quot;: 4}     # P1 dictionary/ordereddict
                or idx = ({&quot;Z&quot;: 3}, {&quot;R&quot;: 4}) # P2 tuple of two single-key dict
                or idx = ((&quot;Z&quot;, 3), (&quot;R&quot;, 4)) # P3 tuple of tuples
                or idx = (keyword(&quot;Z&quot;, 3),
                          keyword(&quot;R&quot;, 4) )   # P4 keyword objects
</pre>
<p>P1 naturally maps to the traditional <tt class="docutils literal">**kwargs</tt> behavior, however it breaks
the convention that two or more entries for the index produce a tuple.  P2
preserves this behavior, and additionally preserves the order.  Preserving the
order would also be possible with an OrderedDict as drafted by PEP-468 <a class="footnote-reference" href="#pep-468" id="id7">[5]</a>.</p>
<p>The remaining cases are here shown:</p>
<pre class="literal-block">
C3. a[1, Z=3]   -&gt; idx = (1, {&quot;Z&quot;: 3})                     # P1/P2
                or idx = (1, (&quot;Z&quot;, 3))                     # P3
                or idx = (1, keyword(&quot;Z&quot;, 3))              # P4

C4. a[1, Z=3, R=4] -&gt; idx = (1, {&quot;Z&quot;: 3, &quot;R&quot;: 4})          # P1
                   or idx = (1, {&quot;Z&quot;: 3}, {&quot;R&quot;: 4})        # P2
                   or idx = (1, (&quot;Z&quot;, 3), (&quot;R&quot;, 4))        # P3
                   or idx = (1, keyword(&quot;Z&quot;, 3),
                                keyword(&quot;R&quot;, 4))           # P4

C5. a[1, 2, Z=3]   -&gt; idx = (1, 2, {&quot;Z&quot;: 3})               # P1/P2
                   or idx = (1, 2, (&quot;Z&quot;, 3))               # P3
                   or idx = (1, 2, keyword(&quot;Z&quot;, 3))        # P4

C6. a[1, 2, Z=3, R=4] -&gt; idx = (1, 2, {&quot;Z&quot;:3, &quot;R&quot;: 4})     # P1
                      or idx = (1, 2, {&quot;Z&quot;: 3}, {&quot;R&quot;: 4})  # P2
                      or idx = (1, 2, (&quot;Z&quot;, 3), (&quot;R&quot;, 4))  # P3
                      or idx = (1, 2, keyword(&quot;Z&quot;, 3),
                                      keyword(&quot;R&quot;, 4))     # P4

C7. a[1, Z=3, 2, R=4] -&gt; idx = (1, 2, {&quot;Z&quot;: 3, &quot;R&quot;: 4})    # P1. Pack the keyword arguments. Ugly.
                      or raise SyntaxError                 # P1. Same behavior as in function calls.
                      or idx = (1, {&quot;Z&quot;: 3}, 2, {&quot;R&quot;: 4})  # P2
                      or idx =  (1, (&quot;Z&quot;, 3), 2, (&quot;R&quot;, 4)) # P3
                      or idx =  (1, keyword(&quot;Z&quot;, 3),
                                 2, keyword(&quot;R&quot;, 4))       # P4
</pre>
<div class="section" id="id8">
<h3><a class="toc-backref" href="#id29">Pros</a></h3>
<ul class="simple">
<li>Signature is unchanged;</li>
<li>P2/P3 can preserve ordering of keyword arguments as specified at indexing,</li>
<li>P1 needs an OrderedDict, but would destroy interposed ordering if allowed:
all keyword indexes would be dumped into the dictionary;</li>
<li>Stays within traditional types: tuples and dicts. Evt. OrderedDict;</li>
<li>Some proposed strategies are similar in behavior to a traditional function call;</li>
<li>The C interface for <tt class="docutils literal">PyObject_GetItem</tt> and family would remain unchanged.</li>
</ul>
</div>
<div class="section" id="id9">
<h3><a class="toc-backref" href="#id30">Cons</a></h3>
<ul class="simple">
<li>Apparenty complex and wasteful;</li>
<li>Degeneracy in notation (e.g. <tt class="docutils literal">a[Z=3]</tt> and <tt class="docutils literal"><span class="pre">a[{&quot;Z&quot;:3}]</span></tt> are equivalent and
indistinguishable notations at the <tt class="docutils literal">__[get|set|del]item__</tt> level).
This behavior may or may not be acceptable.</li>
<li>for P4, an additional object similar in nature to slice() is needed,
but only to disambiguate the above degeneracy.</li>
<li><tt class="docutils literal">idx</tt> type and layout seems to change depending on the whims of the caller;</li>
<li>May be complex to parse what is passed, especially in the case of tuple of tuples;</li>
<li>P2 Creates a lot of single keys dictionary as members of a tuple. Looks ugly.
P3 would be lighter and easier to use than the tuple of dicts, and still
preserves order (unlike the regular dict), but would result in clumsy
extraction of keywords.</li>
</ul>
</div>
</div>
<div class="section" id="strategy-kwargs-argument">
<h2><a class="toc-backref" href="#id31">Strategy &quot;kwargs argument&quot;</a></h2>
<p><tt class="docutils literal">__getitem__</tt> accepts an optional <tt class="docutils literal">**kwargs</tt> argument which should be keyword only.
<tt class="docutils literal">idx</tt> also becomes optional to support a case where no non-keyword arguments are allowed.
The signature would then be either</p>
<pre class="literal-block">
__getitem__(self, idx)
__getitem__(self, idx, **kwargs)
__getitem__(self, **kwargs)
</pre>
<p>Applied to our cases would produce:</p>
<pre class="literal-block">
C0. a[1,2]            -&gt; idx=(1,2);  kwargs={}
C1. a[Z=3]            -&gt; idx=None ;  kwargs={&quot;Z&quot;:3}
C2. a[Z=3, R=4]       -&gt; idx=None ;  kwargs={&quot;Z&quot;:3, &quot;R&quot;:4}
C3. a[1, Z=3]         -&gt; idx=1    ;  kwargs={&quot;Z&quot;:3}
C4. a[1, Z=3, R=4]    -&gt; idx=1    ;  kwargs={&quot;Z&quot;:3, &quot;R&quot;:4}
C5. a[1, 2, Z=3]      -&gt; idx=(1,2);  kwargs={&quot;Z&quot;:3}
C6. a[1, 2, Z=3, R=4] -&gt; idx=(1,2);  kwargs={&quot;Z&quot;:3, &quot;R&quot;:4}
C7. a[1, Z=3, 2, R=4] -&gt; raise SyntaxError # in agreement to function behavior
</pre>
<p>Empty indexing <tt class="docutils literal">a[]</tt> of course remains invalid syntax.</p>
<div class="section" id="id10">
<h3><a class="toc-backref" href="#id32">Pros</a></h3>
<ul class="simple">
<li>Similar to function call, evolves naturally from it;</li>
<li>Use of keyword indexing with an object whose <tt class="docutils literal">__getitem__</tt>
doesn't have a kwargs will fail in an obvious way.
That's not the case for the other strategies.</li>
</ul>
</div>
<div class="section" id="id11">
<h3><a class="toc-backref" href="#id33">Cons</a></h3>
<ul class="simple">
<li>It doesn't preserve order, unless an OrderedDict is used;</li>
<li>Forbids C7, but is it really needed?</li>
<li>Requires a change in the C interface to pass an additional
PyObject for the keyword arguments.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="c-interface">
<h1><a class="toc-backref" href="#id34">C interface</a></h1>
<p>As briefly introduced in the previous analysis, the C interface would
potentially have to change to allow the new feature. Specifically,
<tt class="docutils literal">PyObject_GetItem</tt> and related routines would have to accept an additional
<tt class="docutils literal">PyObject *kw</tt> argument for Strategy &quot;kwargs argument&quot;. The remaining
strategies would not require a change in the C function signatures, but the
different nature of the passed object would potentially require adaptation.</p>
<p>Strategy &quot;named tuple&quot; would behave correctly without any change: the class
returned by the factory method in collections returns a subclass of tuple,
meaning that <tt class="docutils literal">PyTuple_*</tt> functions can handle the resulting object.</p>
</div>
<div class="section" id="alternative-solutions">
<h1><a class="toc-backref" href="#id35">Alternative Solutions</a></h1>
<p>In this section, we present alternative solutions that would workaround the
missing feature and make the proposed enhancement not worth of implementation.</p>
<div class="section" id="use-a-method">
<h2><a class="toc-backref" href="#id36">Use a method</a></h2>
<p>One could keep the indexing as is, and use a traditional <tt class="docutils literal">get()</tt> method for those
cases where basic indexing is not enough. This is a good point, but as already
reported in the introduction, methods have a different semantic weight from
indexing, and you can't use slices directly in methods. Compare e.g.
<tt class="docutils literal">a[1:3, Z=2]</tt> with <tt class="docutils literal">a.get(slice(1,3), Z=2)</tt>.</p>
<p>The authors however recognize this argument as compelling, and the advantage
in semantic expressivity of a keyword-based indexing may be offset by a rarely
used feature that does not bring enough benefit and may have limited adoption.</p>
</div>
<div class="section" id="emulate-requested-behavior-by-abusing-the-slice-object">
<h2><a class="toc-backref" href="#id37">Emulate requested behavior by abusing the slice object</a></h2>
<p>This extremely creative method exploits the slice objects' behavior, provided
that one accepts to use strings (or instantiate properly named placeholder
objects for the keys), and accept to use &quot;:&quot; instead of &quot;=&quot;.</p>
<pre class="literal-block">
&gt;&gt;&gt; a[&quot;K&quot;:3]
slice('K', 3, None)
&gt;&gt;&gt; a[&quot;K&quot;:3, &quot;R&quot;:4]
(slice('K', 3, None), slice('R', 4, None))
&gt;&gt;&gt;
</pre>
<p>While clearly smart, this approach does not allow easy inquire of the key/value
pair, it's too clever and esotheric, and does not allow to pass a slice as in
<tt class="docutils literal">a[K=1:10:2]</tt>.</p>
<p>However, Tim Delaney comments</p>
<blockquote>
&quot;I really do think that <tt class="docutils literal">a[b=c, d=e]</tt> should just be syntax sugar for
<tt class="docutils literal"><span class="pre">a['b':c,</span> <span class="pre">'d':e]</span></tt>. It's simple to explain, and gives the greatest backwards
compatibility. In particular, libraries that already abused slices in this
way will just continue to work with the new syntax.&quot;</blockquote>
<p>We think this behavior would produce inconvenient results. The library Pandas uses
strings as labels, allowing notation such as</p>
<pre class="literal-block">
&gt;&gt;&gt; a[:, &quot;A&quot;:&quot;F&quot;]
</pre>
<p>to extract data from column &quot;A&quot; to column &quot;F&quot;. Under the above comment, this notation
would be equally obtained with</p>
<pre class="literal-block">
&gt;&gt;&gt; a[:, A=&quot;F&quot;]
</pre>
<p>which is weird and collides with the intended meaning of keyword in indexing, that
is, specifying the axis through conventional names rather than positioning.</p>
</div>
<div class="section" id="pass-a-dictionary-as-an-additional-index">
<h2><a class="toc-backref" href="#id38">Pass a dictionary as an additional index</a></h2>
<pre class="literal-block">
&gt;&gt;&gt; a[1, 2, {&quot;K&quot;: 3}]
</pre>
<p>this notation, although less elegant, can already be used and achieves similar
results. It's evident that the proposed Strategy &quot;New argument contents&quot; can be
interpreted as syntactic sugar for this notation.</p>
</div>
</div>
<div class="section" id="additional-comments">
<h1><a class="toc-backref" href="#id39">Additional Comments</a></h1>
<p>Commenters also expressed the following relevant points:</p>
<div class="section" id="relevance-of-ordering-of-keyword-arguments">
<h2><a class="toc-backref" href="#id40">Relevance of ordering of keyword arguments</a></h2>
<p>As part of the discussion of this PEP, it's important to decide if the ordering
information of the keyword arguments is important, and if indexes and keys can
be ordered in an arbitrary way (e.g. <tt class="docutils literal">a[1,Z=3,2,R=4]</tt>). PEP-468 <a class="footnote-reference" href="#pep-468" id="id12">[5]</a>
tries to address the first point by proposing the use of an ordereddict,
however one would be inclined to accept that keyword arguments in indexing are
equivalent to kwargs in function calls, and therefore as of today equally
unordered, and with the same restrictions.</p>
</div>
<div class="section" id="need-for-homogeneity-of-behavior">
<h2><a class="toc-backref" href="#id41">Need for homogeneity of behavior</a></h2>
<p>Relative to Strategy &quot;New argument contents&quot;, a comment from Ian Cordasco
points out that</p>
<blockquote>
&quot;it would be unreasonable for just one method to behave totally
differently from the standard behaviour in Python.  It would be confusing for
only <tt class="docutils literal">__getitem__</tt> (and ostensibly, <tt class="docutils literal">__setitem__</tt>) to take keyword
arguments but instead of turning them into a dictionary, turn them into
individual single-item dictionaries.&quot; We agree with his point, however it must
be pointed out that <tt class="docutils literal">__getitem__</tt> is already special in some regards when it
comes to passed arguments.</blockquote>
<p>Chris Angelico also states:</p>
<blockquote>
&quot;it seems very odd to start out by saying &quot;here, let's give indexing the
option to carry keyword args, just like with function calls&quot;, and then come
back and say &quot;oh, but unlike function calls, they're inherently ordered and
carried very differently&quot;.&quot; Again, we agree on this point.  The most
straightforward strategy to keep homogeneity would be Strategy &quot;kwargs
argument&quot;, opening to a <tt class="docutils literal">**kwargs</tt> argument on <tt class="docutils literal">__getitem__</tt>.</blockquote>
<p>One of the authors (Stefano Borini) thinks that only the &quot;strict dictionary&quot;
strategy is worth of implementation. It is non-ambiguous, simple, does not
force complex parsing, and addresses the problem of referring to axes either
by position or by name. The &quot;options&quot; use case is probably best handled with
a different approach, and may be irrelevant for this PEP. The alternative
&quot;named tuple&quot; is another valid choice.</p>
</div>
<div class="section" id="having-get-become-obsolete-for-indexing-with-default-fallback">
<h2><a class="toc-backref" href="#id42">Having .get() become obsolete for indexing with default fallback</a></h2>
<p>Introducing a &quot;default&quot; keyword could make <tt class="docutils literal">dict.get()</tt> obsolete, which would be
replaced by <tt class="docutils literal"><span class="pre">d[&quot;key&quot;,</span> default=3]</tt>. Chris Angelico however states:</p>
<blockquote>
&quot;Currently, you need to write <tt class="docutils literal">__getitem__</tt> (which raises an exception on
finding a problem) plus something else, e.g. <tt class="docutils literal">get()</tt>, which returns a default
instead. By your proposal, both branches would go inside <tt class="docutils literal">__getitem__</tt>, which
means they could share code; but there still need to be two branches.&quot;</blockquote>
<p>Additionally, Chris continues:</p>
<blockquote>
&quot;There'll be an ad-hoc and fairly arbitrary puddle of names (some will go
<tt class="docutils literal">default=</tt>, others will say that's way too long and go <tt class="docutils literal">def=</tt>, except that
that's a keyword so they'll use <tt class="docutils literal">dflt=</tt> or something...), unless there's a
strong force pushing people to one consistent name.&quot;.</blockquote>
<p>This argument is valid but it's equally valid for any function call, and is
generally fixed by established convention and documentation.</p>
</div>
<div class="section" id="on-degeneracy-of-notation">
<h2><a class="toc-backref" href="#id43">On degeneracy of notation</a></h2>
<p>User Drekin commented: &quot;The case of <tt class="docutils literal">a[Z=3]</tt> and <tt class="docutils literal"><span class="pre">a[{&quot;Z&quot;:</span> 3}]</tt> is similar to
current <tt class="docutils literal">a[1, 2]</tt> and <tt class="docutils literal"><span class="pre">a[(1,</span> 2)]</tt>.  Even though one may argue that the parentheses
are actually not part of tuple notation but are just needed because of syntax,
it may look as degeneracy of notation when compared to function call: <tt class="docutils literal">f(1, 2)</tt>
is not the same thing as <tt class="docutils literal"><span class="pre">f((1,</span> 2))</tt>.&quot;.</p>
</div>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id44">References</a></h1>
<table class="docutils footnote" frame="void" id="keyword-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>&quot;keyword-only args in __getitem__&quot;
(<a class="reference external" href="http://article.gmane.org/gmane.comp.python.ideas/27584">http://article.gmane.org/gmane.comp.python.ideas/27584</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="keyword-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>&quot;Accepting keyword arguments for __getitem__&quot;
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2014-June/028164.html">https://mail.python.org/pipermail/python-ideas/2014-June/028164.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="keyword-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>&quot;PEP pre-draft: Support for indexing with keyword arguments&quot;
<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2014-July/028250.html">https://mail.python.org/pipermail/python-ideas/2014-July/028250.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="namedtuple" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[4]</a></td><td>&quot;namedtuple is not as good as it should be&quot;
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2013-June/021257.html">https://mail.python.org/pipermail/python-ideas/2013-June/021257.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="pep-468" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id7">2</a>, <a class="fn-backref" href="#id12">3</a>)</em> &quot;Preserving the order of **kwargs in a function.&quot;
<a class="reference external" href="http://legacy.python.org/dev/peps/pep-0468/">http://legacy.python.org/dev/peps/pep-0468/</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id45">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>

