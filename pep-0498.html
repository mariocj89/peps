<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">498</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Literal String Interpolation</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0498.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Eric V. Smith &lt;eric&#32;&#97;t&#32;trueblade.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">01-Aug-2015</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.6</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">07-Aug-2015, 30-Aug-2015, 04-Sep-2015, 19-Sep-2015, 06-Nov-2016</td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2015-September/141526.html">https://mail.python.org/pipermail/python-dev/2015-September/141526.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id23">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id24">Rationale</a><ul>
<li><a class="reference internal" href="#no-use-of-globals-or-locals" id="id25">No use of globals() or locals()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification" id="id26">Specification</a><ul>
<li><a class="reference internal" href="#escape-sequences" id="id27">Escape sequences</a></li>
<li><a class="reference internal" href="#code-equivalence" id="id28">Code equivalence</a></li>
<li><a class="reference internal" href="#expression-evaluation" id="id29">Expression evaluation</a></li>
<li><a class="reference internal" href="#format-specifiers" id="id30">Format specifiers</a></li>
<li><a class="reference internal" href="#concatenating-strings" id="id31">Concatenating strings</a></li>
<li><a class="reference internal" href="#error-handling" id="id32">Error handling</a></li>
<li><a class="reference internal" href="#leading-and-trailing-whitespace-in-expressions-is-ignored" id="id33">Leading and trailing whitespace in expressions is ignored</a></li>
<li><a class="reference internal" href="#evaluation-order-of-expressions" id="id34">Evaluation order of expressions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#discussion" id="id35">Discussion</a><ul>
<li><a class="reference internal" href="#python-ideas-discussion" id="id36">python-ideas discussion</a><ul>
<li><a class="reference internal" href="#how-to-denote-f-strings" id="id37">How to denote f-strings</a></li>
<li><a class="reference internal" href="#how-to-specify-the-location-of-expressions-in-f-strings" id="id38">How to specify the location of expressions in f-strings</a></li>
<li><a class="reference internal" href="#supporting-full-python-expressions" id="id39">Supporting full Python expressions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#similar-support-in-other-languages" id="id40">Similar support in other languages</a></li>
<li><a class="reference internal" href="#differences-between-f-string-and-str-format-expressions" id="id41">Differences between f-string and str.format expressions</a></li>
<li><a class="reference internal" href="#triple-quoted-f-strings" id="id42">Triple-quoted f-strings</a></li>
<li><a class="reference internal" href="#raw-f-strings" id="id43">Raw f-strings</a></li>
<li><a class="reference internal" href="#no-binary-f-strings" id="id44">No binary f-strings</a></li>
<li><a class="reference internal" href="#s-r-and-a-are-redundant" id="id45"><tt class="docutils literal">!s</tt>, <tt class="docutils literal">!r</tt>, and <tt class="docutils literal">!a</tt> are redundant</a></li>
<li><a class="reference internal" href="#lambdas-inside-expressions" id="id46">Lambdas inside expressions</a></li>
<li><a class="reference internal" href="#can-t-combine-with-u" id="id47">Can't combine with 'u'</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples-from-python-s-source-code" id="id48">Examples from Python's source code</a></li>
<li><a class="reference internal" href="#references" id="id49">References</a></li>
<li><a class="reference internal" href="#copyright" id="id50">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id23">Abstract</a></h1>
<p>Python supports multiple ways to format text strings. These include
%-formatting <a class="footnote-reference" href="#id12" id="id1">[1]</a>, <tt class="docutils literal">str.format()</tt> <a class="footnote-reference" href="#id13" id="id2">[2]</a>, and <tt class="docutils literal">string.Template</tt>
<a class="footnote-reference" href="#id14" id="id3">[3]</a>. Each of these methods have their advantages, but in addition
have disadvantages that make them cumbersome to use in practice. This
PEP proposed to add a new string formatting mechanism: Literal String
Interpolation. In this PEP, such strings will be referred to as
&quot;f-strings&quot;, taken from the leading character used to denote such
strings, and standing for &quot;formatted strings&quot;.</p>
<p>This PEP does not propose to remove or deprecate any of the existing
string formatting mechanisms.</p>
<p>F-strings provide a way to embed expressions inside string literals,
using a minimal syntax. It should be noted that an f-string is really
an expression evaluated at run time, not a constant value. In Python
source code, an f-string is a literal string, prefixed with 'f', which
contains expressions inside braces. The expressions are replaced with
their values. Some examples are:</p>
<pre class="literal-block">
&gt;&gt;&gt; import datetime
&gt;&gt;&gt; name = 'Fred'
&gt;&gt;&gt; age = 50
&gt;&gt;&gt; anniversary = datetime.date(1991, 10, 12)
&gt;&gt;&gt; f'My name is {name}, my age next year is {age+1}, my anniversary is {anniversary:%A, %B %d, %Y}.'
'My name is Fred, my age next year is 51, my anniversary is Saturday, October 12, 1991.'
&gt;&gt;&gt; f'He said his name is {name!r}.'
&quot;He said his name is 'Fred'.&quot;
</pre>
<p>A similar feature was proposed in <a class="reference external" href="/dev/peps/pep-0215">PEP 215</a>. <a class="reference external" href="/dev/peps/pep-0215">PEP 215</a> proposed to support
a subset of Python expressions, and did not support the type-specific
string formatting (the <tt class="docutils literal">__format__()</tt> method) which was introduced
with <a class="reference external" href="/dev/peps/pep-3101">PEP 3101</a>.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id24">Rationale</a></h1>
<p>This PEP is driven by the desire to have a simpler way to format
strings in Python. The existing ways of formatting are either error
prone, inflexible, or cumbersome.</p>
<p>%-formatting is limited as to the types it supports. Only ints, strs,
and doubles can be formatted. All other types are either not
supported, or converted to one of these types before formatting. In
addition, there's a well-known trap where a single value is passed:</p>
<pre class="literal-block">
&gt;&gt;&gt; msg = 'disk failure'
&gt;&gt;&gt; 'error: %s' % msg
'error: disk failure'
</pre>
<p>But if msg were ever to be a tuple, the same code would fail:</p>
<pre class="literal-block">
&gt;&gt;&gt; msg = ('disk failure', 32)
&gt;&gt;&gt; 'error: %s' % msg
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: not all arguments converted during string formatting
</pre>
<p>To be defensive, the following code should be used:</p>
<pre class="literal-block">
&gt;&gt;&gt; 'error: %s' % (msg,)
&quot;error: ('disk failure', 32)&quot;
</pre>
<p><tt class="docutils literal">str.format()</tt> was added to address some of these problems with
%-formatting. In particular, it uses normal function call syntax (and
therefor supports multiple parameters) and it is extensible through
the <tt class="docutils literal">__format__()</tt> method on the object being converted to a
string. See <a class="reference external" href="/dev/peps/pep-3101">PEP 3101</a> for a detailed rationale. This PEP reuses much of
the <tt class="docutils literal">str.format()</tt> syntax and machinery, in order to provide
continuity with an existing Python string formatting mechanism.</p>
<p>However, <tt class="docutils literal">str.format()</tt> is not without its issues. Chief among them
is its verbosity. For example, the text <tt class="docutils literal">value</tt> is repeated here:</p>
<pre class="literal-block">
&gt;&gt;&gt; value = 4 * 20
&gt;&gt;&gt; 'The value is {value}.'.format(value=value)
'The value is 80.'
</pre>
<p>Even in its simplest form there is a bit of boilerplate, and the value
that's inserted into the placeholder is sometimes far removed from
where the placeholder is situated:</p>
<pre class="literal-block">
&gt;&gt;&gt; 'The value is {}.'.format(value)
'The value is 80.'
</pre>
<p>With an f-string, this becomes:</p>
<pre class="literal-block">
&gt;&gt;&gt; f'The value is {value}.'
'The value is 80.'
</pre>
<p>F-strings provide a concise, readable way to include the value of
Python expressions inside strings.</p>
<p>In this sense, <tt class="docutils literal">string.Template</tt> and %-formatting have similar
shortcomings to <tt class="docutils literal">str.format()</tt>, but also support fewer formatting
options. In particular, they do not support the <tt class="docutils literal">__format__</tt>
protocol, so that there is no way to control how a specific object is
converted to a string, nor can it be extended to additional types that
want to control how they are converted to strings (such as <tt class="docutils literal">Decimal</tt>
and <tt class="docutils literal">datetime</tt>). This example is not possible with
<tt class="docutils literal">string.Template</tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; value = 1234
&gt;&gt;&gt; f'input={value:#06x}'
'input=0x04d2'
</pre>
<p>And neither %-formatting nor <tt class="docutils literal">string.Template</tt> can control
formatting such as:</p>
<pre class="literal-block">
&gt;&gt;&gt; date = datetime.date(1991, 10, 12)
&gt;&gt;&gt; f'{date} was on a {date:%A}'
'1991-10-12 was on a Saturday'
</pre>
<div class="section" id="no-use-of-globals-or-locals">
<h2><a class="toc-backref" href="#id25">No use of globals() or locals()</a></h2>
<p>In the discussions on python-dev <a class="footnote-reference" href="#id15" id="id4">[4]</a>, a number of solutions where
presented that used locals() and globals() or their equivalents. All
of these have various problems. Among these are referencing variables
that are not otherwise used in a closure. Consider:</p>
<pre class="literal-block">
&gt;&gt;&gt; def outer(x):
...     def inner():
...         return 'x={x}'.format_map(locals())
...     return inner
...
&gt;&gt;&gt; outer(42)()
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;stdin&gt;&quot;, line 3, in inner
KeyError: 'x'
</pre>
<p>This returns an error because the compiler has not added a reference
to x inside the closure. You need to manually add a reference to x in
order for this to work:</p>
<pre class="literal-block">
&gt;&gt;&gt; def outer(x):
...     def inner():
...         x
...         return 'x={x}'.format_map(locals())
...     return inner
...
&gt;&gt;&gt; outer(42)()
'x=42'
</pre>
<p>In addition, using locals() or globals() introduces an information
leak. A called routine that has access to the callers locals() or
globals() has access to far more information than needed to do the
string interpolation.</p>
<p>Guido stated <a class="footnote-reference" href="#id16" id="id5">[5]</a> that any solution to better string interpolation
would not use locals() or globals() in its implementation.  (This does
not forbid users from passing locals() or globals() in, it just
doesn't require it, nor does it allow using these functions under the
hood.)</p>
</div>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id26">Specification</a></h1>
<p>In source code, f-strings are string literals that are prefixed by the
letter 'f' or 'F'. Everywhere this PEP uses 'f', 'F' may also be
used. 'f' may be combined with 'r' or 'R', in either order, to produce
raw f-string literals. 'f' may not be combined with 'b': this PEP does
not propose to add binary f-strings. 'f' may not be combined with 'u'.</p>
<p>When tokenizing source files, f-strings use the same rules as normal
strings, raw strings, binary strings, and triple quoted strings. That
is, the string must end with the same character that it started with:
if it starts with a single quote it must end with a single quote, etc.
This implies that any code that currently scans Python code looking
for strings should be trivially modifiable to recognize f-strings
(parsing within an f-string is another matter, of course).</p>
<p>Once tokenized, f-strings are parsed in to literal strings and
expressions.  Expressions appear within curly braces <tt class="docutils literal">'{'</tt> and
<tt class="docutils literal">'}'</tt>.  While scanning the string for expressions, any doubled
braces <tt class="docutils literal"><span class="pre">'{{'</span></tt> or <tt class="docutils literal"><span class="pre">'}}'</span></tt> inside literal portions of an f-string are
replaced by the corresponding single brace.  Doubled literal opening
braces do not signify the start of an expression.  A single closing
curly brace <tt class="docutils literal">'}'</tt> in the literal portion of a string is an error:
literal closing curly braces must be doubled <tt class="docutils literal"><span class="pre">'}}'</span></tt> in order to
represent a single closing brace.</p>
<p>The parts of the f-string outside of braces are literal
strings.  These literal portions are then decoded.  For non-raw
f-strings, this includes converting backslash escapes such as
<tt class="docutils literal">'\n'</tt>, <tt class="docutils literal"><span class="pre">'\&quot;'</span></tt>, <tt class="docutils literal"><span class="pre">&quot;\'&quot;</span></tt>, <tt class="docutils literal">'\xhh'</tt>, <tt class="docutils literal">'\uxxxx'</tt>,
<tt class="docutils literal">'\Uxxxxxxxx'</tt>, and named unicode characters <tt class="docutils literal">'\N{name}'</tt> into
their associated Unicode characters <a class="footnote-reference" href="#id17" id="id6">[6]</a>.</p>
<p>Backslashes may not appear anywhere within expressions.  Comments,
using the <tt class="docutils literal">'#'</tt> character, are not allowed inside an expression.</p>
<p>Following each expression, an optional type conversion may be
specified.  The allowed conversions are <tt class="docutils literal">'!s'</tt>, <tt class="docutils literal">'!r'</tt>, or
<tt class="docutils literal">'!a'</tt>. These are treated the same as in <tt class="docutils literal">str.format()</tt>: <tt class="docutils literal">'!s'</tt>
calls <tt class="docutils literal">str()</tt> on the expression, <tt class="docutils literal">'!r'</tt> calls <tt class="docutils literal">repr()</tt> on the
expression, and <tt class="docutils literal">'!a'</tt> calls <tt class="docutils literal">ascii()</tt> on the expression. These
conversions are applied before the call to <tt class="docutils literal">format()</tt>. The only
reason to use <tt class="docutils literal">'!s'</tt> is if you want to specify a format specifier
that applies to <tt class="docutils literal">str</tt>, not to the type of the expression.</p>
<p>F-strings use the same format specifier mini-language as <tt class="docutils literal">str.format</tt>.
Similar to <tt class="docutils literal">str.format()</tt>, optional format specifiers maybe be
included inside the f-string, separated from the expression (or the
type conversion, if specified) by a colon. If a format specifier is
not provided, an empty string is used.</p>
<p>So, an f-string looks like:</p>
<pre class="literal-block">
f ' &lt;text&gt; { &lt;expression&gt; &lt;optional !s, !r, or !a&gt; &lt;optional : format specifier&gt; } &lt;text&gt; ... '
</pre>
<p>The expression is then formatted using the <tt class="docutils literal">__format__</tt> protocol,
using the format specifier as an argument. The resulting value is
used when building the value of the f-string.</p>
<p>Note that <tt class="docutils literal">__format__()</tt> is not called directly on each value. The
actual code uses the equivalent of <tt class="docutils literal"><span class="pre">type(value).__format__(value,</span>
format_spec)</tt>, or <tt class="docutils literal">format(value, format_spec)</tt>. See the
documentation of the builtin <tt class="docutils literal">format()</tt> function for more details.</p>
<p>Expressions cannot contain <tt class="docutils literal">':'</tt> or <tt class="docutils literal">'!'</tt> outside of strings or
parentheses, brackets, or braces. The exception is that the <tt class="docutils literal"><span class="pre">'!='</span></tt>
operator is allowed as a special case.</p>
<div class="section" id="escape-sequences">
<h2><a class="toc-backref" href="#id27">Escape sequences</a></h2>
<p>Backslashes may not appear inside the expression portions of
f-strings, so you cannot use them, for example, to escape quotes
inside f-strings:</p>
<pre class="literal-block">
&gt;&gt;&gt; f'{\'quoted string\'}'
  File &quot;&lt;stdin&gt;&quot;, line 1
SyntaxError: f-string expression part cannot include a backslash
</pre>
<p>You can use a different type of quote inside the expression:</p>
<pre class="literal-block">
&gt;&gt;&gt; f'{&quot;quoted string&quot;}'
'quoted string'
</pre>
<p>Backslash escapes may appear inside the string portions of an
f-string.</p>
<p>Note that the correct way to have a literal brace appear in the
resulting string value is to double the brace:</p>
<pre class="literal-block">
&gt;&gt;&gt; f'{{ {4*10} }}'
'{ 40 }'
&gt;&gt;&gt; f'{{{4*10}}}'
'{40}'
</pre>
<p>Like all raw strings in Python, no escape processing is done for raw
f-strings:</p>
<pre class="literal-block">
&gt;&gt;&gt; fr'x={4*10}\n'
'x=40\\n'
</pre>
<p>Due to Python's string tokenizing rules, the f-string
<tt class="docutils literal">f'abc <span class="pre">{a['x']}</span> def'</tt> is invalid. The tokenizer parses this as 3
tokens: <tt class="docutils literal">f'abc {a['</tt>, <tt class="docutils literal">x</tt>, and <tt class="docutils literal">']} def'</tt>. Just like regular
strings, this cannot be fixed by using raw strings. There are a number
of correct ways to write this f-string: with a different quote
character:</p>
<pre class="literal-block">
f&quot;abc {a['x']} def&quot;
</pre>
<p>Or with triple quotes:</p>
<pre class="literal-block">
f'''abc {a['x']} def'''
</pre>
</div>
<div class="section" id="code-equivalence">
<h2><a class="toc-backref" href="#id28">Code equivalence</a></h2>
<p>The exact code used to implement f-strings is not specified. However,
it is guaranteed that any embedded value that is converted to a string
will use that value's <tt class="docutils literal">__format__</tt> method. This is the same
mechanism that <tt class="docutils literal">str.format()</tt> uses to convert values to strings.</p>
<p>For example, this code:</p>
<pre class="literal-block">
f'abc{expr1:spec1}{expr2!r:spec2}def{expr3}ghi'
</pre>
<p>Might be evaluated as:</p>
<pre class="literal-block">
'abc' + format(expr1, spec1) + format(repr(expr2), spec2) + 'def' + format(expr3) + 'ghi'
</pre>
</div>
<div class="section" id="expression-evaluation">
<h2><a class="toc-backref" href="#id29">Expression evaluation</a></h2>
<p>The expressions that are extracted from the string are evaluated in
the context where the f-string appeared. This means the expression has
full access to local and global variables. Any valid Python expression
can be used, including function and method calls.</p>
<p>Because the f-strings are evaluated where the string appears in the
source code, there is no additional expressiveness available with
f-strings. There are also no additional security concerns: you could
have also just written the same expression, not inside of an
f-string:</p>
<pre class="literal-block">
&gt;&gt;&gt; def foo():
...   return 20
...
&gt;&gt;&gt; f'result={foo()}'
'result=20'
</pre>
<p>Is equivalent to:</p>
<pre class="literal-block">
&gt;&gt;&gt; 'result=' + str(foo())
'result=20'
</pre>
<p>Expressions are parsed with the equivalent of <tt class="docutils literal"><span class="pre">ast.parse('('</span> +
expression + <span class="pre">')',</span> <span class="pre">'&lt;fstring&gt;',</span> 'eval')</tt> <a class="footnote-reference" href="#id18" id="id7">[7]</a>.</p>
<p>Note that since the expression is enclosed by implicit parentheses
before evaluation, expressions can contain newlines. For example:</p>
<pre class="literal-block">
&gt;&gt;&gt; x = 0
&gt;&gt;&gt; f'''{x
... +1}'''
'1'

&gt;&gt;&gt; d = {0: 'zero'}
&gt;&gt;&gt; f'''{d[0
... ]}'''
'zero'
</pre>
</div>
<div class="section" id="format-specifiers">
<h2><a class="toc-backref" href="#id30">Format specifiers</a></h2>
<p>Format specifiers may also contain evaluated expressions. This allows
code such as:</p>
<pre class="literal-block">
&gt;&gt;&gt; width = 10
&gt;&gt;&gt; precision = 4
&gt;&gt;&gt; value = decimal.Decimal('12.34567')
&gt;&gt;&gt; f'result: {value:{width}.{precision}}'
'result:      12.35'
</pre>
<p>Once expressions in a format specifier are evaluated (if necessary),
format specifiers are not interpreted by the f-string evaluator. Just
as in <tt class="docutils literal">str.format()</tt>, they are merely passed in to the
<tt class="docutils literal">__format__()</tt> method of the object being formatted.</p>
</div>
<div class="section" id="concatenating-strings">
<h2><a class="toc-backref" href="#id31">Concatenating strings</a></h2>
<p>Adjacent f-strings and regular strings are concatenated. Regular
strings are concatenated at compile time, and f-strings are
concatenated at run time. For example, the expression:</p>
<pre class="literal-block">
&gt;&gt;&gt; x = 10
&gt;&gt;&gt; y = 'hi'
&gt;&gt;&gt; 'a' 'b' f'{x}' '{c}' f'str&lt;{y:^4}&gt;' 'd' 'e'
</pre>
<p>yields the value:</p>
<pre class="literal-block">
'ab10{c}str&lt; hi &gt;de'
</pre>
<p>While the exact method of this run time concatenation is unspecified,
the above code might evaluate to:</p>
<pre class="literal-block">
'ab' + format(x) + '{c}' + 'str&lt;' + format(y, '^4') + '&gt;de'
</pre>
<p>Each f-string is entirely evaluated before being concatenated to
adjacent f-strings. That means that this:</p>
<pre class="literal-block">
&gt;&gt;&gt; f'{x' f'}'
</pre>
<p>Is a syntax error, because the first f-string does not contain a
closing brace.</p>
</div>
<div class="section" id="error-handling">
<h2><a class="toc-backref" href="#id32">Error handling</a></h2>
<p>Either compile time or run time errors can occur when processing
f-strings. Compile time errors are limited to those errors that can be
detected when scanning an f-string. These errors all raise
<tt class="docutils literal">SyntaxError</tt>.</p>
<p>Unmatched braces:</p>
<pre class="literal-block">
&gt;&gt;&gt; f'x={x'
  File &quot;&lt;stdin&gt;&quot;, line 1
SyntaxError: f-string: expecting '}'
</pre>
<p>Invalid expressions:</p>
<pre class="literal-block">
&gt;&gt;&gt; f'x={!x}'
  File &quot;&lt;stdin&gt;&quot;, line 1
SyntaxError: f-string: empty expression not allowed
</pre>
<p>Run time errors occur when evaluating the expressions inside an
f-string. Note that an f-string can be evaluated multiple times, and
work sometimes and raise an error at other times:</p>
<pre class="literal-block">
&gt;&gt;&gt; d = {0:10, 1:20}
&gt;&gt;&gt; for i in range(3):
...     print(f'{i}:{d[i]}')
...
0:10
1:20
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;
KeyError: 2
</pre>
<p>or:</p>
<pre class="literal-block">
&gt;&gt;&gt; for x in (32, 100, 'fifty'):
...   print(f'x = {x:+3}')
...
'x = +32'
'x = +100'
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;
ValueError: Sign not allowed in string format specifier
</pre>
</div>
<div class="section" id="leading-and-trailing-whitespace-in-expressions-is-ignored">
<h2><a class="toc-backref" href="#id33">Leading and trailing whitespace in expressions is ignored</a></h2>
<p>For ease of readability, leading and trailing whitespace in
expressions is ignored. This is a by-product of enclosing the
expression in parentheses before evaluation.</p>
</div>
<div class="section" id="evaluation-order-of-expressions">
<h2><a class="toc-backref" href="#id34">Evaluation order of expressions</a></h2>
<p>The expressions in an f-string are evaluated in left-to-right
order. This is detectable only if the expressions have side effects:</p>
<pre class="literal-block">
&gt;&gt;&gt; def fn(l, incr):
...    result = l[0]
...    l[0] += incr
...    return result
...
&gt;&gt;&gt; lst = [0]
&gt;&gt;&gt; f'{fn(lst,2)} {fn(lst,3)}'
'0 2'
&gt;&gt;&gt; f'{fn(lst,2)} {fn(lst,3)}'
'5 7'
&gt;&gt;&gt; lst
[10]
</pre>
</div>
</div>
<div class="section" id="discussion">
<h1><a class="toc-backref" href="#id35">Discussion</a></h1>
<div class="section" id="python-ideas-discussion">
<h2><a class="toc-backref" href="#id36">python-ideas discussion</a></h2>
<p>Most of the discussions on python-ideas <a class="footnote-reference" href="#id19" id="id8">[8]</a> focused on three issues:</p>
<ul class="simple">
<li>How to denote f-strings,</li>
<li>How to specify the location of expressions in f-strings, and</li>
<li>Whether to allow full Python expressions.</li>
</ul>
<div class="section" id="how-to-denote-f-strings">
<h3><a class="toc-backref" href="#id37">How to denote f-strings</a></h3>
<p>Because the compiler must be involved in evaluating the expressions
contained in the interpolated strings, there must be some way to
denote to the compiler which strings should be evaluated. This PEP
chose a leading <tt class="docutils literal">'f'</tt> character preceding the string literal. This
is similar to how <tt class="docutils literal">'b'</tt> and <tt class="docutils literal">'r'</tt> prefixes change the meaning of
the string itself, at compile time. Other prefixes were suggested,
such as <tt class="docutils literal">'i'</tt>. No option seemed better than the other, so <tt class="docutils literal">'f'</tt>
was chosen.</p>
<p>Another option was to support special functions, known to the
compiler, such as <tt class="docutils literal">Format()</tt>. This seems like too much magic for
Python: not only is there a chance for collision with existing
identifiers, the PEP author feels that it's better to signify the
magic with a string prefix character.</p>
</div>
<div class="section" id="how-to-specify-the-location-of-expressions-in-f-strings">
<h3><a class="toc-backref" href="#id38">How to specify the location of expressions in f-strings</a></h3>
<p>This PEP supports the same syntax as <tt class="docutils literal">str.format()</tt> for
distinguishing replacement text inside strings: expressions are
contained inside braces. There were other options suggested, such as
<tt class="docutils literal">string.Template</tt>'s <tt class="docutils literal">$identifier</tt> or <tt class="docutils literal">${expression}</tt>.</p>
<p>While <tt class="docutils literal">$identifier</tt> is no doubt more familiar to shell scripters and
users of some other languages, in Python <tt class="docutils literal">str.format()</tt> is heavily
used. A quick search of Python's standard library shows only a handful
of uses of <tt class="docutils literal">string.Template</tt>, but hundreds of uses of
<tt class="docutils literal">str.format()</tt>.</p>
<p>Another proposed alternative was to have the substituted text between
<tt class="docutils literal">\{</tt> and <tt class="docutils literal">}</tt> or between <tt class="docutils literal">\{</tt> and <tt class="docutils literal">\}</tt>. While this syntax would
probably be desirable if all string literals were to support
interpolation, this PEP only supports strings that are already marked
with the leading <tt class="docutils literal">'f'</tt>. As such, the PEP is using unadorned braces
to denoted substituted text, in order to leverage end user familiarity
with <tt class="docutils literal">str.format()</tt>.</p>
</div>
<div class="section" id="supporting-full-python-expressions">
<h3><a class="toc-backref" href="#id39">Supporting full Python expressions</a></h3>
<p>Many people on the python-ideas discussion wanted support for either
only single identifiers, or a limited subset of Python expressions
(such as the subset supported by <tt class="docutils literal">str.format()</tt>). This PEP supports
full Python expressions inside the braces. Without full expressions,
some desirable usage would be cumbersome. For example:</p>
<pre class="literal-block">
&gt;&gt;&gt; f'Column={col_idx+1}'
&gt;&gt;&gt; f'number of items: {len(items)}'
</pre>
<p>would become:</p>
<pre class="literal-block">
&gt;&gt;&gt; col_number = col_idx+1
&gt;&gt;&gt; f'Column={col_number}'
&gt;&gt;&gt; n_items = len(items)
&gt;&gt;&gt; f'number of items: {n_items}'
</pre>
<p>While it's true that very ugly expressions could be included in the
f-strings, this PEP takes the position that such uses should be
addressed in a linter or code review:</p>
<pre class="literal-block">
&gt;&gt;&gt; f'mapping is { {a:b for (a, b) in ((1, 2), (3, 4))} }'
'mapping is {1: 2, 3: 4}'
</pre>
</div>
</div>
<div class="section" id="similar-support-in-other-languages">
<h2><a class="toc-backref" href="#id40">Similar support in other languages</a></h2>
<p>Wikipedia has a good discussion of string interpolation in other
programming languages <a class="footnote-reference" href="#id20" id="id9">[9]</a>. This feature is implemented in many
languages, with a variety of syntaxes and restrictions.</p>
</div>
<div class="section" id="differences-between-f-string-and-str-format-expressions">
<h2><a class="toc-backref" href="#id41">Differences between f-string and str.format expressions</a></h2>
<p>There is one small difference between the limited expressions allowed
in <tt class="docutils literal">str.format()</tt> and the full expressions allowed inside
f-strings. The difference is in how index lookups are performed. In
<tt class="docutils literal">str.format()</tt>, index values that do not look like numbers are
converted to strings:</p>
<pre class="literal-block">
&gt;&gt;&gt; d = {'a': 10, 'b': 20}
&gt;&gt;&gt; 'a={d[a]}'.format(d=d)
'a=10'
</pre>
<p>Notice that the index value is converted to the string <tt class="docutils literal">'a'</tt> when it
is looked up in the dict.</p>
<p>However, in f-strings, you would need to use a literal for the value
of <tt class="docutils literal">'a'</tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; f'a={d[&quot;a&quot;]}'
'a=10'
</pre>
<p>This difference is required because otherwise you would not be able to
use variables as index values:</p>
<pre class="literal-block">
&gt;&gt;&gt; a = 'b'
&gt;&gt;&gt; f'a={d[a]}'
'a=20'
</pre>
<p>See <a class="footnote-reference" href="#id21" id="id10">[10]</a> for a further discussion. It was this observation that led to
full Python expressions being supported in f-strings.</p>
<p>Furthermore, the limited expressions that <tt class="docutils literal">str.format()</tt> understands
need not be valid Python expressions. For example:</p>
<pre class="literal-block">
&gt;&gt;&gt; '{i[&quot;;]}'.format(i={'&quot;;':4})
'4'
</pre>
<p>For this reason, the str.format() &quot;expression parser&quot; is not suitable
for use when implementing f-strings.</p>
</div>
<div class="section" id="triple-quoted-f-strings">
<h2><a class="toc-backref" href="#id42">Triple-quoted f-strings</a></h2>
<p>Triple quoted f-strings are allowed. These strings are parsed just as
normal triple-quoted strings are. After parsing and decoding, the
normal f-string logic is applied, and <tt class="docutils literal">__format__()</tt> is called on
each value.</p>
</div>
<div class="section" id="raw-f-strings">
<h2><a class="toc-backref" href="#id43">Raw f-strings</a></h2>
<p>Raw and f-strings may be combined. For example, they could be used to
build up regular expressions:</p>
<pre class="literal-block">
&gt;&gt;&gt; header = 'Subject'
&gt;&gt;&gt; fr'{header}:\s+'
'Subject:\\s+'
</pre>
<p>In addition, raw f-strings may be combined with triple-quoted strings.</p>
</div>
<div class="section" id="no-binary-f-strings">
<h2><a class="toc-backref" href="#id44">No binary f-strings</a></h2>
<p>For the same reason that we don't support <tt class="docutils literal">bytes.format()</tt>, you may
not combine <tt class="docutils literal">'f'</tt> with <tt class="docutils literal">'b'</tt> string literals. The primary problem
is that an object's <tt class="docutils literal">__format__()</tt> method may return Unicode data that
is not compatible with a bytes string.</p>
<p>Binary f-strings would first require a solution for
<tt class="docutils literal">bytes.format()</tt>. This idea has been proposed in the past, most
recently in <a class="reference external" href="/dev/peps/pep-0461">PEP 461</a> <a class="footnote-reference" href="#id22" id="id11">[11]</a>. The discussions of such a feature usually
suggest either</p>
<ul class="simple">
<li>adding a method such as <tt class="docutils literal">__bformat__()</tt> so an object can control
how it is converted to bytes, or</li>
<li>having <tt class="docutils literal">bytes.format()</tt> not be as general purpose or extensible
as <tt class="docutils literal">str.format()</tt>.</li>
</ul>
<p>Both of these remain as options in the future, if such functionality
is desired.</p>
</div>
<div class="section" id="s-r-and-a-are-redundant">
<h2><a class="toc-backref" href="#id45"><tt class="docutils literal">!s</tt>, <tt class="docutils literal">!r</tt>, and <tt class="docutils literal">!a</tt> are redundant</a></h2>
<p>The <tt class="docutils literal">!s</tt>, <tt class="docutils literal">!r</tt>, and <tt class="docutils literal">!a</tt> conversions are not strictly
required. Because arbitrary expressions are allowed inside the
f-strings, this code:</p>
<pre class="literal-block">
&gt;&gt;&gt; a = 'some string'
&gt;&gt;&gt; f'{a!r}'
&quot;'some string'&quot;
</pre>
<p>Is identical to:</p>
<pre class="literal-block">
&gt;&gt;&gt; f'{repr(a)}'
&quot;'some string'&quot;
</pre>
<p>Similarly, <tt class="docutils literal">!s</tt> can be replaced by calls to <tt class="docutils literal">str()</tt> and <tt class="docutils literal">!a</tt> by
calls to <tt class="docutils literal">ascii()</tt>.</p>
<p>However, <tt class="docutils literal">!s</tt>, <tt class="docutils literal">!r</tt>, and <tt class="docutils literal">!a</tt> are supported by this PEP in order
to minimize the differences with <tt class="docutils literal">str.format()</tt>. <tt class="docutils literal">!s</tt>, <tt class="docutils literal">!r</tt>, and
<tt class="docutils literal">!a</tt> are required in <tt class="docutils literal">str.format()</tt> because it does not allow the
execution of arbitrary expressions.</p>
</div>
<div class="section" id="lambdas-inside-expressions">
<h2><a class="toc-backref" href="#id46">Lambdas inside expressions</a></h2>
<p>Because lambdas use the <tt class="docutils literal">':'</tt> character, they cannot appear outside
of parentheses in an expression. The colon is interpreted as the start
of the format specifier, which means the start of the lambda
expression is seen and is syntactically invalid. As there's no
practical use for a plain lambda in an f-string expression, this is
not seen as much of a limitation.</p>
<p>If you feel you must use lambdas, they may be used inside of parentheses:</p>
<pre class="literal-block">
&gt;&gt;&gt; f'{(lambda x: x*2)(3)}'
'6'
</pre>
</div>
<div class="section" id="can-t-combine-with-u">
<h2><a class="toc-backref" href="#id47">Can't combine with 'u'</a></h2>
<p>The 'u' prefix was added to Python 3.3 in <a class="reference external" href="/dev/peps/pep-0414">PEP 414</a> as a means to ease
source compatibility with Python 2.7. Because Python 2.7 will never
support f-strings, there is nothing to be gained by being able to
combine the 'f' prefix with 'u'.</p>
</div>
</div>
<div class="section" id="examples-from-python-s-source-code">
<h1><a class="toc-backref" href="#id48">Examples from Python's source code</a></h1>
<p>Here are some examples from Python source code that currently use
<tt class="docutils literal">str.format()</tt>, and how they would look with f-strings. This PEP
does not recommend wholesale converting to f-strings, these are just
examples of real-world usages of <tt class="docutils literal">str.format()</tt> and how they'd look
if written from scratch using f-strings.</p>
<p><tt class="docutils literal">Lib/asyncio/locks.py</tt>:</p>
<pre class="literal-block">
extra = '{},waiters:{}'.format(extra, len(self._waiters))
extra = f'{extra},waiters:{len(self._waiters)}'
</pre>
<p><tt class="docutils literal">Lib/configparser.py</tt>:</p>
<pre class="literal-block">
message.append(&quot; [line {0:2d}]&quot;.format(lineno))
message.append(f&quot; [line {lineno:2d}]&quot;)
</pre>
<p><tt class="docutils literal">Tools/clinic/clinic.py</tt>:</p>
<pre class="literal-block">
methoddef_name = &quot;{}_METHODDEF&quot;.format(c_basename.upper())
methoddef_name = f&quot;{c_basename.upper()}_METHODDEF&quot;
</pre>
<p><tt class="docutils literal"><span class="pre">python-config.py</span></tt>:</p>
<pre class="literal-block">
print(&quot;Usage: {0} [{1}]&quot;.format(sys.argv[0], '|'.join('--'+opt for opt in valid_opts)), file=sys.stderr)
print(f&quot;Usage: {sys.argv[0]} [{'|'.join('--'+opt for opt in valid_opts)}]&quot;, file=sys.stderr)
</pre>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id49">References</a></h1>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>%-formatting
(<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting">https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>str.format
(<a class="reference external" href="https://docs.python.org/3/library/string.html#formatstrings">https://docs.python.org/3/library/string.html#formatstrings</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>string.Template documentation
(<a class="reference external" href="https://docs.python.org/3/library/string.html#template-strings">https://docs.python.org/3/library/string.html#template-strings</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>Formatting using locals() and globals()
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2015-July/034671.html">https://mail.python.org/pipermail/python-ideas/2015-July/034671.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>Avoid locals() and globals()
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2015-July/034701.html">https://mail.python.org/pipermail/python-ideas/2015-July/034701.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td>String literal description
(<a class="reference external" href="https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals">https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[7]</a></td><td>ast.parse() documentation
(<a class="reference external" href="https://docs.python.org/3/library/ast.html#ast.parse">https://docs.python.org/3/library/ast.html#ast.parse</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[8]</a></td><td>Start of python-ideas discussion
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2015-July/034657.html">https://mail.python.org/pipermail/python-ideas/2015-July/034657.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[9]</a></td><td>Wikipedia article on string interpolation
(<a class="reference external" href="https://en.wikipedia.org/wiki/String_interpolation">https://en.wikipedia.org/wiki/String_interpolation</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[10]</a></td><td>Differences in str.format() and f-string expressions
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2015-July/034726.html">https://mail.python.org/pipermail/python-ideas/2015-July/034726.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[11]</a></td><td><a class="reference external" href="/dev/peps/pep-0461">PEP 461</a> rejects bytes.format()
(<a class="reference external" href="https://www.python.org/dev/peps/pep-0461/#proposed-variations">https://www.python.org/dev/peps/pep-0461/#proposed-variations</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id50">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

