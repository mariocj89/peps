<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">535</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Rich comparison chaining</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0535.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Nick Coghlan &lt;ncoghlan&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Deferred</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Requires:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0532">532</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">12-Nov-2016</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.8</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#pep-deferral" id="id2">PEP Deferral</a></li>
<li><a class="reference internal" href="#abstract" id="id3">Abstract</a></li>
<li><a class="reference internal" href="#relationship-with-other-peps" id="id4">Relationship with other PEPs</a></li>
<li><a class="reference internal" href="#specification" id="id5">Specification</a></li>
<li><a class="reference internal" href="#rationale" id="id6">Rationale</a></li>
<li><a class="reference internal" href="#implementation" id="id7">Implementation</a></li>
<li><a class="reference internal" href="#references" id="id8">References</a></li>
<li><a class="reference internal" href="#copyright" id="id9">Copyright</a></li>
</ul>
</div>
<div class="section" id="pep-deferral">
<h1><a class="toc-backref" href="#id2">PEP Deferral</a></h1>
<p>Further consideration of this PEP has been deferred until Python 3.8 at the
earliest.</p>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id3">Abstract</a></h1>
<p>Inspired by <a class="reference external" href="/dev/peps/pep-0335">PEP 335</a>, and building on the circuit breaking protocol described
in <a class="reference external" href="/dev/peps/pep-0532">PEP 532</a>, this PEP proposes a change to the definition of chained comparisons,
where the comparison chaining will be updated to use the left-associative
circuit breaking operator (<tt class="docutils literal">else</tt>) rather than the logical disjunction
operator  (<tt class="docutils literal">and</tt>) if the left hand comparison returns a circuit breaker as
its result.</p>
<p>While there are some practical complexities arising from the current handling
of single-valued arrays in NumPy, this change should be sufficient to allow
elementwise chained comparison operations for matrices, where the result
is a matrix of boolean values, rather than raising <tt class="docutils literal">ValueError</tt>
or tautologically returning <tt class="docutils literal">True</tt> (indicating a non-empty matrix).</p>
</div>
<div class="section" id="relationship-with-other-peps">
<h1><a class="toc-backref" href="#id4">Relationship with other PEPs</a></h1>
<p>This PEP has been extracted from earlier iterations of <a class="reference external" href="/dev/peps/pep-0532">PEP 532</a>, as a
follow-on use case for the circuit breaking protocol, rather than an essential
part of its introduction.</p>
<p>The specific proposal in this PEP to handle the element-wise comparison use
case by changing the semantic definition of comparison chaining is drawn
directly from Guido's rejection of <a class="reference external" href="/dev/peps/pep-0335">PEP 335</a>.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id5">Specification</a></h1>
<p>A chained comparison like <tt class="docutils literal">0 &lt; x &lt; 10</tt> written as:</p>
<pre class="literal-block">
LEFT_BOUND LEFT_OP EXPR RIGHT_OP RIGHT_BOUND
</pre>
<p>is currently roughly semantically equivalent to:</p>
<pre class="literal-block">
_expr = EXPR
_lhs_result = LEFT_BOUND LEFT_OP _expr
_expr_result = _lhs_result and (_expr RIGHT_OP RIGHT_BOUND)
</pre>
<p>Using the circuit breaking concepts introduced in <a class="reference external" href="/dev/peps/pep-0532">PEP 532</a>, this PEP proposes
that comparison chaining be changed to explicitly check if the left comparison
returns a circuit breaker, and if so, use <tt class="docutils literal">else</tt> rather than <tt class="docutils literal">and</tt> to
implement the comparison chaining:</p>
<pre class="literal-block">
_expr = EXPR
_lhs_result = LEFT_BOUND LEFT_OP _expr
if hasattr(type(_lhs_result), &quot;__else__&quot;):
    _expr_result = _lhs_result else (_expr RIGHT_OP RIGHT_BOUND)
else:
    _expr_result = _lhs_result and (_expr RIGHT_OP RIGHT_BOUND)
</pre>
<p>This allows types like NumPy arrays to control the behaviour of chained
comparisons by returning suitably defined circuit breakers from comparison
operations.</p>
<p>The expansion of this logic to an arbitrary number of chained comparison
operations would be the same as the existing expansion for <tt class="docutils literal">and</tt>.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id6">Rationale</a></h1>
<p>In ultimately rejecting <a class="reference external" href="/dev/peps/pep-0335">PEP 335</a>, Guido van Rossum noted [<a class="reference internal" href="#id1">1</a>]:</p>
<blockquote>
The NumPy folks brought up a somewhat separate issue: for them,
the most common use case is chained comparisons (e.g. A &lt; B &lt; C).</blockquote>
<p>To understand this observation, we first need to look at how comparisons work
with NumPy arrays:</p>
<pre class="literal-block">
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; increasing = np.arange(5)
&gt;&gt;&gt; increasing
array([0, 1, 2, 3, 4])
&gt;&gt;&gt; decreasing = np.arange(4, -1, -1)
&gt;&gt;&gt; decreasing
array([4, 3, 2, 1, 0])
&gt;&gt;&gt; increasing &lt; decreasing
array([ True,  True, False, False, False], dtype=bool)
</pre>
<p>Here we see that NumPy array comparisons are element-wise by default, comparing
each element in the left hand array to the corresponding element in the right
hand array, and producing a matrix of boolean results.</p>
<p>If either side of the comparison is a scalar value, then it is broadcast across
the array and compared to each individual element:</p>
<pre class="literal-block">
&gt;&gt;&gt; 0 &lt; increasing
array([False,  True,  True,  True,  True], dtype=bool)
&gt;&gt;&gt; increasing &lt; 4
array([ True,  True,  True,  True, False], dtype=bool)
</pre>
<p>However, this broadcasting idiom breaks down if we attempt to use chained
comparisons:</p>
<pre class="literal-block">
&gt;&gt;&gt; 0 &lt; increasing &lt; 4
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()
</pre>
<p>The problem is that internally, Python implicitly expands this chained
comparison into the form:</p>
<pre class="literal-block">
&gt;&gt;&gt; 0 &lt; increasing and increasing &lt; 4
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()
</pre>
<p>And NumPy only permits implicit coercion to a boolean value for single-element
arrays where <tt class="docutils literal">a.any()</tt> and <tt class="docutils literal">a.all()</tt> can be assured of having the same
result:</p>
<pre class="literal-block">
&gt;&gt;&gt; np.array([False]) and np.array([False])
array([False], dtype=bool)
&gt;&gt;&gt; np.array([False]) and np.array([True])
array([False], dtype=bool)
&gt;&gt;&gt; np.array([True]) and np.array([False])
array([False], dtype=bool)
&gt;&gt;&gt; np.array([True]) and np.array([True])
array([ True], dtype=bool)
</pre>
<p>The proposal in this PEP would allow this situation to be changed by updating
the definition of element-wise comparison operations in NumPy to return a
dedicated subclass that implements the new circuit breaking protocol and also
changes the result array's interpretation in a boolean context to always
return <tt class="docutils literal">False</tt> and hence never trigger the short-circuiting behaviour:</p>
<pre class="literal-block">
class ComparisonResultArray(np.ndarray):
    def __bool__(self):
        # Element-wise comparison chaining never short-circuits
        return False
    def _raise_NotImplementedError(self):
        msg = (&quot;Comparison array truth values are ambiguous outside &quot;
               &quot;chained comparisons. Use a.any() or a.all()&quot;)
        raise NotImplementedError(msg)
    def __not__(self):
        self._raise_NotImplementedError()
    def __then__(self, result):
        self._raise_NotImplementedError()
    def __else__(self, result):
        return np.logical_and(self, other.view(ComparisonResultArray))
</pre>
<p>With this change, the chained comparison example above would be able to return:</p>
<pre class="literal-block">
&gt;&gt;&gt; 0 &lt; increasing &lt; 4
ComparisonResultArray([ False,  True,  True,  True, False], dtype=bool)
</pre>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id7">Implementation</a></h1>
<p>Actual implementation has been deferred pending in-principle interest in the
idea of making the changes proposed in <a class="reference external" href="/dev/peps/pep-0532">PEP 532</a>.</p>
<p>...TBD...</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id8">References</a></h1>
<table class="docutils footnote" frame="void" id="id1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><a class="reference external" href="/dev/peps/pep-0335">PEP 335</a> rejection notification
(<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2012-March/117510.html">https://mail.python.org/pipermail/python-dev/2012-March/117510.html</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id9">Copyright</a></h1>
<p>This document has been placed in the public domain under the terms of the
CC0 1.0 license: <a class="reference external" href="https://creativecommons.org/publicdomain/zero/1.0/">https://creativecommons.org/publicdomain/zero/1.0/</a></p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

