<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">349</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Allow str() to return unicode strings</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0349.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Neil Schemenauer &lt;nas&#32;&#97;t&#32;arctrix.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Deferred</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">02-Aug-2005</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.5</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">06-Aug-2005</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id3">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id4">Rationale</a></li>
<li><a class="reference internal" href="#specification" id="id5">Specification</a></li>
<li><a class="reference internal" href="#backwards-compatibility" id="id6">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#alternative-solutions" id="id7">Alternative Solutions</a></li>
<li><a class="reference internal" href="#references" id="id8">References</a></li>
<li><a class="reference internal" href="#copyright" id="id9">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id3">Abstract</a></h1>
<p>This PEP proposes to change the <tt class="docutils literal">str()</tt> built-in function so that it
can return unicode strings.  This change would make it easier to
write code that works with either string type and would also make
some existing code handle unicode strings.  The C function
<tt class="docutils literal">PyObject_Str()</tt> would remain unchanged and the function
<tt class="docutils literal">PyString_New()</tt> would be added instead.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id4">Rationale</a></h1>
<p>Python has had a Unicode string type for some time now but use of
it is not yet widespread.  There is a large amount of Python code
that assumes that string data is represented as str instances.
The long term plan for Python is to phase out the str type and use
unicode for all string data.  Clearly, a smooth migration path
must be provided.</p>
<p>We need to upgrade existing libraries, written for str instances,
to be made capable of operating in an all-unicode string world.
We can't change to an all-unicode world until all essential
libraries are made capable for it.  Upgrading the libraries in one
shot does not seem feasible.  A more realistic strategy is to
individually make the libraries capable of operating on unicode
strings while preserving their current all-str environment
behaviour.</p>
<p>First, we need to be able to write code that can accept unicode
instances without attempting to coerce them to str instances.  Let
us label such code as Unicode-safe.  Unicode-safe libraries can be
used in an all-unicode world.</p>
<p>Second, we need to be able to write code that, when provided only
str instances, will not create unicode results.  Let us label such
code as str-stable.  Libraries that are str-stable can be used by
libraries and applications that are not yet Unicode-safe.</p>
<p>Sometimes it is simple to write code that is both str-stable and
Unicode-safe.  For example, the following function just works:</p>
<pre class="literal-block">
def appendx(s):
    return s + 'x'
</pre>
<p>That's not too surprising since the unicode type is designed to
make the task easier.  The principle is that when str and unicode
instances meet, the result is a unicode instance.  One notable
difficulty arises when code requires a string representation of an
object; an operation traditionally accomplished by using the <tt class="docutils literal">str()</tt>
built-in function.</p>
<p>Using the current <tt class="docutils literal">str()</tt> function makes the code not Unicode-safe.
Replacing a <tt class="docutils literal">str()</tt> call with a <tt class="docutils literal">unicode()</tt> call makes the code not
str-stable.  Changing <tt class="docutils literal">str()</tt> so that it could return unicode
instances would solve this problem.  As a further benefit, some code
that is currently not Unicode-safe because it uses <tt class="docutils literal">str()</tt> would
become Unicode-safe.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id5">Specification</a></h1>
<p>A Python implementation of the <tt class="docutils literal">str()</tt> built-in follows:</p>
<pre class="literal-block">
def str(s):
    &quot;&quot;&quot;Return a nice string representation of the object.  The
    return value is a str or unicode instance.
    &quot;&quot;&quot;
    if type(s) is str or type(s) is unicode:
        return s
    r = s.__str__()
    if not isinstance(r, (str, unicode)):
        raise TypeError('__str__ returned non-string')
    return r
</pre>
<p>The following function would be added to the C API and would be the
equivalent to the <tt class="docutils literal">str()</tt> built-in (ideally it be called <tt class="docutils literal">PyObject_Str</tt>,
but changing that function could cause a massive number of
compatibility problems):</p>
<pre class="literal-block">
PyObject *PyString_New(PyObject *);
</pre>
<p>A reference implementation is available on Sourceforge <a class="footnote-reference" href="#id2" id="id1">[1]</a> as a
patch.</p>
</div>
<div class="section" id="backwards-compatibility">
<h1><a class="toc-backref" href="#id6">Backwards Compatibility</a></h1>
<p>Some code may require that <tt class="docutils literal">str()</tt> returns a str instance.  In the
standard library, only one such case has been found so far.  The
function <tt class="docutils literal">email.header_decode()</tt> requires a str instance and the
<tt class="docutils literal">email.Header.decode_header()</tt> function tries to ensure this by
calling <tt class="docutils literal">str()</tt> on its argument.  The code was fixed by changing
the line &quot;header = str(header)&quot; to:</p>
<pre class="literal-block">
if isinstance(header, unicode):
    header = header.encode('ascii')
</pre>
<p>Whether this is truly a bug is questionable since <tt class="docutils literal">decode_header()</tt>
really operates on byte strings, not character strings.  Code that
passes it a unicode instance could itself be considered buggy.</p>
</div>
<div class="section" id="alternative-solutions">
<h1><a class="toc-backref" href="#id7">Alternative Solutions</a></h1>
<p>A new built-in function could be added instead of changing <tt class="docutils literal">str()</tt>.
Doing so would introduce virtually no backwards compatibility
problems.  However, since the compatibility problems are expected to
rare, changing <tt class="docutils literal">str()</tt> seems preferable to adding a new built-in.</p>
<p>The basestring type could be changed to have the proposed behaviour,
rather than changing <tt class="docutils literal">str()</tt>.  However, that would be confusing
behaviour for an abstract base type.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id8">References</a></h1>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://www.python.org/sf/1266570">http://www.python.org/sf/1266570</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id9">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>

