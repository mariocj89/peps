<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">305</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">CSV File API</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0305.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Kevin Altis &lt;altis&#32;&#97;t&#32;semi-retired.com&gt;,
Dave Cole &lt;djc&#32;&#97;t&#32;object-craft.com.au&gt;,
Andrew McNamara &lt;andrewm&#32;&#97;t&#32;object-craft.com.au&gt;,
Skip Montanaro &lt;skip&#32;&#97;t&#32;pobox.com&gt;,
Cliff Wells &lt;LogiplexSoftware&#32;&#97;t&#32;earthlink.net&gt;</td>
</tr>
<tr class="field"><th class="field-name">Discussions-To:</th><td class="field-body">&lt;<a class="reference external" href="mailto:csv&#64;python.org?subject=PEP%20305">csv&#32;&#97;t&#32;python.org</a>&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">26-Jan-2003</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">31-Jan-2003, 13-Feb-2003</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id11">Abstract</a></li>
<li><a class="reference internal" href="#to-do-notes-for-the-interested-and-ambitious" id="id12">To Do (Notes for the Interested and Ambitious)</a></li>
<li><a class="reference internal" href="#application-domain" id="id13">Application Domain</a></li>
<li><a class="reference internal" href="#rationale" id="id14">Rationale</a></li>
<li><a class="reference internal" href="#existing-modules" id="id15">Existing Modules</a></li>
<li><a class="reference internal" href="#module-interface" id="id16">Module Interface</a><ul>
<li><a class="reference internal" href="#reading-csv-files" id="id17">Reading CSV Files</a></li>
<li><a class="reference internal" href="#writing-csv-files" id="id18">Writing CSV Files</a></li>
<li><a class="reference internal" href="#managing-different-dialects" id="id19">Managing Different Dialects</a></li>
<li><a class="reference internal" href="#formatting-parameters" id="id20">Formatting Parameters</a></li>
<li><a class="reference internal" href="#reader-objects" id="id21">Reader Objects</a></li>
<li><a class="reference internal" href="#writer-objects" id="id22">Writer Objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation" id="id23">Implementation</a></li>
<li><a class="reference internal" href="#testing" id="id24">Testing</a></li>
<li><a class="reference internal" href="#issues" id="id25">Issues</a></li>
<li><a class="reference internal" href="#references" id="id26">References</a></li>
<li><a class="reference internal" href="#copyright" id="id27">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id11">Abstract</a></h1>
<p>The Comma Separated Values (CSV) file format is the most common import
and export format for spreadsheets and databases.  Although many CSV
files are simple to parse, the format is not formally defined by a
stable specification and is subtle enough that parsing lines of a CSV
file with something like <tt class="docutils literal"><span class="pre">line.split(&quot;,&quot;)</span></tt> is eventually bound to
fail.  This PEP defines an API for reading and writing CSV files.  It
is accompanied by a corresponding module which implements the API.</p>
</div>
<div class="section" id="to-do-notes-for-the-interested-and-ambitious">
<h1><a class="toc-backref" href="#id12">To Do (Notes for the Interested and Ambitious)</a></h1>
<ul class="simple">
<li>Better motivation for the choice of passing a file object to the
constructors.  See
<a class="reference external" href="https://mail.python.org/pipermail/csv/2003-January/000179.html">https://mail.python.org/pipermail/csv/2003-January/000179.html</a></li>
<li>Unicode.  ugh.</li>
</ul>
</div>
<div class="section" id="application-domain">
<h1><a class="toc-backref" href="#id13">Application Domain</a></h1>
<p>This PEP is about doing one thing well: parsing tabular data which may
use a variety of field separators, quoting characters, quote escape
mechanisms and line endings.  The authors intend the proposed module
to solve this one parsing problem efficiently.  The authors do not
intend to address any of these related topics:</p>
<ul class="simple">
<li>data interpretation (is a field containing the string &quot;10&quot; supposed
to be a string, a float or an int? is it a number in base 10, base
16 or base 2? is a number in quotes a number or a string?)</li>
<li>locale-specific data representation (should the number 1.23 be
written as &quot;1.23&quot; or &quot;1,23&quot; or &quot;1 23&quot;?) -- this may eventually be
addressed.</li>
<li>fixed width tabular data - can already be parsed reliably.</li>
</ul>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id14">Rationale</a></h1>
<p>Often, CSV files are formatted simply enough that you can get by
reading them line-by-line and splitting on the commas which delimit
the fields.  This is especially true if all the data being read is
numeric.  This approach may work for a while, then come back to bite
you in the butt when somebody puts something unexpected in the data
like a comma.  As you dig into the problem you may eventually come to
the conclusion that you can solve the problem using regular
expressions.  This will work for a while, then break mysteriously one
day.  The problem grows, so you dig deeper and eventually realize that
you need a purpose-built parser for the format.</p>
<p>CSV formats are not well-defined and different implementations have a
number of subtle corner cases.  It has been suggested that the &quot;V&quot; in
the acronym stands for &quot;Vague&quot; instead of &quot;Values&quot;.  Different
delimiters and quoting characters are just the start.  Some programs
generate whitespace after each delimiter which is not part of the
following field.  Others quote embedded quoting characters by doubling
them, others by prefixing them with an escape character.  The list of
weird ways to do things can seem endless.</p>
<p>All this variability means it is difficult for programmers to reliably
parse CSV files from many sources or generate CSV files designed to be
fed to specific external programs without a thorough understanding of
those sources and programs.  This PEP and the software which accompany
it attempt to make the process less fragile.</p>
</div>
<div class="section" id="existing-modules">
<h1><a class="toc-backref" href="#id15">Existing Modules</a></h1>
<p>This problem has been tackled before.  At least three modules
currently available in the Python community enable programmers to read
and write CSV files:</p>
<ul class="simple">
<li>Object Craft's CSV module <a class="footnote-reference" href="#id8" id="id1">[2]</a></li>
<li>Cliff Wells' Python-DSV module <a class="footnote-reference" href="#id9" id="id2">[3]</a></li>
<li>Laurence Tratt's ASV module <a class="footnote-reference" href="#id10" id="id3">[4]</a></li>
</ul>
<p>Each has a different API, making it somewhat difficult for programmers
to switch between them.  More of a problem may be that they interpret
some of the CSV corner cases differently, so even after surmounting
the differences between the different module APIs, the programmer has
to also deal with semantic differences between the packages.</p>
</div>
<div class="section" id="module-interface">
<h1><a class="toc-backref" href="#id16">Module Interface</a></h1>
<p>This PEP supports three basic APIs, one to read and parse CSV files,
one to write them, and one to identify different CSV dialects to the
readers and writers.</p>
<div class="section" id="reading-csv-files">
<h2><a class="toc-backref" href="#id17">Reading CSV Files</a></h2>
<p>CSV readers are created with the reader factory function:</p>
<pre class="literal-block">
obj = reader(iterable [, dialect='excel']
             [optional keyword args])
</pre>
<p>A reader object is an iterator which takes an iterable object
returning lines as the sole required parameter.  If it supports a
binary mode (file objects do), the iterable argument to the reader
function must have been opened in binary mode.  This gives the reader
object full control over the interpretation of the file's contents.
The optional dialect parameter is discussed below.  The reader
function also accepts several optional keyword arguments which define
specific format settings for the parser (see the section &quot;Formatting
Parameters&quot;).  Readers are typically used as follows:</p>
<pre class="literal-block">
csvreader = csv.reader(file(&quot;some.csv&quot;))
for row in csvreader:
    process(row)
</pre>
<p>Each row returned by a reader object is a list of strings or Unicode
objects.</p>
<p>When both a dialect parameter and individual formatting parameters are
passed to the constructor, first the dialect is queried for formatting
parameters, then individual formatting parameters are examined.</p>
</div>
<div class="section" id="writing-csv-files">
<h2><a class="toc-backref" href="#id18">Writing CSV Files</a></h2>
<p>Creating writers is similar:</p>
<pre class="literal-block">
obj = writer(fileobj [, dialect='excel'],
             [optional keyword args])
</pre>
<p>A writer object is a wrapper around a file-like object opened for
writing in binary mode (if such a distinction is made).  It accepts
the same optional keyword parameters as the reader constructor.</p>
<p>Writers are typically used as follows:</p>
<pre class="literal-block">
csvwriter = csv.writer(file(&quot;some.csv&quot;, &quot;w&quot;))
for row in someiterable:
    csvwriter.writerow(row)
</pre>
<p>To generate a set of field names as the first row of the CSV file, the
programmer must explicitly write it, e.g.:</p>
<pre class="literal-block">
csvwriter = csv.writer(file(&quot;some.csv&quot;, &quot;w&quot;), fieldnames=names)
csvwriter.write(names)
for row in someiterable:
    csvwriter.write(row)
</pre>
<p>or arrange for it to be the first row in the iterable being written.</p>
</div>
<div class="section" id="managing-different-dialects">
<h2><a class="toc-backref" href="#id19">Managing Different Dialects</a></h2>
<p>Because CSV is a somewhat ill-defined format, there are plenty of ways
one CSV file can differ from another, yet contain exactly the same
data.  Many tools which can import or export tabular data allow the
user to indicate the field delimiter, quote character, line
terminator, and other characteristics of the file.  These can be
fairly easily determined, but are still mildly annoying to figure out,
and make for fairly long function calls when specified individually.</p>
<p>To try and minimize the difficulty of figuring out and specifying a
bunch of formatting parameters, reader and writer objects support a
dialect argument which is just a convenient handle on a group of these
lower level parameters.  When a dialect is given as a string it
identifies one of the dialects known to the module via its
registration functions, otherwise it must be an instance of the
Dialect class as described below.</p>
<p>Dialects will generally be named after applications or organizations
which define specific sets of format constraints.  Two dialects are
defined in the module as of this writing, &quot;excel&quot;, which describes the
default format constraints for CSV file export by Excel 97 and Excel
2000, and &quot;excel-tab&quot;, which is the same as &quot;excel&quot; but specifies an
ASCII TAB character as the field delimiter.</p>
<p>Dialects are implemented as attribute only classes to enable users to
construct variant dialects by subclassing.  The &quot;excel&quot; dialect is a
subclass of Dialect and is defined as follows:</p>
<pre class="literal-block">
class Dialect:
    # placeholders
    delimiter = None
    quotechar = None
    escapechar = None
    doublequote = None
    skipinitialspace = None
    lineterminator = None
    quoting = None

class excel(Dialect):
    delimiter = ','
    quotechar = '&quot;'
    doublequote = True
    skipinitialspace = False
    lineterminator = '\r\n'
    quoting = QUOTE_MINIMAL
</pre>
<p>The &quot;excel-tab&quot; dialect is defined as:</p>
<pre class="literal-block">
class exceltsv(excel):
    delimiter = '\t'
</pre>
<p>(For a description of the individual formatting parameters see the
section &quot;Formatting Parameters&quot;.)</p>
<p>To enable string references to specific dialects, the module defines
several functions:</p>
<pre class="literal-block">
dialect = get_dialect(name)
names = list_dialects()
register_dialect(name, dialect)
unregister_dialect(name)
</pre>
<p><tt class="docutils literal">get_dialect()</tt> returns the dialect instance associated with the
given name.  <tt class="docutils literal">list_dialects()</tt> returns a list of all registered
dialect names.  <tt class="docutils literal">register_dialects()</tt> associates a string name with
a dialect class.  <tt class="docutils literal">unregister_dialect()</tt> deletes a name/dialect
association.</p>
</div>
<div class="section" id="formatting-parameters">
<h2><a class="toc-backref" href="#id20">Formatting Parameters</a></h2>
<p>In addition to the dialect argument, both the reader and writer
constructors take several specific formatting parameters, specified as
keyword parameters.  The formatting parameters understood are:</p>
<ul class="simple">
<li><tt class="docutils literal">quotechar</tt> specifies a one-character string to use as the quoting
character.  It defaults to '&quot;'.  Setting this to None has the same
effect as setting quoting to csv.QUOTE_NONE.</li>
<li><tt class="docutils literal">delimiter</tt> specifies a one-character string to use as the field
separator.  It defaults to ','.</li>
<li><tt class="docutils literal">escapechar</tt> specifies a one-character string used to escape the
delimiter when quotechar is set to None.</li>
<li><tt class="docutils literal">skipinitialspace</tt> specifies how to interpret whitespace which
immediately follows a delimiter.  It defaults to False, which means
that whitespace immediately following a delimiter is part of the
following field.</li>
<li><tt class="docutils literal">lineterminator</tt> specifies the character sequence which should
terminate rows.</li>
<li><tt class="docutils literal">quoting</tt> controls when quotes should be generated by the writer.
It can take on any of the following module constants:<ul>
<li>csv.QUOTE_MINIMAL means only when required, for example, when a
field contains either the quotechar or the delimiter</li>
<li>csv.QUOTE_ALL means that quotes are always placed around fields.</li>
<li>csv.QUOTE_NONNUMERIC means that quotes are always placed around
nonnumeric fields.</li>
<li>csv.QUOTE_NONE means that quotes are never placed around fields.</li>
</ul>
</li>
<li><tt class="docutils literal">doublequote</tt> controls the handling of quotes inside fields.  When
True two consecutive quotes are interpreted as one during read, and
when writing, each quote is written as two quotes.</li>
</ul>
<p>When processing a dialect setting and one or more of the other
optional parameters, the dialect parameter is processed before the
individual formatting parameters.  This makes it easy to choose a
dialect, then override one or more of the settings without defining a
new dialect class.  For example, if a CSV file was generated by Excel
2000 using single quotes as the quote character and a colon as the
delimiter, you could create a reader like:</p>
<pre class="literal-block">
csvreader = csv.reader(file(&quot;some.csv&quot;), dialect=&quot;excel&quot;,
                       quotechar=&quot;'&quot;, delimiter=':')
</pre>
<p>Other details of how Excel generates CSV files would be handled
automatically because of the reference to the &quot;excel&quot; dialect.</p>
</div>
<div class="section" id="reader-objects">
<h2><a class="toc-backref" href="#id21">Reader Objects</a></h2>
<p>Reader objects are iterables whose next() method returns a sequence of
strings, one string per field in the row.</p>
</div>
<div class="section" id="writer-objects">
<h2><a class="toc-backref" href="#id22">Writer Objects</a></h2>
<p>Writer objects have two methods, writerow() and writerows().  The
former accepts an iterable (typically a list) of fields which are to
be written to the output.  The latter accepts a list of iterables and
calls writerow() for each.</p>
</div>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id23">Implementation</a></h1>
<p>There is a sample implementation available.  <a class="footnote-reference" href="#id7" id="id4">[1]</a> The goal is for it
to efficiently implement the API described in the PEP.  It is heavily
based on the Object Craft csv module. <a class="footnote-reference" href="#id8" id="id5">[2]</a></p>
</div>
<div class="section" id="testing">
<h1><a class="toc-backref" href="#id24">Testing</a></h1>
<p>The sample implementation <a class="footnote-reference" href="#id7" id="id6">[1]</a> includes a set of test cases.</p>
</div>
<div class="section" id="issues">
<h1><a class="toc-backref" href="#id25">Issues</a></h1>
<ol class="arabic">
<li><p class="first">Should a parameter control how consecutive delimiters are
interpreted?  Our thought is &quot;no&quot;.  Consecutive delimiters should
always denote an empty field.</p>
</li>
<li><p class="first">What about Unicode?  Is it sufficient to pass a file object gotten
from codecs.open()?  For example:</p>
<pre class="literal-block">
csvreader = csv.reader(codecs.open(&quot;some.csv&quot;, &quot;r&quot;, &quot;cp1252&quot;))

csvwriter = csv.writer(codecs.open(&quot;some.csv&quot;, &quot;w&quot;, &quot;utf-8&quot;))
</pre>
<p>In the first example, text would be assumed to be encoded as cp1252.
Should the system be aggressive in converting to Unicode or should
Unicode strings only be returned if necessary?</p>
<p>In the second example, the file will take care of automatically
encoding Unicode strings as utf-8 before writing to disk.</p>
<p>Note: As of this writing, the csv module doesn't handle Unicode
data.</p>
</li>
<li><p class="first">What about alternate escape conventions?  If the dialect in use
includes an <tt class="docutils literal">escapechar</tt> parameter which is not None and the
<tt class="docutils literal">quoting</tt> parameter is set to QUOTE_NONE, delimiters appearing
within fields will be prefixed by the escape character when writing
and are expected to be prefixed by the escape character when
reading.</p>
</li>
<li><p class="first">Should there be a &quot;fully quoted&quot; mode for writing?  What about
&quot;fully quoted except for numeric values&quot;?  Both are implemented
(QUOTE_ALL and QUOTE_NONNUMERIC, respectively).</p>
</li>
<li><p class="first">What about end-of-line?  If I generate a CSV file on a Unix system,
will Excel properly recognize the LF-only line terminators?  Files
must be opened for reading or writing as appropriate using binary
mode.  Specify the <tt class="docutils literal">lineterminator</tt> sequence as <tt class="docutils literal">'\r\n'</tt>.  The
resulting file will be written correctly.</p>
</li>
<li><p class="first">What about an option to generate dicts from the reader and accept
dicts by the writer?  See the DictReader and DictWriter classes in
csv.py.</p>
</li>
<li><p class="first">Are quote character and delimiters limited to single characters?
For the time being, yes.</p>
</li>
<li><p class="first">How should rows of different lengths be handled?  Interpretation of
the data is the application's job.  There is no such thing as a
&quot;short row&quot; or a &quot;long row&quot; at this level.</p>
</li>
</ol>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id26">References</a></h1>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id4">1</a>, <a class="fn-backref" href="#id6">2</a>)</em> csv module, Python Sandbox
(<a class="reference external" href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/python/python/nondist/sandbox/csv/">http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/python/python/nondist/sandbox/csv/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id5">2</a>)</em> csv module, Object Craft
(<a class="reference external" href="http://www.object-craft.com.au/projects/csv">http://www.object-craft.com.au/projects/csv</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[3]</a></td><td>Python-DSV module, Wells
(<a class="reference external" href="http://sourceforge.net/projects/python-dsv/">http://sourceforge.net/projects/python-dsv/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[4]</a></td><td>ASV module, Tratt
(<a class="reference external" href="http://tratt.net/laurie/python/asv/">http://tratt.net/laurie/python/asv/</a>)</td></tr>
</tbody>
</table>
<p>There are many references to other CSV-related projects on the Web.  A
few are included here.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id27">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>

