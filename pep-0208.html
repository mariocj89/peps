<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">208</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Reworking the Coercion Model</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0208.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">nas&#32;&#97;t&#32;arctrix.com (Neil Schemenauer), mal&#32;&#97;t&#32;lemburg.com (Marc-Andr√© Lemburg)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">04-Dec-2000</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.1</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id7">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id8">Rationale</a></li>
<li><a class="reference internal" href="#specification" id="id9">Specification</a></li>
<li><a class="reference internal" href="#reference-implementation" id="id10">Reference Implementation</a></li>
<li><a class="reference internal" href="#credits" id="id11">Credits</a></li>
<li><a class="reference internal" href="#copyright" id="id12">Copyright</a></li>
<li><a class="reference internal" href="#references" id="id13">References</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id7">Abstract</a></h1>
<p>Many Python types implement numeric operations.  When the arguments of
a numeric operation are of different types, the interpreter tries to
coerce the arguments into a common type.  The numeric operation is
then performed using this common type.  This PEP proposes a new type
flag to indicate that arguments to a type's numeric operations should
not be coerced.  Operations that do not support the supplied types
indicate it by returning a new singleton object.  Types which do not
set the type flag are handled in a backwards compatible manner.
Allowing operations handle different types is often simpler, more
flexible, and faster than having the interpreter do coercion.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id8">Rationale</a></h1>
<p>When implementing numeric or other related operations, it is often
desirable to provide not only operations between operands of one type
only, e.g. integer + integer, but to generalize the idea behind the
operation to other type combinations as well, e.g. integer + float.</p>
<p>A common approach to this mixed type situation is to provide a method
of &quot;lifting&quot; the operands to a common type (coercion) and then use
that type's operand method as execution mechanism.  Yet, this strategy
has a few drawbacks:</p>
<ul class="simple">
<li>the &quot;lifting&quot; process creates at least one new (temporary)
operand object,</li>
<li>since the coercion method is not being told about the operation
that is to follow, it is not possible to implement operation
specific coercion of types,</li>
<li>there is no elegant way to solve situations were a common type
is not at hand, and</li>
<li>the coercion method will always have to be called prior to the
operation's method itself.</li>
</ul>
<p>A fix for this situation is obviously needed, since these drawbacks
make implementations of types needing these features very cumbersome,
if not impossible.  As an example, have a look at the <tt class="docutils literal">DateTime</tt> and
<tt class="docutils literal">DateTimeDelta</tt> <a class="footnote-reference" href="#id4" id="id1">[1]</a> types, the first being absolute, the second
relative.  You can always add a relative value to an absolute one,
giving a new absolute value.  Yet, there is no common type which the
existing coercion mechanism could use to implement that operation.</p>
<p>Currently, <tt class="docutils literal">PyInstance</tt> types are treated specially by the interpreter
in that their numeric methods are passed arguments of different types.
Removing this special case simplifies the interpreter and allows other
types to implement numeric methods that behave like instance types.
This is especially useful for extension types like ExtensionClass.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id9">Specification</a></h1>
<p>Instead of using a central coercion method, the process of handling
different operand types is simply left to the operation.  If the
operation finds that it cannot handle the given operand type
combination, it may return a special singleton as indicator.</p>
<p>Note that &quot;numbers&quot; (anything that implements the number protocol, or
part of it) written in Python already use the first part of this
strategy - it is the C level API that we focus on here.</p>
<p>To maintain nearly 100% backward compatibility we have to be very
careful to make numbers that don't know anything about the new
strategy (old style numbers) work just as well as those that expect
the new scheme (new style numbers).  Furthermore, binary compatibility
is a must, meaning that the interpreter may only access and use new
style operations if the number indicates the availability of these.</p>
<p>A new style number is considered by the interpreter as such if and
only if it sets the type flag <tt class="docutils literal">Py_TPFLAGS_CHECKTYPES</tt>.  The main
difference between an old style number and a new style one is that the
numeric slot functions can no longer assume to be passed arguments of
identical type.  New style slots must check all arguments for proper
type and implement the necessary conversions themselves.  This may seem
to cause more work on the behalf of the type implementor, but is in
fact no more difficult than writing the same kind of routines for an
old style coercion slot.</p>
<p>If a new style slot finds that it cannot handle the passed argument
type combination, it may return a new reference of the special
singleton <tt class="docutils literal">Py_NotImplemented</tt> to the caller.  This will cause the caller
to try the other operands operation slots until it finds a slot that
does implement the operation for the specific type combination.  If
none of the possible slots succeed, it raises a <tt class="docutils literal">TypeError</tt>.</p>
<p>To make the implementation easy to understand (the whole topic is
esoteric enough), a new layer in the handling of numeric operations is
introduced.  This layer takes care of all the different cases that need
to be taken into account when dealing with all the possible
combinations of old and new style numbers.  It is implemented by the
two static functions <tt class="docutils literal">binary_op()</tt> and <tt class="docutils literal">ternary_op()</tt>, which are both
internal functions that only the functions in Objects/abstract.c
have access to.  The numeric API (<tt class="docutils literal">PyNumber_*</tt>) is easy to adapt to
this new layer.</p>
<p>As a side-effect all numeric slots can be NULL-checked (this has to be
done anyway, so the added feature comes at no extra cost).</p>
<p>The scheme used by the layer to execute a binary operation is as
follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="8%" />
<col width="85%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">v</th>
<th class="head">w</th>
<th class="head">Action taken</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>new</td>
<td>new</td>
<td>v.op(v,w), w.op(v,w)</td>
</tr>
<tr><td>new</td>
<td>old</td>
<td>v.op(v,w), coerce(v,w), v.op(v,w)</td>
</tr>
<tr><td>old</td>
<td>new</td>
<td>w.op(v,w), coerce(v,w), v.op(v,w)</td>
</tr>
<tr><td>old</td>
<td>old</td>
<td>coerce(v,w), v.op(v,w)</td>
</tr>
</tbody>
</table>
<p>The indicated action sequence is executed from left to right until
either the operation succeeds and a valid result (!=
<tt class="docutils literal">Py_NotImplemented</tt>) is returned or an exception is raised.  Exceptions
are returned to the calling function as-is.  If a slot returns
<tt class="docutils literal">Py_NotImplemented</tt>, the next item in the sequence is executed.</p>
<p>Note that coerce(v,w) will use the old style <tt class="docutils literal">nb_coerce</tt> slot methods
via a call to <tt class="docutils literal">PyNumber_Coerce()</tt>.</p>
<p>Ternary operations have a few more cases to handle:</p>
<table border="1" class="docutils">
<colgroup>
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="85%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">v</th>
<th class="head">w</th>
<th class="head">z</th>
<th class="head">Action taken</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>new</td>
<td>new</td>
<td>new</td>
<td>v.op(v,w,z), w.op(v,w,z), z.op(v,w,z)</td>
</tr>
<tr><td>new</td>
<td>old</td>
<td>new</td>
<td>v.op(v,w,z), z.op(v,w,z), coerce(v,w,z), v.op(v,w,z)</td>
</tr>
<tr><td>old</td>
<td>new</td>
<td>new</td>
<td>w.op(v,w,z), z.op(v,w,z), coerce(v,w,z), v.op(v,w,z)</td>
</tr>
<tr><td>old</td>
<td>old</td>
<td>new</td>
<td>z.op(v,w,z), coerce(v,w,z), v.op(v,w,z)</td>
</tr>
<tr><td>new</td>
<td>new</td>
<td>old</td>
<td>v.op(v,w,z), w.op(v,w,z), coerce(v,w,z), v.op(v,w,z)</td>
</tr>
<tr><td>new</td>
<td>old</td>
<td>old</td>
<td>v.op(v,w,z), coerce(v,w,z), v.op(v,w,z)</td>
</tr>
<tr><td>old</td>
<td>new</td>
<td>old</td>
<td>w.op(v,w,z), coerce(v,w,z), v.op(v,w,z)</td>
</tr>
<tr><td>old</td>
<td>old</td>
<td>old</td>
<td>coerce(v,w,z), v.op(v,w,z)</td>
</tr>
</tbody>
</table>
<p>The same notes as above, except that coerce(v,w,z) actually does:</p>
<pre class="literal-block">
if z != Py_None:
    coerce(v,w), coerce(v,z), coerce(w,z)
else:
    # treat z as absent variable
    coerce(v,w)
</pre>
<p>The current implementation uses this scheme already (there's only one
ternary slot: <tt class="docutils literal">nb_pow(a,b,c))</tt>.</p>
<p>Note that the numeric protocol is also used for some other related
tasks, e.g. sequence concatenation.  These can also benefit from the
new mechanism by implementing right-hand operations for type
combinations that would otherwise fail to work.  As an example, take
string concatenation: currently you can only do string + string.  With
the new mechanism, a new string-like type could implement new_type +
string and string + new_type, even though strings don't know anything
about new_type.</p>
<p>Since comparisons also rely on coercion (every time you compare an
integer to a float, the integer is first converted to float and then
compared...), a new slot to handle numeric comparisons is needed:</p>
<pre class="literal-block">
PyObject *nb_cmp(PyObject *v, PyObject *w)
</pre>
<p>This slot should compare the two objects and return an integer object
stating the result.  Currently, this result integer may only be -1, 0, 1.
If the slot cannot handle the type combination, it may return a
reference to <tt class="docutils literal">Py_NotImplemented</tt>.  [XXX Note that this slot is still
in flux since it should take into account rich comparisons
(i.e. <a class="reference external" href="/dev/peps/pep-0207">PEP 207</a>).]</p>
<p>Numeric comparisons are handled by a new numeric protocol API:</p>
<pre class="literal-block">
PyObject *PyNumber_Compare(PyObject *v, PyObject *w)
</pre>
<p>This function compare the two objects as &quot;numbers&quot; and return an
integer object stating the result.  Currently, this result integer may
only be -1, 0, 1.  In case the operation cannot be handled by the given
objects, a <tt class="docutils literal">TypeError</tt> is raised.</p>
<p>The <tt class="docutils literal">PyObject_Compare()</tt> API needs to adjusted accordingly to make use
of this new API.</p>
<p>Other changes include adapting some of the built-in functions (e.g.
<tt class="docutils literal">cmp()</tt>) to use this API as well.  Also, <tt class="docutils literal">PyNumber_CoerceEx()</tt> will need to
check for new style numbers before calling the <tt class="docutils literal">nb_coerce</tt> slot.  New
style numbers don't provide a coercion slot and thus cannot be
explicitly coerced.</p>
</div>
<div class="section" id="reference-implementation">
<h1><a class="toc-backref" href="#id10">Reference Implementation</a></h1>
<p>A preliminary patch for the CVS version of Python is available through
the Source Forge patch manager <a class="footnote-reference" href="#id5" id="id2">[2]</a>.</p>
</div>
<div class="section" id="credits">
<h1><a class="toc-backref" href="#id11">Credits</a></h1>
<p>This PEP and the patch are heavily based on work done by Marc-Andr√©
Lemburg <a class="footnote-reference" href="#id6" id="id3">[3]</a>.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id12">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id13">References</a></h1>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://www.lemburg.com/files/python/mxDateTime.html">http://www.lemburg.com/files/python/mxDateTime.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="http://sourceforge.net/patch/?func=detailpatch&amp;patch_id=102652&amp;group_id=5470">http://sourceforge.net/patch/?func=detailpatch&amp;patch_id=102652&amp;group_id=5470</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="http://www.lemburg.com/files/python/CoercionProposal.html">http://www.lemburg.com/files/python/CoercionProposal.html</a></td></tr>
</tbody>
</table>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

