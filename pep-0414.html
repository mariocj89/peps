<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">414</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Explicit Unicode Literal for Python 3.3</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0414.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Armin Ronacher &lt;armin.ronacher&#32;&#97;t&#32;active-4.com&gt;,
Nick Coghlan &lt;ncoghlan&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">15-Feb-2012</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">28-Feb-2012, 04-Mar-2012</td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2012-February/116995.html">https://mail.python.org/pipermail/python-dev/2012-February/116995.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id11">Abstract</a></li>
<li><a class="reference internal" href="#bdfl-pronouncement" id="id12">BDFL Pronouncement</a></li>
<li><a class="reference internal" href="#proposal" id="id13">Proposal</a></li>
<li><a class="reference internal" href="#exclusion-of-raw-unicode-literals" id="id14">Exclusion of &quot;Raw&quot; Unicode Literals</a></li>
<li><a class="reference internal" href="#author-s-note" id="id15">Author's Note</a></li>
<li><a class="reference internal" href="#rationale" id="id16">Rationale</a></li>
<li><a class="reference internal" href="#common-objections" id="id17">Common Objections</a><ul>
<li><a class="reference internal" href="#complaint-this-pep-may-harm-adoption-of-python-3-2" id="id18">Complaint: This PEP may harm adoption of Python 3.2</a></li>
<li><a class="reference internal" href="#complaint-python-3-shouldn-t-be-made-worse-just-to-support-porting-from-python-2" id="id19">Complaint: Python 3 shouldn't be made worse just to support porting from Python 2</a></li>
<li><a class="reference internal" href="#complaint-the-wsgi-native-strings-concept-is-an-ugly-hack" id="id20">Complaint: The WSGI &quot;native strings&quot; concept is an ugly hack</a></li>
<li><a class="reference internal" href="#complaint-the-existing-tools-should-be-good-enough-for-everyone" id="id21">Complaint: The existing tools should be good enough for everyone</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references" id="id22">References</a></li>
<li><a class="reference internal" href="#copyright" id="id23">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id11">Abstract</a></h1>
<p>This document proposes the reintegration of an explicit unicode literal
from Python 2.x to the Python 3.x language specification, in order to
reduce the volume of changes needed when porting Unicode-aware
Python 2 applications to Python 3.</p>
</div>
<div class="section" id="bdfl-pronouncement">
<h1><a class="toc-backref" href="#id12">BDFL Pronouncement</a></h1>
<p>This PEP has been formally accepted for Python 3.3:</p>
<blockquote>
I'm accepting the PEP. It's about as harmless as they come. Make it so.</blockquote>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id13">Proposal</a></h1>
<p>This PEP proposes that Python 3.3 restore support for Python 2's Unicode
literal syntax, substantially increasing the number of lines of existing
Python 2 code in Unicode aware applications that will run without modification
on Python 3.</p>
<p>Specifically, the Python 3 definition for string literal prefixes will be
expanded to allow:</p>
<pre class="literal-block">
&quot;u&quot; | &quot;U&quot;
</pre>
<p>in addition to the currently supported:</p>
<pre class="literal-block">
&quot;r&quot; | &quot;R&quot;
</pre>
<p>The following will all denote ordinary Python 3 strings:</p>
<pre class="literal-block">
'text'
&quot;text&quot;
'''text'''
&quot;&quot;&quot;text&quot;&quot;&quot;
u'text'
u&quot;text&quot;
u'''text'''
u&quot;&quot;&quot;text&quot;&quot;&quot;
U'text'
U&quot;text&quot;
U'''text'''
U&quot;&quot;&quot;text&quot;&quot;&quot;
</pre>
<p>No changes are proposed to Python 3's actual Unicode handling, only to the
acceptable forms for string literals.</p>
</div>
<div class="section" id="exclusion-of-raw-unicode-literals">
<h1><a class="toc-backref" href="#id14">Exclusion of &quot;Raw&quot; Unicode Literals</a></h1>
<p>Python 2 supports a concept of &quot;raw&quot; Unicode literals that don't meet the
conventional definition of a raw string: <tt class="docutils literal">\uXXXX</tt> and <tt class="docutils literal">\UXXXXXXXX</tt> escape
sequences are still processed by the compiler and converted to the
appropriate Unicode code points when creating the associated Unicode objects.</p>
<p>Python 3 has no corresponding concept - the compiler performs <em>no</em>
preprocessing of the contents of raw string literals. This matches the
behaviour of 8-bit raw string literals in Python 2.</p>
<p>Since such strings are rarely used and would be interpreted differently in
Python 3 if permitted, it was decided that leaving them out entirely was
a better choice. Code which uses them will thus still fail immediately on
Python 3 (with a Syntax Error), rather than potentially producing different
output.</p>
<p>To get equivalent behaviour that will run on both Python 2 and Python 3,
either an ordinary Unicode literal can be used (with appropriate additional
escaping within the string), or else string concatenation or string
formatting can be combine the raw portions of the string with those that
require the use of Unicode escape sequences.</p>
<p>Note that when using <tt class="docutils literal">from __future__ import unicode_literals</tt> in Python 2,
the nominally &quot;raw&quot; Unicode string literals will process <tt class="docutils literal">\uXXXX</tt> and
<tt class="docutils literal">\UXXXXXXXX</tt> escape sequences, just like Python 2 strings explicitly marked
with the &quot;raw Unicode&quot; prefix.</p>
</div>
<div class="section" id="author-s-note">
<h1><a class="toc-backref" href="#id15">Author's Note</a></h1>
<p>This PEP was originally written by Armin Ronacher, and Guido's approval was
given based on that version.</p>
<p>The currently published version has been rewritten by Nick Coghlan to
include additional historical details and rationale that were taken into
account when Guido made his decision, but were not explicitly documented in
Armin's version of the PEP.</p>
<p>Readers should be aware that many of the arguments in this PEP are <em>not</em>
technical ones. Instead, they relate heavily to the <em>social</em> and <em>personal</em>
aspects of software development.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id16">Rationale</a></h1>
<p>With the release of a Python 3 compatible version of the Web Services Gateway
Interface (WSGI) specification (<a class="reference external" href="/dev/peps/pep-3333">PEP 3333</a>) for Python 3.2, many parts of the
Python web ecosystem have been making a concerted effort to support Python 3
without adversely affecting their existing developer and user communities.</p>
<p>One major item of feedback from key developers in those communities, including
Chris McDonough (WebOb, Pyramid), Armin Ronacher (Flask, Werkzeug), Jacob
Kaplan-Moss (Django) and Kenneth Reitz (<tt class="docutils literal">requests</tt>) is that the requirement
to change the spelling of <em>every</em> Unicode literal in an application
(regardless of how that is accomplished) is a key stumbling block for porting
efforts.</p>
<p>In particular, unlike many of the other Python 3 changes, it isn't one that
framework and library authors can easily handle on behalf of their users. Most
of those users couldn't care less about the &quot;purity&quot; of the Python language
specification, they just want their websites and applications to work as well
as possible.</p>
<p>While it is the Python web community that has been most vocal in highlighting
this concern, it is expected that other highly Unicode aware domains (such as
GUI development) may run into similar issues as they (and their communities)
start making concerted efforts to support Python 3.</p>
</div>
<div class="section" id="common-objections">
<h1><a class="toc-backref" href="#id17">Common Objections</a></h1>
<div class="section" id="complaint-this-pep-may-harm-adoption-of-python-3-2">
<h2><a class="toc-backref" href="#id18">Complaint: This PEP may harm adoption of Python 3.2</a></h2>
<p>This complaint is interesting, as it carries within it a tacit admission that
this PEP <em>will</em> make it easier to port Unicode aware Python 2 applications to
Python 3.</p>
<p>There are many existing Python communities that are prepared to put up with
the constraints imposed by the existing suite of porting tools, or to update
their Python 2 code bases sufficiently that the problems are minimised.</p>
<p>This PEP is not for those communities. Instead, it is designed specifically to
help people that <em>don't</em> want to put up with those difficulties.</p>
<p>However, since the proposal is for a comparatively small tweak to the language
syntax with no semantic changes, it is feasible to support it as a third
party import hook. While such an import hook imposes some import time
overhead, and requires additional steps from each application that needs it
to get the hook in place, it allows applications that target Python 3.2
to use libraries and frameworks that would otherwise only run on Python 3.3+
due to their use of unicode literal prefixes.</p>
<p>One such import hook project is Vinay Sajip's <tt class="docutils literal">uprefix</tt> <a class="footnote-reference" href="#id9" id="id1">[4]</a>.</p>
<p>For those that prefer to translate their code in advance rather than
converting on the fly at import time, Armin Ronacher is working on a hook
that runs at install time rather than during import <a class="footnote-reference" href="#id10" id="id2">[5]</a>.</p>
<p>Combining the two approaches is of course also possible. For example, the
import hook could be used for rapid edit-test cycles during local
development, but the install hook for continuous integration tasks and
deployment on Python 3.2.</p>
<p>The approaches described in this section may prove useful, for example, for
applications that wish to target Python 3 on the Ubuntu 12.04 LTS release,
which will ship with Python 2.7 and 3.2 as officially supported Python
versions.</p>
</div>
<div class="section" id="complaint-python-3-shouldn-t-be-made-worse-just-to-support-porting-from-python-2">
<h2><a class="toc-backref" href="#id19">Complaint: Python 3 shouldn't be made worse just to support porting from Python 2</a></h2>
<p>This is indeed one of the key design principles of Python 3. However, one of
the key design principles of Python as a whole is that &quot;practicality beats
purity&quot;. If we're going to impose a significant burden on third party
developers, we should have a solid rationale for doing so.</p>
<p>In most cases, the rationale for backwards incompatible Python 3 changes are
either to improve code correctness (for example, stricter default separation
of binary and text data and integer division upgrading to floats when
necessary), reduce typical memory usage (for example, increased usage of
iterators and views over concrete lists), or to remove distracting nuisances
that make Python code harder to read without increasing its expressiveness
(for example, the comma based syntax for naming caught exceptions). Changes
backed by such reasoning are <em>not</em> going to be reverted, regardless of
objections from Python 2 developers attempting to make the transition to
Python 3.</p>
<p>In many cases, Python 2 offered two ways of doing things for historical reasons.
For example, inequality could be tested with both <tt class="docutils literal">!=</tt> and <tt class="docutils literal">&lt;&gt;</tt> and integer
literals could be specified with an optional <tt class="docutils literal">L</tt> suffix. Such redundancies
have been eliminated in Python 3, which reduces the overall size of the
language and improves consistency across developers.</p>
<p>In the original Python 3 design (up to and including Python 3.2), the explicit
prefix syntax for unicode literals was deemed to fall into this category, as it
is completely unnecessary in Python 3. However, the difference between those
other cases and unicode literals is that the unicode literal prefix is <em>not</em>
redundant in Python 2 code: it is a programmatically significant distinction
that needs to be preserved in some fashion to avoid losing information.</p>
<p>While porting tools were created to help with the transition (see next section)
it still creates an additional burden on heavy users of unicode strings in
Python 2, solely so that future developers learning Python 3 don't need to be
told &quot;For historical reasons, string literals may have an optional <tt class="docutils literal">u</tt> or
<tt class="docutils literal">U</tt> prefix. Never use this yourselves, it's just there to help with porting
from an earlier version of the language.&quot;</p>
<p>Plenty of students learning Python 2 received similar warnings regarding string
exceptions without being confused or irreparably stunted in their growth as
Python developers. It will be the same with this feature.</p>
<p>This point is further reinforced by the fact that Python 3 <em>still</em> allows the
uppercase variants of the <tt class="docutils literal">B</tt> and <tt class="docutils literal">R</tt> prefixes for bytes literals and raw
bytes and string literals. If the potential for confusion due to string prefix
variants is that significant, where was the outcry asking that these
redundant prefixes be removed along with all the other redundancies that were
eliminated in Python 3?</p>
<p>Just as support for string exceptions was eliminated from Python 2 using the
normal deprecation process, support for redundant string prefix characters
(specifically, <tt class="docutils literal">B</tt>, <tt class="docutils literal">R</tt>, <tt class="docutils literal">u</tt>, <tt class="docutils literal">U</tt>) may eventually be eliminated
from Python 3, regardless of the current acceptance of this PEP. However,
such a change will likely only occur once third party libraries supporting
Python 2.7 is about as common as libraries supporting Python 2.2 or 2.3 is
today.</p>
</div>
<div class="section" id="complaint-the-wsgi-native-strings-concept-is-an-ugly-hack">
<h2><a class="toc-backref" href="#id20">Complaint: The WSGI &quot;native strings&quot; concept is an ugly hack</a></h2>
<p>One reason the removal of unicode literals has provoked such concern amongst
the web development community is that the updated WSGI specification had to
make a few compromises to minimise the disruption for existing web servers
that provide a WSGI-compatible interface (this was deemed necessary in order
to make the updated standard a viable target for web application authors and
web framework developers).</p>
<p>One of those compromises is the concept of a &quot;native string&quot;. WSGI defines
three different kinds of string:</p>
<ul class="simple">
<li>text strings: handled as <tt class="docutils literal">unicode</tt> in Python 2 and <tt class="docutils literal">str</tt> in Python 3</li>
<li>native strings: handled as <tt class="docutils literal">str</tt> in both Python 2 and Python 3</li>
<li>binary data: handled as <tt class="docutils literal">str</tt> in Python 2 and <tt class="docutils literal">bytes</tt> in Python 3</li>
</ul>
<p>Some developers consider WSGI's &quot;native strings&quot; to be an ugly hack, as they
are <em>explicitly</em> documented as being used solely for <tt class="docutils literal"><span class="pre">latin-1</span></tt> decoded
&quot;text&quot;, regardless of the actual encoding of the underlying data. Using this
approach bypasses many of the updates to Python 3's data model that are
designed to encourage correct handling of text encodings. However, it
generally works due to the specific details of the problem domain - web server
and web framework developers are some of the individuals <em>most</em> aware of how
blurry the line can get between binary data and text when working with HTTP
and related protocols, and how important it is to understand the implications
of the encodings in use when manipulating encoded text data. At the
<em>application</em> level most of these details are hidden from the developer by
the web frameworks and support libraries (both in Python 2 <em>and</em> in Python 3).</p>
<p>In practice, native strings are a useful concept because there are some APIs
(both in the standard library and in third party frameworks and packages) and
some internal interpreter details that are designed primarily to work with
<tt class="docutils literal">str</tt>. These components often don't support <tt class="docutils literal">unicode</tt> in Python 2
or <tt class="docutils literal">bytes</tt> in Python 3, or, if they do, require additional encoding details
and/or impose constraints that don't apply to the <tt class="docutils literal">str</tt> variants.</p>
<p>Some example of interfaces that are best handled by using actual <tt class="docutils literal">str</tt>
instances are:</p>
<ul class="simple">
<li>Python identifiers (as attributes, dict keys, class names, module names,
import references, etc)</li>
<li>URLs for the most part as well as HTTP headers in urllib/http servers</li>
<li>WSGI environment keys and CGI-inherited values</li>
<li>Python source code for dynamic compilation and AST hacks</li>
<li>Exception messages</li>
<li><tt class="docutils literal">__repr__</tt> return value</li>
<li>preferred filesystem paths</li>
<li>preferred OS environment</li>
</ul>
<p>In Python 2.6 and 2.7, these distinctions are most naturally expressed as
follows:</p>
<ul class="simple">
<li><tt class="docutils literal">u&quot;&quot;</tt>: text string (<tt class="docutils literal">unicode</tt>)</li>
<li><tt class="docutils literal">&quot;&quot;</tt>: native string (<tt class="docutils literal">str</tt>)</li>
<li><tt class="docutils literal">b&quot;&quot;</tt>: binary data (<tt class="docutils literal">str</tt>, also aliased as <tt class="docutils literal">bytes</tt>)</li>
</ul>
<p>In Python 3, the <tt class="docutils literal"><span class="pre">latin-1</span></tt> decoded native strings are not distinguished
from any other text strings:</p>
<ul class="simple">
<li><tt class="docutils literal">&quot;&quot;</tt>: text string (<tt class="docutils literal">str</tt>)</li>
<li><tt class="docutils literal">&quot;&quot;</tt>: native string (<tt class="docutils literal">str</tt>)</li>
<li><tt class="docutils literal">b&quot;&quot;</tt>: binary data (<tt class="docutils literal">bytes</tt>)</li>
</ul>
<p>If <tt class="docutils literal">from __future__ import unicode_literals</tt> is used to modify the behaviour
of Python 2, then, along with an appropriate definition of <tt class="docutils literal">n()</tt>, the
distinction can be expressed as:</p>
<ul class="simple">
<li><tt class="docutils literal">&quot;&quot;</tt>: text string</li>
<li><tt class="docutils literal"><span class="pre">n(&quot;&quot;)</span></tt>: native string</li>
<li><tt class="docutils literal">b&quot;&quot;</tt>: binary data</li>
</ul>
<p>(While <tt class="docutils literal">n=str</tt> works for simple cases, it can sometimes have problems
due to non-ASCII source encodings)</p>
<p>In the common subset of Python 2 and Python 3 (with appropriate
specification of a source encoding and definitions of the <tt class="docutils literal">u()</tt> and <tt class="docutils literal">b()</tt>
helper functions), they can be expressed as:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">u(&quot;&quot;)</span></tt>: text string</li>
<li><tt class="docutils literal">&quot;&quot;</tt>: native string</li>
<li><tt class="docutils literal"><span class="pre">b(&quot;&quot;)</span></tt>: binary data</li>
</ul>
<p>That last approach is the only variant that supports Python 2.5 and earlier.</p>
<p>Of all the alternatives, the format currently supported in Python 2.6 and 2.7
is by far the cleanest approach that clearly distinguishes the three desired
kinds of behaviour. With this PEP, that format will also be supported in
Python 3.3+. It will also be supported in Python 3.1 and 3.2 through the use
of import and install hooks. While it is significantly less likely, it is
also conceivable that the hooks could be adapted to allow the use of the
<tt class="docutils literal">b</tt> prefix on Python 2.5.</p>
</div>
<div class="section" id="complaint-the-existing-tools-should-be-good-enough-for-everyone">
<h2><a class="toc-backref" href="#id21">Complaint: The existing tools should be good enough for everyone</a></h2>
<p>A commonly expressed sentiment from developers that have already successfully
ported applications to Python 3 is along the lines of &quot;if you think it's hard,
you're doing it wrong&quot; or &quot;it's not that hard, just try it!&quot;. While it is no
doubt unintentional, these responses all have the effect of telling the
people that are pointing out inadequacies in the current porting toolset
&quot;there's nothing wrong with the porting tools, you just suck and don't know
how to use them properly&quot;.</p>
<p>These responses are a case of completely missing the point of what people are
complaining about. The feedback that resulted in this PEP isn't due to people
complaining that ports aren't possible. Instead, the feedback is coming from
people that have successfully <em>completed</em> ports and are objecting that they
found the experience thoroughly <em>unpleasant</em> for the class of application that
they needed to port (specifically, Unicode aware web frameworks and support
libraries).</p>
<p>This is a subjective appraisal, and it's the reason why the Python 3
porting tools ecosystem is a case where the &quot;one obvious way to do it&quot;
philosophy emphatically does <em>not</em> apply. While it was originally intended that
&quot;develop in Python 2, convert with <tt class="docutils literal">2to3</tt>, test both&quot; would be the standard
way to develop for both versions in parallel, in practice, the needs of
different projects and developer communities have proven to be sufficiently
diverse that a variety of approaches have been devised, allowing each group
to select an approach that best fits their needs.</p>
<p>Lennart Regebro has produced an excellent overview of the available migration
strategies <a class="footnote-reference" href="#id7" id="id3">[2]</a>, and a similar review is provided in the official porting
guide <a class="footnote-reference" href="#id8" id="id4">[3]</a>. (Note that the official guidance has softened to &quot;it depends on
your specific situation&quot; since Lennart wrote his overview).</p>
<p>However, both of those guides are written from the founding assumption that
all of the developers involved are <em>already</em> committed to the idea of
supporting Python 3. They make no allowance for the <em>social</em> aspects of such a
change when you're interacting with a user base that may not be especially
tolerant of disruptions without a clear benefit, or are trying to persuade
Python 2 focused upstream developers to accept patches that are solely about
improving Python 3 forward compatibility.</p>
<p>With the current porting toolset, <em>every</em> migration strategy will result in
changes to <em>every</em> Unicode literal in a project. No exceptions. They will
be converted to either an unprefixed string literal (if the project decides to
adopt the <tt class="docutils literal">unicode_literals</tt> import) or else to a converter call like
<tt class="docutils literal"><span class="pre">u(&quot;text&quot;)</span></tt>.</p>
<p>If the <tt class="docutils literal">unicode_literals</tt> import approach is employed, but is not adopted
across the entire project at the same time, then the meaning of a bare string
literal may become annoyingly ambiguous. This problem can be particularly
pernicious for <em>aggregated</em> software, like a Django site - in such a situation,
some files may end up using the <tt class="docutils literal">unicode_literals</tt> import and others may not,
creating definite potential for confusion.</p>
<p>While these problems are clearly solvable at a technical level, they're a
completely unnecessary distraction at the social level. Developer energy should
be reserved for addressing <em>real</em> technical difficulties associated with the
Python 3 transition (like distinguishing their 8-bit text strings from their
binary data). They shouldn't be punished with additional code changes (even
automated ones) solely due to the fact that they have <em>already</em> explicitly
identified their Unicode strings in Python 2.</p>
<p>Armin Ronacher has created an experimental extension to 2to3 which only
modernizes Python code to the extent that it runs on Python 2.7 or later with
support from the cross-version compatibility <tt class="docutils literal">six</tt> library. This tool is
available as <tt class="docutils literal"><span class="pre">python-modernize</span></tt> <a class="footnote-reference" href="#id6" id="id5">[1]</a>. Currently, the deltas generated by
this tool will affect every Unicode literal in the converted source. This
will create legitimate concerns amongst upstream developers asked to accept
such changes, and amongst framework <em>users</em> being asked to change their
applications.</p>
<p>However, by eliminating the noise from changes to the Unicode literal syntax,
many projects could be cleanly and (comparatively) non-controversially made
forward compatible with Python 3.3+ just by running <tt class="docutils literal"><span class="pre">python-modernize</span></tt> and
applying the recommended changes.</p>
</div>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id22">References</a></h1>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[1]</a></td><td>Python-Modernize
(<a class="reference external" href="http://github.com/mitsuhiko/python-modernize">http://github.com/mitsuhiko/python-modernize</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>Porting to Python 3: Migration Strategies
(<a class="reference external" href="http://python3porting.com/strategies.html">http://python3porting.com/strategies.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td>Porting Python 2 Code to Python 3
(<a class="reference external" href="http://docs.python.org/howto/pyporting.html">http://docs.python.org/howto/pyporting.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[4]</a></td><td>uprefix import hook project
(<a class="reference external" href="https://bitbucket.org/vinay.sajip/uprefix">https://bitbucket.org/vinay.sajip/uprefix</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[5]</a></td><td>install hook to remove unicode string prefix characters
(<a class="reference external" href="https://github.com/mitsuhiko/unicode-literals-pep/tree/master/install-hook">https://github.com/mitsuhiko/unicode-literals-pep/tree/master/install-hook</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id23">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>

