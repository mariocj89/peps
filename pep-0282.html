<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">282</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">A Logging System</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0282.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">vinay_sajip at red-dove.com (Vinay Sajip), trentm&#32;&#97;t&#32;activestate.com (Trent Mick)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">4-Feb-2002</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.3</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id17">Abstract</a></li>
<li><a class="reference internal" href="#motivation" id="id18">Motivation</a></li>
<li><a class="reference internal" href="#influences" id="id19">Influences</a></li>
<li><a class="reference internal" href="#simple-example" id="id20">Simple Example</a></li>
<li><a class="reference internal" href="#control-flow" id="id21">Control Flow</a></li>
<li><a class="reference internal" href="#levels" id="id22">Levels</a></li>
<li><a class="reference internal" href="#loggers" id="id23">Loggers</a></li>
<li><a class="reference internal" href="#handlers" id="id24">Handlers</a></li>
<li><a class="reference internal" href="#logrecords" id="id25">LogRecords</a></li>
<li><a class="reference internal" href="#formatters" id="id26">Formatters</a></li>
<li><a class="reference internal" href="#filters" id="id27">Filters</a></li>
<li><a class="reference internal" href="#configuration" id="id28">Configuration</a></li>
<li><a class="reference internal" href="#thread-safety" id="id29">Thread Safety</a></li>
<li><a class="reference internal" href="#module-level-functions" id="id30">Module-Level Functions</a></li>
<li><a class="reference internal" href="#implementation" id="id31">Implementation</a></li>
<li><a class="reference internal" href="#packaging" id="id32">Packaging</a></li>
<li><a class="reference internal" href="#references" id="id33">References</a></li>
<li><a class="reference internal" href="#copyright" id="id34">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id17">Abstract</a></h1>
<p>This PEP describes a proposed logging package for Python's
standard library.</p>
<p>Basically the system involves the user creating one or more logger
objects on which methods are called to log debugging notes,
general information, warnings, errors etc.  Different logging
'levels' can be used to distinguish important messages from less
important ones.</p>
<p>A registry of named singleton logger objects is maintained so that</p>
<ol class="arabic simple">
<li>different logical logging streams (or 'channels') exist
(say, one for 'zope.zodb' stuff and another for
'mywebsite'-specific stuff)</li>
<li>one does not have to pass logger object references around.</li>
</ol>
<p>The system is configurable at runtime.  This configuration
mechanism allows one to tune the level and type of logging done
while not touching the application itself.</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id18">Motivation</a></h1>
<p>If a single logging mechanism is enshrined in the standard
library, 1) logging is more likely to be done 'well', and 2)
multiple libraries will be able to be integrated into larger
applications which can be logged reasonably coherently.</p>
</div>
<div class="section" id="influences">
<h1><a class="toc-backref" href="#id19">Influences</a></h1>
<p>This proposal was put together after having studied the
following logging packages:</p>
<ul class="simple">
<li>java.util.logging in JDK 1.4 (a.k.a. JSR047) <a class="footnote-reference" href="#id11" id="id1">[1]</a></li>
<li>log4j <a class="footnote-reference" href="#id12" id="id2">[2]</a></li>
<li>the Syslog package from the Protomatter project <a class="footnote-reference" href="#id13" id="id3">[3]</a></li>
<li>MAL's mx.Log package <a class="footnote-reference" href="#id14" id="id4">[4]</a></li>
</ul>
</div>
<div class="section" id="simple-example">
<h1><a class="toc-backref" href="#id20">Simple Example</a></h1>
<p>This shows a very simple example of how the logging package can be
used to generate simple logging output on stderr.</p>
<pre class="literal-block">
--------- mymodule.py -------------------------------
import logging
log = logging.getLogger(&quot;MyModule&quot;)

def doIt():
        log.debug(&quot;Doin' stuff...&quot;)
        #do stuff...
        raise TypeError, &quot;Bogus type error for testing&quot;
-----------------------------------------------------

--------- myapp.py ----------------------------------
import mymodule, logging

logging.basicConfig()

log = logging.getLogger(&quot;MyApp&quot;)

log.info(&quot;Starting my app&quot;)
try:
        mymodule.doIt()
except Exception, e:
        log.exception(&quot;There was a problem.&quot;)
log.info(&quot;Ending my app&quot;)
-----------------------------------------------------

% python myapp.py

INFO:MyApp: Starting my app
DEBUG:MyModule: Doin' stuff...
ERROR:MyApp: There was a problem.
Traceback (most recent call last):
        File &quot;myapp.py&quot;, line 9, in ?
                mymodule.doIt()
        File &quot;mymodule.py&quot;, line 7, in doIt
                raise TypeError, &quot;Bogus type error for testing&quot;
TypeError: Bogus type error for testing

INFO:MyApp: Ending my app
</pre>
<p>The above example shows the default output format.  All
aspects of the output format should be configurable, so that
you could have output formatted like this:</p>
<pre class="literal-block">
2002-04-19 07:56:58,174 MyModule   DEBUG - Doin' stuff...

or just

Doin' stuff...
</pre>
</div>
<div class="section" id="control-flow">
<h1><a class="toc-backref" href="#id21">Control Flow</a></h1>
<p>Applications make logging calls on <strong>Logger</strong> objects.  Loggers are
organized in a hierarchical namespace and child Loggers inherit
some logging properties from their parents in the namespace.</p>
<p>Logger names fit into a &quot;dotted name&quot; namespace, with dots
(periods) indicating sub-namespaces.  The namespace of logger
objects therefore corresponds to a single tree data structure.</p>
<pre class="literal-block">
&quot;&quot; is the root of the namespace
&quot;Zope&quot; would be a child node of the root
&quot;Zope.ZODB&quot; would be a child node of &quot;Zope&quot;
</pre>
<p>These Logger objects create <strong>LogRecord</strong> objects which are passed
to <strong>Handler</strong> objects for output.  Both Loggers and Handlers may
use logging <strong>levels</strong> and (optionally) <strong>Filters</strong> to decide if they
are interested in a particular LogRecord.  When it is necessary to
output a LogRecord externally, a Handler can (optionally) use a
<strong>Formatter</strong> to localize and format the message before sending it
to an I/O stream.</p>
<p>Each Logger keeps track of a set of output Handlers.  By default
all Loggers also send their output to all Handlers of their
ancestor Loggers.  Loggers may, however, also be configured to
ignore Handlers higher up the tree.</p>
<p>The APIs are structured so that calls on the Logger APIs can be
cheap when logging is disabled.  If logging is disabled for a
given log level, then the Logger can make a cheap comparison test
and return.  If logging is enabled for a given log level, the
Logger is still careful to minimize costs before passing the
LogRecord into the Handlers.  In particular, localization and
formatting (which are relatively expensive) are deferred until the
Handler requests them.</p>
<p>The overall Logger hierarchy can also have a level associated with
it, which takes precedence over the levels of individual Loggers.
This is done through a module-level function:</p>
<pre class="literal-block">
def disable(lvl):
    &quot;&quot;&quot;
    Do not generate any LogRecords for requests with a severity less
    than 'lvl'.
    &quot;&quot;&quot;
    ...
</pre>
</div>
<div class="section" id="levels">
<h1><a class="toc-backref" href="#id22">Levels</a></h1>
<p>The logging levels, in increasing order of importance, are:</p>
<pre class="literal-block">
DEBUG
INFO
WARN
ERROR
CRITICAL
</pre>
<p>The term CRITICAL is used in preference to FATAL, which is used by
log4j.  The levels are conceptually the same - that of a serious,
or very serious, error.  However, FATAL implies death, which in
Python implies a raised and uncaught exception, traceback, and
exit.  Since the logging module does not enforce such an outcome
from a FATAL-level log entry, it makes sense to use CRITICAL in
preference to FATAL.</p>
<p>These are just integer constants, to allow simple comparison of
importance.  Experience has shown that too many levels can be
confusing, as they lead to subjective interpretation of which
level should be applied to any particular log request.</p>
<p>Although the above levels are strongly recommended, the logging
system should not be prescriptive.  Users may define their own
levels, as well as the textual representation of any levels.  User
defined levels must, however, obey the constraints that they are
all positive integers and that they increase in order of
increasing severity.</p>
<p>User-defined logging levels are supported through two module-level
functions:</p>
<pre class="literal-block">
def getLevelName(lvl):
        &quot;&quot;&quot;Return the text for level 'lvl'.&quot;&quot;&quot;
        ...

def addLevelName(lvl, lvlName):
        &quot;&quot;&quot;
        Add the level 'lvl' with associated text 'levelName', or
        set the textual representation of existing level 'lvl' to be
        'lvlName'.&quot;&quot;&quot;
        ...
</pre>
</div>
<div class="section" id="loggers">
<h1><a class="toc-backref" href="#id23">Loggers</a></h1>
<p>Each Logger object keeps track of a log level (or threshold) that
it is interested in, and discards log requests below that level.</p>
<p>A <strong>Manager</strong> class instance maintains the hierarchical namespace of
named Logger objects.  Generations are denoted with dot-separated
names: Logger &quot;foo&quot; is the parent of Loggers &quot;foo.bar&quot; and
&quot;foo.baz&quot;.</p>
<p>The Manager class instance is a singleton and is not directly
exposed to users, who interact with it using various module-level
functions.</p>
<p>The general logging method is:</p>
<pre class="literal-block">
class Logger:
    def log(self, lvl, msg, *args, **kwargs):
        &quot;&quot;&quot;Log 'str(msg) % args' at logging level 'lvl'.&quot;&quot;&quot;
        ...
</pre>
<p>However, convenience functions are defined for each logging level:</p>
<pre class="literal-block">
class Logger:
    def debug(self, msg, *args, **kwargs): ...
    def info(self, msg, *args, **kwargs): ...
    def warn(self, msg, *args, **kwargs): ...
    def error(self, msg, *args, **kwargs): ...
    def critical(self, msg, *args, **kwargs): ...
</pre>
<p>Only one keyword argument is recognized at present - &quot;exc_info&quot;.
If true, the caller wants exception information to be provided in
the logging output.  This mechanism is only needed if exception
information needs to be provided at <strong>any</strong> logging level.  In the
more common case, where exception information needs to be added to
the log only when errors occur, i.e. at the ERROR level, then
another convenience method is provided:</p>
<pre class="literal-block">
class Logger:
    def exception(self, msg, *args): ...
</pre>
<p>This should only be called in the context of an exception handler,
and is the preferred way of indicating a desire for exception
information in the log.  The other convenience methods are
intended to be called with exc_info only in the unusual situation
where you might want to provide exception information in the
context of an INFO message, for example.</p>
<p>The &quot;msg&quot; argument shown above will normally be a format string;
however, it can be any object x for which <tt class="docutils literal">str(x)</tt> returns the
format string.  This facilitates, for example, the use of an
object which fetches a locale- specific message for an
internationalized/localized application, perhaps using the
standard gettext module.  An outline example:</p>
<pre class="literal-block">
class Message:
    &quot;&quot;&quot;Represents a message&quot;&quot;&quot;
    def __init__(self, id):
        &quot;&quot;&quot;Initialize with the message ID&quot;&quot;&quot;

    def __str__(self):
        &quot;&quot;&quot;Return an appropriate localized message text&quot;&quot;&quot;

...

logger.info(Message(&quot;abc&quot;), ...)
</pre>
<p>Gathering and formatting data for a log message may be expensive,
and a waste if the logger was going to discard the message anyway.
To see if a request will be honoured by the logger, the
<tt class="docutils literal">isEnabledFor()</tt> method can be used:</p>
<pre class="literal-block">
class Logger:
    def isEnabledFor(self, lvl):
        &quot;&quot;&quot;
        Return true if requests at level 'lvl' will NOT be
        discarded.
        &quot;&quot;&quot;
        ...
</pre>
<p>so instead of this expensive and possibly wasteful DOM to XML
conversion:</p>
<pre class="literal-block">
...
hamletStr = hamletDom.toxml()
log.info(hamletStr)
...
</pre>
<p>one can do this:</p>
<pre class="literal-block">
if log.isEnabledFor(logging.INFO):
    hamletStr = hamletDom.toxml()
    log.info(hamletStr)
</pre>
<p>When new loggers are created, they are initialized with a level
which signifies &quot;no level&quot;.  A level can be set explicitly using
the <tt class="docutils literal">setLevel()</tt> method:</p>
<pre class="literal-block">
class Logger:
    def setLevel(self, lvl): ...
</pre>
<p>If a logger's level is not set, the system consults all its
ancestors, walking up the hierarchy until an explicitly set level
is found.  That is regarded as the &quot;effective level&quot; of the
logger, and can be queried via the getEffectiveLevel() method:</p>
<pre class="literal-block">
def getEffectiveLevel(self): ...
</pre>
<p>Loggers are never instantiated directly.  Instead, a module-level
function is used:</p>
<pre class="literal-block">
def getLogger(name=None): ...
</pre>
<p>If no name is specified, the root logger is returned.  Otherwise,
if a logger with that name exists, it is returned.  If not, a new
logger is initialized and returned.  Here, &quot;name&quot; is synonymous
with &quot;channel name&quot;.</p>
<p>Users can specify a custom subclass of Logger to be used by the
system when instantiating new loggers:</p>
<pre class="literal-block">
def setLoggerClass(klass): ...
</pre>
<p>The passed class should be a subclass of Logger, and its <tt class="docutils literal">__init__</tt>
method should call <tt class="docutils literal">Logger.__init__</tt>.</p>
</div>
<div class="section" id="handlers">
<h1><a class="toc-backref" href="#id24">Handlers</a></h1>
<p>Handlers are responsible for doing something useful with a given
<tt class="docutils literal">LogRecord</tt>.  The following core Handlers will be implemented:</p>
<ul class="simple">
<li><tt class="docutils literal">StreamHandler</tt>: A handler for writing to a file-like object.</li>
<li><tt class="docutils literal">FileHandler</tt>: A handler for writing to a single file or set
of rotating files.</li>
<li><tt class="docutils literal">SocketHandler</tt>: A handler for writing to remote TCP ports.</li>
<li><tt class="docutils literal">DatagramHandler</tt>: A handler for writing to UDP sockets, for
low-cost logging.  Jeff Bauer already had such a system <a class="footnote-reference" href="#id15" id="id5">[5]</a>.</li>
<li><tt class="docutils literal">MemoryHandler</tt>: A handler that buffers log records in memory
until the buffer is full or a particular condition occurs
<a class="footnote-reference" href="#id11" id="id6">[1]</a>.</li>
<li><tt class="docutils literal">SMTPHandler</tt>: A handler for sending to email addresses via SMTP.</li>
<li><tt class="docutils literal">SysLogHandler</tt>: A handler for writing to Unix syslog via UDP.</li>
<li><tt class="docutils literal">NTEventLogHandler</tt>: A handler for writing to event logs on
Windows NT, 2000 and XP.</li>
<li><tt class="docutils literal">HTTPHandler</tt>: A handler for writing to a Web server with
either GET or POST semantics.</li>
</ul>
<p>Handlers can also have levels set for them using the
<tt class="docutils literal">setLevel()</tt> method:</p>
<pre class="literal-block">
def setLevel(self, lvl): ...
</pre>
<p>The FileHandler can be set up to create a rotating set of log
files.  In this case, the file name passed to the constructor is
taken as a &quot;base&quot; file name.  Additional file names for the
rotation are created by appending .1, .2, etc. to the base file
name, up to a maximum as specified when rollover is requested.
The setRollover method is used to specify a maximum size for a log
file and a maximum number of backup files in the rotation.</p>
<pre class="literal-block">
def setRollover(maxBytes, backupCount): ...
</pre>
<p>If maxBytes is specified as zero, no rollover ever occurs and the
log file grows indefinitely.  If a non-zero size is specified,
when that size is about to be exceeded, rollover occurs.  The
rollover method ensures that the base file name is always the most
recent, .1 is the next most recent, .2 the next most recent after
that, and so on.</p>
<p>There are many additional handlers implemented in the test/example
scripts provided with <a class="footnote-reference" href="#id16" id="id7">[6]</a> - for example, XMLHandler and
SOAPHandler.</p>
</div>
<div class="section" id="logrecords">
<h1><a class="toc-backref" href="#id25">LogRecords</a></h1>
<p>A LogRecord acts as a receptacle for information about a
logging event.  It is little more than a dictionary, though it
does define a <tt class="docutils literal">getMessage</tt> method which merges a message with
optional runarguments.</p>
</div>
<div class="section" id="formatters">
<h1><a class="toc-backref" href="#id26">Formatters</a></h1>
<p>A Formatter is responsible for converting a LogRecord to a string
representation.  A Handler may call its Formatter before writing a
record.  The following core Formatters will be implemented:</p>
<ul class="simple">
<li><tt class="docutils literal">Formatter</tt>: Provide printf-like formatting, using the % operator.</li>
<li><tt class="docutils literal">BufferingFormatter</tt>: Provide formatting for multiple
messages, with header and trailer formatting support.</li>
</ul>
<p>Formatters are associated with Handlers by calling <tt class="docutils literal">setFormatter()</tt>
on a handler:</p>
<pre class="literal-block">
def setFormatter(self, form): ...
</pre>
<p>Formatters use the % operator to format the logging message.  The
format string should contain <tt class="docutils literal">%(name)x</tt> and the attribute dictionary
of the LogRecord is used to obtain message-specific data.  The
following attributes are provided:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr><td><tt class="docutils literal">%(name)s</tt></td>
<td>Name of the logger (logging channel)</td>
</tr>
<tr><td><tt class="docutils literal">%(levelno)s</tt></td>
<td>Numeric logging level for the message (DEBUG,
INFO, WARN, ERROR, CRITICAL)</td>
</tr>
<tr><td><tt class="docutils literal">%(levelname)s</tt></td>
<td>Text logging level for the message (&quot;DEBUG&quot;, &quot;INFO&quot;,
&quot;WARN&quot;, &quot;ERROR&quot;, &quot;CRITICAL&quot;)</td>
</tr>
<tr><td><tt class="docutils literal">%(pathname)s</tt></td>
<td>Full pathname of the source file where the logging
call was issued (if available)</td>
</tr>
<tr><td><tt class="docutils literal">%(filename)s</tt></td>
<td>Filename portion of pathname</td>
</tr>
<tr><td><tt class="docutils literal">%(module)s</tt></td>
<td>Module from which logging call was made</td>
</tr>
<tr><td><tt class="docutils literal">%(lineno)d</tt></td>
<td>Source line number where the logging call was issued
(if available)</td>
</tr>
<tr><td><tt class="docutils literal">%(created)f</tt></td>
<td>Time when the LogRecord was created (<tt class="docutils literal">time.time()</tt>
return value)</td>
</tr>
<tr><td><tt class="docutils literal">%(asctime)s</tt></td>
<td>Textual time when the LogRecord was created</td>
</tr>
<tr><td><tt class="docutils literal">%(msecs)d</tt></td>
<td>Millisecond portion of the creation time</td>
</tr>
<tr><td><tt class="docutils literal">%(relativeCreated)d</tt></td>
<td>Time in milliseconds when the LogRecord was created,
relative to the time the logging module was loaded
(typically at application startup time)</td>
</tr>
<tr><td><tt class="docutils literal">%(thread)d</tt></td>
<td>Thread ID (if available)</td>
</tr>
<tr><td><tt class="docutils literal">%(message)s</tt></td>
<td>The result of record.getMessage(), computed just as
the record is emitted</td>
</tr>
</tbody>
</table>
<p>If a formatter sees that the format string includes &quot;(asctime)s&quot;,
the creation time is formatted into the LogRecord's asctime
attribute.  To allow flexibility in formatting dates, Formatters
are initialized with a format string for the message as a whole,
and a separate format string for date/time.  The date/time format
string should be in time.strftime format.  The default value for
the message format is &quot;%(message)s&quot;.  The default date/time format
is ISO8601.</p>
<p>The formatter uses a class attribute, &quot;converter&quot;, to indicate how
to convert a time from seconds to a tuple.  By default, the value
of &quot;converter&quot; is &quot;time.localtime&quot;.  If needed, a different
converter (e.g.  &quot;time.gmtime&quot;) can be set on an individual
formatter instance, or the class attribute changed to affect all
formatter instances.</p>
</div>
<div class="section" id="filters">
<h1><a class="toc-backref" href="#id27">Filters</a></h1>
<p>When level-based filtering is insufficient, a Filter can be called
by a Logger or Handler to decide if a LogRecord should be output.
Loggers and Handlers can have multiple filters installed, and any
one of them can veto a LogRecord being output.</p>
<pre class="literal-block">
class Filter:
    def filter(self, record):
        &quot;&quot;&quot;
        Return a value indicating true if the record is to be
        processed.  Possibly modify the record, if deemed
        appropriate by the filter.
        &quot;&quot;&quot;
</pre>
<p>The default behaviour allows a Filter to be initialized with a
Logger name.  This will only allow through events which are
generated using the named logger or any of its children.  For
example, a filter initialized with &quot;A.B&quot; will allow events logged
by loggers &quot;A.B&quot;, &quot;A.B.C&quot;, &quot;A.B.C.D&quot;, &quot;A.B.D&quot; etc. but not &quot;A.BB&quot;,
&quot;B.A.B&quot; etc.  If initialized with the empty string, all events are
passed by the Filter.  This filter behaviour is useful when it is
desired to focus attention on one particular area of an
application; the focus can be changed simply by changing a filter
attached to the root logger.</p>
<p>There are many examples of Filters provided in <a class="footnote-reference" href="#id16" id="id8">[6]</a>.</p>
</div>
<div class="section" id="configuration">
<h1><a class="toc-backref" href="#id28">Configuration</a></h1>
<p>The main benefit of a logging system like this is that one can
control how much and what logging output one gets from an
application without changing that application's source code.
Therefore, although configuration can be performed through the
logging API, it must also be possible to change the logging
configuration without changing an application at all.  For
long-running programs like Zope, it should be possible to change
the logging configuration while the program is running.</p>
<p>Configuration includes the following:</p>
<ul class="simple">
<li>What logging level a logger or handler should be interested in.</li>
<li>What handlers should be attached to which loggers.</li>
<li>What filters should be attached to which handlers and loggers.</li>
<li>Specifying attributes specific to certain handlers and filters.</li>
</ul>
<p>In general each application will have its own requirements for how
a user may configure logging output.  However, each application
will specify the required configuration to the logging system
through a standard mechanism.</p>
<p>The most simple configuration is that of a single handler, writing
to stderr, attached to the root logger.  This configuration is set
up by calling the <tt class="docutils literal">basicConfig()</tt> function once the logging module
has been imported.</p>
<pre class="literal-block">
def basicConfig(): ...
</pre>
<p>For more sophisticated configurations, this PEP makes no specific
proposals, for the following reasons:</p>
<ul class="simple">
<li>A specific proposal may be seen as prescriptive.</li>
<li>Without the benefit of wide practical experience in the
Python community, there is no way to know whether any given
configuration approach is a good one.  That practice can't
really come until the logging module is used, and that means
until <strong>after</strong> Python 2.3 has shipped.</li>
<li>There is a likelihood that different types of applications
may require different configuration approaches, so that no
&quot;one size fits all&quot;.</li>
</ul>
<p>The reference implementation <a class="footnote-reference" href="#id16" id="id9">[6]</a> has a working configuration file
format, implemented for the purpose of proving the concept and
suggesting one possible alternative.  It may be that separate
extension modules, not part of the core Python distribution, are
created for logging configuration and log viewing, supplemental
handlers and other features which are not of interest to the bulk
of the community.</p>
</div>
<div class="section" id="thread-safety">
<h1><a class="toc-backref" href="#id29">Thread Safety</a></h1>
<p>The logging system should support thread-safe operation without
any special action needing to be taken by its users.</p>
</div>
<div class="section" id="module-level-functions">
<h1><a class="toc-backref" href="#id30">Module-Level Functions</a></h1>
<p>To support use of the logging mechanism in short scripts and small
applications, module-level functions <tt class="docutils literal">debug()</tt>, <tt class="docutils literal">info()</tt>, <tt class="docutils literal">warn()</tt>,
<tt class="docutils literal">error()</tt>, <tt class="docutils literal">critical()</tt> and <tt class="docutils literal">exception()</tt> are provided.  These work in
the same way as the correspondingly named methods of Logger - in
fact they delegate to the corresponding methods on the root
logger.  A further convenience provided by these functions is that
if no configuration has been done, <tt class="docutils literal">basicConfig()</tt> is automatically
called.</p>
<p>At application exit, all handlers can be flushed by calling the function:</p>
<pre class="literal-block">
def shutdown(): ...
</pre>
<p>This will flush and close all handlers.</p>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id31">Implementation</a></h1>
<p>The reference implementation is Vinay Sajip's logging module <a class="footnote-reference" href="#id16" id="id10">[6]</a>.</p>
</div>
<div class="section" id="packaging">
<h1><a class="toc-backref" href="#id32">Packaging</a></h1>
<p>The reference implementation is implemented as a single module.
This offers the simplest interface - all users have to do is
&quot;import logging&quot; and they are in a position to use all the
functionality available.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id33">References</a></h1>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id6">2</a>)</em> java.util.logging
<a class="reference external" href="http://java.sun.com/j2se/1.4/docs/guide/util/logging/">http://java.sun.com/j2se/1.4/docs/guide/util/logging/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>log4j: a Java logging package
<a class="reference external" href="http://jakarta.apache.org/log4j/docs/index.html">http://jakarta.apache.org/log4j/docs/index.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>Protomatter's Syslog
<a class="reference external" href="http://protomatter.sourceforge.net/1.1.6/index.html">http://protomatter.sourceforge.net/1.1.6/index.html</a>
<a class="reference external" href="http://protomatter.sourceforge.net/1.1.6/javadoc/com/protomatter/syslog/syslog-whitepaper.html">http://protomatter.sourceforge.net/1.1.6/javadoc/com/protomatter/syslog/syslog-whitepaper.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>MAL mentions his mx.Log logging module:
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2002-February/019767.html">https://mail.python.org/pipermail/python-dev/2002-February/019767.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>Jeff Bauer's Mr. Creosote
<a class="reference external" href="http://starship.python.net/crew/jbauer/creosote/">http://starship.python.net/crew/jbauer/creosote/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[6]</td><td><em>(<a class="fn-backref" href="#id7">1</a>, <a class="fn-backref" href="#id8">2</a>, <a class="fn-backref" href="#id9">3</a>, <a class="fn-backref" href="#id10">4</a>)</em> Vinay Sajip's logging module.
<a class="reference external" href="http://www.red-dove.com/python_logging.html">http://www.red-dove.com/python_logging.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id34">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>

