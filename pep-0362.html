<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">362</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Function Signature Object</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0362.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Brett Cannon &lt;brett&#32;&#97;t&#32;python.org&gt;, Jiwon Seo &lt;seojiwon&#32;&#97;t&#32;gmail.com&gt;,
Yury Selivanov &lt;yury&#32;&#97;t&#32;magic.io&gt;, Larry Hastings &lt;larry&#32;&#97;t&#32;hastings.org&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">21-Aug-2006</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.3</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">04-Jun-2012</td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2012-June/120682.html">https://mail.python.org/pipermail/python-dev/2012-June/120682.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id4">Abstract</a></li>
<li><a class="reference internal" href="#signature-object" id="id5">Signature Object</a></li>
<li><a class="reference internal" href="#parameter-object" id="id6">Parameter Object</a></li>
<li><a class="reference internal" href="#boundarguments-object" id="id7">BoundArguments Object</a></li>
<li><a class="reference internal" href="#implementation" id="id8">Implementation</a></li>
<li><a class="reference internal" href="#design-considerations" id="id9">Design Considerations</a><ul>
<li><a class="reference internal" href="#no-implicit-caching-of-signature-objects" id="id10">No implicit caching of Signature objects</a></li>
<li><a class="reference internal" href="#some-functions-may-not-be-introspectable" id="id11">Some functions may not be introspectable</a></li>
<li><a class="reference internal" href="#signature-and-parameter-equivalence" id="id12">Signature and Parameter equivalence</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples" id="id13">Examples</a><ul>
<li><a class="reference internal" href="#visualizing-callable-objects-signature" id="id14">Visualizing Callable Objects' Signature</a></li>
<li><a class="reference internal" href="#annotation-checker" id="id15">Annotation Checker</a></li>
</ul>
</li>
<li><a class="reference internal" href="#acceptance" id="id16">Acceptance</a></li>
<li><a class="reference internal" href="#references" id="id17">References</a></li>
<li><a class="reference internal" href="#copyright" id="id18">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id4">Abstract</a></h1>
<p>Python has always supported powerful introspection capabilities,
including introspecting functions and methods (for the rest of
this PEP, &quot;function&quot; refers to both functions and methods).  By
examining a function object you can fully reconstruct the function's
signature.  Unfortunately this information is stored in an inconvenient
manner, and is spread across a half-dozen deeply nested attributes.</p>
<p>This PEP proposes a new representation for function signatures.
The new representation contains all necessary information about a function
and its parameters, and makes introspection easy and straightforward.</p>
<p>However, this object does not replace the existing function
metadata, which is used by Python itself to execute those
functions.  The new metadata object is intended solely to make
function introspection easier for Python programmers.</p>
</div>
<div class="section" id="signature-object">
<h1><a class="toc-backref" href="#id5">Signature Object</a></h1>
<p>A Signature object represents the call signature of a function and
its return annotation.  For each parameter accepted by the function
it stores a <a class="reference internal" href="#parameter-object">Parameter object</a> in its <tt class="docutils literal">parameters</tt> collection.</p>
<p>A Signature object has the following public attributes and methods:</p>
<ul>
<li><dl class="first docutils">
<dt>return_annotation <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">The &quot;return&quot; annotation for the function. If the function
has no &quot;return&quot; annotation, this attribute is set to
<tt class="docutils literal">Signature.empty</tt>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>parameters <span class="classifier-delimiter">:</span> <span class="classifier">OrderedDict</span></dt>
<dd><p class="first last">An ordered mapping of parameters' names to the corresponding
Parameter objects.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>bind(*args, **kwargs) -&gt; BoundArguments</dt>
<dd><p class="first last">Creates a mapping from positional and keyword arguments to
parameters.  Raises a <tt class="docutils literal">TypeError</tt> if the passed arguments do
not match the signature.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>bind_partial(*args, **kwargs) -&gt; BoundArguments</dt>
<dd><p class="first last">Works the same way as <tt class="docutils literal">bind()</tt>, but allows the omission
of some required arguments (mimics <tt class="docutils literal">functools.partial</tt>
behavior.)  Raises a <tt class="docutils literal">TypeError</tt> if the passed arguments do
not match the signature.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>replace(parameters=&lt;optional&gt;, *, return_annotation=&lt;optional&gt;) -&gt; Signature</dt>
<dd><p class="first">Creates a new Signature instance based on the instance
<tt class="docutils literal">replace</tt> was invoked on.  It is possible to pass different
<tt class="docutils literal">parameters</tt> and/or <tt class="docutils literal">return_annotation</tt> to override the
corresponding properties of the base signature.  To remove
<tt class="docutils literal">return_annotation</tt> from the copied <tt class="docutils literal">Signature</tt>, pass in
<tt class="docutils literal">Signature.empty</tt>.</p>
<p class="last">Note that the '=&lt;optional&gt;' notation, means that the argument is
optional.  This notation applies to the rest of this PEP.</p>
</dd>
</dl>
</li>
</ul>
<p>Signature objects are immutable.  Use <tt class="docutils literal">Signature.replace()</tt> to
make a modified copy:</p>
<pre class="literal-block">
&gt;&gt;&gt; def foo() -&gt; None:
...     pass
&gt;&gt;&gt; sig = signature(foo)

&gt;&gt;&gt; new_sig = sig.replace(return_annotation=&quot;new return annotation&quot;)
&gt;&gt;&gt; new_sig is not sig
True
&gt;&gt;&gt; new_sig.return_annotation != sig.return_annotation
True
&gt;&gt;&gt; new_sig.parameters == sig.parameters
True

&gt;&gt;&gt; new_sig = new_sig.replace(return_annotation=new_sig.empty)
&gt;&gt;&gt; new_sig.return_annotation is Signature.empty
True
</pre>
<p>There are two ways to instantiate a Signature class:</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>Signature(parameters=&lt;optional&gt;, *, return_annotation=Signature.empty)</dt>
<dd>Default Signature constructor.  Accepts an optional sequence
of <tt class="docutils literal">Parameter</tt> objects, and an optional <tt class="docutils literal">return_annotation</tt>.
Parameters sequence is validated to check that there are no
parameters with duplicate names, and that the parameters
are in the right order, i.e. positional-only first, then
positional-or-keyword, etc.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Signature.from_function(function)</dt>
<dd>Returns a Signature object reflecting the signature of the
function passed in.</dd>
</dl>
</li>
</ul>
<p>It's possible to test Signatures for equality.  Two signatures are
equal when their parameters are equal, their positional and
positional-only parameters appear in the same order, and they
have equal return annotations.</p>
<p>Changes to the Signature object, or to any of its data members,
do not affect the function itself.</p>
<p>Signature also implements <tt class="docutils literal">__str__</tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; str(Signature.from_function((lambda *args: None)))
'(*args)'

&gt;&gt;&gt; str(Signature())
'()'
</pre>
</div>
<div class="section" id="parameter-object">
<h1><a class="toc-backref" href="#id6">Parameter Object</a></h1>
<p>Python's expressive syntax means functions can accept many different
kinds of parameters with many subtle semantic differences.  We
propose a rich Parameter object designed to represent any possible
function parameter.</p>
<p>A Parameter object has the following public attributes and methods:</p>
<ul>
<li><dl class="first docutils">
<dt>name <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The name of the parameter as a string.  Must be a valid
python identifier name (with the exception of <tt class="docutils literal">POSITIONAL_ONLY</tt>
parameters, which can have it set to <tt class="docutils literal">None</tt>.)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>default <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">The default value for the parameter.  If the parameter has no
default value, this attribute is set to <tt class="docutils literal">Parameter.empty</tt>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>annotation <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">The annotation for the parameter.  If the parameter has no
annotation, this attribute is set to <tt class="docutils literal">Parameter.empty</tt>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>kind</dt>
<dd><p class="first">Describes how argument values are bound to the parameter.
Possible values:</p>
<ul>
<li><p class="first"><tt class="docutils literal">Parameter.POSITIONAL_ONLY</tt> - value must be supplied
as a positional argument.</p>
<p>Python has no explicit syntax for defining positional-only
parameters, but many built-in and extension module functions
(especially those that accept only one or two parameters)
accept them.</p>
</li>
<li><p class="first"><tt class="docutils literal">Parameter.POSITIONAL_OR_KEYWORD</tt> - value may be
supplied as either a keyword or positional argument
(this is the standard binding behaviour for functions
implemented in Python.)</p>
</li>
<li><p class="first"><tt class="docutils literal">Parameter.KEYWORD_ONLY</tt> - value must be supplied
as a keyword argument.  Keyword only parameters are those
which appear after a &quot;*&quot; or &quot;*args&quot; entry in a Python
function definition.</p>
</li>
<li><p class="first"><tt class="docutils literal">Parameter.VAR_POSITIONAL</tt> - a tuple of positional
arguments that aren't bound to any other parameter.
This corresponds to a &quot;*args&quot; parameter in a Python
function definition.</p>
</li>
<li><p class="first"><tt class="docutils literal">Parameter.VAR_KEYWORD</tt> - a dict of keyword arguments
that aren't bound to any other parameter. This corresponds
to a &quot;**kwargs&quot; parameter in a Python function definition.</p>
</li>
</ul>
<p class="last">Always use <tt class="docutils literal">Parameter.*</tt> constants for setting and checking
value of the <tt class="docutils literal">kind</tt> attribute.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>replace(*, name=&lt;optional&gt;, kind=&lt;optional&gt;, default=&lt;optional&gt;, annotation=&lt;optional&gt;) -&gt; Parameter</dt>
<dd><p class="first last">Creates a new Parameter instance based on the instance
<tt class="docutils literal">replaced</tt> was invoked on.  To override a Parameter
attribute, pass the corresponding argument.  To remove
an attribute from a <tt class="docutils literal">Parameter</tt>, pass <tt class="docutils literal">Parameter.empty</tt>.</p>
</dd>
</dl>
</li>
</ul>
<p>Parameter constructor:</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>Parameter(name, kind, *, annotation=Parameter.empty, default=Parameter.empty)</dt>
<dd>Instantiates a Parameter object. <tt class="docutils literal">name</tt> and <tt class="docutils literal">kind</tt> are required,
while <tt class="docutils literal">annotation</tt> and <tt class="docutils literal">default</tt> are optional.</dd>
</dl>
</li>
</ul>
<p>Two parameters are equal when they have equal names, kinds, defaults,
and annotations.</p>
<p>Parameter objects are immutable.  Instead of modifying a Parameter object,
you can use <tt class="docutils literal">Parameter.replace()</tt> to create a modified copy like so:</p>
<pre class="literal-block">
&gt;&gt;&gt; param = Parameter('foo', Parameter.KEYWORD_ONLY, default=42)
&gt;&gt;&gt; str(param)
'foo=42'

&gt;&gt;&gt; str(param.replace())
'foo=42'

&gt;&gt;&gt; str(param.replace(default=Parameter.empty, annotation='spam'))
&quot;foo:'spam'&quot;
</pre>
</div>
<div class="section" id="boundarguments-object">
<h1><a class="toc-backref" href="#id7">BoundArguments Object</a></h1>
<p>Result of a <tt class="docutils literal">Signature.bind</tt> call.  Holds the mapping of arguments
to the function's parameters.</p>
<p>Has the following public attributes:</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>arguments <span class="classifier-delimiter">:</span> <span class="classifier">OrderedDict</span></dt>
<dd>An ordered, mutable mapping of parameters' names to arguments' values.
Contains only explicitly bound arguments.  Arguments for
which <tt class="docutils literal">bind()</tt> relied on a default value are skipped.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>args <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>Tuple of positional arguments values.  Dynamically computed from
the 'arguments' attribute.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>kwargs <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>Dict of keyword arguments values. Dynamically computed from
the 'arguments' attribute.</dd>
</dl>
</li>
</ul>
<p>The <tt class="docutils literal">arguments</tt> attribute should be used in conjunction with
<tt class="docutils literal">Signature.parameters</tt> for any arguments processing purposes.</p>
<p><tt class="docutils literal">args</tt> and <tt class="docutils literal">kwargs</tt> properties can be used to invoke functions:</p>
<pre class="literal-block">
def test(a, *, b):
    ...

sig = signature(test)
ba = sig.bind(10, b=20)
test(*ba.args, **ba.kwargs)
</pre>
<p>Arguments which could be passed as part of either <tt class="docutils literal">*args</tt> or <tt class="docutils literal">**kwargs</tt>
will be included only in the <tt class="docutils literal">BoundArguments.args</tt> attribute.  Consider the
following example:</p>
<pre class="literal-block">
def test(a=1, b=2, c=3):
    pass

sig = signature(test)
ba = sig.bind(a=10, c=13)

&gt;&gt;&gt; ba.args
(10,)

&gt;&gt;&gt; ba.kwargs:
{'c': 13}
</pre>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id8">Implementation</a></h1>
<p>The implementation adds a new function <tt class="docutils literal">signature()</tt> to the <tt class="docutils literal">inspect</tt>
module.  The function is the preferred way of getting a <tt class="docutils literal">Signature</tt> for
a callable object.</p>
<p>The function implements the following algorithm:</p>
<ul class="simple">
<li>If the object is not callable - raise a TypeError</li>
<li>If the object has a <tt class="docutils literal">__signature__</tt> attribute and if it
is not <tt class="docutils literal">None</tt> - return it</li>
<li>If it has a <tt class="docutils literal">__wrapped__</tt> attribute, return
<tt class="docutils literal">signature(object.__wrapped__)</tt></li>
<li>If the object is an instance of <tt class="docutils literal">FunctionType</tt>, construct
and return a new <tt class="docutils literal">Signature</tt> for it</li>
<li>If the object is a bound method, construct and return a new <tt class="docutils literal">Signature</tt>
object, with its first parameter (usually <tt class="docutils literal">self</tt> or <tt class="docutils literal">cls</tt>)
removed.  (<tt class="docutils literal">classmethod</tt> and <tt class="docutils literal">staticmethod</tt> are supported
too.  Since both are descriptors, the former returns a bound method,
and the latter returns its wrapped function.)</li>
<li>If the object is an instance of <tt class="docutils literal">functools.partial</tt>, construct
a new <tt class="docutils literal">Signature</tt> from its <tt class="docutils literal">partial.func</tt> attribute, and
account for already bound <tt class="docutils literal">partial.args</tt> and <tt class="docutils literal">partial.kwargs</tt></li>
<li>If the object is a class or metaclass:<ul>
<li>If the object's type has a <tt class="docutils literal">__call__</tt> method defined in
its MRO, return a Signature for it</li>
<li>If the object has a <tt class="docutils literal">__new__</tt> method defined in its MRO,
return a Signature object for it</li>
<li>If the object has a <tt class="docutils literal">__init__</tt> method defined in its MRO,
return a Signature object for it</li>
</ul>
</li>
<li>Return <tt class="docutils literal">signature(object.__call__)</tt></li>
</ul>
<p>Note that the <tt class="docutils literal">Signature</tt> object is created in a lazy manner, and
is not automatically cached.  However, the user can manually cache a
Signature by storing it in the <tt class="docutils literal">__signature__</tt> attribute.</p>
<p>An implementation for Python 3.3 can be found at <a class="footnote-reference" href="#impl" id="id1">[1]</a>.
The python issue tracking the patch is <a class="footnote-reference" href="#issue" id="id2">[2]</a>.</p>
</div>
<div class="section" id="design-considerations">
<h1><a class="toc-backref" href="#id9">Design Considerations</a></h1>
<div class="section" id="no-implicit-caching-of-signature-objects">
<h2><a class="toc-backref" href="#id10">No implicit caching of Signature objects</a></h2>
<p>The first PEP design had a provision for implicit caching of <tt class="docutils literal">Signature</tt>
objects in the <tt class="docutils literal">inspect.signature()</tt> function.  However, this has the
following downsides:</p>
<ul class="simple">
<li>If the <tt class="docutils literal">Signature</tt> object is cached then any changes to the function
it describes will not be reflected in it.  However, If the caching is
needed, it can be always done manually and explicitly</li>
<li>It is better to reserve the <tt class="docutils literal">__signature__</tt> attribute for the cases
when there is a need to explicitly set to a <tt class="docutils literal">Signature</tt> object that
is different from the actual one</li>
</ul>
</div>
<div class="section" id="some-functions-may-not-be-introspectable">
<h2><a class="toc-backref" href="#id11">Some functions may not be introspectable</a></h2>
<p>Some functions may not be introspectable in certain implementations of
Python.  For example, in CPython, built-in functions defined in C provide
no metadata about their arguments.  Adding support for them is out of
scope for this PEP.</p>
</div>
<div class="section" id="signature-and-parameter-equivalence">
<h2><a class="toc-backref" href="#id12">Signature and Parameter equivalence</a></h2>
<p>We assume that parameter names have semantic significance--two
signatures are equal only when their corresponding parameters are equal
and have the exact same names.  Users who want looser equivalence tests,
perhaps ignoring names of VAR_KEYWORD or VAR_POSITIONAL parameters, will
need to implement those themselves.</p>
</div>
</div>
<div class="section" id="examples">
<h1><a class="toc-backref" href="#id13">Examples</a></h1>
<div class="section" id="visualizing-callable-objects-signature">
<h2><a class="toc-backref" href="#id14">Visualizing Callable Objects' Signature</a></h2>
<p>Let's define some classes and functions:</p>
<pre class="literal-block">
from inspect import signature
from functools import partial, wraps


class FooMeta(type):
    def __new__(mcls, name, bases, dct, *, bar:bool=False):
        return super().__new__(mcls, name, bases, dct)

    def __init__(cls, name, bases, dct, **kwargs):
        return super().__init__(name, bases, dct)


class Foo(metaclass=FooMeta):
    def __init__(self, spam:int=42):
        self.spam = spam

    def __call__(self, a, b, *, c) -&gt; tuple:
        return a, b, c

    &#64;classmethod
    def spam(cls, a):
        return a


def shared_vars(*shared_args):
    &quot;&quot;&quot;Decorator factory that defines shared variables that are
       passed to every invocation of the function&quot;&quot;&quot;

    def decorator(f):
        &#64;wraps(f)
        def wrapper(*args, **kwargs):
            full_args = shared_args + args
            return f(*full_args, **kwargs)

        # Override signature
        sig = signature(f)
        sig = sig.replace(tuple(sig.parameters.values())[1:])
        wrapper.__signature__ = sig

        return wrapper
    return decorator


&#64;shared_vars({})
def example(_state, a, b, c):
    return _state, a, b, c


def format_signature(obj):
    return str(signature(obj))
</pre>
<p>Now, in the python REPL:</p>
<pre class="literal-block">
&gt;&gt;&gt; format_signature(FooMeta)
'(name, bases, dct, *, bar:bool=False)'

&gt;&gt;&gt; format_signature(Foo)
'(spam:int=42)'

&gt;&gt;&gt; format_signature(Foo.__call__)
'(self, a, b, *, c) -&gt; tuple'

&gt;&gt;&gt; format_signature(Foo().__call__)
'(a, b, *, c) -&gt; tuple'

&gt;&gt;&gt; format_signature(Foo.spam)
'(a)'

&gt;&gt;&gt; format_signature(partial(Foo().__call__, 1, c=3))
'(b, *, c=3) -&gt; tuple'

&gt;&gt;&gt; format_signature(partial(partial(Foo().__call__, 1, c=3), 2, c=20))
'(*, c=20) -&gt; tuple'

&gt;&gt;&gt; format_signature(example)
'(a, b, c)'

&gt;&gt;&gt; format_signature(partial(example, 1, 2))
'(c)'

&gt;&gt;&gt; format_signature(partial(partial(example, 1, b=2), c=3))
'(b=2, c=3)'
</pre>
</div>
<div class="section" id="annotation-checker">
<h2><a class="toc-backref" href="#id15">Annotation Checker</a></h2>
<pre class="literal-block">
import inspect
import functools

def checktypes(func):
    '''Decorator to verify arguments and return types

    Example:

        &gt;&gt;&gt; &#64;checktypes
        ... def test(a:int, b:str) -&gt; int:
        ...     return int(a * b)

        &gt;&gt;&gt; test(10, '1')
        1111111111

        &gt;&gt;&gt; test(10, 1)
        Traceback (most recent call last):
          ...
        ValueError: foo: wrong type of 'b' argument, 'str' expected, got 'int'
    '''

    sig = inspect.signature(func)

    types = {}
    for param in sig.parameters.values():
        # Iterate through function's parameters and build the list of
        # arguments types
        type_ = param.annotation
        if type_ is param.empty or not inspect.isclass(type_):
            # Missing annotation or not a type, skip it
            continue

        types[param.name] = type_

        # If the argument has a type specified, let's check that its
        # default value (if present) conforms with the type.
        if param.default is not param.empty and not isinstance(param.default, type_):
            raise ValueError(&quot;{func}: wrong type of a default value for {arg!r}&quot;. \
                             format(func=func.__qualname__, arg=param.name))

    def check_type(sig, arg_name, arg_type, arg_value):
        # Internal function that encapsulates arguments type checking
        if not isinstance(arg_value, arg_type):
            raise ValueError(&quot;{func}: wrong type of {arg!r} argument, &quot; \
                             &quot;{exp!r} expected, got {got!r}&quot;. \
                             format(func=func.__qualname__, arg=arg_name,
                                    exp=arg_type.__name__, got=type(arg_value).__name__))

    &#64;functools.wraps(func)
    def wrapper(*args, **kwargs):
        # Let's bind the arguments
        ba = sig.bind(*args, **kwargs)
        for arg_name, arg in ba.arguments.items():
            # And iterate through the bound arguments
            try:
                type_ = types[arg_name]
            except KeyError:
                continue
            else:
                # OK, we have a type for the argument, lets get the corresponding
                # parameter description from the signature object
                param = sig.parameters[arg_name]
                if param.kind == param.VAR_POSITIONAL:
                    # If this parameter is a variable-argument parameter,
                    # then we need to check each of its values
                    for value in arg:
                        check_type(sig, arg_name, type_, value)
                elif param.kind == param.VAR_KEYWORD:
                    # If this parameter is a variable-keyword-argument parameter:
                    for subname, value in arg.items():
                        check_type(sig, arg_name + ':' + subname, type_, value)
                else:
                    # And, finally, if this parameter a regular one:
                    check_type(sig, arg_name, type_, arg)

        result = func(*ba.args, **ba.kwargs)

        # The last bit - let's check that the result is correct
        return_type = sig.return_annotation
        if (return_type is not sig._empty and
                isinstance(return_type, type) and
                not isinstance(result, return_type)):

            raise ValueError('{func}: wrong return type, {exp} expected, got {got}'. \
                             format(func=func.__qualname__, exp=return_type.__name__,
                                    got=type(result).__name__))
        return result

    return wrapper
</pre>
</div>
</div>
<div class="section" id="acceptance">
<h1><a class="toc-backref" href="#id16">Acceptance</a></h1>
<p><a class="reference external" href="/dev/peps/pep-0362">PEP 362</a> was accepted by Guido, Friday, June 22, 2012 <a class="footnote-reference" href="#accepted" id="id3">[3]</a> .
The reference implementation was committed to trunk later that day.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id17">References</a></h1>
<table class="docutils footnote" frame="void" id="impl" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>pep362 branch (<a class="reference external" href="https://bitbucket.org/1st1/cpython/overview">https://bitbucket.org/1st1/cpython/overview</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="issue" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>issue 15008 (<a class="reference external" href="http://bugs.python.org/issue15008">http://bugs.python.org/issue15008</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="accepted" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>&quot;A Desperate Plea For Introspection (aka: BDFAP Needed)&quot; (<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2012-June/120682.html">https://mail.python.org/pipermail/python-dev/2012-June/120682.html</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id18">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

