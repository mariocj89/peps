<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">253</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Subtyping Built-in Types</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0253.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">guido&#32;&#97;t&#32;python.org (Guido van Rossum)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">14-May-2001</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.2</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id4">Abstract</a></li>
<li><a class="reference internal" href="#introduction" id="id5">Introduction</a></li>
<li><a class="reference internal" href="#about-metatypes" id="id6">About metatypes</a></li>
<li><a class="reference internal" href="#making-a-type-a-factory-for-its-instances" id="id7">Making a type a factory for its instances</a></li>
<li><a class="reference internal" href="#preparing-a-type-for-subtyping" id="id8">Preparing a type for subtyping</a></li>
<li><a class="reference internal" href="#creating-a-subtype-of-a-built-in-type-in-c" id="id9">Creating a subtype of a built-in type in C</a></li>
<li><a class="reference internal" href="#subtyping-in-python" id="id10">Subtyping in Python</a></li>
<li><a class="reference internal" href="#multiple-inheritance" id="id11">Multiple inheritance</a></li>
<li><a class="reference internal" href="#mro-method-resolution-order-the-lookup-rule" id="id12">MRO:  Method resolution order (the lookup rule)</a></li>
<li><a class="reference internal" href="#xxx-to-be-done" id="id13">XXX To be done</a><ul>
<li><a class="reference internal" href="#open-issues" id="id14">open issues</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation" id="id15">Implementation</a></li>
<li><a class="reference internal" href="#references" id="id16">References</a></li>
<li><a class="reference internal" href="#copyright" id="id17">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id4">Abstract</a></h1>
<p>This PEP proposes additions to the type object API that will allow
the creation of subtypes of built-in types, in C and in Python.</p>
<p>[Editor's note: the ideas described in this PEP have been incorporated
into Python.  The PEP no longer accurately describes the implementation.]</p>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id5">Introduction</a></h1>
<p>Traditionally, types in Python have been created statically, by
declaring a global variable of type PyTypeObject and initializing
it with a static initializer.  The slots in the type object
describe all aspects of a Python type that are relevant to the
Python interpreter.  A few slots contain dimensional information
(like the basic allocation size of instances), others contain
various flags, but most slots are pointers to functions to
implement various kinds of behaviors.  A NULL pointer means that
the type does not implement the specific behavior; in that case
the system may provide a default behavior or raise an exception
when the behavior is invoked for an instance of the type.  Some
collections of function pointers that are usually defined together
are obtained indirectly via a pointer to an additional structure
containing more function pointers.</p>
<p>While the details of initializing a PyTypeObject structure haven't
been documented as such, they are easily gleaned from the examples
in the source code, and I am assuming that the reader is
sufficiently familiar with the traditional way of creating new
Python types in C.</p>
<p>This PEP will introduce the following features:</p>
<ul class="simple">
<li>a type can be a factory function for its instances</li>
<li>types can be subtyped in C</li>
<li>types can be subtyped in Python with the class statement</li>
<li>multiple inheritance from types is supported (insofar as
practical -- you still can't multiply inherit from list and
dictionary)</li>
<li>the standard coercion functions (int, tuple, str etc.) will
be redefined to be the corresponding type objects, which serve
as their own factory functions</li>
<li>a class statement can contain a <tt class="docutils literal">__metaclass__</tt> declaration,
specifying the metaclass to be used to create the new class</li>
<li>a class statement can contain a <tt class="docutils literal">__slots__</tt> declaration,
specifying the specific names of the instance variables
supported</li>
</ul>
<p>This PEP builds on <a class="reference external" href="/dev/peps/pep-0252">PEP 252</a>, which adds standard introspection to
types; for example, when a particular type object initializes the
<tt class="docutils literal">tp_hash</tt> slot, that type object has a <tt class="docutils literal">__hash__</tt> method when
introspected.  <a class="reference external" href="/dev/peps/pep-0252">PEP 252</a> also adds a dictionary to type objects
which contains all methods.  At the Python level, this dictionary
is read-only for built-in types; at the C level, it is accessible
directly (but it should not be modified except as part of
initialization).</p>
<p>For binary compatibility, a flag bit in the tp_flags slot
indicates the existence of the various new slots in the type
object introduced below.  Types that don't have the
<tt class="docutils literal">Py_TPFLAGS_HAVE_CLASS</tt> bit set in their <tt class="docutils literal">tp_flags</tt> slot are assumed
to have NULL values for all the subtyping slots.  (Warning: the
current implementation prototype is not yet consistent in its
checking of this flag bit.  This should be fixed before the final
release.)</p>
<p>In current Python, a distinction is made between types and
classes.  This PEP together with <a class="reference external" href="/dev/peps/pep-0254">PEP 254</a> will remove that
distinction.  However, for backwards compatibility the distinction
will probably remain for years to come, and without <a class="reference external" href="/dev/peps/pep-0254">PEP 254</a>, the
distinction is still large: types ultimately have a built-in type
as a base class, while classes ultimately derive from a
user-defined class.  Therefore, in the rest of this PEP, I will
use the word type whenever I can -- including base type or
supertype, derived type or subtype, and metatype.  However,
sometimes the terminology necessarily blends, for example an
object's type is given by its <tt class="docutils literal">__class__</tt> attribute, and subtyping
in Python is spelled with a class statement.  If further
distinction is necessary, user-defined classes can be referred to
as &quot;classic&quot; classes.</p>
</div>
<div class="section" id="about-metatypes">
<h1><a class="toc-backref" href="#id6">About metatypes</a></h1>
<p>Inevitably the discussion comes to metatypes (or metaclasses).
Metatypes are nothing new in Python: Python has always been able
to talk about the type of a type:</p>
<pre class="literal-block">
&gt;&gt;&gt; a = 0
&gt;&gt;&gt; type(a)
&lt;type 'int'&gt;
&gt;&gt;&gt; type(type(a))
&lt;type 'type'&gt;
&gt;&gt;&gt; type(type(type(a)))
&lt;type 'type'&gt;
&gt;&gt;&gt;
</pre>
<p>In this example, <tt class="docutils literal">type(a)</tt> is a &quot;regular&quot; type, and <tt class="docutils literal">type(type(a))</tt> is
a metatype.  While as distributed all types have the same metatype
(<tt class="docutils literal">PyType_Type</tt>, which is also its own metatype), this is not a
requirement, and in fact a useful and relevant 3rd party extension
(ExtensionClasses by Jim Fulton) creates an additional metatype.
The type of classic classes, known as <tt class="docutils literal">types.ClassType</tt>, can also be
considered a distinct metatype.</p>
<p>A feature closely connected to metatypes is the &quot;Don Beaudry
hook&quot;, which says that if a metatype is callable, its instances
(which are regular types) can be subclassed (really subtyped)
using a Python class statement.  I will use this rule to support
subtyping of built-in types, and in fact it greatly simplifies the
logic of class creation to always simply call the metatype.  When
no base class is specified, a default metatype is called -- the
default metatype is the &quot;ClassType&quot; object, so the class statement
will behave as before in the normal case.  (This default can be
changed per module by setting the global variable <tt class="docutils literal">__metaclass__</tt>.)</p>
<p>Python uses the concept of metatypes or metaclasses in a different
way than Smalltalk.  In Smalltalk-80, there is a hierarchy of
metaclasses that mirrors the hierarchy of regular classes,
metaclasses map 1-1 to classes (except for some funny business at
the root of the hierarchy), and each class statement creates both
a regular class and its metaclass, putting class methods in the
metaclass and instance methods in the regular class.</p>
<p>Nice though this may be in the context of Smalltalk, it's not
compatible with the traditional use of metatypes in Python, and I
prefer to continue in the Python way.  This means that Python
metatypes are typically written in C, and may be shared between
many regular types. (It will be possible to subtype metatypes in
Python, so it won't be absolutely necessary to write C to use
metatypes; but the power of Python metatypes will be limited.  For
example, Python code will never be allowed to allocate raw memory
and initialize it at will.)</p>
<p>Metatypes determine various <strong>policies</strong> for types, such as what
happens when a type is called, how dynamic types are (whether a
type's <tt class="docutils literal">__dict__</tt> can be modified after it is created), what the
method resolution order is, how instance attributes are looked
up, and so on.</p>
<p>I'll argue that left-to-right depth-first is not the best
solution when you want to get the most use from multiple
inheritance.</p>
<p>I'll argue that with multiple inheritance, the metatype of the
subtype must be a descendant of the metatypes of all base types.</p>
<p>I'll come back to metatypes later.</p>
</div>
<div class="section" id="making-a-type-a-factory-for-its-instances">
<h1><a class="toc-backref" href="#id7">Making a type a factory for its instances</a></h1>
<p>Traditionally, for each type there is at least one C factory
function that creates instances of the type (<tt class="docutils literal">PyTuple_New()</tt>,
<tt class="docutils literal">PyInt_FromLong()</tt> and so on).  These factory functions take care of
both allocating memory for the object and initializing that
memory.  As of Python 2.0, they also have to interface with the
garbage collection subsystem, if the type chooses to participate
in garbage collection (which is optional, but strongly recommended
for so-called &quot;container&quot; types: types that may contain references
to other objects, and hence may participate in reference cycles).</p>
<p>In this proposal, type objects can be factory functions for their
instances, making the types directly callable from Python.  This
mimics the way classes are instantiated.  The C APIs for creating
instances of various built-in types will remain valid and in some
cases more efficient.  Not all types will become their own factory
functions.</p>
<p>The type object has a new slot, tp_new, which can act as a factory
for instances of the type.  Types are now callable, because the
tp_call slot is set in <tt class="docutils literal">PyType_Type</tt> (the metatype); the function
looks for the tp_new slot of the type that is being called.</p>
<p>Explanation: the <tt class="docutils literal">tp_call</tt> slot of a regular type object (such as
<tt class="docutils literal">PyInt_Type</tt> or <tt class="docutils literal">PyList_Type</tt>) defines what happens when <strong>instances</strong>
of that type are called; in particular, the <tt class="docutils literal">tp_call</tt> slot in the
function type, <tt class="docutils literal">PyFunction_Type</tt>, is the key to making functions
callable.  As another example, <tt class="docutils literal">PyInt_Type.tp_call</tt> is <tt class="docutils literal">NULL</tt>, because
integers are not callable.  The new paradigm makes <strong>type objects</strong>
callable.  Since type objects are instances of their metatype
(<tt class="docutils literal">PyType_Type</tt>), the metatype's <tt class="docutils literal">tp_call</tt> slot (<tt class="docutils literal">PyType_Type.tp_call</tt>)
points to a function that is invoked when any type object is
called.  Now, since each type has to do something different to
create an instance of itself, <tt class="docutils literal">PyType_Type.tp_call</tt> immediately
defers to the <tt class="docutils literal">tp_new</tt> slot of the type that is being called.
<tt class="docutils literal">PyType_Type</tt> itself is also callable: its <tt class="docutils literal">tp_new</tt> slot creates a new
type.  This is used by the class statement (formalizing the Don
Beaudry hook, see above).  And what makes <tt class="docutils literal">PyType_Type</tt> callable?
The <tt class="docutils literal">tp_call</tt> slot of <strong>its</strong> metatype -- but since it is its own
metatype, that is its own <tt class="docutils literal">tp_call</tt> slot!</p>
<p>If the type's <tt class="docutils literal">tp_new</tt> slot is NULL, an exception is raised.
Otherwise, the tp_new slot is called.  The signature for the
<tt class="docutils literal">tp_new</tt> slot is</p>
<pre class="literal-block">
PyObject *tp_new(PyTypeObject *type,
                 PyObject *args,
                 PyObject *kwds)
</pre>
<p>where 'type' is the type whose <tt class="docutils literal">tp_new</tt> slot is called, and 'args'
and 'kwds' are the sequential and keyword arguments to the call,
passed unchanged from tp_call.  (The 'type' argument is used in
combination with inheritance, see below.)</p>
<p>There are no constraints on the object type that is returned,
although by convention it should be an instance of the given
type.  It is not necessary that a new object is returned; a
reference to an existing object is fine too.  The return value
should always be a new reference, owned by the caller.</p>
<p>Once the <tt class="docutils literal">tp_new</tt> slot has returned an object, further initialization
is attempted by calling the <tt class="docutils literal">tp_init()</tt> slot of the resulting
object's type, if not NULL.  This has the following signature:</p>
<pre class="literal-block">
int tp_init(PyObject *self,
            PyObject *args,
            PyObject *kwds)
</pre>
<p>It corresponds more closely to the <tt class="docutils literal">__init__()</tt> method of classic
classes, and in fact is mapped to that by the slot/special-method
correspondence rules.  The difference in responsibilities between
the <tt class="docutils literal">tp_new()</tt> slot and the <tt class="docutils literal">tp_init()</tt> slot lies in the invariants
they ensure.  The <tt class="docutils literal">tp_new()</tt> slot should ensure only the most
essential invariants, without which the C code that implements the
objects would break.  The <tt class="docutils literal">tp_init()</tt> slot should be used for
overridable user-specific initializations.  Take for example the
dictionary type.  The implementation has an internal pointer to a
hash table which should never be NULL.  This invariant is taken
care of by the <tt class="docutils literal">tp_new()</tt> slot for dictionaries.  The dictionary
<tt class="docutils literal">tp_init()</tt> slot, on the other hand, could be used to give the
dictionary an initial set of keys and values based on the
arguments passed in.</p>
<p>Note that for immutable object types, the initialization cannot be
done by the <tt class="docutils literal">tp_init()</tt> slot: this would provide the Python user
with a way to change the initialization.  Therefore, immutable
objects typically have an empty <tt class="docutils literal">tp_init()</tt> implementation and do
all their initialization in their <tt class="docutils literal">tp_new()</tt> slot.</p>
<p>You may wonder why the <tt class="docutils literal">tp_new()</tt> slot shouldn't call the <tt class="docutils literal">tp_init()</tt>
slot itself.  The reason is that in certain circumstances (like
support for persistent objects), it is important to be able to
create an object of a particular type without initializing it any
further than necessary.  This may conveniently be done by calling
the <tt class="docutils literal">tp_new()</tt> slot without calling <tt class="docutils literal">tp_init()</tt>.  It is also possible
that <tt class="docutils literal">tp_init()</tt> is not called, or called more than once -- its
operation should be robust even in these anomalous cases.</p>
<p>For some objects, <tt class="docutils literal">tp_new()</tt> may return an existing object.  For
example, the factory function for integers caches the integers -1
through 99.  This is permissible only when the type argument to
<tt class="docutils literal">tp_new()</tt> is the type that defined the <tt class="docutils literal">tp_new()</tt> function (in the
example, if <tt class="docutils literal">type == &amp;PyInt_Type</tt>), and when the <tt class="docutils literal">tp_init()</tt> slot for
this type does nothing.  If the type argument differs, the
<tt class="docutils literal">tp_new()</tt> call is initiated by a derived type's <tt class="docutils literal">tp_new()</tt> to
create the object and initialize the base type portion of the
object; in this case <tt class="docutils literal">tp_new()</tt> should always return a new object
(or raise an exception).</p>
<p>Both <tt class="docutils literal">tp_new()</tt> and <tt class="docutils literal">tp_init()</tt> should receive exactly the same 'args'
and 'kwds' arguments, and both should check that the arguments are
acceptable, because they may be called independently.</p>
<p>There's a third slot related to object creation: <tt class="docutils literal">tp_alloc()</tt>.  Its
responsibility is to allocate the memory for the object,
initialize the reference count (<tt class="docutils literal">ob_refcnt</tt>) and the type pointer
(<tt class="docutils literal">ob_type</tt>), and initialize the rest of the object to all zeros.  It
should also register the object with the garbage collection
subsystem if the type supports garbage collection.  This slot
exists so that derived types can override the memory allocation
policy (like which heap is being used) separately from the
initialization code.  The signature is:</p>
<pre class="literal-block">
PyObject *tp_alloc(PyTypeObject *type, int nitems)
</pre>
<p>The type argument is the type of the new object.  The nitems
argument is normally zero, except for objects with a variable
allocation size (basically strings, tuples, and longs).  The
allocation size is given by the following expression:</p>
<pre class="literal-block">
type-&gt;tp_basicsize  +  nitems * type-&gt;tp_itemsize
</pre>
<p>The <tt class="docutils literal">tp_alloc</tt> slot is only used for subclassable types.  The <tt class="docutils literal">tp_new()</tt>
function of the base class must call the <tt class="docutils literal">tp_alloc()</tt> slot of the
type passed in as its first argument.  It is the <tt class="docutils literal">tp_new()</tt>
function's responsibility to calculate the number of items.  The
<tt class="docutils literal">tp_alloc()</tt> slot will set the ob_size member of the new object if
the <tt class="docutils literal"><span class="pre">type-&gt;tp_itemsize</span></tt> member is nonzero.</p>
<p>(Note: in certain debugging compilation modes, the type structure
used to have members named <tt class="docutils literal">tp_alloc</tt> and a <tt class="docutils literal">tp_free</tt> slot already,
counters for the number of allocations and deallocations.  These
are renamed to <tt class="docutils literal">tp_allocs</tt> and <tt class="docutils literal">tp_deallocs</tt>.)</p>
<p>Standard implementations for <tt class="docutils literal">tp_alloc()</tt> and <tt class="docutils literal">tp_new()</tt> are
available.  <tt class="docutils literal">PyType_GenericAlloc()</tt> allocates an object from the
standard heap and initializes it properly.  It uses the above
formula to determine the amount of memory to allocate, and takes
care of GC registration.  The only reason not to use this
implementation would be to allocate objects from a different heap
(as is done by some very small frequently used objects like ints
and tuples).  <tt class="docutils literal">PyType_GenericNew()</tt> adds very little: it just calls
the type's <tt class="docutils literal">tp_alloc()</tt> slot with zero for nitems.  But for mutable
types that do all their initialization in their <tt class="docutils literal">tp_init()</tt> slot,
this may be just the ticket.</p>
</div>
<div class="section" id="preparing-a-type-for-subtyping">
<h1><a class="toc-backref" href="#id8">Preparing a type for subtyping</a></h1>
<p>The idea behind subtyping is very similar to that of single
inheritance in C++.  A base type is described by a structure
declaration (similar to the C++ class declaration) plus a type
object (similar to the C++ vtable).  A derived type can extend the
structure (but must leave the names, order and type of the members
of the base structure unchanged) and can override certain slots in
the type object, leaving others the same.  (Unlike C++ vtables,
all Python type objects have the same memory layout.)</p>
<p>The base type must do the following:</p>
<ul class="simple">
<li>Add the flag value <tt class="docutils literal">Py_TPFLAGS_BASETYPE</tt> to <tt class="docutils literal">tp_flags</tt>.</li>
<li>Declare and use <tt class="docutils literal">tp_new()</tt>, <tt class="docutils literal">tp_alloc()</tt> and optional <tt class="docutils literal">tp_init()</tt>
slots.</li>
<li>Declare and use <tt class="docutils literal">tp_dealloc()</tt> and <tt class="docutils literal">tp_free()</tt>.</li>
<li>Export its object structure declaration.</li>
<li>Export a subtyping-aware type-checking macro.</li>
</ul>
<p>The requirements and signatures for <tt class="docutils literal">tp_new()</tt>, <tt class="docutils literal">tp_alloc()</tt> and
<tt class="docutils literal">tp_init()</tt> have already been discussed above: <tt class="docutils literal">tp_alloc()</tt> should
allocate the memory and initialize it to mostly zeros; <tt class="docutils literal">tp_new()</tt>
should call the <tt class="docutils literal">tp_alloc()</tt> slot and then proceed to do the
minimally required initialization; <tt class="docutils literal">tp_init()</tt> should be used for
more extensive initialization of mutable objects.</p>
<p>It should come as no surprise that there are similar conventions
at the end of an object's lifetime.  The slots involved are
<tt class="docutils literal">tp_dealloc()</tt> (familiar to all who have ever implemented a Python
extension type) and <tt class="docutils literal">tp_free()</tt>, the new kid on the block.  (The
names aren't quite symmetric; <tt class="docutils literal">tp_free()</tt> corresponds to <tt class="docutils literal">tp_alloc()</tt>,
which is fine, but <tt class="docutils literal">tp_dealloc()</tt> corresponds to <tt class="docutils literal">tp_new()</tt>.  Maybe
the tp_dealloc slot should be renamed?)</p>
<p>The <tt class="docutils literal">tp_free()</tt> slot should be used to free the memory and
unregister the object with the garbage collection subsystem, and
can be overridden by a derived class; <tt class="docutils literal">tp_dealloc()</tt> should
deinitialize the object (usually by calling <tt class="docutils literal">Py_XDECREF()</tt> for
various sub-objects) and then call <tt class="docutils literal">tp_free()</tt> to deallocate the
memory.  The signature for <tt class="docutils literal">tp_dealloc()</tt> is the same as it always
was:</p>
<pre class="literal-block">
void tp_dealloc(PyObject *object)
</pre>
<p>The signature for tp_free() is the same:</p>
<pre class="literal-block">
void tp_free(PyObject *object)
</pre>
<p>(In a previous version of this PEP, there was also a role reserved
for the <tt class="docutils literal">tp_clear()</tt> slot.  This turned out to be a bad idea.)</p>
<p>To be usefully subtyped in C, a type must export the structure
declaration for its instances through a header file, as it is
needed to derive a subtype.  The type object for the base type
must also be exported.</p>
<p>If the base type has a type-checking macro (like <tt class="docutils literal">PyDict_Check()</tt>),
this macro should be made to recognize subtypes.  This can be done
by using the new <tt class="docutils literal">PyObject_TypeCheck(object, type)</tt> macro, which
calls a function that follows the base class links.</p>
<p>The <tt class="docutils literal">PyObject_TypeCheck()</tt> macro contains a slight optimization: it
first compares <tt class="docutils literal"><span class="pre">object-&gt;ob_type</span></tt> directly to the type argument, and
if this is a match, bypasses the function call.  This should make
it fast enough for most situations.</p>
<p>Note that this change in the type-checking macro means that C
functions that require an instance of the base type may be invoked
with instances of the derived type.  Before enabling subtyping of
a particular type, its code should be checked to make sure that
this won't break anything.  It has proved useful in the prototype
to add another type-checking macro for the built-in Python object
types, to check for exact type match too (for example,
<tt class="docutils literal">PyDict_Check(x)</tt> is true if x is an instance of dictionary or of a
dictionary subclass, while <tt class="docutils literal">PyDict_CheckExact(x)</tt> is true only if x
is a dictionary).</p>
</div>
<div class="section" id="creating-a-subtype-of-a-built-in-type-in-c">
<h1><a class="toc-backref" href="#id9">Creating a subtype of a built-in type in C</a></h1>
<p>The simplest form of subtyping is subtyping in C.  It is the
simplest form because we can require the C code to be aware of
some of the problems, and it's acceptable for C code that doesn't
follow the rules to dump core.  For added simplicity, it is
limited to single inheritance.</p>
<p>Let's assume we're deriving from a mutable base type whose
tp_itemsize is zero.  The subtype code is not GC-aware, although
it may inherit GC-awareness from the base type (this is
automatic).  The base type's allocation uses the standard heap.</p>
<p>The derived type begins by declaring a type structure which
contains the base type's structure.  For example, here's the type
structure for a subtype of the built-in list type:</p>
<pre class="literal-block">
typedef struct {
    PyListObject list;
    int state;
} spamlistobject;
</pre>
<p>Note that the base type structure member (here <tt class="docutils literal">PyListObject</tt>) must
be the first member of the structure; any following members are
additions.  Also note that the base type is not referenced via a
pointer; the actual contents of its structure must be included!
(The goal is for the memory layout of the beginning of the
subtype instance to be the same as that of the base type
instance.)</p>
<p>Next, the derived type must declare a type object and initialize
it.  Most of the slots in the type object may be initialized to
zero, which is a signal that the base type slot must be copied
into it.  Some slots that must be initialized properly:</p>
<ul class="simple">
<li>The object header must be filled in as usual; the type should
be <tt class="docutils literal">&amp;PyType_Type</tt>.</li>
<li>The tp_basicsize slot must be set to the size of the subtype
instance struct (in the above example: <tt class="docutils literal">sizeof(spamlistobject)</tt>).</li>
<li>The tp_base slot must be set to the address of the base type's
type object.</li>
<li>If the derived slot defines any pointer members, the
<tt class="docutils literal">tp_dealloc</tt> slot function requires special attention, see
below; otherwise, it can be set to zero, to inherit the base
type's deallocation function.</li>
<li>The <tt class="docutils literal">tp_flags</tt> slot must be set to the usual <tt class="docutils literal">Py_TPFLAGS_DEFAULT</tt>
value.</li>
<li>The <tt class="docutils literal">tp_name</tt> slot must be set; it is recommended to set <tt class="docutils literal">tp_doc</tt>
as well (these are not inherited).</li>
</ul>
<p>If the subtype defines no additional structure members (it only
defines new behavior, no new data), the <tt class="docutils literal">tp_basicsize</tt> and the
<tt class="docutils literal">tp_dealloc</tt> slots may be left set to zero.</p>
<p>The subtype's <tt class="docutils literal">tp_dealloc</tt> slot deserves special attention.  If the
derived type defines no additional pointer members that need to be
DECREF'ed or freed when the object is deallocated, it can be set
to zero.  Otherwise, the subtype's <tt class="docutils literal">tp_dealloc()</tt> function must call
<tt class="docutils literal">Py_XDECREF()</tt> for any <tt class="docutils literal">PyObject *</tt> members and the correct memory
freeing function for any other pointers it owns, and then call the
base class's <tt class="docutils literal">tp_dealloc()</tt> slot.  This call has to be made via the
base type's type structure, for example, when deriving from the
standard list type:</p>
<pre class="literal-block">
PyList_Type.tp_dealloc(self);
</pre>
<p>If the subtype wants to use a different allocation heap than the
base type, the subtype must override both the <tt class="docutils literal">tp_alloc()</tt> and the
<tt class="docutils literal">tp_free()</tt> slots.  These will be called by the base class's
<tt class="docutils literal">tp_new()</tt> and <tt class="docutils literal">tp_dealloc()</tt> slots, respectively.</p>
<p>To complete the initialization of the type, <tt class="docutils literal">PyType_InitDict()</tt> must
be called.  This replaces slots initialized to zero in the subtype
with the value of the corresponding base type slots.  (It also
fills in <tt class="docutils literal">tp_dict</tt>, the type's dictionary, and does various other
initializations necessary for type objects.)</p>
<p>A subtype is not usable until <tt class="docutils literal">PyType_InitDict()</tt> is called for it;
this is best done during module initialization, assuming the
subtype belongs to a module.  An alternative for subtypes added to
the Python core (which don't live in a particular module) would be
to initialize the subtype in their constructor function.  It is
allowed to call <tt class="docutils literal">PyType_InitDict()</tt> more than once; the second and
further calls have no effect.  To avoid unnecessary calls, a test
for <tt class="docutils literal"><span class="pre">tp_dict==NULL</span></tt> can be made.</p>
<p>(During initialization of the Python interpreter, some types are
actually used before they are initialized.  As long as the slots
that are actually needed are initialized, especially <tt class="docutils literal">tp_dealloc</tt>,
this works, but it is fragile and not recommended as a general
practice.)</p>
<p>To create a subtype instance, the subtype's <tt class="docutils literal">tp_new()</tt> slot is
called.  This should first call the base type's <tt class="docutils literal">tp_new()</tt> slot and
then initialize the subtype's additional data members.  To further
initialize the instance, the <tt class="docutils literal">tp_init()</tt> slot is typically called.
Note that the <tt class="docutils literal">tp_new()</tt> slot should <strong>not</strong> call the <tt class="docutils literal">tp_init()</tt> slot;
this is up to <tt class="docutils literal">tp_new()</tt>'s caller (typically a factory function).
There are circumstances where it is appropriate not to call
<tt class="docutils literal">tp_init()</tt>.</p>
<p>If a subtype defines a <tt class="docutils literal">tp_init()</tt> slot, the <tt class="docutils literal">tp_init()</tt> slot should
normally first call the base type's <tt class="docutils literal">tp_init()</tt> slot.</p>
<p>(XXX There should be a paragraph or two about argument passing
here.)</p>
</div>
<div class="section" id="subtyping-in-python">
<h1><a class="toc-backref" href="#id10">Subtyping in Python</a></h1>
<p>The next step is to allow subtyping of selected built-in types
through a class statement in Python.  Limiting ourselves to single
inheritance for now, here is what happens for a simple class
statement:</p>
<pre class="literal-block">
class C(B):
    var1 = 1
    def method1(self): pass
    # etc.
</pre>
<p>The body of the class statement is executed in a fresh environment
(basically, a new dictionary used as local namespace), and then C
is created.  The following explains how C is created.</p>
<p>Assume B is a type object.  Since type objects are objects, and
every object has a type, B has a type.  Since B is itself a type,
we also call its type its metatype.  B's metatype is accessible
via <tt class="docutils literal">type(B)</tt> or <tt class="docutils literal">B.__class__</tt> (the latter notation is new for types;
it is introduced in <a class="reference external" href="/dev/peps/pep-0252">PEP 252</a>).  Let's say this metatype is M (for
Metatype).  The class statement will create a new type, C.  Since
C will be a type object just like B, we view the creation of C as
an instantiation of the metatype, M.  The information that needs
to be provided for the creation of a subclass is:</p>
<ul class="simple">
<li>its name (in this example the string &quot;C&quot;);</li>
<li>its bases (a singleton tuple containing B);</li>
<li>the results of executing the class body, in the form of a
dictionary (for example
<tt class="docutils literal">{&quot;var1&quot;: 1, &quot;method1&quot;: &lt;functionmethod1 at <span class="pre">...&gt;,</span> <span class="pre">...}</span></tt>).</li>
</ul>
<p>The class statement will result in the following call:</p>
<pre class="literal-block">
C = M(&quot;C&quot;, (B,), dict)
</pre>
<p>where dict is the dictionary resulting from execution of the
class body.  In other words, the metatype (M) is called.</p>
<p>Note that even though the example has only one base, we still pass
in a (singleton) sequence of bases; this makes the interface
uniform with the multiple-inheritance case.</p>
<p>In current Python, this is called the &quot;Don Beaudry hook&quot; after its
inventor; it is an exceptional case that is only invoked when a
base class is not a regular class.  For a regular base class (or
when no base class is specified), current Python calls
<tt class="docutils literal">PyClass_New()</tt>, the C level factory function for classes, directly.</p>
<p>Under the new system this is changed so that Python <strong>always</strong>
determines a metatype and calls it as given above.  When one or
more bases are given, the type of the first base is used as the
metatype; when no base is given, a default metatype is chosen.  By
setting the default metatype to <tt class="docutils literal">PyClass_Type</tt>, the metatype of
&quot;classic&quot; classes, the classic behavior of the class statement is
retained.  This default can be changed per module by setting the
global variable <tt class="docutils literal">__metaclass__</tt>.</p>
<p>There are two further refinements here.  First, a useful feature
is to be able to specify a metatype directly.  If the class
suite defines a variable <tt class="docutils literal">__metaclass__</tt>, that is the metatype
to call.  (Note that setting <tt class="docutils literal">__metaclass__</tt> at the module level
only affects class statements without a base class and without an
explicit <tt class="docutils literal">__metaclass__</tt> declaration; but setting <tt class="docutils literal">__metaclass__</tt> in a
class suite overrides the default metatype unconditionally.)</p>
<p>Second, with multiple bases, not all bases need to have the same
metatype.  This is called a metaclass conflict <a class="footnote-reference" href="#id3" id="id1">[1]</a>.  Some
metaclass conflicts can be resolved by searching through the set
of bases for a metatype that derives from all other given
metatypes.  If such a metatype cannot be found, an exception is
raised and the class statement fails.</p>
<p>This conflict resolution can be implemented by the metatype
constructors: the class statement just calls the metatype of the first
base (or that specified by the <tt class="docutils literal">__metaclass__</tt> variable), and this
metatype's constructor looks for the most derived metatype.  If
that is itself, it proceeds; otherwise, it calls that metatype's
constructor.  (Ultimate flexibility: another metatype might choose
to require that all bases have the same metatype, or that there's
only one base class, or whatever.)</p>
<p>(In <a class="footnote-reference" href="#id3" id="id2">[1]</a>, a new metaclass is automatically derived that is a
subclass of all given metaclasses.  But since it is questionable
in Python how conflicting method definitions of the various
metaclasses should be merged, I don't think this is feasible.
Should the need arise, the user can derive such a metaclass
manually and specify it using the <tt class="docutils literal">__metaclass__</tt> variable.  It is
also possible to have a new metaclass that does this.)</p>
<p>Note that calling M requires that M itself has a type: the
meta-metatype.  And the meta-metatype has a type, the
meta-meta-metatype.  And so on.  This is normally cut short at
some level by making a metatype be its own metatype.  This is
indeed what happens in Python: the <tt class="docutils literal">ob_type</tt> reference in
<tt class="docutils literal">PyType_Type</tt> is set to <tt class="docutils literal">&amp;PyType_Type</tt>.  In the absence of third party
metatypes, <tt class="docutils literal">PyType_Type</tt> is the only metatype in the Python
interpreter.</p>
<p>(In a previous version of this PEP, there was one additional
meta-level, and there was a meta-metatype called &quot;turtle&quot;.  This
turned out to be unnecessary.)</p>
<p>In any case, the work for creating C is done by M's <tt class="docutils literal">tp_new()</tt> slot.
It allocates space for an &quot;extended&quot; type structure, containing:
the type object; the auxiliary structures (as_sequence etc.); the
string object containing the type name (to ensure that this object
isn't deallocated while the type object is still referencing it); and
some auxiliary storage (to be described later).  It initializes this
storage to zeros except for a few crucial slots (for example, tp_name
is set to point to the type name) and then sets the tp_base slot to
point to B.  Then <tt class="docutils literal">PyType_InitDict()</tt> is called to inherit B's slots.
Finally, C's <tt class="docutils literal">tp_dict</tt> slot is updated with the contents of the
namespace dictionary (the third argument to the call to M).</p>
</div>
<div class="section" id="multiple-inheritance">
<h1><a class="toc-backref" href="#id11">Multiple inheritance</a></h1>
<p>The Python class statement supports multiple inheritance, and we
will also support multiple inheritance involving built-in types.</p>
<p>However, there are some restrictions.  The C runtime architecture
doesn't make it feasible to have a meaningful subtype of two
different built-in types except in a few degenerate cases.
Changing the C runtime to support fully general multiple
inheritance would be too much of an upheaval of the code base.</p>
<p>The main problem with multiple inheritance from different built-in
types stems from the fact that the C implementation of built-in
types accesses structure members directly; the C compiler
generates an offset relative to the object pointer and that's
that.  For example, the list and dictionary type structures each
declare a number of different but overlapping structure members.
A C function accessing an object expecting a list won't work when
passed a dictionary, and vice versa, and there's not much we could
do about this without rewriting all code that accesses lists and
dictionaries.  This would be too much work, so we won't do this.</p>
<p>The problem with multiple inheritance is caused by conflicting
structure member allocations.  Classes defined in Python normally
don't store their instance variables in structure members: they
are stored in an instance dictionary.  This is the key to a
partial solution.  Suppose we have the following two classes:</p>
<pre class="literal-block">
class A(dictionary):
    def foo(self): pass

class B(dictionary):
    def bar(self): pass

class C(A, B): pass
</pre>
<p>(Here, 'dictionary' is the type of built-in dictionary objects,
a.k.a. <tt class="docutils literal"><span class="pre">type({})</span></tt> or <tt class="docutils literal"><span class="pre">{}.__class__</span></tt> or <tt class="docutils literal">types.DictType</tt>.)  If we look at
the structure layout, we find that an A instance has the layout
of a dictionary followed by the <tt class="docutils literal">__dict__</tt> pointer, and a B instance
has the same layout; since there are no structure member layout
conflicts, this is okay.</p>
<p>Here's another example:</p>
<pre class="literal-block">
class X(object):
    def foo(self): pass

class Y(dictionary):
    def bar(self): pass

class Z(X, Y): pass
</pre>
<p>(Here, 'object' is the base for all built-in types; its structure
layout only contains the <tt class="docutils literal">ob_refcnt</tt> and <tt class="docutils literal">ob_type</tt> members.)  This
example is more complicated, because the <tt class="docutils literal">__dict__</tt> pointer for X
instances has a different offset than that for Y instances.  Where
is the <tt class="docutils literal">__dict__</tt> pointer for Z instances?  The answer is that the
offset for the <tt class="docutils literal">__dict__</tt> pointer is not hardcoded, it is stored in
the type object.</p>
<p>Suppose on a particular machine an 'object' structure is 8 bytes
long, and a 'dictionary' struct is 60 bytes, and an object pointer
is 4 bytes.  Then an X structure is 12 bytes (an object structure
followed by a <tt class="docutils literal">__dict__</tt> pointer), and a Y structure is 64 bytes (a
dictionary structure followed by a <tt class="docutils literal">__dict__</tt> pointer).  The Z
structure has the same layout as the Y structure in this example.
Each type object (X, Y and Z) has a &quot;__dict__ offset&quot; which is
used to find the <tt class="docutils literal">__dict__</tt> pointer.  Thus, the recipe for looking
up an instance variable is:</p>
<ol class="arabic simple">
<li>get the type of the instance</li>
<li>get the <tt class="docutils literal">__dict__</tt> offset from the type object</li>
<li>add the <tt class="docutils literal">__dict__</tt> offset to the instance pointer</li>
<li>look in the resulting address to find a dictionary reference</li>
<li>look up the instance variable name in that dictionary</li>
</ol>
<p>Of course, this recipe can only be implemented in C, and I have
left out some details.  But this allows us to use multiple
inheritance patterns similar to the ones we can use with classic
classes.</p>
<p>XXX I should write up the complete algorithm here to determine
base class compatibility, but I can't be bothered right now.  Look
at <tt class="docutils literal">best_base()</tt> in typeobject.c in the implementation mentioned
below.</p>
</div>
<div class="section" id="mro-method-resolution-order-the-lookup-rule">
<h1><a class="toc-backref" href="#id12">MRO:  Method resolution order (the lookup rule)</a></h1>
<p>With multiple inheritance comes the question of method resolution
order: the order in which a class or type and its bases are
searched looking for a method of a given name.</p>
<p>In classic Python, the rule is given by the following recursive
function, also known as the left-to-right depth-first rule:</p>
<pre class="literal-block">
def classic_lookup(cls, name):
    if cls.__dict__.has_key(name):
        return cls.__dict__[name]
    for base in cls.__bases__:
        try:
            return classic_lookup(base, name)
        except AttributeError:
            pass
    raise AttributeError, name
</pre>
<p>The problem with this becomes apparent when we consider a &quot;diamond
diagram&quot;:</p>
<pre class="literal-block">
      class A:
        ^ ^  def save(self): ...
       /   \
      /     \
     /       \
    /         \
class B     class C:
    ^         ^  def save(self): ...
     \       /
      \     /
       \   /
        \ /
      class D
</pre>
<p>Arrows point from a subtype to its base <tt class="docutils literal">type(s)</tt>.  This particular
diagram means B and C derive from A, and D derives from B and C
(and hence also, indirectly, from A).</p>
<p>Assume that C overrides the method <tt class="docutils literal">save()</tt>, which is defined in the
base A.  (<tt class="docutils literal">C.save()</tt> probably calls <tt class="docutils literal">A.save()</tt> and then saves some of
its own state.)  B and D don't override <tt class="docutils literal">save()</tt>.  When we invoke
<tt class="docutils literal">save()</tt> on a D instance, which method is called?  According to the
classic lookup rule, <tt class="docutils literal">A.save()</tt> is called, ignoring <tt class="docutils literal">C.save()</tt>!</p>
<p>This is not good.  It probably breaks C (its state doesn't get
saved), defeating the whole purpose of inheriting from C in the
first place.</p>
<p>Why was this not a problem in classic Python?  Diamond diagrams
are rarely found in classic Python class hierarchies.  Most class
hierarchies use single inheritance, and multiple inheritance is
usually confined to mix-in classes.  In fact, the problem shown
here is probably the reason why multiple inheritance is unpopular
in classic Python.</p>
<p>Why will this be a problem in the new system?  The 'object' type
at the top of the type hierarchy defines a number of methods that
can usefully be extended by subtypes, for example <tt class="docutils literal">__getattr__()</tt>.</p>
<p>(Aside: in classic Python, the <tt class="docutils literal">__getattr__()</tt> method is not really
the implementation for the get-attribute operation; it is a hook
that only gets invoked when an attribute cannot be found by normal
means.  This has often been cited as a shortcoming -- some class
designs have a legitimate need for a <tt class="docutils literal">__getattr__()</tt> method that
gets called for <strong>all</strong> attribute references.  But then of course
this method has to be able to invoke the default implementation
directly.  The most natural way is to make the default
implementation available as <tt class="docutils literal">object.__getattr__(self, name)</tt>.)</p>
<p>Thus, a classic class hierarchy like this:</p>
<pre class="literal-block">
class B     class C:
    ^         ^  def __getattr__(self, name): ...
     \       /
      \     /
       \   /
        \ /
      class D
</pre>
<p>will change into a diamond diagram under the new system:</p>
<pre class="literal-block">
      object:
        ^ ^  __getattr__()
       /   \
      /     \
     /       \
    /         \
class B     class C:
    ^         ^  def __getattr__(self, name): ...
     \       /
      \     /
       \   /
        \ /
      class D
</pre>
<p>and while in the original diagram <tt class="docutils literal">C.__getattr__()</tt> is invoked,
under the new system with the classic lookup rule,
<tt class="docutils literal">object.__getattr__()</tt> would be invoked!</p>
<p>Fortunately, there's a lookup rule that's better.  It's a bit
difficult to explain, but it does the right thing in the diamond
diagram, and it is the same as the classic lookup rule when there
are no diamonds in the inheritance graph (when it is a tree).</p>
<p>The new lookup rule constructs a list of all classes in the
inheritance diagram in the order in which they will be searched.
This construction is done at class definition time to save time.
To explain the new lookup rule, let's first consider what such a
list would look like for the classic lookup rule.  Note that in
the presence of diamonds the classic lookup visits some classes
multiple times.  For example, in the ABCD diamond diagram above,
the classic lookup rule visits the classes in this order:</p>
<pre class="literal-block">
D, B, A, C, A
</pre>
<p>Note how A occurs twice in the list.  The second occurrence is
redundant, since anything that could be found there would already
have been found when searching the first occurrence.</p>
<p>We use this observation to explain our new lookup rule.  Using the
classic lookup rule, construct the list of classes that would be
searched, including duplicates.  Now for each class that occurs in
the list multiple times, remove all occurrences except for the
last.  The resulting list contains each ancestor class exactly
once (including the most derived class, D in the example).</p>
<p>Searching for methods in this order will do the right thing for
the diamond diagram.  Because of the way the list is constructed,
it does not change the search order in situations where no diamond
is involved.</p>
<p>Isn't this backwards incompatible?  Won't it break existing code?
It would, if we changed the method resolution order for all
classes.  However, in Python 2.2, the new lookup rule will only be
applied to types derived from built-in types, which is a new
feature.  Class statements without a base class create &quot;classic
classes&quot;, and so do class statements whose base classes are
themselves classic classes.  For classic classes the classic
lookup rule will be used. (To experiment with the new lookup rule
for classic classes, you will be able to specify a different
metaclass explicitly.)  We'll also provide a tool that analyzes a
class hierarchy looking for methods that would be affected by a
change in method resolution order.</p>
<p>XXX Another way to explain the motivation for the new MRO, due to
Damian Conway: you never use the method defined in a base class if
it is defined in a derived class that you haven't explored yet
(using the old search order).</p>
</div>
<div class="section" id="xxx-to-be-done">
<h1><a class="toc-backref" href="#id13">XXX To be done</a></h1>
<p>Additional topics to be discussed in this PEP:</p>
<ul class="simple">
<li>backwards compatibility issues!!!</li>
<li>class methods and static methods</li>
<li>cooperative methods and <tt class="docutils literal">super()</tt></li>
<li>mapping between type object slots (tp_foo) and special methods
(<tt class="docutils literal">__foo__</tt>) (actually, this may belong in <a class="reference external" href="/dev/peps/pep-0252">PEP 252</a>)</li>
<li>built-in names for built-in types (object, int, str, list etc.)</li>
<li><tt class="docutils literal">__dict__</tt> and <tt class="docutils literal">__dictoffset__</tt></li>
<li><tt class="docutils literal">__slots__</tt></li>
<li>the <tt class="docutils literal">HEAPTYPE</tt> flag bit</li>
<li>GC support</li>
<li>API docs for all the new functions</li>
<li>how to use <tt class="docutils literal">__new__</tt></li>
<li>writing metaclasses (using <tt class="docutils literal">mro()</tt> etc.)</li>
<li>high level user overview</li>
</ul>
<div class="section" id="open-issues">
<h2><a class="toc-backref" href="#id14">open issues</a></h2>
<ul class="simple">
<li>do we need <tt class="docutils literal">__del__</tt>?</li>
<li>assignment to <tt class="docutils literal">__dict__</tt>, <tt class="docutils literal">__bases__</tt></li>
<li>inconsistent naming
(e.g. tp_dealloc/tp_new/tp_init/tp_alloc/tp_free)</li>
<li>add builtin alias 'dict' for 'dictionary'?</li>
<li>when subclasses of dict/list etc. are passed to system
functions, the <tt class="docutils literal">__getitem__</tt> overrides (etc.) aren't always
used</li>
</ul>
</div>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id15">Implementation</a></h1>
<p>A prototype implementation of this PEP (and for <a class="reference external" href="/dev/peps/pep-0252">PEP 252</a>) is
available from CVS, and in the series of Python 2.2 alpha and beta
releases.  For some examples of the features described here, see
the file Lib/test/test_descr.py and the extension module
Modules/xxsubtype.c.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id16">References</a></h1>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>)</em> &quot;Putting Metaclasses to Work&quot;, by Ira R. Forman and Scott
H. Danforth, Addison-Wesley 1999.
(<a class="reference external" href="http://www.aw.com/product/0,2627,0201433052,00.html">http://www.aw.com/product/0,2627,0201433052,00.html</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id17">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

