<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">3114</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Renaming iterator.next() to iterator.__next__()</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-3114.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Ka-Ping Yee &lt;ping&#32;&#97;t&#32;zesty.ca&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">04-Mar-2007</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.0</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id13">Abstract</a></li>
<li><a class="reference internal" href="#names-with-double-underscores" id="id14">Names With Double Underscores</a></li>
<li><a class="reference internal" href="#double-underscore-methods-and-built-in-functions" id="id15">Double-Underscore Methods and Built-In Functions</a></li>
<li><a class="reference internal" href="#previous-proposals" id="id16">Previous Proposals</a></li>
<li><a class="reference internal" href="#objections" id="id17">Objections</a></li>
<li><a class="reference internal" href="#transition-plan" id="id18">Transition Plan</a></li>
<li><a class="reference internal" href="#approval" id="id19">Approval</a></li>
<li><a class="reference internal" href="#implementation" id="id20">Implementation</a></li>
<li><a class="reference internal" href="#references" id="id21">References</a></li>
<li><a class="reference internal" href="#copyright" id="id22">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id13">Abstract</a></h1>
<p>The iterator protocol in Python 2.x consists of two methods:
<tt class="docutils literal">__iter__()</tt> called on an iterable object to yield an iterator, and
<tt class="docutils literal">next()</tt> called on an iterator object to yield the next item in the
sequence.  Using a <tt class="docutils literal">for</tt> loop to iterate over an iterable object
implicitly calls both of these methods.  This PEP proposes that the
<tt class="docutils literal">next</tt> method be renamed to <tt class="docutils literal">__next__</tt>, consistent with all the
other protocols in Python in which a method is implicitly called as
part of a language-level protocol, and that a built-in function named
<tt class="docutils literal">next</tt> be introduced to invoke <tt class="docutils literal">__next__</tt> method, consistent with
the manner in which other protocols are explicitly invoked.</p>
</div>
<div class="section" id="names-with-double-underscores">
<h1><a class="toc-backref" href="#id14">Names With Double Underscores</a></h1>
<p>In Python, double underscores before and after a name are used to
distinguish names that belong to the language itself.  Attributes and
methods that are implicitly used or created by the interpreter employ
this naming convention; some examples are:</p>
<ul class="simple">
<li><tt class="docutils literal">__file__</tt> - an attribute automatically created by the interpreter</li>
<li><tt class="docutils literal">__dict__</tt> - an attribute with special meaning to the interpreter</li>
<li><tt class="docutils literal">__init__</tt> - a method implicitly called by the interpreter</li>
</ul>
<p>Note that this convention applies to methods such as <tt class="docutils literal">__init__</tt> that
are explicitly defined by the programmer, as well as attributes such as
<tt class="docutils literal">__file__</tt> that can only be accessed by naming them explicitly, so it
includes names that are used <em>or</em> created by the interpreter.</p>
<p>(Not all things that are called &quot;protocols&quot; are made of methods with
double-underscore names.  For example, the <tt class="docutils literal">__contains__</tt> method has
double underscores because the language construct <tt class="docutils literal">x in y</tt> implicitly
calls <tt class="docutils literal">__contains__</tt>.  But even though the <tt class="docutils literal">read</tt> method is part of
the file protocol, it does not have double underscores because there is
no language construct that implicitly invokes <tt class="docutils literal">x.read()</tt>.)</p>
<p>The use of double underscores creates a separate namespace for names
that are part of the Python language definition, so that programmers
are free to create variables, attributes, and methods that start with
letters, without fear of silently colliding with names that have a
language-defined purpose.  (Colliding with reserved keywords is still
a concern, but at least this will immediately yield a syntax error.)</p>
<p>The naming of the <tt class="docutils literal">next</tt> method on iterators is an exception to
this convention.  Code that nowhere contains an explicit call to a
<tt class="docutils literal">next</tt> method can nonetheless be silently affected by the presence
of such a method.  Therefore, this PEP proposes that iterators should
have a <tt class="docutils literal">__next__</tt> method instead of a <tt class="docutils literal">next</tt> method (with no
change in semantics).</p>
</div>
<div class="section" id="double-underscore-methods-and-built-in-functions">
<h1><a class="toc-backref" href="#id15">Double-Underscore Methods and Built-In Functions</a></h1>
<p>The Python language defines several protocols that are implemented or
customized by defining methods with double-underscore names.  In each
case, the protocol is provided by an internal method implemented as a
C function in the interpreter.  For objects defined in Python, this
C function supports customization by implicitly invoking a Python method
with a double-underscore name (it often does a little bit of additional
work beyond just calling the Python method.)</p>
<p>Sometimes the protocol is invoked by a syntactic construct:</p>
<ul class="simple">
<li><tt class="docutils literal">x[y]</tt> --&gt; internal <tt class="docutils literal">tp_getitem</tt> --&gt; <tt class="docutils literal">x.__getitem__(y)</tt></li>
<li><tt class="docutils literal">x + y</tt> --&gt; internal <tt class="docutils literal">nb_add</tt> --&gt; <tt class="docutils literal">x.__add__(y)</tt></li>
<li><tt class="docutils literal"><span class="pre">-x</span></tt> --&gt; internal <tt class="docutils literal">nb_negative</tt> --&gt; <tt class="docutils literal">x.__neg__()</tt></li>
</ul>
<p>Sometimes there is no syntactic construct, but it is still useful to be
able to explicitly invoke the protocol.  For such cases Python offers a
built-in function of the same name but without the double underscores.</p>
<ul class="simple">
<li><tt class="docutils literal">len(x)</tt> --&gt; internal <tt class="docutils literal">sq_length</tt> --&gt; <tt class="docutils literal">x.__len__()</tt></li>
<li><tt class="docutils literal">hash(x)</tt> --&gt; internal <tt class="docutils literal">tp_hash</tt> --&gt; <tt class="docutils literal">x.__hash__()</tt></li>
<li><tt class="docutils literal">iter(x)</tt> --&gt; internal <tt class="docutils literal">tp_iter</tt> --&gt; <tt class="docutils literal">x.__iter__()</tt></li>
</ul>
<p>Following this pattern, the natural way to handle <tt class="docutils literal">next</tt> is to add a
<tt class="docutils literal">next</tt> built-in function that behaves in exactly the same fashion.</p>
<ul class="simple">
<li><tt class="docutils literal">next(x)</tt> --&gt; internal <tt class="docutils literal">tp_iternext</tt> --&gt; <tt class="docutils literal">x.__next__()</tt></li>
</ul>
<p>Further, it is proposed that the <tt class="docutils literal">next</tt> built-in function accept a
sentinel value as an optional second argument, following the style of
the <tt class="docutils literal">getattr</tt> and <tt class="docutils literal">iter</tt> built-in functions.  When called with two
arguments, <tt class="docutils literal">next</tt> catches the StopIteration exception and returns
the sentinel value instead of propagating the exception.  This creates
a nice duality between <tt class="docutils literal">iter</tt> and <tt class="docutils literal">next</tt>:</p>
<blockquote>
iter(function, sentinel) &lt;--&gt; next(iterator, sentinel)</blockquote>
</div>
<div class="section" id="previous-proposals">
<h1><a class="toc-backref" href="#id16">Previous Proposals</a></h1>
<p>This proposal is not a new idea.  The idea proposed here was supported
by the BDFL on python-dev <a class="footnote-reference" href="#id7" id="id1">[1]</a> and is even mentioned in the original
iterator PEP, <a class="reference external" href="/dev/peps/pep-0234">PEP 234</a>:</p>
<pre class="literal-block">
(In retrospect, it might have been better to go for __next__()
and have a new built-in, next(it), which calls it.__next__().
But alas, it's too late; this has been deployed in Python 2.2
since December 2001.)
</pre>
</div>
<div class="section" id="objections">
<h1><a class="toc-backref" href="#id17">Objections</a></h1>
<p>There have been a few objections to the addition of more built-ins.
In particular, Martin von Loewis writes <a class="footnote-reference" href="#id8" id="id2">[2]</a>:</p>
<pre class="literal-block">
I dislike the introduction of more builtins unless they have a true
generality (i.e. are likely to be needed in many programs). For this
one, I think the normal usage of __next__ will be with a for loop, so
I don't think one would often need an explicit next() invocation.

It is also not true that most protocols are explicitly invoked through
builtin functions. Instead, most protocols are can be explicitly invoked
through methods in the operator module. So following tradition, it
should be operator.next.

...

As an alternative, I propose that object grows a .next() method,
which calls __next__ by default.
</pre>
</div>
<div class="section" id="transition-plan">
<h1><a class="toc-backref" href="#id18">Transition Plan</a></h1>
<p>Two additional transformations will be added to the 2to3 translation
tool <a class="footnote-reference" href="#id9" id="id3">[3]</a>:</p>
<ul class="simple">
<li>Method definitions named <tt class="docutils literal">next</tt> will be renamed to <tt class="docutils literal">__next__</tt>.</li>
<li>Explicit calls to the <tt class="docutils literal">next</tt> method will be replaced with calls
to the built-in <tt class="docutils literal">next</tt> function.  For example, <tt class="docutils literal">x.next()</tt> will
become <tt class="docutils literal">next(x)</tt>.</li>
</ul>
<p>Collin Winter looked into the possibility of automatically deciding
whether to perform the second transformation depending on the presence
of a module-level binding to <tt class="docutils literal">next</tt> <a class="footnote-reference" href="#id10" id="id4">[4]</a> and found that it would be
&quot;ugly and slow&quot;.  Instead, the translation tool will emit warnings
upon detecting such a binding.  Collin has proposed warnings for the
following conditions <a class="footnote-reference" href="#id11" id="id5">[5]</a>:</p>
<ul class="simple">
<li>Module-level assignments to <tt class="docutils literal">next</tt>.</li>
<li>Module-level definitions of a function named <tt class="docutils literal">next</tt>.</li>
<li>Module-level imports of the name <tt class="docutils literal">next</tt>.</li>
<li>Assignments to <tt class="docutils literal">__builtin__.next</tt>.</li>
</ul>
</div>
<div class="section" id="approval">
<h1><a class="toc-backref" href="#id19">Approval</a></h1>
<p>This PEP was accepted by Guido on March 6, 2007 <a class="footnote-reference" href="#id11" id="id6">[5]</a>.</p>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id20">Implementation</a></h1>
<p>A patch with the necessary changes (except the 2to3 tool) was written
by Georg Brandl and committed as revision 54910.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id21">References</a></h1>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Single- vs. Multi-pass iterability (Guido van Rossum)
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2002-July/026814.html">https://mail.python.org/pipermail/python-dev/2002-July/026814.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>PEP: rename it.next() to it.__next__()... (Martin von Loewis)
<a class="reference external" href="https://mail.python.org/pipermail/python-3000/2007-March/005965.html">https://mail.python.org/pipermail/python-3000/2007-March/005965.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>2to3 refactoring tool
<a class="reference external" href="http://svn.python.org/view/sandbox/trunk/2to3/">http://svn.python.org/view/sandbox/trunk/2to3/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>PEP: rename it.next() to it.__next__()... (Collin Winter)
<a class="reference external" href="https://mail.python.org/pipermail/python-3000/2007-March/006020.html">https://mail.python.org/pipermail/python-3000/2007-March/006020.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td><em>(<a class="fn-backref" href="#id5">1</a>, <a class="fn-backref" href="#id6">2</a>)</em> <a class="reference external" href="/dev/peps/pep-3113">PEP 3113</a> transition plan
<a class="reference external" href="https://mail.python.org/pipermail/python-3000/2007-March/006044.html">https://mail.python.org/pipermail/python-3000/2007-March/006044.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[6]</td><td>PEP: rename it.next() to it.__next__()... (Guido van Rossum)
<a class="reference external" href="https://mail.python.org/pipermail/python-3000/2007-March/006027.html">https://mail.python.org/pipermail/python-3000/2007-March/006027.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id22">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

