<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">358</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">The &quot;bytes&quot; Object</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0358.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Neil Schemenauer &lt;nas&#32;&#97;t&#32;arctrix.com&gt;, Guido van Rossum &lt;guido&#32;&#97;t&#32;python.org&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">15-Feb-2006</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.6, 3.0</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#update" id="id2">Update</a></li>
<li><a class="reference internal" href="#abstract" id="id3">Abstract</a></li>
<li><a class="reference internal" href="#motivation" id="id4">Motivation</a></li>
<li><a class="reference internal" href="#specification" id="id5">Specification</a></li>
<li><a class="reference internal" href="#out-of-scope-issues" id="id6">Out of Scope Issues</a></li>
<li><a class="reference internal" href="#open-issues" id="id7">Open Issues</a></li>
<li><a class="reference internal" href="#frequently-asked-questions" id="id8">Frequently Asked Questions</a></li>
<li><a class="reference internal" href="#copyright" id="id9">Copyright</a></li>
</ul>
</div>
<div class="section" id="update">
<h1><a class="toc-backref" href="#id2">Update</a></h1>
<p>This PEP has partially been superseded by <a class="reference external" href="/dev/peps/pep-3137">PEP 3137</a>.</p>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id3">Abstract</a></h1>
<p>This PEP outlines the introduction of a raw bytes sequence type.
Adding the bytes type is one step in the transition to
Unicode-based str objects which will be introduced in Python 3.0.</p>
<p>The PEP describes how the bytes type should work in Python 2.6, as
well as how it should work in Python 3.0.  (Occasionally there are
differences because in Python 2.6, we have two string types, str
and unicode, while in Python 3.0 we will only have one string
type, whose name will be str but whose semantics will be like the
2.6 unicode type.)</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id4">Motivation</a></h1>
<p>Python's current string objects are overloaded.  They serve to hold
both sequences of characters and sequences of bytes.  This
overloading of purpose leads to confusion and bugs.  In future
versions of Python, string objects will be used for holding
character data.  The bytes object will fulfil the role of a byte
container.  Eventually the unicode type will be renamed to str
and the old str type will be removed.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id5">Specification</a></h1>
<p>A bytes object stores a mutable sequence of integers that are in
the range 0 to 255.  Unlike string objects, indexing a bytes
object returns an integer.  Assigning or comparing an object that
is not an integer to an element causes a <tt class="docutils literal">TypeError</tt> exception.
Assigning an element to a value outside the range 0 to 255 causes
a <tt class="docutils literal">ValueError</tt> exception.  The <tt class="docutils literal">.__len__()</tt> method of bytes returns
the number of integers stored in the sequence (i.e. the number of
bytes).</p>
<p>The constructor of the bytes object has the following signature:</p>
<pre class="literal-block">
bytes([initializer[, encoding]])
</pre>
<p>If no arguments are provided then a bytes object containing zero
elements is created and returned.  The initializer argument can be
a string (in 2.6, either str or unicode), an iterable of integers,
or a single integer.  The pseudo-code for the constructor
(optimized for clear semantics, not for speed) is:</p>
<pre class="literal-block">
def bytes(initializer=0, encoding=None):
    if isinstance(initializer, int): # In 2.6, int -&gt; (int, long)
        initializer = [0]*initializer
    elif isinstance(initializer, basestring):
        if isinstance(initializer, unicode): # In 3.0, &quot;if True&quot;
            if encoding is None:
                # In 3.0, raise TypeError(&quot;explicit encoding required&quot;)
                encoding = sys.getdefaultencoding()
            initializer = initializer.encode(encoding)
        initializer = [ord(c) for c in initializer]
    else:
        if encoding is not None:
            raise TypeError(&quot;no encoding allowed for this initializer&quot;)
        tmp = []
        for c in initializer:
            if not isinstance(c, int):
                raise TypeError(&quot;initializer must be iterable of ints&quot;)
            if not 0 &lt;= c &lt; 256:
                raise ValueError(&quot;initializer element out of range&quot;)
            tmp.append(c)
        initializer = tmp
    new = &lt;new bytes object of length len(initializer)&gt;
    for i, c in enumerate(initializer):
        new[i] = c
    return new
</pre>
<p>The <tt class="docutils literal">.__repr__()</tt> method returns a string that can be evaluated to
generate a new bytes object containing a bytes literal:</p>
<pre class="literal-block">
&gt;&gt;&gt; bytes([10, 20, 30])
b'\n\x14\x1e'
</pre>
<p>The object has a <tt class="docutils literal">.decode()</tt> method equivalent to the <tt class="docutils literal">.decode()</tt>
method of the str object.  The object has a classmethod <tt class="docutils literal">.fromhex()</tt>
that takes a string of characters from the set <tt class="docutils literal"><span class="pre">[0-9a-fA-F</span> ]</tt> and
returns a bytes object (similar to <tt class="docutils literal">binascii.unhexlify</tt>).  For
example:</p>
<pre class="literal-block">
&gt;&gt;&gt; bytes.fromhex('5c5350ff')
b'\\SP\xff'
&gt;&gt;&gt; bytes.fromhex('5c 53 50 ff')
b'\\SP\xff'
</pre>
<p>The object has a <tt class="docutils literal">.hex()</tt> method that does the reverse conversion
(similar to <tt class="docutils literal">binascii.hexlify</tt>):</p>
<pre class="literal-block">
&gt;&gt; bytes([92, 83, 80, 255]).hex()
'5c5350ff'
</pre>
<p>The bytes object has some methods similar to list methods, and
others similar to str methods.  Here is a complete list of
methods, with their approximate signatures:</p>
<pre class="literal-block">
.__add__(bytes) -&gt; bytes
.__contains__(int | bytes) -&gt; bool
.__delitem__(int | slice) -&gt; None
.__delslice__(int, int) -&gt; None
.__eq__(bytes) -&gt; bool
.__ge__(bytes) -&gt; bool
.__getitem__(int | slice) -&gt; int | bytes
.__getslice__(int, int) -&gt; bytes
.__gt__(bytes) -&gt; bool
.__iadd__(bytes) -&gt; bytes
.__imul__(int) -&gt; bytes
.__iter__() -&gt; iterator
.__le__(bytes) -&gt; bool
.__len__() -&gt; int
.__lt__(bytes) -&gt; bool
.__mul__(int) -&gt; bytes
.__ne__(bytes) -&gt; bool
.__reduce__(...) -&gt; ...
.__reduce_ex__(...) -&gt; ...
.__repr__() -&gt; str
.__reversed__() -&gt; bytes
.__rmul__(int) -&gt; bytes
.__setitem__(int | slice, int | iterable[int]) -&gt; None
.__setslice__(int, int, iterable[int]) -&gt; Bote
.append(int) -&gt; None
.count(int) -&gt; int
.decode(str) -&gt; str | unicode # in 3.0, only str
.endswith(bytes) -&gt; bool
.extend(iterable[int]) -&gt; None
.find(bytes) -&gt; int
.index(bytes | int) -&gt; int
.insert(int, int) -&gt; None
.join(iterable[bytes]) -&gt; bytes
.partition(bytes) -&gt; (bytes, bytes, bytes)
.pop([int]) -&gt; int
.remove(int) -&gt; None
.replace(bytes, bytes) -&gt; bytes
.rindex(bytes | int) -&gt; int
.rpartition(bytes) -&gt; (bytes, bytes, bytes)
.split(bytes) -&gt; list[bytes]
.startswith(bytes) -&gt; bool
.reverse() -&gt; None
.rfind(bytes) -&gt; int
.rindex(bytes | int) -&gt; int
.rsplit(bytes) -&gt; list[bytes]
.translate(bytes, [bytes]) -&gt; bytes
</pre>
<p>Note the conspicuous absence of <tt class="docutils literal">.isupper()</tt>, <tt class="docutils literal">.upper()</tt>, and friends.
(But see &quot;Open Issues&quot; below.)  There is no <tt class="docutils literal">.__hash__()</tt> because
the object is mutable.  There is no use case for a <tt class="docutils literal">.sort()</tt> method.</p>
<p>The bytes type also supports the buffer interface, supporting
reading and writing binary (but not character) data.</p>
</div>
<div class="section" id="out-of-scope-issues">
<h1><a class="toc-backref" href="#id6">Out of Scope Issues</a></h1>
<ul class="simple">
<li>Python 3k will have a much different I/O subsystem.  Deciding
how that I/O subsystem will work and interact with the bytes
object is out of the scope of this PEP.  The expectation however
is that binary I/O will read and write bytes, while text I/O
will read strings.  Since the bytes type supports the buffer
interface, the existing binary I/O operations in Python 2.6 will
support bytes objects.</li>
<li>It has been suggested that a special method named <tt class="docutils literal">.__bytes__()</tt>
be added to the language to allow objects to be converted into
byte arrays.  This decision is out of scope.</li>
<li>A bytes literal of the form <tt class="docutils literal"><span class="pre">b&quot;...&quot;</span></tt> is also proposed.  This is
the subject of <a class="reference external" href="/dev/peps/pep-3112">PEP 3112</a>.</li>
</ul>
</div>
<div class="section" id="open-issues">
<h1><a class="toc-backref" href="#id7">Open Issues</a></h1>
<ul class="simple">
<li>The <tt class="docutils literal">.decode()</tt> method is redundant since a bytes object <tt class="docutils literal">b</tt> can
also be decoded by calling <tt class="docutils literal">unicode(b, &lt;encoding&gt;)</tt> (in 2.6) or
<tt class="docutils literal">str(b, &lt;encoding&gt;)</tt> (in 3.0).  Do we need encode/decode methods
at all?  In a sense the spelling using a constructor is cleaner.</li>
<li>Need to specify the methods still more carefully.</li>
<li>Pickling and marshalling support need to be specified.</li>
<li>Should all those list methods really be implemented?</li>
<li>A case could be made for supporting <tt class="docutils literal">.ljust()</tt>, <tt class="docutils literal">.rjust()</tt>,
<tt class="docutils literal">.center()</tt> with a mandatory second argument.</li>
<li>A case could be made for supporting <tt class="docutils literal">.split()</tt> with a mandatory
argument.</li>
<li>A case could even be made for supporting <tt class="docutils literal">.islower()</tt>, <tt class="docutils literal">.isupper()</tt>,
<tt class="docutils literal">.isspace()</tt>, <tt class="docutils literal">.isalpha()</tt>, <tt class="docutils literal">.isalnum()</tt>, <tt class="docutils literal">.isdigit()</tt> and the
corresponding conversions (<tt class="docutils literal">.lower()</tt> etc.), using the ASCII
definitions for letters, digits and whitespace.  If this is
accepted, the cases for <tt class="docutils literal">.ljust()</tt>, <tt class="docutils literal">.rjust()</tt>, <tt class="docutils literal">.center()</tt> and
<tt class="docutils literal">.split()</tt> become much stronger, and they should have default
arguments as well, using an ASCII space or all ASCII whitespace
(for <tt class="docutils literal">.split()</tt>).</li>
</ul>
</div>
<div class="section" id="frequently-asked-questions">
<h1><a class="toc-backref" href="#id8">Frequently Asked Questions</a></h1>
<p><strong>Q:</strong> Why have the optional encoding argument when the encode method of
Unicode objects does the same thing?</p>
<p><strong>A:</strong> In the current version of Python, the encode method returns a str
object and we cannot change that without breaking code.  The
construct <tt class="docutils literal"><span class="pre">bytes(s.encode(...))</span></tt> is expensive because it has to
copy the byte sequence multiple times.  Also, Python generally
provides two ways of converting an object of type A into an
object of type B: ask an A instance to convert itself to a B, or
ask the type B to create a new instance from an A. Depending on
what A and B are, both APIs make sense; sometimes reasons of
decoupling require that A can't know about B, in which case you
have to use the latter approach; sometimes B can't know about A,
in which case you have to use the former.</p>
<p><strong>Q:</strong> Why does bytes ignore the encoding argument if the initializer is
a str?  (This only applies to 2.6.)</p>
<p><strong>A:</strong> There is no sane meaning that the encoding can have in that case.
str objects <em>are</em> byte arrays and they know nothing about the
encoding of character data they contain.  We need to assume that
the programmer has provided a str object that already uses the
desired encoding. If you need something other than a pure copy of
the bytes then you need to first decode the string.  For example:</p>
<pre class="literal-block">
bytes(s.decode(encoding1), encoding2)
</pre>
<p><strong>Q:</strong> Why not have the encoding argument default to Latin-1 (or some
other encoding that covers the entire byte range) rather than
ASCII?</p>
<p><strong>A:</strong> The system default encoding for Python is ASCII.  It seems least
confusing to use that default.  Also, in Py3k, using Latin-1 as
the default might not be what users expect.  For example, they
might prefer a Unicode encoding.  Any default will not always
work as expected.  At least ASCII will complain loudly if you try
to encode non-ASCII data.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id9">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

