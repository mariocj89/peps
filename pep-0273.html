<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">273</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Import Modules from Zip Archives</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0273.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">jim&#32;&#97;t&#32;interet.com (James C. Ahlstrom)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">11-Oct-2001</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.3</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">26-Oct-2001</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id8">Abstract</a></li>
<li><a class="reference internal" href="#note" id="id9">Note</a></li>
<li><a class="reference internal" href="#specification" id="id10">Specification</a></li>
<li><a class="reference internal" href="#subdirectory-equivalence" id="id11">Subdirectory Equivalence</a></li>
<li><a class="reference internal" href="#efficiency" id="id12">Efficiency</a></li>
<li><a class="reference internal" href="#zlib" id="id13">zlib</a></li>
<li><a class="reference internal" href="#booting" id="id14">Booting</a></li>
<li><a class="reference internal" href="#directory-imports" id="id15">Directory Imports</a></li>
<li><a class="reference internal" href="#benchmarks" id="id16">Benchmarks</a></li>
<li><a class="reference internal" href="#custom-imports" id="id17">Custom Imports</a></li>
<li><a class="reference internal" href="#implementation" id="id18">Implementation</a></li>
<li><a class="reference internal" href="#references" id="id19">References</a></li>
<li><a class="reference internal" href="#copyright" id="id20">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id8">Abstract</a></h1>
<p>This PEP adds the ability to import Python modules
<tt class="docutils literal">*.py</tt>, <tt class="docutils literal">*.py[co]</tt> and packages from zip archives.  The
same code is used to speed up normal directory imports
provided <tt class="docutils literal">os.listdir</tt> is available.</p>
</div>
<div class="section" id="note">
<h1><a class="toc-backref" href="#id9">Note</a></h1>
<p>Zip imports were added to Python 2.3, but the final implementation
uses an approach different from the one described in this PEP.
The 2.3 implementation is SourceForge patch #652586 <a class="footnote-reference" href="#id5" id="id1">[1]</a>, which adds
new import hooks described in <a class="reference external" href="/dev/peps/pep-0302">PEP 302</a>.</p>
<p>The rest of this PEP is therefore only of historical interest.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id10">Specification</a></h1>
<p>Currently, <tt class="docutils literal">sys.path</tt> is a list of directory names as strings.  If
this PEP is implemented, an item of <tt class="docutils literal">sys.path</tt> can be a string
naming a zip file archive.  The zip archive can contain a
subdirectory structure to support package imports.  The zip
archive satisfies imports exactly as a subdirectory would.</p>
<p>The implementation is in C code in the Python core and works on
all supported Python platforms.</p>
<p>Any files may be present in the zip archive, but only files
<tt class="docutils literal">*.py</tt> and <tt class="docutils literal">*.py[co]</tt> are available for import.  Zip import of
dynamic modules (<tt class="docutils literal">*.pyd</tt>, <tt class="docutils literal">*.so</tt>) is disallowed.</p>
<p>Just as <tt class="docutils literal">sys.path</tt> currently has default directory names, a default
zip archive name is added too.  Otherwise there is no way to
import all Python library files from an archive.</p>
</div>
<div class="section" id="subdirectory-equivalence">
<h1><a class="toc-backref" href="#id11">Subdirectory Equivalence</a></h1>
<p>The zip archive must be treated exactly as a subdirectory tree so
we can support package imports based on current and future rules.
All zip data is taken from the Central Directory, the data must be
correct, and brain dead zip files are not accommodated.</p>
<p>Suppose <tt class="docutils literal">sys.path</tt> contains &quot;/A/B/SubDir&quot; and &quot;/C/D/E/Archive.zip&quot;,
and we are trying to import <tt class="docutils literal">modfoo</tt> from the <tt class="docutils literal">Q</tt> package.  Then
<tt class="docutils literal">import.c</tt> will generate a list of paths and extensions and will
look for the file.  The list of generated paths does not change
for zip imports.  Suppose <tt class="docutils literal">import.c</tt> generates the path
&quot;/A/B/SubDir/Q/R/modfoo.pyc&quot;.  Then it will also generate the path
&quot;/C/D/E/Archive.zip/Q/R/modfoo.pyc&quot;.  Finding the SubDir path is
exactly equivalent to finding &quot;Q/R/modfoo.pyc&quot; in the archive.</p>
<p>Suppose you zip up /A/B/SubDir/* and all its subdirectories.  Then
your zip file will satisfy imports just as your subdirectory did.</p>
<p>Well, not quite.  You can't satisfy dynamic modules from a zip
file.  Dynamic modules have extensions like <tt class="docutils literal">.dll</tt>, <tt class="docutils literal">.pyd</tt>, and <tt class="docutils literal">.so</tt>.
They are operating system dependent, and probably can't be loaded
except from a file.  It might be possible to extract the dynamic
module from the zip file, write it to a plain file and load it.
But that would mean creating temporary files, and dealing with all
the <tt class="docutils literal"><span class="pre">dynload_*.c</span></tt>, and that's probably not a good idea.</p>
<p>When trying to import <tt class="docutils literal">*.pyc</tt>, if it is not available then
<tt class="docutils literal">*.pyo</tt> will be used instead.  And vice versa when looking for <tt class="docutils literal">*.pyo</tt>.
If neither <tt class="docutils literal">*.pyc</tt> nor <tt class="docutils literal">*.pyo</tt> is available, or if the magic numbers
are invalid, then <tt class="docutils literal">*.py</tt> will be compiled and used to satisfy the
import, but the compiled file will not be saved.  Python would
normally write it to the same directory as <tt class="docutils literal">*.py</tt>, but surely we
don't want to write to the zip file.  We could write to the
directory of the zip archive, but that would clutter it up, not
good if it is <tt class="docutils literal">/usr/bin</tt> for example.</p>
<p>Failing to write the compiled files will make zip imports very slow,
and the user will probably not figure out what is wrong.  So it
is best to put <tt class="docutils literal">*.pyc</tt> and <tt class="docutils literal">*.pyo</tt> in the archive with the <tt class="docutils literal">*.py</tt>.</p>
</div>
<div class="section" id="efficiency">
<h1><a class="toc-backref" href="#id12">Efficiency</a></h1>
<p>The only way to find files in a zip archive is linear search.  So
for each zip file in <tt class="docutils literal">sys.path</tt>, we search for its names once, and
put the names plus other relevant data into a static Python
dictionary.  The key is the archive name from <tt class="docutils literal">sys.path</tt> joined with
the file name (including any subdirectories) within the archive.
This is exactly the name generated by <tt class="docutils literal">import.c</tt>, and makes lookup
easy.</p>
<p>This same mechanism is used to speed up directory (non-zip) imports.
See below.</p>
</div>
<div class="section" id="zlib">
<h1><a class="toc-backref" href="#id13">zlib</a></h1>
<p>Compressed zip archives require <tt class="docutils literal">zlib</tt> for decompression.  Prior to
any other imports, we attempt an import of <tt class="docutils literal">zlib</tt>.  Import of
compressed files will fail with a message &quot;missing <tt class="docutils literal">zlib</tt>&quot; unless
<tt class="docutils literal">zlib</tt> is available.</p>
</div>
<div class="section" id="booting">
<h1><a class="toc-backref" href="#id14">Booting</a></h1>
<p>Python imports <tt class="docutils literal">site.py</tt> itself, and this imports <tt class="docutils literal">os</tt>, <tt class="docutils literal">nt</tt>, <tt class="docutils literal">ntpath</tt>,
<tt class="docutils literal">stat</tt>, and <tt class="docutils literal">UserDict</tt>.  It also imports <tt class="docutils literal">sitecustomize.py</tt> which may
import more modules.  Zip imports must be available before <tt class="docutils literal">site.py</tt>
is imported.</p>
<p>Just as there are default directories in <tt class="docutils literal">sys.path</tt>, there must be
one or more default zip archives too.</p>
<p>The problem is what the name should be.  The name should be linked
with the Python version, so the Python executable can correctly
find its corresponding libraries even when there are multiple
Python versions on the same machine.</p>
<p>We add one name to <tt class="docutils literal">sys.path</tt>.  On Unix, the directory is
<tt class="docutils literal">sys.prefix + &quot;/lib&quot;</tt>, and the file name is
<tt class="docutils literal">&quot;python%s%s.zip&quot; % (sys.version[0], sys.version[2])</tt>.
So for Python 2.2 and prefix <tt class="docutils literal">/usr/local</tt>, the path
<tt class="docutils literal">/usr/local/lib/python2.2/</tt> is already on <tt class="docutils literal">sys.path</tt>, and
<tt class="docutils literal">/usr/local/lib/python22.zip</tt> would be added.
On Windows, the file is the full path to <tt class="docutils literal">python22.dll</tt>, with
&quot;dll&quot; replaced by &quot;zip&quot;.  The zip archive name is always inserted
as the second item in <tt class="docutils literal">sys.path</tt>.  The first is the directory of the
<tt class="docutils literal">main.py</tt> (thanks Tim).</p>
</div>
<div class="section" id="directory-imports">
<h1><a class="toc-backref" href="#id15">Directory Imports</a></h1>
<p>The static Python dictionary used to speed up zip imports can be
used to speed up normal directory imports too.  For each item in
<tt class="docutils literal">sys.path</tt> that is not a zip archive, we call <tt class="docutils literal">os.listdir</tt>, and add
the directory contents to the dictionary.  Then instead of calling
<tt class="docutils literal">fopen()</tt> in a double loop, we just check the dictionary.  This
greatly speeds up imports.  If <tt class="docutils literal">os.listdir</tt> doesn't exist, the
dictionary is not used.</p>
</div>
<div class="section" id="benchmarks">
<h1><a class="toc-backref" href="#id16">Benchmarks</a></h1>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="29%" />
<col width="29%" />
<col width="17%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Case</th>
<th class="head">Original 2.2a3</th>
<th class="head">Using os.listdir</th>
<th class="head">Zip Uncomp</th>
<th class="head">Zip Compr</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td>3.2 2.5 3.2-&gt;1.02</td>
<td>2.3 2.5 2.3-&gt;0.87</td>
<td>1.66-&gt;0.93</td>
<td>1.5-&gt;1.07</td>
</tr>
<tr><td>2</td>
<td>2.8 3.9 3.0-&gt;1.32</td>
<td>Same as Case 1.</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>3</td>
<td>5.7 5.7 5.7-&gt;5.7</td>
<td>2.1 2.1 2.1-&gt;1.8</td>
<td>1.25-&gt;0.99</td>
<td>1.19-&gt;1.13</td>
</tr>
<tr><td>4</td>
<td>9.4 9.4 9.3-&gt;9.35</td>
<td>Same as Case 3.</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>Case 1: Local drive C:, <tt class="docutils literal">sys.path</tt> has its default value.
Case 2: Local drive C:, directory with files is at the end of <tt class="docutils literal">sys.path</tt>.
Case 3: Network  drive, <tt class="docutils literal">sys.path</tt> has its default value.
Case 4: Network  drive, directory with files is at the end of <tt class="docutils literal">sys.path</tt>.</p>
<p>Benchmarks were performed on a Pentium 4 clone, 1.4 GHz, 256 Meg.
The machine was running Windows 2000 with a Linux/Samba network server.
Times are in seconds, and are the time to import about 100 Lib modules.
Case 2 and 4 have the &quot;correct&quot; directory moved to the end of <tt class="docutils literal">sys.path</tt>.
&quot;Uncomp&quot; means uncompressed zip archive, &quot;Compr&quot; means compressed.</p>
<p>Initial times are after a re-boot of the system; the time after
&quot;-&gt;&quot; is the time after repeated runs.  Times to import from C:
after a re-boot are rather highly variable for the &quot;Original&quot; case,
but are more realistic.</p>
</div>
<div class="section" id="custom-imports">
<h1><a class="toc-backref" href="#id17">Custom Imports</a></h1>
<p>The logic demonstrates the ability to import using default searching
until a needed Python module (in this case, <tt class="docutils literal">os</tt>) becomes available.
This can be used to bootstrap custom importers.  For example, if
&quot;<tt class="docutils literal">importer()</tt>&quot; in <tt class="docutils literal">__init__.py</tt> exists, then it could be used for imports.
The &quot;<tt class="docutils literal">importer()</tt>&quot; can freely import os and other modules, and these
will be satisfied from the default mechanism.  This PEP does not
define any custom importers, and this note is for information only.</p>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id18">Implementation</a></h1>
<p>A C implementation is available as SourceForge patch 492105.
Superseded by patch 652586 and current CVS. <a class="footnote-reference" href="#id6" id="id2">[2]</a></p>
<p>A newer version (updated for recent CVS by Paul Moore) is 645650.
Superseded by patch 652586 and current CVS. <a class="footnote-reference" href="#id7" id="id3">[3]</a></p>
<p>A competing implementation by Just van Rossum is 652586, which is
the basis for the final implementation of <a class="reference external" href="/dev/peps/pep-0302">PEP 302</a>.  <a class="reference external" href="/dev/peps/pep-0273">PEP 273</a> has
been implemented using <a class="reference external" href="/dev/peps/pep-0302">PEP 302</a>'s import hooks. <a class="footnote-reference" href="#id5" id="id4">[1]</a></p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id19">References</a></h1>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id4">2</a>)</em> Just van Rossum, New import hooks + Import from Zip files
<a class="reference external" href="https://bugs.python.org/issue652586">https://bugs.python.org/issue652586</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Import from Zip archive, James C. Ahlstrom
<a class="reference external" href="https://bugs.python.org/issue492105">https://bugs.python.org/issue492105</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>Import from Zip Archive, Paul Moore
<a class="reference external" href="https://bugs.python.org/issue645650">https://bugs.python.org/issue645650</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id20">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
fill-column: 70
End: -->
</div>

