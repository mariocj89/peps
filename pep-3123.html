<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">3123</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Making PyObject_HEAD conform to standard C</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-3123.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Martin von LÃ¶wis &lt;martin&#32;&#97;t&#32;v.loewis.de&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">27-Apr-2007</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.0</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id2">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id3">Rationale</a></li>
<li><a class="reference internal" href="#specification" id="id4">Specification</a></li>
<li><a class="reference internal" href="#compatibility-with-python-2-6" id="id5">Compatibility with Python 2.6</a></li>
<li><a class="reference internal" href="#copyright" id="id6">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id2">Abstract</a></h1>
<p>Python currently relies on undefined C behavior, with its
usage of <tt class="docutils literal">PyObject_HEAD</tt>. This PEP proposes to change that
into standard C.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id3">Rationale</a></h1>
<p>Standard C defines that an object must be accessed only through a
pointer of its type, and that all other accesses are undefined
behavior, with a few exceptions. In particular, the following
code has undefined behavior:</p>
<pre class="literal-block">
struct FooObject{
  PyObject_HEAD
  int data;
};

PyObject *foo(struct FooObject*f){
 return (PyObject*)f;
}

int bar(){
 struct FooObject *f = malloc(sizeof(struct FooObject));
 struct PyObject *o = foo(f);
 f-&gt;ob_refcnt = 0;
 o-&gt;ob_refcnt = 1;
 return f-&gt;ob_refcnt;
}
</pre>
<p>The problem here is that the storage is both accessed as
if it where struct <tt class="docutils literal">PyObject</tt>, and as struct <tt class="docutils literal">FooObject</tt>.</p>
<p>Historically, compilers did not have any problems with this
code. However, modern compilers use that clause as an
optimization opportunity, finding that <tt class="docutils literal"><span class="pre">f-&gt;ob_refcnt</span></tt> and
<tt class="docutils literal"><span class="pre">o-&gt;ob_refcnt</span></tt> cannot possibly refer to the same memory, and
that therefore the function should return 0, without having
to fetch the value of ob_refcnt at all in the return
statement. For GCC, Python now uses <tt class="docutils literal"><span class="pre">-fno-strict-aliasing</span></tt>
to work around that problem; with other compilers, it
may just see undefined behavior. Even with GCC, using
<tt class="docutils literal"><span class="pre">-fno-strict-aliasing</span></tt> may pessimize the generated code
unnecessarily.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id4">Specification</a></h1>
<p>Standard C has one specific exception to its aliasing rules precisely
designed to support the case of Python: a value of a struct type may
also be accessed through a pointer to the first field. E.g. if a
struct starts with an <tt class="docutils literal">int</tt>, the <tt class="docutils literal">struct *</tt> may also be cast to
an <tt class="docutils literal">int *</tt>, allowing to write int values into the first field.</p>
<p>For Python, <tt class="docutils literal">PyObject_HEAD</tt> and <tt class="docutils literal">PyObject_VAR_HEAD</tt> will be changed
to not list all fields anymore, but list a single field of type
<tt class="docutils literal">PyObject</tt>/<tt class="docutils literal">PyVarObject</tt>:</p>
<pre class="literal-block">
typedef struct _object {
  _PyObject_HEAD_EXTRA
  Py_ssize_t ob_refcnt;
  struct _typeobject *ob_type;
} PyObject;

typedef struct {
  PyObject ob_base;
  Py_ssize_t ob_size;
} PyVarObject;

#define PyObject_HEAD        PyObject ob_base;
#define PyObject_VAR_HEAD    PyVarObject ob_base;
</pre>
<p>Types defined as fixed-size structure will then include PyObject
as its first field, PyVarObject for variable-sized objects. E.g.:</p>
<pre class="literal-block">
typedef struct {
  PyObject ob_base;
  PyObject *start, *stop, *step;
} PySliceObject;

typedef struct {
  PyVarObject ob_base;
  PyObject **ob_item;
  Py_ssize_t allocated;
} PyListObject;
</pre>
<p>The above definitions of <tt class="docutils literal">PyObject_HEAD</tt> are normative, so extension
authors MAY either use the macro, or put the <tt class="docutils literal">ob_base</tt> field explicitly
into their structs.</p>
<p>As a convention, the base field SHOULD be called ob_base. However, all
accesses to ob_refcnt and ob_type MUST cast the object pointer to
PyObject* (unless the pointer is already known to have that type), and
SHOULD use the respective accessor macros. To simplify access to
ob_type, ob_refcnt, and ob_size, macros:</p>
<pre class="literal-block">
#define Py_TYPE(o)    (((PyObject*)(o))-&gt;ob_type)
#define Py_REFCNT(o)  (((PyObject*)(o))-&gt;ob_refcnt)
#define Py_SIZE(o)    (((PyVarObject*)(o))-&gt;ob_size)
</pre>
<p>are added. E.g. the code blocks</p>
<pre class="literal-block">
#define PyList_CheckExact(op) ((op)-&gt;ob_type == &amp;PyList_Type)

return func-&gt;ob_type-&gt;tp_name;
</pre>
<p>needs to be changed to:</p>
<pre class="literal-block">
#define PyList_CheckExact(op) (Py_TYPE(op) == &amp;PyList_Type)

return Py_TYPE(func)-&gt;tp_name;
</pre>
<p>For initialization of type objects, the current sequence</p>
<pre class="literal-block">
PyObject_HEAD_INIT(NULL)
0, /* ob_size */
</pre>
<p>becomes incorrect, and must be replaced with</p>
<pre class="literal-block">
PyVarObject_HEAD_INIT(NULL, 0)
</pre>
</div>
<div class="section" id="compatibility-with-python-2-6">
<h1><a class="toc-backref" href="#id5">Compatibility with Python 2.6</a></h1>
<p>To support modules that compile with both Python 2.6 and Python 3.0,
the <tt class="docutils literal">Py_*</tt> macros are added to Python 2.6. The macros <tt class="docutils literal">Py_INCREF</tt>
and <tt class="docutils literal">Py_DECREF</tt> will be changed to cast their argument to <tt class="docutils literal">PyObject *</tt>,
so that module authors can also explicitly declare the <tt class="docutils literal">ob_base</tt>
field in modules designed for Python 2.6.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id6">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

