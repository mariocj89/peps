<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">214</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Extended Print Statement</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0214.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">barry&#32;&#97;t&#32;python.org (Barry Warsaw)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">24-Jul-2000</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.0</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">16-Aug-2000</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id5">Introduction</a></li>
<li><a class="reference internal" href="#proposal" id="id6">Proposal</a></li>
<li><a class="reference internal" href="#justification" id="id7">Justification</a></li>
<li><a class="reference internal" href="#reference-implementation" id="id8">Reference Implementation</a></li>
<li><a class="reference internal" href="#alternative-approaches" id="id9">Alternative Approaches</a></li>
<li><a class="reference internal" href="#more-justification-by-the-bdfl" id="id10">More Justification by the BDFL</a></li>
<li><a class="reference internal" href="#references" id="id11">References</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id5">Introduction</a></h1>
<p>This PEP describes a syntax to extend the standard 'print'
statement so that it can be used to print to any file-like object,
instead of the default <tt class="docutils literal">sys.stdout</tt>.  This PEP tracks the status and
ownership of this feature.  It contains a description of the
feature and outlines changes necessary to support the feature.
This PEP summarizes discussions held in mailing list forums, and
provides URLs for further information, where appropriate.  The CVS
revision history of this file contains the definitive historical
record.</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id6">Proposal</a></h1>
<p>This proposal introduces a syntax extension to the print
statement, which allows the programmer to optionally specify the
output file target.  An example usage is as follows:</p>
<pre class="literal-block">
print &gt;&gt; mylogfile, 'this message goes to my log file'
</pre>
<p>Formally, the syntax of the extended print statement is:</p>
<pre class="literal-block">
print_stmt: ... | '&gt;&gt;' test [ (',' test)+ [','] ] )
</pre>
<p>where the ellipsis indicates the original print_stmt syntax
unchanged.  In the extended form, the expression just after &gt;&gt;
must yield an object with a <tt class="docutils literal">write()</tt> method (i.e. a file-like
object).  Thus these two statements are equivalent:</p>
<pre class="literal-block">
print 'hello world'
print &gt;&gt; sys.stdout, 'hello world'
</pre>
<p>As are these two statements:</p>
<pre class="literal-block">
print
print &gt;&gt; sys.stdout
</pre>
<p>These two statements are syntax errors:</p>
<pre class="literal-block">
print ,
print &gt;&gt; sys.stdout,
</pre>
</div>
<div class="section" id="justification">
<h1><a class="toc-backref" href="#id7">Justification</a></h1>
<p>'print' is a Python keyword and introduces the print statement as
described in section 6.6 of the language reference manual <a class="footnote-reference" href="#id3" id="id1">[1]</a>.
The print statement has a number of features:</p>
<ul class="simple">
<li>it auto-converts the items to strings</li>
<li>it inserts spaces between items automatically</li>
<li>it appends a newline unless the statement ends in a comma</li>
</ul>
<p>The formatting that the print statement performs is limited; for
more control over the output, a combination of <tt class="docutils literal">sys.stdout.write()</tt>,
and string interpolation can be used.</p>
<p>The print statement by definition outputs to <tt class="docutils literal">sys.stdout</tt>.  More
specifically, <tt class="docutils literal">sys.stdout</tt> must be a file-like object with a <tt class="docutils literal">write()</tt>
method, but it can be rebound to redirect output to files other
than specifically standard output.  A typical idiom is:</p>
<pre class="literal-block">
save_stdout = sys.stdout
try:
    sys.stdout = mylogfile
    print 'this message goes to my log file'
finally:
    sys.stdout = save_stdout
</pre>
<p>The problem with this approach is that the binding is global, and
so affects every statement inside the try: clause.  For example,
if we added a call to a function that actually did want to print
to stdout, this output too would get redirected to the logfile.</p>
<p>This approach is also very inconvenient for interleaving prints to
various output streams, and complicates coding in the face of
legitimate try/except or try/finally clauses.</p>
</div>
<div class="section" id="reference-implementation">
<h1><a class="toc-backref" href="#id8">Reference Implementation</a></h1>
<p>A reference implementation, in the form of a patch against the
Python 2.0 source tree, is available on SourceForge's patch
manager <a class="footnote-reference" href="#id4" id="id2">[2]</a>.  This approach adds two new opcodes, <tt class="docutils literal">PRINT_ITEM_TO</tt> and
<tt class="docutils literal">PRINT_NEWLINE_TO</tt>, which simply pop the file like object off the
top of the stack and use it instead of <tt class="docutils literal">sys.stdout</tt> as the output
stream.</p>
<p>(This reference implementation has been adopted in Python 2.0.)</p>
</div>
<div class="section" id="alternative-approaches">
<h1><a class="toc-backref" href="#id9">Alternative Approaches</a></h1>
<p>An alternative to this syntax change has been proposed (originally
by Moshe Zadka) which requires no syntax changes to Python.  A
<tt class="docutils literal">writeln()</tt> function could be provided (possibly as a builtin), that
would act much like extended print, with a few additional
features:</p>
<pre class="literal-block">
def writeln(*args, **kws):
    import sys
    file = sys.stdout
    sep = ' '
    end = '\n'
    if kws.has_key('file'):
        file = kws['file']
        del kws['file']
    if kws.has_key('nl'):
        if not kws['nl']:
            end = ' '
        del kws['nl']
    if kws.has_key('sep'):
        sep = kws['sep']
        del kws['sep']
    if kws:
        raise TypeError('unexpected keywords')
    file.write(sep.join(map(str, args)) + end)
</pre>
<p><tt class="docutils literal">writeln()</tt> takes a three optional keyword arguments.  In the
context of this proposal, the relevant argument is 'file' which
can be set to a file-like object with a <tt class="docutils literal">write()</tt> method.  Thus:</p>
<pre class="literal-block">
print &gt;&gt; mylogfile, 'this goes to my log file'
</pre>
<p>would be written as:</p>
<pre class="literal-block">
writeln('this goes to my log file', file=mylogfile)
</pre>
<p><tt class="docutils literal">writeln()</tt> has the additional functionality that the keyword
argument 'nl' is a flag specifying whether to append a newline or
not, and an argument 'sep' which specifies the separator to output
in between each item.</p>
</div>
<div class="section" id="more-justification-by-the-bdfl">
<h1><a class="toc-backref" href="#id10">More Justification by the BDFL</a></h1>
<p>The proposal has been challenged on the newsgroup.  One series of
challenges doesn't like '&gt;&gt;' and would rather see some other
symbol.</p>
<ul>
<li><p class="first">Challenge: Why not one of these?</p>
<pre class="literal-block">
print in stderr items,....
print + stderr items,.......
print[stderr] items,.....
print to stderr items,.....
</pre>
<p>Response: If we want to use a special symbol (<tt class="docutils literal">print &lt;symbol&gt;</tt>
expression), the Python parser requires that it is not already a
symbol that can start an expression -- otherwise it can't decide
which form of print statement is used.  (The Python parser is a
simple LL(1) or recursive descent parser.)</p>
<p>This means that we can't use the &quot;keyword only in context trick&quot;
that was used for &quot;import as&quot;, because an identifier can start an
expression.  This rules out +stderr, [sterr], and to stderr.  It
leaves us with binary operator symbols and other miscellaneous
symbols that are currently illegal here, such as 'import'.</p>
<p>If I had to choose between 'print in file' and 'print &gt;&gt; file' I
would definitely choose '&gt;&gt;'.  In part because 'in' would be a new
invention (I know of no other language that uses it, while '&gt;&gt;' is
used in sh, awk, Perl, and C++), in part because '&gt;&gt;', being
non-alphabetic, stands out more so is more likely to catch the
reader's attention.</p>
</li>
<li><p class="first">Challenge: Why does there have to be a comma between the file and
the rest?</p>
<p>Response: The comma separating the file from the following expression is
necessary!  Of course you want the file to be an arbitrary
expression, not just a single word.  (You definitely want to be
able to write <tt class="docutils literal">print &gt;&gt;sys.stderr</tt>.)  Without the expression the
parser would't be able to distinguish where that expression ends
and where the next one begins, e.g.</p>
<pre class="literal-block">
print &gt;&gt;i +1, 2
print &gt;&gt;a [1], 2
print &gt;&gt;f (1), 2
</pre>
</li>
<li><p class="first">Challenge: Why do you need a syntax extension?  Why not
writeln(file, item, ...)?</p>
<p>Response: First of all, this is lacking a feature of the print
statement: the trailing comma to print which suppresses the final
newline.  Note that 'print a,' still isn't equivalent to
'sys.stdout.write(a)' -- print inserts a space between items, and
takes arbitrary objects as arguments; <tt class="docutils literal">write()</tt> doesn't insert a
space and requires a single string.</p>
<p>When you are considering an extension for the print statement,
it's not right to add a function or method that adds a new feature
in one dimension (where the output goes) but takes away in another
dimension (spaces between items, and the choice of trailing
newline or not).  We could add a whole slew of methods or
functions to deal with the various cases but that seems to add
more confusion than necessary, and would only make sense if we
were to deprecate the print statement altogether.</p>
<p>I feel that this debate is really about whether print should have
been a function or method rather than a statement.  If you are in
the function camp, of course adding special syntax to the existing
print statement is not something you like.  I suspect the
objection to the new syntax comes mostly from people who already
think that the print statement was a bad idea.  Am I right?</p>
<p>About 10 years ago I debated with myself whether to make the most
basic from of output a function or a statement; basically I was
trying to decide between &quot;print(item, ...)&quot; and &quot;print item, ...&quot;.
I chose to make it a statement because printing needs to be taught
very early on, and is very important in the programs that
beginners write.  Also, because ABC, which lead the way for so
many things, made it a statement.  In a move that's typical for
the interaction between ABC and Python, I changed the name from
WRITE to print, and reversed the convention for adding newlines
from requiring extra syntax to add a newline (ABC used trailing
slashes to indicate newlines) to requiring extra syntax (the
trailing comma) to suppress the newline.  I kept the feature that
items are separated by whitespace on output.</p>
<p>Full example: in ABC,</p>
<pre class="literal-block">
WRITE 1
WRITE 2/
</pre>
<p>has the same effect as:</p>
<pre class="literal-block">
print 1,
print 2
</pre>
<p>has in Python, outputting in effect &quot;1 2n&quot;.</p>
<p>I'm not 100% sure that the choice for a statement was right (ABC
had the compelling reason that it used statement syntax for
anything with side effects, but Python doesn't have this
convention), but I'm also not convinced that it's wrong.  I
certainly like the economy of the print statement.  (I'm a rabid
Lisp-hater -- syntax-wise, not semantics-wise! -- and excessive
parentheses in syntax annoy me.  Don't ever write <tt class="docutils literal">return(i) or
<span class="pre">if(x==y):</span></tt> in your Python code! :-)</p>
<p>Anyway, I'm not ready to deprecate the print statement, and over
the years we've had many requests for an option to specify the
file.</p>
</li>
<li><p class="first">Challenge: Why not &gt; instead of &gt;&gt;?</p>
<p>Response: To DOS and Unix users, &gt;&gt; suggests &quot;append&quot;, while &gt;
suggests &quot;overwrite&quot;; the semantics are closest to append.  Also,
for C++ programmers, &gt;&gt; and &lt;&lt; are I/O operators.</p>
</li>
<li><p class="first">Challenge: But in C++, &gt;&gt; is input and &lt;&lt; is output!</p>
<p>Response: doesn't matter; C++ clearly took it from Unix and
reversed the arrows.  The important thing is that for output, the
arrow points to the file.</p>
</li>
<li><p class="first">Challenge: Surely you can design a <tt class="docutils literal">println()</tt> function can do all
what <tt class="docutils literal"><span class="pre">print&gt;&gt;file</span></tt> can do; why isn't that enough?</p>
<p>Response: I think of this in terms of a simple programming
exercise.  Suppose a beginning programmer is asked to write a
function that prints the tables of multiplication.  A reasonable
solution is:</p>
<pre class="literal-block">
def tables(n):
    for j in range(1, n+1):
        for i in range(1, n+1):
            print i, 'x', j, '=', i*j
        print
</pre>
<p>Now suppose the second exercise is to add printing to a different
file.  With the new syntax, the programmer only needs to learn one
new thing: <tt class="docutils literal">print &gt;&gt; file</tt>, and the answer can be like this:</p>
<pre class="literal-block">
def tables(n, file=sys.stdout):
    for j in range(1, n+1):
        for i in range(1, n+1):
            print &gt;&gt; file, i, 'x', j, '=', i*j
        print &gt;&gt; file
</pre>
<p>With only a print statement and a <tt class="docutils literal">println()</tt> function, the
programmer first has to learn about <tt class="docutils literal">println()</tt>, transforming the
original program to using <tt class="docutils literal">println()</tt>:</p>
<pre class="literal-block">
def tables(n):
    for j in range(1, n+1):
        for i in range(1, n+1):
            println(i, 'x', j, '=', i*j)
        println()
</pre>
<p>and <strong>then</strong> about the file keyword argument:</p>
<pre class="literal-block">
def tables(n, file=sys.stdout):
    for j in range(1, n+1):
        for i in range(1, n+1):
            println(i, 'x', j, '=', i*j, file=sys.stdout)
        println(file=sys.stdout)
</pre>
<p>Thus, the transformation path is longer:</p>
<pre class="literal-block">
(1) print
(2) print &gt;&gt; file
</pre>
<p>vs.</p>
<pre class="literal-block">
(1) print
(2) println()
(3) println(file=...)
</pre>
<p>Note: defaulting the file argument to <tt class="docutils literal">sys.stdout</tt> at compile time
is wrong, because it doesn't work right when the caller assigns to
<tt class="docutils literal">sys.stdout</tt> and then uses <tt class="docutils literal">tables()</tt> without specifying the file.
This is a common problem (and would occur with a <tt class="docutils literal">println()</tt>
function too).  The standard solution so far has been:</p>
<pre class="literal-block">
def tables(n, file=None):
    if file is None:
        file = sys.stdout
    for j in range(1, n+1):
        for i in range(1, n+1):
            print &gt;&gt; file, i, 'x', j, '=', i*j
        print &gt;&gt; file
</pre>
<p>I've added a feature to the implementation (which I would also
recommend to <tt class="docutils literal">println()</tt>) whereby if the file argument is <tt class="docutils literal">None</tt>,
<tt class="docutils literal">sys.stdout</tt> is automatically used.  Thus,</p>
<pre class="literal-block">
print &gt;&gt; None, foo bar
</pre>
<p>(or, of course, <tt class="docutils literal">print &gt;&gt; x</tt> where x is a variable whose value is
None) means the same as</p>
<pre class="literal-block">
print foo, bar
</pre>
<p>and the <tt class="docutils literal">tables()</tt> function can be written as follows:</p>
<pre class="literal-block">
def tables(n, file=None):
    for j in range(1, n+1):
        for i in range(1, n+1):
            print &gt;&gt; file, i, 'x', j, '=', i*j
        print &gt;&gt; file
</pre>
</li>
</ul>
<!-- XXX this needs more justification, and a section of its own -->
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id11">References</a></h1>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://docs.python.org/reference/simple_stmts.html#print">http://docs.python.org/reference/simple_stmts.html#print</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="http://sourceforge.net/patch/download.php?id=100970">http://sourceforge.net/patch/download.php?id=100970</a></td></tr>
</tbody>
</table>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

