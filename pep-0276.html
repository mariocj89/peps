<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">276</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Simple Iterator for ints</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0276.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">james_althoff&#32;&#97;t&#32;i2.com (Jim Althoff)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">12-Nov-2001</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.3</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id5">Abstract</a></li>
<li><a class="reference internal" href="#bdfl-pronouncement" id="id6">BDFL Pronouncement</a></li>
<li><a class="reference internal" href="#specification" id="id7">Specification</a></li>
<li><a class="reference internal" href="#rationale" id="id8">Rationale</a></li>
<li><a class="reference internal" href="#backwards-compatibility" id="id9">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#issues" id="id10">Issues</a></li>
<li><a class="reference internal" href="#implementation" id="id11">Implementation</a></li>
<li><a class="reference internal" href="#references" id="id12">References</a></li>
<li><a class="reference internal" href="#copyright" id="id13">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id5">Abstract</a></h1>
<p>Python 2.1 added new functionality to support iterators <a class="footnote-reference" href="#id2" id="id1">[1]</a>.
Iterators have proven to be useful and convenient in many coding
situations.  It is noted that the implementation of Python's
for-loop control structure uses the iterator protocol as of
release 2.1.  It is also noted that Python provides iterators for
the following builtin types: lists, tuples, dictionaries, strings,
and files.  This PEP proposes the addition of an iterator for the
builtin type int (<tt class="docutils literal">types.IntType</tt>).  Such an iterator would simplify
the coding of certain for-loops in Python.</p>
</div>
<div class="section" id="bdfl-pronouncement">
<h1><a class="toc-backref" href="#id6">BDFL Pronouncement</a></h1>
<p>This PEP was rejected on 17 June 2005 with a note to python-dev.</p>
<p>Much of the original need was met by the <tt class="docutils literal">enumerate()</tt> function which
was accepted for Python 2.3.</p>
<p>Also, the proposal both allowed and encouraged misuses such as:</p>
<pre class="literal-block">
&gt;&gt;&gt; for i in 3: print i
0
1
2
</pre>
<p>Likewise, it was not helpful that the proposal would disable the
syntax error in statements like:</p>
<pre class="literal-block">
x, = 1
</pre>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id7">Specification</a></h1>
<p>Define an iterator for types.intType (i.e., the builtin type
&quot;int&quot;) that is returned from the builtin function &quot;iter&quot; when
called with an instance of types.intType as the argument.</p>
<p>The returned iterator has the following behavior:</p>
<ul>
<li><p class="first">Assume that object i is an instance of <tt class="docutils literal">types.intType</tt> (the
builtin type int) and that i &gt; 0</p>
</li>
<li><p class="first"><tt class="docutils literal">iter(i)</tt> returns an iterator object</p>
</li>
<li><p class="first">said iterator object iterates through the sequence of ints
0,1,2,...,i-1</p>
<p>Example:</p>
<blockquote>
<p><tt class="docutils literal">iter(5)</tt> returns an iterator object that iterates through the
sequence of ints 0,1,2,3,4</p>
</blockquote>
</li>
<li><p class="first">if i &lt;= 0, <tt class="docutils literal">iter(i)</tt> returns an &quot;empty&quot; iterator, i.e., one that
throws StopIteration upon the first call of its &quot;next&quot; method</p>
</li>
</ul>
<p>In other words, the conditions and semantics of said iterator is
consistent with the conditions and semantics of the <tt class="docutils literal">range()</tt> and
<tt class="docutils literal">xrange()</tt> functions.</p>
<p>Note that the sequence 0,1,2,...,i-1 associated with the int i is
considered &quot;natural&quot; in the context of Python programming because
it is consistent with the builtin indexing protocol of sequences
in Python.  Python lists and tuples, for example, are indexed
starting at 0 and ending at len(object)-1 (when using positive
indices).  In other words, such objects are indexed with the
sequence 0,1,2,...,len(object)-1</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id8">Rationale</a></h1>
<p>A common programming idiom is to take a collection of objects and
apply some operation to each item in the collection in some
established sequential order.  Python provides the &quot;for in&quot;
looping control structure for handling this common idiom.  Cases
arise, however, where it is necessary (or more convenient) to
access each item in an &quot;indexed&quot; collection by iterating through
each index and accessing each item in the collection using the
corresponding index.</p>
<p>For example, one might have a two-dimensional &quot;table&quot; object where one
requires the application of some operation to the first column of
each row in the table.  Depending on the implementation of the table
it might not be possible to access first each row and then each
column as individual objects.  It might, rather, be possible to
access a cell in the table using a row index and a column index.
In such a case it is necessary to use an idiom where one iterates
through a sequence of indices (indexes) in order to access the
desired items in the table.  (Note that the commonly used
DefaultTableModel class in Java-Swing-Jython has this very protocol).</p>
<p>Another common example is where one needs to process two or more
collections in parallel.  Another example is where one needs to
access, say, every second item in a collection.</p>
<p>There are many other examples where access to items in a
collection is facilitated by a computation on an index thus
necessitating access to the indices rather than direct access to
the items themselves.</p>
<p>Let's call this idiom the &quot;indexed for-loop&quot; idiom.  Some
programming languages provide builtin syntax for handling this
idiom.  In Python the common convention for implementing the
indexed for-loop idiom is to use the builtin <tt class="docutils literal">range()</tt> or <tt class="docutils literal">xrange()</tt>
function to generate a sequence of indices as in, for example:</p>
<pre class="literal-block">
for rowcount in range(table.getRowCount()):
    print table.getValueAt(rowcount, 0)
</pre>
<p>or</p>
<pre class="literal-block">
for rowcount in xrange(table.getRowCount()):
    print table.getValueAt(rowcount, 0)
</pre>
<p>From time to time there are discussions in the Python community
about the indexed for-loop idiom.  It is sometimes argued that the
need for using the <tt class="docutils literal">range()</tt> or <tt class="docutils literal">xrange()</tt> function for this design
idiom is:</p>
<ul class="simple">
<li>Not obvious (to new-to-Python programmers),</li>
<li>Error prone (easy to forget, even for experienced Python
programmers)</li>
<li>Confusing and distracting for those who feel compelled to understand
the differences and recommended usage of <tt class="docutils literal">xrange()</tt> vis-a-vis <tt class="docutils literal">range()</tt></li>
<li>Unwieldy, especially when combined with the <tt class="docutils literal">len()</tt> function,
i.e., <tt class="docutils literal">xrange(len(sequence))</tt></li>
<li>Not as convenient as equivalent mechanisms in other languages,</li>
<li>Annoying, a &quot;wart&quot;, etc.</li>
</ul>
<p>And from time to time proposals are put forth for ways in which
Python could provide a better mechanism for this idiom.  Recent
examples include <a class="reference external" href="/dev/peps/pep-0204">PEP 204</a>, &quot;Range Literals&quot;, and <a class="reference external" href="/dev/peps/pep-0212">PEP 212</a>, &quot;Loop
Counter Iteration&quot;.</p>
<p>Most often, such proposal include changes to Python's syntax and
other &quot;heavyweight&quot; changes.</p>
<p>Part of the difficulty here is that advocating new syntax implies
a comprehensive solution for &quot;general indexing&quot; that has to
include aspects like:</p>
<ul class="simple">
<li>starting index value</li>
<li>ending index value</li>
<li>step value</li>
<li>open intervals versus closed intervals versus half opened intervals</li>
</ul>
<p>Finding a new syntax that is comprehensive, simple, general,
Pythonic, appealing to many, easy to implement, not in conflict
with existing structures, not excessively overloading of existing
structures, etc. has proven to be more difficult than one might
anticipate.</p>
<p>The proposal outlined in this PEP tries to address the problem by
suggesting a simple &quot;lightweight&quot; solution that helps the most
common case by using a proven mechanism that is already available
(as of Python 2.1): namely, iterators.</p>
<p>Because for-loops already use &quot;iterator&quot; protocol as of Python
2.1, adding an iterator for types.IntType as proposed in this PEP
would enable by default the following shortcut for the indexed
for-loop idiom:</p>
<pre class="literal-block">
for rowcount in table.getRowCount():
    print table.getValueAt(rowcount, 0)
</pre>
<p>The following benefits for this approach vis-a-vis the current
mechanism of using the <tt class="docutils literal">range()</tt> or <tt class="docutils literal">xrange()</tt> functions are claimed
to be:</p>
<ul class="simple">
<li>Simpler,</li>
<li>Less cluttered,</li>
<li>Focuses on the problem at hand without the need to resort to
secondary implementation-oriented functions (<tt class="docutils literal">range()</tt> and
<tt class="docutils literal">xrange()</tt>)</li>
</ul>
<p>And compared to other proposals for change:</p>
<ul class="simple">
<li>Requires no new syntax</li>
<li>Requires no new keywords</li>
<li>Takes advantage of the new and well-established iterator mechanism</li>
</ul>
<p>And generally:</p>
<ul class="simple">
<li>Is consistent with iterator-based &quot;convenience&quot; changes already
included (as of Python 2.1) for other builtin types such as:
lists, tuples, dictionaries, strings, and files.</li>
</ul>
</div>
<div class="section" id="backwards-compatibility">
<h1><a class="toc-backref" href="#id9">Backwards Compatibility</a></h1>
<p>The proposed mechanism is generally backwards compatible as it
calls for neither new syntax nor new keywords.  All existing,
valid Python programs should continue to work unmodified.</p>
<p>However, this proposal is not perfectly backwards compatible in
the sense that certain statements that are currently invalid
would, under the current proposal, become valid.</p>
<p>Tim Peters has pointed out two such examples:</p>
<ol class="arabic">
<li><p class="first">The common case where one forgets to include <tt class="docutils literal">range()</tt> or
<tt class="docutils literal">xrange()</tt>, for example:</p>
<pre class="literal-block">
for rowcount in table.getRowCount():
    print table.getValueAt(rowcount, 0)
</pre>
<p>in Python 2.2 raises a TypeError exception.</p>
<p>Under the current proposal, the above statement would be valid
and would work as (presumably) intended.  Presumably, this is a
good thing.</p>
<p>As noted by Tim, this is the common case of the &quot;forgotten
range&quot; mistake (which one currently corrects by adding a call
to <tt class="docutils literal">range()</tt> or <tt class="docutils literal">xrange()</tt>).</p>
</li>
<li><p class="first">The (hopefully) very uncommon case where one makes a typing
mistake when using tuple unpacking.  For example:</p>
<pre class="literal-block">
x, = 1
</pre>
<p>in Python 2.2 raises a <tt class="docutils literal">TypeError</tt> exception.</p>
<p>Under the current proposal, the above statement would be valid
and would set x to 0.  The PEP author has no data as to how
common this typing error is nor how difficult it would be to
catch such an error under the current proposal.  He imagines
that it does not occur frequently and that it would be
relatively easy to correct should it happen.</p>
</li>
</ol>
</div>
<div class="section" id="issues">
<h1><a class="toc-backref" href="#id10">Issues</a></h1>
<p>Extensive discussions concerning <a class="reference external" href="/dev/peps/pep-0276">PEP 276</a> on the Python interest
mailing list suggests a range of opinions: some in favor, some
neutral, some against.  Those in favor tend to agree with the
claims above of the usefulness, convenience, ease of learning,
and simplicity of a simple iterator for integers.</p>
<p>Issues with <a class="reference external" href="/dev/peps/pep-0276">PEP 276</a> include:</p>
<ul>
<li><p class="first">Using range/xrange is fine as is.</p>
<p>Response: Some posters feel this way.  Other disagree.</p>
</li>
<li><p class="first">Some feel that iterating over the sequence &quot;0, 1, 2, ..., n-1&quot;
for an integer n is not intuitive.  &quot;for i in 5:&quot; is considered
(by some) to be &quot;non-obvious&quot;, for example.  Some dislike this
usage because it doesn't have &quot;the right feel&quot;.  Some dislike it
because they believe that this type of usage forces one to view
integers as a sequences and this seems wrong to them.  Some
dislike it because they prefer to view for-loops as dealing
with explicit sequences rather than with arbitrary iterators.</p>
<p>Response: Some like the proposed idiom and see it as simple,
elegant, easy to learn, and easy to use.  Some are neutral on
this issue.  Others, as noted, dislike it.</p>
</li>
<li><p class="first">Is it obvious that <tt class="docutils literal">iter(5)</tt> maps to the sequence 0,1,2,3,4?</p>
<p>Response: Given, as noted above, that Python has a strong
convention for indexing sequences starting at 0 and stopping at
(inclusively) the index whose value is one less than the length
of the sequence, it is argued that the proposed sequence is
reasonably intuitive to the Python programmer while being useful
and practical.  More importantly, it is argued that once learned
this convention is very easy to remember.  Note that the doc
string for the range function makes a reference to the
natural and useful association between <tt class="docutils literal">range(n)</tt> and the indices
for a list whose length is n.</p>
</li>
<li><p class="first">Possible ambiguity</p>
<pre class="literal-block">
for i in 10: print i
</pre>
<p>might be mistaken for</p>
<pre class="literal-block">
for i in (10,): print i
</pre>
<p>Response: This is exactly the same situation with strings in
current Python (replace 10 with 'spam' in the above, for
example).</p>
</li>
<li><p class="first">Too general: in the newest releases of Python there are
contexts -- as with for-loops -- where iterators are called
implicitly.  Some fear that having an iterator invoked for
an integer in one of the context (excluding for-loops) might
lead to unexpected behavior and bugs.  The &quot;x, = 1&quot; example
noted above is an a case in point.</p>
<p>Response: From the author's perspective the examples of the
above that were identified in the <a class="reference external" href="/dev/peps/pep-0276">PEP 276</a> discussions did
not appear to be ones that would be accidentally misused
in ways that would lead to subtle and hard-to-detect errors.</p>
<p>In addition, it seems that there is a way to deal with this
issue by using a variation of what is outlined in the
specification section of this proposal.  Instead of adding
an <tt class="docutils literal">__iter__</tt> method to class int, change the for-loop handling
code to convert (in essence) from</p>
<pre class="literal-block">
for i in n:  # when isinstance(n,int) is 1
</pre>
<p>to</p>
<pre class="literal-block">
for i in xrange(n):
</pre>
<p>This approach gives the same results in a for-loop as an
<tt class="docutils literal">__iter__</tt> method would but would prevent iteration on integer
values in any other context.  Lists and tuples, for example,
don't have <tt class="docutils literal">__iter__</tt> and are handled with special code.
Integer values would be one more special case.</p>
</li>
<li><p class="first">&quot;i in n&quot; seems very unnatural.</p>
<p>Response: Some feel that &quot;i in len(mylist)&quot; would be easily
understandable and useful.  Some don't like it, particularly
when a literal is used as in &quot;i in 5&quot;.  If the variant
mentioned in the response to the previous issue is implemented,
this issue is moot.  If not, then one could also address this
issue by defining a <tt class="docutils literal">__contains__</tt> method in class int that would
always raise a TypeError.  This would then make the behavior of
&quot;i in n&quot; identical to that of current Python.</p>
</li>
<li><p class="first">Might dissuade newbies from using the indexed for-loop idiom when
the standard &quot;for item in collection:&quot; idiom is clearly better.</p>
<p>Response: The standard idiom is so nice when it fits that it
needs neither extra &quot;carrot&quot; nor &quot;stick&quot;.  On the other hand,
one does notice cases of overuse/misuse of the standard idiom
(due, most likely, to the awkwardness of the indexed for-loop
idiom), as in:</p>
<pre class="literal-block">
for item in sequence:
    print sequence.index(item)
</pre>
</li>
<li><p class="first">Why not propose even bigger changes?</p>
</li>
</ul>
<p>The majority of disagreement with <a class="reference external" href="/dev/peps/pep-0276">PEP 276</a> came from those who
favor much larger changes to Python to address the more general
problem of specifying a sequence of integers where such
a specification is general enough to handle the starting value,
ending value, and stepping value of the sequence and also
addresses variations of open, closed, and half-open (half-closed)
integer intervals.  Many suggestions of such were discussed.</p>
<p>These include:</p>
<ul class="simple">
<li>adding Haskell-like notation for specifying a sequence of
integers in a literal list,</li>
<li>various uses of slicing notation to specify sequences,</li>
<li>changes to the syntax of for-in loops to allow the use of
relational operators in the loop header,</li>
<li>creation of an integer-interval class along with methods that
overload relational operators or division operators
to provide &quot;slicing&quot; on integer-interval objects,</li>
<li>and more.</li>
</ul>
<p>It should be noted that there was much debate but not an
overwhelming consensus for any of these larger-scale suggestions.</p>
<p>Clearly, <a class="reference external" href="/dev/peps/pep-0276">PEP 276</a> does not propose such a large-scale change
and instead focuses on a specific problem area.  Towards the
end of the discussion period, several posters expressed favor
for the narrow focus and simplicity of <a class="reference external" href="/dev/peps/pep-0276">PEP 276</a> vis-a-vis the more
ambitious suggestions that were advanced.  There did appear to be
consensus for the need for a PEP for any such larger-scale,
alternative suggestion.  In light of this recognition, details of
the various alternative suggestions are not discussed here further.</p>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id11">Implementation</a></h1>
<p>An implementation is not available at this time but is expected
to be straightforward.  The author has implemented a subclass of
int with an <tt class="docutils literal">__iter__</tt> method (written in Python) as a means to test
out the ideas in this proposal, however.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id12">References</a></h1>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="/dev/peps/pep-0234">PEP 234</a>, Iterators
<a class="reference external" href="http://www.python.org/dev/peps/pep-0234/">http://www.python.org/dev/peps/pep-0234/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><a class="reference external" href="/dev/peps/pep-0204">PEP 204</a>, Range Literals
<a class="reference external" href="http://www.python.org/dev/peps/pep-0204/">http://www.python.org/dev/peps/pep-0204/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><a class="reference external" href="/dev/peps/pep-0212">PEP 212</a>, Loop Counter Iteration
<a class="reference external" href="http://www.python.org/dev/peps/pep-0212/">http://www.python.org/dev/peps/pep-0212/</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id13">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
fill-column: 70
End: -->
</div>

