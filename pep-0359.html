<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">359</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">The &quot;make&quot; Statement</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0359.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Steven Bethard &lt;steven.bethard&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Withdrawn</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">05-Apr-2006</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.6</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">05-Apr-2006, 06-Apr-2006, 13-Apr-2006</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id21">Abstract</a></li>
<li><a class="reference internal" href="#withdrawal-notice" id="id22">Withdrawal Notice</a></li>
<li><a class="reference internal" href="#motivation" id="id23">Motivation</a><ul>
<li><a class="reference internal" href="#example-simple-namespaces" id="id24">Example: simple namespaces</a></li>
<li><a class="reference internal" href="#example-gui-objects" id="id25">Example: GUI objects</a></li>
<li><a class="reference internal" href="#example-custom-descriptors" id="id26">Example: custom descriptors</a></li>
<li><a class="reference internal" href="#example-property-namespaces" id="id27">Example: property namespaces</a></li>
<li><a class="reference internal" href="#example-interfaces" id="id28">Example: interfaces</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification" id="id29">Specification</a></li>
<li><a class="reference internal" href="#open-issues" id="id30">Open Issues</a><ul>
<li><a class="reference internal" href="#keyword" id="id31">Keyword</a></li>
<li><a class="reference internal" href="#the-make-statement-as-an-alternate-constructor" id="id32">The make-statement as an alternate constructor</a></li>
<li><a class="reference internal" href="#customizing-the-dict-in-which-the-block-is-executed" id="id33">Customizing the dict in which the block is executed</a></li>
</ul>
</li>
<li><a class="reference internal" href="#optional-extensions" id="id34">Optional Extensions</a><ul>
<li><a class="reference internal" href="#remove-the-make-keyword" id="id35">Remove the make keyword</a></li>
<li><a class="reference internal" href="#removing-metaclass-in-python-3000" id="id36">Removing __metaclass__ in Python 3000</a></li>
<li><a class="reference internal" href="#removing-class-statements-in-python-3000" id="id37">Removing class statements in Python 3000</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references" id="id38">References</a></li>
<li><a class="reference internal" href="#copyright" id="id39">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id21">Abstract</a></h1>
<p>This PEP proposes a generalization of the class-declaration syntax,
the <tt class="docutils literal">make</tt> statement.  The proposed syntax and semantics parallel
the syntax for class definition, and so:</p>
<pre class="literal-block">
make &lt;callable&gt; &lt;name&gt; &lt;tuple&gt;:
    &lt;block&gt;
</pre>
<p>is translated into the assignment:</p>
<pre class="literal-block">
&lt;name&gt; = &lt;callable&gt;(&quot;&lt;name&gt;&quot;, &lt;tuple&gt;, &lt;namespace&gt;)
</pre>
<p>where <tt class="docutils literal">&lt;namespace&gt;</tt> is the dict created by executing <tt class="docutils literal">&lt;block&gt;</tt>.
This is mostly syntactic sugar for:</p>
<pre class="literal-block">
class &lt;name&gt; &lt;tuple&gt;:
    __metaclass__ = &lt;callable&gt;
    &lt;block&gt;
</pre>
<p>and is intended to help more clearly express the intent of the
statement when something other than a class is being created.  Of
course, other syntax for such a statement is possible, but it is hoped
that by keeping a strong parallel to the class statement, an
understanding of how classes and metaclasses work will translate into
an understanding of how the make-statement works as well.</p>
<p>The PEP is based on a suggestion <a class="footnote-reference" href="#id11" id="id1">[1]</a> from Michele Simionato on the
python-dev list.</p>
</div>
<div class="section" id="withdrawal-notice">
<h1><a class="toc-backref" href="#id22">Withdrawal Notice</a></h1>
<p>This PEP was withdrawn at Guido's request <a class="footnote-reference" href="#id12" id="id2">[2]</a>. Guido didn't like it,
and in particular didn't like how the property use-case puts the
instance methods of a property at a different level than other
instance methods and requires fixed names for the property functions.</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id23">Motivation</a></h1>
<p>Class statements provide two nice facilities to Python:</p>
<ol class="arabic simple">
<li>They execute a block of statements and provide the resulting
bindings as a dict to the metaclass.</li>
<li>They encourage DRY (don't repeat yourself) by allowing the class
being created to know the name it is being assigned.</li>
</ol>
<p>Thus in a simple class statement like:</p>
<pre class="literal-block">
class C(object):
    x = 1
    def foo(self):
        return 'bar'
</pre>
<p>the metaclass (<tt class="docutils literal">type</tt>) gets called with something like:</p>
<pre class="literal-block">
C = type('C', (object,), {'x':1, 'foo':&lt;function foo at ...&gt;})
</pre>
<p>The class statement is just syntactic sugar for the above assignment
statement, but clearly a very useful sort of syntactic sugar.  It
avoids not only the repetition of <tt class="docutils literal">C</tt>, but also simplifies the
creation of the dict by allowing it to be expressed as a series of
statements.</p>
<p>Historically, type instances (a.k.a. class objects) have been the
only objects blessed with this sort of syntactic support.  The make
statement aims to extend this support to other sorts of objects where
such syntax would also be useful.</p>
<div class="section" id="example-simple-namespaces">
<h2><a class="toc-backref" href="#id24">Example: simple namespaces</a></h2>
<p>Let's say I have some attributes in a module that I access like:</p>
<pre class="literal-block">
mod.thematic_roletype
mod.opinion_roletype

mod.text_format
mod.html_format
</pre>
<p>and since &quot;Namespaces are one honking great idea&quot;, I'd like to be able
to access these attributes instead as:</p>
<pre class="literal-block">
mod.roletypes.thematic
mod.roletypes.opinion

mod.format.text
mod.format.html
</pre>
<p>I currently have two main options:</p>
<ol class="arabic simple">
<li>Turn the module into a package, turn <tt class="docutils literal">roletypes</tt> and <tt class="docutils literal">format</tt>
into submodules, and move the attributes to the submodules.</li>
<li>Create <tt class="docutils literal">roletypes</tt> and <tt class="docutils literal">format</tt> classes, and move the
attributes to the classes.</li>
</ol>
<p>The former is a fair chunk of refactoring work, and produces two tiny
modules without much content.  The latter keeps the attributes local
to the module, but creates classes when there is no intention of ever
creating instances of those classes.</p>
<p>In situations like this, it would be nice to simply be able to declare
a &quot;namespace&quot; to hold the few attributes.  With the new make
statement, I could introduce my new namespaces with something like:</p>
<pre class="literal-block">
make namespace roletypes:
    thematic = ...
    opinion = ...

make namespace format:
    text = ...
    html = ...
</pre>
<p>and keep my attributes local to the module without making classes that
are never intended to be instantiated.  One definition of namespace
that would make this work is:</p>
<pre class="literal-block">
class namespace(object):
    def __init__(self, name, args, kwargs):
        self.__dict__.update(kwargs)
</pre>
<p>Given this definition, at the end of the make-statements above,
<tt class="docutils literal">roletypes</tt> and <tt class="docutils literal">format</tt> would be namespace instances.</p>
</div>
<div class="section" id="example-gui-objects">
<h2><a class="toc-backref" href="#id25">Example: GUI objects</a></h2>
<p>In GUI toolkits, objects like frames and panels are often associated
with attributes and functions.  With the make-statement, code that
looks something like:</p>
<pre class="literal-block">
root = Tkinter.Tk()
frame = Tkinter.Frame(root)
frame.pack()
def say_hi():
    print &quot;hi there, everyone!&quot;
hi_there = Tkinter.Button(frame, text=&quot;Hello&quot;, command=say_hi)
hi_there.pack(side=Tkinter.LEFT)
root.mainloop()
</pre>
<p>could be rewritten to group the Button's function with its
declaration:</p>
<pre class="literal-block">
root = Tkinter.Tk()
frame = Tkinter.Frame(root)
frame.pack()
make Tkinter.Button hi_there(frame):
    text = &quot;Hello&quot;
    def command():
        print &quot;hi there, everyone!&quot;
hi_there.pack(side=Tkinter.LEFT)
root.mainloop()
</pre>
</div>
<div class="section" id="example-custom-descriptors">
<h2><a class="toc-backref" href="#id26">Example: custom descriptors</a></h2>
<p>Since descriptors are used to customize access to an attribute, it's
often useful to know the name of that attribute.  Current Python
doesn't give an easy way to find this name and so a lot of custom
descriptors, like Ian Bicking's setonce descriptor <a class="footnote-reference" href="#id13" id="id3">[3]</a>, have to hack
around this somehow.  With the make-statement, you could create a
<tt class="docutils literal">setonce</tt> attribute like:</p>
<pre class="literal-block">
class A(object):
    ...
    make setonce x:
        &quot;A's x attribute&quot;
    ...
</pre>
<p>where the <tt class="docutils literal">setonce</tt> descriptor would be defined like:</p>
<pre class="literal-block">
class setonce(object):

    def __init__(self, name, args, kwargs):
        self._name = '_setonce_attr_%s' % name
        self.__doc__ = kwargs.pop('__doc__', None)

    def __get__(self, obj, type=None):
        if obj is None:
            return self
        return getattr(obj, self._name)

    def __set__(self, obj, value):
        try:
            getattr(obj, self._name)
        except AttributeError:
            setattr(obj, self._name, value)
        else:
            raise AttributeError(&quot;Attribute already set&quot;)

    def set(self, obj, value):
        setattr(obj, self._name, value)

    def __delete__(self, obj):
        delattr(obj, self._name)
</pre>
<p>Note that unlike the original implementation, the private attribute
name is stable since it uses the name of the descriptor, and therefore
instances of class A are pickleable.</p>
</div>
<div class="section" id="example-property-namespaces">
<h2><a class="toc-backref" href="#id27">Example: property namespaces</a></h2>
<p>Python's property type takes three function arguments and a docstring
argument which, though relevant only to the property, must be declared
before it and then passed as arguments to the property call, e.g.:</p>
<pre class="literal-block">
class C(object):
    ...
    def get_x(self):
        ...
    def set_x(self):
        ...
    x = property(get_x, set_x, &quot;the x of the frobulation&quot;)
</pre>
<p>This issue has been brought up before, and Guido <a class="footnote-reference" href="#id14" id="id4">[4]</a> and others <a class="footnote-reference" href="#id15" id="id5">[5]</a>
have briefly mused over alternate property syntaxes to make declaring
properties easier.  With the make-statement, the following syntax
could be supported:</p>
<pre class="literal-block">
class C(object):
    ...
    make block_property x:
        '''The x of the frobulation'''
        def fget(self):
            ...
        def fset(self):
            ...
</pre>
<p>with the following definition of <tt class="docutils literal">block_property</tt>:</p>
<pre class="literal-block">
def block_property(name, args, block_dict):
    fget = block_dict.pop('fget', None)
    fset = block_dict.pop('fset', None)
    fdel = block_dict.pop('fdel', None)
    doc = block_dict.pop('__doc__', None)
    assert not block_dict
    return property(fget, fset, fdel, doc)
</pre>
</div>
<div class="section" id="example-interfaces">
<h2><a class="toc-backref" href="#id28">Example: interfaces</a></h2>
<p>Guido <a class="footnote-reference" href="#id16" id="id6">[6]</a> and others have occasionally suggested introducing
interfaces into python.  Most suggestions have offered syntax along
the lines of:</p>
<pre class="literal-block">
interface IFoo:
    &quot;&quot;&quot;Foo blah blah&quot;&quot;&quot;

    def fumble(name, count):
        &quot;&quot;&quot;docstring&quot;&quot;&quot;
</pre>
<p>but since there is currently no way in Python to declare an interface
in this manner, most implementations of Python interfaces use class
objects instead, e.g. Zope's:</p>
<pre class="literal-block">
class IFoo(Interface):
    &quot;&quot;&quot;Foo blah blah&quot;&quot;&quot;

    def fumble(name, count):
        &quot;&quot;&quot;docstring&quot;&quot;&quot;
</pre>
<p>With the new make-statement, these interfaces could instead be
declared as:</p>
<pre class="literal-block">
make Interface IFoo:
    &quot;&quot;&quot;Foo blah blah&quot;&quot;&quot;

    def fumble(name, count):
        &quot;&quot;&quot;docstring&quot;&quot;&quot;
</pre>
<p>which makes the intent (that this is an interface, not a class) much
clearer.</p>
</div>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id29">Specification</a></h1>
<p>Python will translate a make-statement:</p>
<pre class="literal-block">
make &lt;callable&gt; &lt;name&gt; &lt;tuple&gt;:
    &lt;block&gt;
</pre>
<p>into the assignment:</p>
<pre class="literal-block">
&lt;name&gt; = &lt;callable&gt;(&quot;&lt;name&gt;&quot;, &lt;tuple&gt;, &lt;namespace&gt;)
</pre>
<p>where <tt class="docutils literal">&lt;namespace&gt;</tt> is the dict created by executing <tt class="docutils literal">&lt;block&gt;</tt>.
The <tt class="docutils literal">&lt;tuple&gt;</tt> expression is optional; if not present, an empty tuple
will be assumed.</p>
<p>A patch is available implementing these semantics <a class="footnote-reference" href="#id17" id="id7">[7]</a>.</p>
<p>The make-statement introduces a new keyword, <tt class="docutils literal">make</tt>.  Thus in Python
2.6, the make-statement will have to be enabled using <tt class="docutils literal">from
__future__ import make_statement</tt>.</p>
</div>
<div class="section" id="open-issues">
<h1><a class="toc-backref" href="#id30">Open Issues</a></h1>
<div class="section" id="keyword">
<h2><a class="toc-backref" href="#id31">Keyword</a></h2>
<p>Does the <tt class="docutils literal">make</tt> keyword break too much code?  Originally, the make
statement used the keyword <tt class="docutils literal">create</tt> (a suggestion due to Nick
Coghlan).  However, investigations into the standard library <a class="footnote-reference" href="#id18" id="id8">[8]</a> and
Zope+Plone code <a class="footnote-reference" href="#id19" id="id9">[9]</a> revealed that <tt class="docutils literal">create</tt> would break a lot more
code, so <tt class="docutils literal">make</tt> was adopted as the keyword instead.  However, there
are still a few instances where <tt class="docutils literal">make</tt> would break code.  Is there a
better keyword for the statement?</p>
<p>Some possible keywords and their counts in the standard library (plus
some installed packages):</p>
<ul class="simple">
<li>make - 2 (both in tests)</li>
<li>create - 19 (including existing function in imaplib)</li>
<li>build - 83 (including existing class in distutils.command.build)</li>
<li>construct - 0</li>
<li>produce - 0</li>
</ul>
</div>
<div class="section" id="the-make-statement-as-an-alternate-constructor">
<h2><a class="toc-backref" href="#id32">The make-statement as an alternate constructor</a></h2>
<p>Currently, there are not many functions which have the signature
<tt class="docutils literal">(name, args, kwargs)</tt>.  That means that something like:</p>
<pre class="literal-block">
make dict params:
    x = 1
    y = 2
</pre>
<p>is currently impossible because the dict constructor has a different
signature.  Does this sort of thing need to be supported?  One
suggestion, by Carl Banks, would be to add a <tt class="docutils literal">__make__</tt> magic method
that if found would be called instead of <tt class="docutils literal">__call__</tt>.  For types,
the <tt class="docutils literal">__make__</tt> method would be identical to <tt class="docutils literal">__call__</tt> and thus
unnecessary, but dicts could support the make-statement by defining a
<tt class="docutils literal">__make__</tt> method on the dict type that looks something like:</p>
<pre class="literal-block">
def __make__(cls, name, args, kwargs):
    return cls(**kwargs)
</pre>
<p>Of course, rather than adding another magic method, the dict type
could just grow a classmethod something like <tt class="docutils literal">dict.fromblock</tt> that
could be used like:</p>
<pre class="literal-block">
make dict.fromblock params:
    x = 1
    y = 2
</pre>
<p>So the question is, will many types want to use the make-statement as
an alternate constructor?  And if so, does that alternate constructor
need to have the same name as the original constructor?</p>
</div>
<div class="section" id="customizing-the-dict-in-which-the-block-is-executed">
<h2><a class="toc-backref" href="#id33">Customizing the dict in which the block is executed</a></h2>
<p>Should users of the make-statement be able to determine in which dict
object the code is executed?  This would allow the make-statement to
be used in situations where a normal dict object would not suffice,
e.g. if order and repeated names must be allowed.  Allowing this sort
of customization could allow XML to be written without repeating
element names, and with nesting of make-statements corresponding to
nesting of XML elements:</p>
<pre class="literal-block">
make Element html:
    make Element body:
        text('before first h1')
        make Element h1:
            attrib(style='first')
            text('first h1')
            tail('after first h1')
        make Element h1:
            attrib(style='second')
            text('second h1')
            tail('after second h1')
</pre>
<p>If the make-statement tried to get the dict in which to execute its
block by calling the callable's <tt class="docutils literal">__make_dict__</tt> method, the
following code would allow the make-statement to be used as above:</p>
<pre class="literal-block">
class Element(object):

    class __make_dict__(dict):

        def __init__(self, *args, **kwargs):
            self._super = super(Element.__make_dict__, self)
            self._super.__init__(*args, **kwargs)
            self.elements = []
            self.text = None
            self.tail = None
            self.attrib = {}

        def __getitem__(self, name):
            try:
                return self._super.__getitem__(name)
            except KeyError:
                if name in ['attrib', 'text', 'tail']:
                    return getattr(self, 'set_%s' % name)
                else:
                    return globals()[name]

        def __setitem__(self, name, value):
            self._super.__setitem__(name, value)
            self.elements.append(value)

        def set_attrib(self, **kwargs):
            self.attrib = kwargs

        def set_text(self, text):
            self.text = text

        def set_tail(self, text):
            self.tail = text

    def __new__(cls, name, args, edict):
        get_element = etree.ElementTree.Element
        result = get_element(name, attrib=edict.attrib)
        result.text = edict.text
        result.tail = edict.tail
        for element in edict.elements:
            result.append(element)
        return result
</pre>
<p>Note, however, that the code to support this is somewhat fragile --
it has to magically populate the namespace with <tt class="docutils literal">attrib</tt>, <tt class="docutils literal">text</tt>
and <tt class="docutils literal">tail</tt>, and it assumes that every name binding inside the make
statement body is creating an Element.  As it stands, this code would
break with the introduction of a simple for-loop to any one of the
make-statement bodies, because the for-loop would bind a name to a
non-Element object.  This could be worked around by adding some sort
of isinstance check or attribute examination, but this still results
in a somewhat fragile solution.</p>
<p>It has also been pointed out that the with-statement can provide
equivalent nesting with a much more explicit syntax:</p>
<pre class="literal-block">
with Element('html') as html:
    with Element('body') as body:
        body.text = 'before first h1'
        with Element('h1', style='first') as h1:
            h1.text = 'first h1'
            h1.tail = 'after first h1'
        with Element('h1', style='second') as h1:
            h1.text = 'second h1'
            h1.tail = 'after second h1'
</pre>
<p>And if the repetition of the element names here is too much of a DRY
violoation, it is also possible to eliminate all as-clauses except for
the first by adding a few methods to Element. <a class="footnote-reference" href="#id20" id="id10">[10]</a></p>
<p>So are there real use-cases for executing the block in a dict of a
different type?  And if so, should the make-statement be extended to
support them?</p>
</div>
</div>
<div class="section" id="optional-extensions">
<h1><a class="toc-backref" href="#id34">Optional Extensions</a></h1>
<div class="section" id="remove-the-make-keyword">
<h2><a class="toc-backref" href="#id35">Remove the make keyword</a></h2>
<p>It might be possible to remove the make keyword so that such
statements would begin with the callable being called, e.g.:</p>
<pre class="literal-block">
namespace ns:
    badger = 42
    def spam():
        ...

interface C(...):
    ...
</pre>
<p>However, almost all other Python statements begin with a keyword, and
removing the keyword would make it harder to look up this construct in
the documentation.  Additionally, this would add some complexity in
the grammar and so far I (Steven Bethard) have not been able to
implement the feature without the keyword.</p>
</div>
<div class="section" id="removing-metaclass-in-python-3000">
<h2><a class="toc-backref" href="#id36">Removing __metaclass__ in Python 3000</a></h2>
<p>As a side-effect of its generality, the make-statement mostly
eliminates the need for the <tt class="docutils literal">__metaclass__</tt> attribute in class
objects.  Thus in Python 3000, instead of:</p>
<pre class="literal-block">
class &lt;name&gt; &lt;bases-tuple&gt;:
    __metaclass__ = &lt;metaclass&gt;
    &lt;block&gt;
</pre>
<p>metaclasses could be supported by using the metaclass as the callable
in a make-statement:</p>
<pre class="literal-block">
make &lt;metaclass&gt; &lt;name&gt; &lt;bases-tuple&gt;:
    &lt;block&gt;
</pre>
<p>Removing the <tt class="docutils literal">__metaclass__</tt> hook would simplify the BUILD_CLASS
opcode a bit.</p>
</div>
<div class="section" id="removing-class-statements-in-python-3000">
<h2><a class="toc-backref" href="#id37">Removing class statements in Python 3000</a></h2>
<p>In the most extreme application of make-statements, the class
statement itself could be deprecated in favor of <tt class="docutils literal">make type</tt>
statements.</p>
</div>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id38">References</a></h1>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Michele Simionato's original suggestion
(<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2005-October/057435.html">https://mail.python.org/pipermail/python-dev/2005-October/057435.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Guido requests withdrawal
(<a class="reference external" href="https://mail.python.org/pipermail/python-3000/2006-April/000936.html">https://mail.python.org/pipermail/python-3000/2006-April/000936.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>Ian Bicking's setonce descriptor
(<a class="reference external" href="http://blog.ianbicking.org/easy-readonly-attributes.html">http://blog.ianbicking.org/easy-readonly-attributes.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>Guido ponders property syntax
(<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2005-October/057404.html">https://mail.python.org/pipermail/python-dev/2005-October/057404.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>Namespace-based property recipe
(<a class="reference external" href="http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/442418">http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/442418</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td>Python interfaces
(<a class="reference external" href="http://www.artima.com/weblogs/viewpost.jsp?thread=86641">http://www.artima.com/weblogs/viewpost.jsp?thread=86641</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[7]</a></td><td>Make Statement patch
(<a class="reference external" href="http://ucsu.colorado.edu/~bethard/py/make_statement.patch">http://ucsu.colorado.edu/~bethard/py/make_statement.patch</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[8]</a></td><td>Instances of create in the stdlib
(<a class="reference external" href="https://mail.python.org/pipermail/python-list/2006-April/335159.html">https://mail.python.org/pipermail/python-list/2006-April/335159.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[9]</a></td><td>Instances of create in Zope+Plone
(<a class="reference external" href="https://mail.python.org/pipermail/python-list/2006-April/335284.html">https://mail.python.org/pipermail/python-list/2006-April/335284.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[10]</a></td><td>Eliminate as-clauses in with-statement XML
(<a class="reference external" href="https://mail.python.org/pipermail/python-list/2006-April/336774.html">https://mail.python.org/pipermail/python-list/2006-April/336774.html</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id39">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

