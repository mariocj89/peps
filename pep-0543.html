<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">543</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">A Unified TLS API for Python</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0543.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Cory Benfield &lt;cory&#32;&#97;t&#32;lukasa.co.uk&gt;,
Christian Heimes &lt;christian&#32;&#97;t&#32;python.org&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Draft</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">17-Oct-2016</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.7</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">11-Jan-2017, 19-Jan-2017, 02-Feb-2017, 09-Feb-2017</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id38">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id39">Rationale</a><ul>
<li><a class="reference internal" href="#problems" id="id40">Problems</a></li>
</ul>
</li>
<li><a class="reference internal" href="#proposal" id="id41">Proposal</a><ul>
<li><a class="reference internal" href="#interfaces" id="id42">Interfaces</a><ul>
<li><a class="reference internal" href="#configuration" id="id43">Configuration</a></li>
<li><a class="reference internal" href="#context" id="id44">Context</a></li>
<li><a class="reference internal" href="#buffer" id="id45">Buffer</a></li>
<li><a class="reference internal" href="#socket" id="id46">Socket</a></li>
<li><a class="reference internal" href="#cipher-suites" id="id47">Cipher Suites</a><ul>
<li><a class="reference internal" href="#openssl" id="id48">OpenSSL</a></li>
<li><a class="reference internal" href="#securetransport" id="id49">SecureTransport</a></li>
<li><a class="reference internal" href="#schannel" id="id50">SChannel</a></li>
<li><a class="reference internal" href="#network-security-services-nss" id="id51">Network Security Services (NSS)</a></li>
<li><a class="reference internal" href="#proposed-interface" id="id52">Proposed Interface</a></li>
</ul>
</li>
<li><a class="reference internal" href="#protocol-negotiation" id="id53">Protocol Negotiation</a></li>
<li><a class="reference internal" href="#tls-versions" id="id54">TLS Versions</a></li>
<li><a class="reference internal" href="#errors" id="id55">Errors</a></li>
<li><a class="reference internal" href="#certificates" id="id56">Certificates</a></li>
<li><a class="reference internal" href="#private-keys" id="id57">Private Keys</a></li>
<li><a class="reference internal" href="#trust-store" id="id58">Trust Store</a></li>
<li><a class="reference internal" href="#runtime-access" id="id59">Runtime Access</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#changes-to-the-standard-library" id="id60">Changes to the Standard Library</a><ul>
<li><a class="reference internal" href="#migration-of-the-ssl-module" id="id61">Migration of the ssl module</a></li>
</ul>
</li>
<li><a class="reference internal" href="#future" id="id62">Future</a></li>
<li><a class="reference internal" href="#credits" id="id63">Credits</a></li>
<li><a class="reference internal" href="#id1" id="id64">References</a></li>
<li><a class="reference internal" href="#copyright" id="id65">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id38">Abstract</a></h1>
<p>This PEP would define a standard TLS interface in the form of a collection of
abstract base classes. This interface would allow Python implementations and
third-party libraries to provide bindings to TLS libraries other than OpenSSL
that can be used by tools that expect the interface provided by the Python
standard library, with the goal of reducing the dependence of the Python
ecosystem on OpenSSL.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id39">Rationale</a></h1>
<p>In the 21st century it has become increasingly clear that robust and
user-friendly TLS support is an extremely important part of the ecosystem of
any popular programming language. For most of its lifetime, this role in the
Python ecosystem has primarily been served by the <a class="reference external" href="https://docs.python.org/3/library/ssl.html">ssl module</a> <a class="footnote-reference" href="#id2" id="id3">[1]</a>, which provides
a Python API to the <a class="reference external" href="https://www.openssl.org/">OpenSSL library</a> <a class="footnote-reference" href="#id4" id="id5">[2]</a>.</p>
<p>Because the <tt class="docutils literal">ssl</tt> module is distributed with the Python standard library, it
has become the overwhelmingly most-popular method for handling TLS in Python.
An extraordinary majority of Python libraries, both in the standard library and
on the Python Package Index, rely on the <tt class="docutils literal">ssl</tt> module for their TLS
connectivity.</p>
<p>Unfortunately, the preeminence of the <tt class="docutils literal">ssl</tt> module has had a number of
unforeseen side-effects that have had the effect of tying the entire Python
ecosystem tightly to OpenSSL. This has forced Python users to use OpenSSL even
in situations where it may provide a worse user experience than alternative TLS
implementations, which imposes a cognitive burden and makes it hard to provide
&quot;platform-native&quot; experiences.</p>
<div class="section" id="problems">
<h2><a class="toc-backref" href="#id40">Problems</a></h2>
<p>The fact that the <tt class="docutils literal">ssl</tt> module is built into the standard library has meant
that all standard-library Python networking libraries are entirely reliant on
the OpenSSL that the Python implementation has been linked against. This
leads to the following issues:</p>
<ul>
<li><p class="first">It is difficult to take advantage of new, higher-security TLS without
recompiling Python to get a new OpenSSL. While there are third-party bindings
to OpenSSL (e.g. <a class="reference external" href="https://pypi.org/project/pyOpenSSL/">pyOpenSSL</a> <a class="footnote-reference" href="#id6" id="id7">[3]</a>), these need to be shimmed into a format that
the standard library understands, forcing projects that want to use them to
maintain substantial compatibility layers.</p>
</li>
<li><p class="first">For Windows distributions of Python, they need to be shipped with a copy of
OpenSSL. This puts the CPython development team in the position of being
OpenSSL redistributors, potentially needing to ship security updates to the
Windows Python distributions when OpenSSL vulnerabilities are released.</p>
</li>
<li><p class="first">For macOS distributions of Python, they need either to be shipped with a copy
of OpenSSL or linked against the system OpenSSL library. Apple has formally
deprecated linking against the system OpenSSL library, and even if they had
not, that library version has been unsupported by upstream for nearly one
year as of the time of writing. The CPython development team has started
shipping newer OpenSSLs with the Python available from python.org, but this
has the same problem as with Windows.</p>
</li>
<li><p class="first">Many systems, including but not limited to Windows and macOS, do not make
their system certificate stores available to OpenSSL. This forces users to
either obtain their trust roots from elsewhere (e.g. <a class="reference external" href="https://pypi.org/project/certifi/">certifi</a> <a class="footnote-reference" href="#id8" id="id9">[4]</a>) or to
attempt to export their system trust stores in some form.</p>
<p>Relying on <a class="reference external" href="https://pypi.org/project/certifi/">certifi</a> <a class="footnote-reference" href="#id8" id="id10">[4]</a> is less than ideal, as most system administrators do
not expect to receive security-critical software updates from PyPI.
Additionally, it is not easy to extend the <a class="reference external" href="https://pypi.org/project/certifi/">certifi</a> <a class="footnote-reference" href="#id8" id="id11">[4]</a> trust bundle to include
custom roots, or to centrally manage trust using the <a class="reference external" href="https://pypi.org/project/certifi/">certifi</a> <a class="footnote-reference" href="#id8" id="id12">[4]</a> model.</p>
<p>Even in situations where the system certificate stores are made available to
OpenSSL in some form, the experience is still sub-standard, as OpenSSL will
perform different validation checks than the platform-native TLS
implementation. This can lead to users experiencing different behaviour on
their browsers or other platform-native tools than they experience in Python,
with little or no recourse to resolve the problem.</p>
</li>
<li><p class="first">Users may wish to integrate with TLS libraries other than OpenSSL for many
other reasons, such as OpenSSL missing features (e.g. TLS 1.3 support), or
because OpenSSL is simply too large and unwieldy for the platform (e.g. for
embedded Python). Those users are left with the requirement to use
third-party networking libraries that can interact with their preferred TLS
library or to shim their preferred library into the OpenSSL-specific <tt class="docutils literal">ssl</tt>
module API.</p>
</li>
</ul>
<p>Additionally, the <tt class="docutils literal">ssl</tt> module as implemented today limits the ability of
CPython itself to add support for alternative TLS backends, or remove OpenSSL
support entirely, should either of these become necessary or useful. The
<tt class="docutils literal">ssl</tt> module exposes too many OpenSSL-specific function calls and features to
easily map to an alternative TLS backend.</p>
</div>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id41">Proposal</a></h1>
<p>This PEP proposes to introduce a few new Abstract Base Classes in Python 3.7 to
provide TLS functionality that is not so strongly tied to OpenSSL. It also
proposes to update standard library modules to use only the interface exposed
by these abstract base classes wherever possible. There are three goals here:</p>
<ol class="arabic simple">
<li>To provide a common API surface for both core and third-party developers to
target their TLS implementations to. This allows TLS developers to provide
interfaces that can be used by most Python code, and allows network
developers to have an interface that they can target that will work with a
wide range of TLS implementations.</li>
<li>To provide an API that has few or no OpenSSL-specific concepts leak through.
The <tt class="docutils literal">ssl</tt> module today has a number of warts caused by leaking OpenSSL
concepts through to the API: the new ABCs would remove those specific
concepts.</li>
<li>To provide a path for the core development team to make OpenSSL one of many
possible TLS backends, rather than requiring that it be present on a system
in order for Python to have TLS support.</li>
</ol>
<p>The proposed interface is laid out below.</p>
<div class="section" id="interfaces">
<h2><a class="toc-backref" href="#id42">Interfaces</a></h2>
<p>There are several interfaces that require standardisation. Those interfaces
are:</p>
<ol class="arabic simple">
<li>Configuring TLS, currently implemented by the <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext">SSLContext</a> <a class="footnote-reference" href="#id13" id="id14">[5]</a> class in the
<tt class="docutils literal">ssl</tt> module.</li>
<li>Providing an in-memory buffer for doing in-memory encryption or decryption
with no actual I/O (necessary for asynchronous I/O models), currently
implemented by the <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLObject">SSLObject</a> <a class="footnote-reference" href="#id21" id="id22">[7]</a> class in the <tt class="docutils literal">ssl</tt> module.</li>
<li>Wrapping a socket object, currently implemented by the <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLSocket">SSLSocket</a> <a class="footnote-reference" href="#id19" id="id20">[6]</a> class
in the <tt class="docutils literal">ssl</tt> module.</li>
<li>Applying TLS configuration to the wrapping objects in (2) and (3). Currently
this is also implemented by the <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext">SSLContext</a> <a class="footnote-reference" href="#id13" id="id15">[5]</a> class in the <tt class="docutils literal">ssl</tt> module.</li>
<li>Specifying TLS cipher suites. There is currently no code for doing this in
the standard library: instead, the standard library uses OpenSSL cipher
suite strings.</li>
<li>Specifying application-layer protocols that can be negotiated during the
TLS handshake.</li>
<li>Specifying TLS versions.</li>
<li>Reporting errors to the caller, currently implemented by the <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLError">SSLError</a> <a class="footnote-reference" href="#id23" id="id24">[8]</a>
class in the <tt class="docutils literal">ssl</tt> module.</li>
<li>Specifying certificates to load, either as client or server certificates.</li>
<li>Specifying which trust database should be used to validate certificates
presented by a remote peer.</li>
<li>Finding a way to get hold of these interfaces at run time.</li>
</ol>
<p>For the sake of simplicitly, this PEP proposes to take a unified approach to
(2) and (3) (that is, buffers and sockets). The Python socket API is a
sizeable one, and implementing a wrapped socket that has the same behaviour as
a regular Python socket is a subtle and tricky thing to do. However, it is
entirely possible to implement a <em>generic</em> wrapped socket in terms of wrapped
buffers: that is, it is possible to write a wrapped socket (3) that will work
for any implementation that provides (2). For this reason, this PEP proposes to
provide an ABC for wrapped buffers (2) but a concrete class for wrapped sockets
(3).</p>
<p>This decision has the effect of making it impossible to bind a small number of
TLS libraries to this ABC, because those TLS libraries <em>cannot</em> provide a
wrapped buffer implementation. The most notable of these at this time appears
to be Amazon's <a class="reference external" href="https://github.com/awslabs/s2n">s2n</a> <a class="footnote-reference" href="#id34" id="id35">[13]</a>, which currently does not provide an I/O abstraction
layer. However, even this library consider this a missing feature and are
<a class="reference external" href="https://github.com/awslabs/s2n/issues/358">working to add it</a> <a class="footnote-reference" href="#id36" id="id37">[14]</a>. For this reason, it is safe to assume that a concrete
implementation of (3) in terms of (2) will be a substantial effort-saving
device and a great tool for correctness. Therefore, this PEP proposes doing
just that.</p>
<p>Obviously, (5) doesn't require an abstract base class: instead, it requires a
richer API for configuring supported cipher suites that can be easily updated
with supported cipher suites for different implementations.</p>
<p>(9) is a thorny problem, because in an ideal world the private keys associated
with these certificates would never end up in-memory in the Python process
(that is, the TLS library would collaborate with a Hardware Security Module
(HSM) to provide the private key in such a way that it cannot be extracted from
process memory). Thus, we need to provide an extensible model of providing
certificates that allows concrete implementations the ability to provide this
higher level of security, while also allowing a lower bar for those
implementations that cannot. This lower bar would be the same as the status
quo: that is, the certificate may be loaded from an in-memory buffer or from a
file on disk.</p>
<p>(10) also represents an issue because different TLS implementations vary wildly
in how they allow users to select trust stores. Some implementations have
specific trust store formats that only they can use (such as the OpenSSL CA
directory format that is created by <tt class="docutils literal">c_rehash</tt>), and others may not allow you
to specify a trust store that does not include their default trust store.</p>
<p>For this reason, we need to provide a model that assumes very little about the
form that trust stores take. The &quot;Trust Store&quot; section below goes into more
detail about how this is achieved.</p>
<p>Finally, this API will split the responsibilities currently assumed by the
<a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext">SSLContext</a> <a class="footnote-reference" href="#id13" id="id16">[5]</a> object: specifically, the responsibility for holding and managing
configuration and the responsibility for using that configuration to build
wrapper objects.</p>
<p>This is necessarily primarily for supporting functionality like Server Name
Indication (SNI). In OpenSSL (and thus in the <tt class="docutils literal">ssl</tt> module), the server has
the ability to modify the TLS configuration in response to the client telling
the server what hostname it is trying to reach. This is mostly used to change
certificate chain so as to present the correct TLS certificate chain for the
given hostname. The specific mechanism by which this is done is by returning
a new <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext">SSLContext</a> <a class="footnote-reference" href="#id13" id="id17">[5]</a> object with the appropriate configuration.</p>
<p>This is not a model that maps well to other TLS implementations. Instead, we
need to make it possible to provide a return value from the SNI callback that
can be used to indicate what configuration changes should be made. This means
providing an object that can hold TLS configuration. This object needs to be
applied to specific TLSWrappedBuffer, and TLSWrappedSocket objects.</p>
<p>For this reason, we split the responsibility of <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext">SSLContext</a> <a class="footnote-reference" href="#id13" id="id18">[5]</a> into two separate
objects. The <tt class="docutils literal">TLSConfiguration</tt> object is an object that acts as container
for TLS configuration: the <tt class="docutils literal">ClientContext</tt> and <tt class="docutils literal">ServerContext</tt> objects are
objects that are instantiated with a <tt class="docutils literal">TLSConfiguration</tt> object. All three
objects would be immutable.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The following API declarations uniformly use type hints to aid
reading. Some of these type hints cannot actually be used in practice
because they are circularly referential. Consider them more a
guideline than a reflection of the final code in the module.</p>
</div>
<div class="section" id="configuration">
<h3><a class="toc-backref" href="#id43">Configuration</a></h3>
<p>The <tt class="docutils literal">TLSConfiguration</tt> concrete class defines an object that can hold and
manage TLS configuration. The goals of this class are as follows:</p>
<ol class="arabic simple">
<li>To provide a method of specifying TLS configuration that avoids the risk of
errors in typing (this excludes the use of a simple dictionary).</li>
<li>To provide an object that can be safely compared to other configuration
objects to detect changes in TLS configuration, for use with the SNI
callback.</li>
</ol>
<p>This class is not an ABC, primarily because it is not expected to have
implementation-specific behaviour. The responsibility for transforming a
<tt class="docutils literal">TLSConfiguration</tt> object into a useful set of configuration for a given TLS
implementation belongs to the Context objects discussed below.</p>
<p>This class has one other notable property: it is immutable. This is a desirable
trait for a few reasons. The most important one is that it allows these objects
to be used as dictionary keys, which is potentially extremely valuable for
certain TLS backends and their SNI configuration. On top of this, it frees
implementations from needing to worry about their configuration objects being
changed under their feet, which allows them to avoid needing to carefully
synchronize changes between their concrete data structures and the
configuration object.</p>
<p>This object is extendable: that is, future releases of Python may add
configuration fields to this object as they become useful. For
backwards-compatibility purposes, new fields are only appended to this object.
Existing fields will never be removed, renamed, or reordered.</p>
<p>The <tt class="docutils literal">TLSConfiguration</tt> object would be defined by the following code:</p>
<pre class="literal-block">
ServerNameCallback = Callable[[TLSBufferObject, Optional[str], TLSConfiguration], Any]


_configuration_fields = [
    'validate_certificates',
    'certificate_chain',
    'ciphers',
    'inner_protocols',
    'lowest_supported_version',
    'highest_supported_version',
    'trust_store',
    'sni_callback',
]


_DEFAULT_VALUE = object()


class TLSConfiguration(namedtuple('TLSConfiguration', _configuration_fields)):
    &quot;&quot;&quot;
    An immutable TLS Configuration object. This object has the following
    properties:

    :param validate_certificates bool: Whether to validate the TLS
        certificates. This switch operates at a very broad scope: either
        validation is enabled, in which case all forms of validation are
        performed including hostname validation if possible, or validation
        is disabled, in which case no validation is performed.

        Not all backends support having their certificate validation
        disabled. If a backend does not support having their certificate
        validation disabled, attempting to set this property to ``False``
        will throw a ``TLSError`` when this object is passed into a
        context object.

    :param certificate_chain Tuple[Tuple[Certificate],PrivateKey]: The
        certificate, intermediate certificate, and the corresponding
        private key for the leaf certificate. These certificates will be
        offered to the remote peer during the handshake if required.

        The first Certificate in the list must be the leaf certificate. All
        subsequent certificates will be offered as intermediate additional
        certificates.

    :param ciphers Tuple[Union[CipherSuite, int]]:
        The available ciphers for TLS connections created with this
        configuration, in priority order.

    :param inner_protocols Tuple[Union[NextProtocol, bytes]]:
        Protocols that connections created with this configuration should
        advertise as supported during the TLS handshake. These may be
        advertised using either or both of ALPN or NPN. This list of
        protocols should be ordered by preference.

    :param lowest_supported_version TLSVersion:
        The minimum version of TLS that should be allowed on TLS
        connections using this configuration.

    :param highest_supported_version TLSVersion:
        The maximum version of TLS that should be allowed on TLS
        connections using this configuration.

    :param trust_store TrustStore:
        The trust store that connections using this configuration will use
        to validate certificates.

    :param sni_callback Optional[ServerNameCallback]:
        A callback function that will be called after the TLS Client Hello
        handshake message has been received by the TLS server when the TLS
        client specifies a server name indication.

        Only one callback can be set per ``TLSConfiguration``. If the
        ``sni_callback`` is ``None`` then the callback is disabled. If the
        ``TLSConfiguration`` is used for a ``ClientContext`` then this
        setting will be ignored.

        The ``callback`` function will be called with three arguments: the
        first will be the ``TLSBufferObject`` for the connection; the
        second will be a string that represents the server name that the
        client is intending to communicate (or ``None`` if the TLS Client
        Hello does not contain a server name); and the third argument will
        be the original ``TLSConfiguration`` that configured the
        connection. The server name argument will be the IDNA *decoded*
        server name.

        The ``callback`` must return a ``TLSConfiguration`` to allow
        negotiation to continue. Other return values signal errors.
        Attempting to control what error is signaled by the underlying TLS
        implementation is not specified in this API, but is up to the
        concrete implementation to handle.

        The Context will do its best to apply the ``TLSConfiguration``
        changes from its original configuration to the incoming connection.
        This will usually include changing the certificate chain, but may
        also include changes to allowable ciphers or any other
        configuration settings.
    &quot;&quot;&quot;
    __slots__ = ()

    def __new__(cls, validate_certificates: Optional[bool] = None,
                     certificate_chain: Optional[Tuple[Tuple[Certificate], PrivateKey]] = None,
                     ciphers: Optional[Tuple[Union[CipherSuite, int]]] = None,
                     inner_protocols: Optional[Tuple[Union[NextProtocol, bytes]]] = None,
                     lowest_supported_version: Optional[TLSVersion] = None,
                     highest_supported_version: Optional[TLSVersion] = None,
                     trust_store: Optional[TrustStore] = None,
                     sni_callback: Optional[ServerNameCallback] = None):

        if validate_certificates is None:
            validate_certificates = True

        if ciphers is None:
            ciphers = DEFAULT_CIPHER_LIST

        if inner_protocols is None:
            inner_protocols = []

        if lowest_supported_version is None:
            lowest_supported_version = TLSVersion.TLSv1

        if highest_supported_version is None:
            highest_supported_version = TLSVersion.MAXIMUM_SUPPORTED

        return super().__new__(
            cls, validate_certificates, certificate_chain, ciphers,
            inner_protocols, lowest_supported_version,
            highest_supported_version, trust_store, sni_callback
        )

    def update(self, validate_certificates=_DEFAULT_VALUE,
                     certificate_chain=_DEFAULT_VALUE,
                     ciphers=_DEFAULT_VALUE,
                     inner_protocols=_DEFAULT_VALUE,
                     lowest_supported_version=_DEFAULT_VALUE,
                     highest_supported_version=_DEFAULT_VALUE,
                     trust_store=_DEFAULT_VALUE,
                     sni_callback=_DEFAULT_VALUE):
        &quot;&quot;&quot;
        Create a new ``TLSConfiguration``, overriding some of the settings
        on the original configuration with the new settings.
        &quot;&quot;&quot;
        if validate_certificates is _DEFAULT_VALUE:
            validate_certificates = self.validate_certificates

        if certificate_chain is _DEFAULT_VALUE:
            certificate_chain = self.certificate_chain

        if ciphers is _DEFAULT_VALUE:
            ciphers = self.ciphers

        if inner_protocols is _DEFAULT_VALUE:
            inner_protocols = self.inner_protocols

        if lowest_supported_version is _DEFAULT_VALUE:
            lowest_supported_version = self.lowest_supported_version

        if highest_supported_version is _DEFAULT_VALUE:
            highest_supported_version = self.highest_supported_version

        if trust_store is _DEFAULT_VALUE:
            trust_store = self.trust_store

        if sni_callback is _DEFAULT_VALUE:
            sni_callback = self.sni_callback

        return self.__class__(
            validate_certificates, certificate_chain, ciphers,
            inner_protocols, lowest_supported_version,
            highest_supported_version, trust_store, sni_callback
        )
</pre>
</div>
<div class="section" id="context">
<h3><a class="toc-backref" href="#id44">Context</a></h3>
<p>We define two Context abstract base classes. These ABCs define objects that
allow configuration of TLS to be applied to specific connections. They can be
thought of as factories for <tt class="docutils literal">TLSWrappedSocket</tt> and <tt class="docutils literal">TLSWrappedBuffer</tt>
objects.</p>
<p>Unlike the current <tt class="docutils literal">ssl</tt> module, we provide two context classes instead of
one. Specifically, we provide the <tt class="docutils literal">ClientContext</tt> and <tt class="docutils literal">ServerContext</tt>
classes. This simplifies the APIs (for example, there is no sense in the server
providing the <tt class="docutils literal">server_hostname</tt> parameter to <tt class="docutils literal">ssl.SSLContext.wrap_socket</tt>,
but because there is only one context class that parameter is still available),
and ensures that implementations know as early as possible which side of a TLS
connection they will serve. Additionally, it allows implementations to opt-out
of one or either side of the connection. For example, SecureTransport on macOS
is not really intended for server use and has an enormous amount of
functionality missing for server-side use. This would allow SecureTransport
implementations to simply not define a concrete subclass of <tt class="docutils literal">ServerContext</tt>
to signal their lack of support.</p>
<p>One of the other major differences to the current <tt class="docutils literal">ssl</tt> module is that a
number of flags and options have been removed. Most of these are self-evident,
but it is worth noting that <tt class="docutils literal">auto_handshake</tt> has been removed from
<tt class="docutils literal">wrap_socket</tt>. This was removed because it fundamentally represents an odd
design wart that saves very minimal effort at the cost of a complexity increase
both for users and implementers. This PEP requires that all users call
<tt class="docutils literal">do_handshake</tt> explicitly after connecting.</p>
<p>As much as possible implementers should aim to make these classes immutable:
that is, they should prefer not to allow users to mutate their internal state
directly, instead preferring to create new contexts from new TLSConfiguration
objects. Obviously, the ABCs cannot enforce this constraint, and so they do not
attempt to.</p>
<p>The <tt class="docutils literal">Context</tt> abstract base class has the following class definition:</p>
<pre class="literal-block">
TLSBufferObject = Union[TLSWrappedSocket, TLSWrappedBuffer]


class _BaseContext(metaclass=ABCMeta):
    &#64;abstractmethod
    def __init__(self, configuration: TLSConfiguration):
        &quot;&quot;&quot;
        Create a new context object from a given TLS configuration.
        &quot;&quot;&quot;

    &#64;property
    &#64;abstractmethod
    def configuration(self) -&gt; TLSConfiguration:
        &quot;&quot;&quot;
        Returns the TLS configuration that was used to create the context.
        &quot;&quot;&quot;


class ClientContext(_BaseContext):
    def wrap_socket(self,
                    socket: socket.socket,
                    server_hostname: Optional[str]) -&gt; TLSWrappedSocket:
        &quot;&quot;&quot;
        Wrap an existing Python socket object ``socket`` and return a
        ``TLSWrappedSocket`` object. ``socket`` must be a ``SOCK_STREAM``
        socket: all other socket types are unsupported.

        The returned SSL socket is tied to the context, its settings and
        certificates. The socket object originally passed to this method
        should not be used again: attempting to use it in any way will lead
        to undefined behaviour, especially across different TLS
        implementations. To get the original socket object back once it has
        been wrapped in TLS, see the ``unwrap`` method of the
        TLSWrappedSocket.

        The parameter ``server_hostname`` specifies the hostname of the
        service which we are connecting to. This allows a single server to
        host multiple SSL-based services with distinct certificates, quite
        similarly to HTTP virtual hosts. This is also used to validate the
        TLS certificate for the given hostname. If hostname validation is
        not desired, then pass ``None`` for this parameter. This parameter
        has no default value because opting-out of hostname validation is
        dangerous, and should not be the default behaviour.
        &quot;&quot;&quot;
        buffer = self.wrap_buffers(server_hostname)
        return TLSWrappedSocket(socket, buffer)

    &#64;abstractmethod
    def wrap_buffers(self, server_hostname: Optional[str]) -&gt; TLSWrappedBuffer:
        &quot;&quot;&quot;
        Create an in-memory stream for TLS, using memory buffers to store
        incoming and outgoing ciphertext. The TLS routines will read
        received TLS data from one buffer, and write TLS data that needs to
        be emitted to another buffer.

        The implementation details of how this buffering works are up to
        the individual TLS implementation. This allows TLS libraries that
        have their own specialised support to continue to do so, while
        allowing those without to use whatever Python objects they see fit.

        The ``server_hostname`` parameter has the same meaning as in
        ``wrap_socket``.
        &quot;&quot;&quot;


class ServerContext(_BaseContext):
    def wrap_socket(self, socket: socket.socket) -&gt; TLSWrappedSocket:
        &quot;&quot;&quot;
        Wrap an existing Python socket object ``socket`` and return a
        ``TLSWrappedSocket`` object. ``socket`` must be a ``SOCK_STREAM``
        socket: all other socket types are unsupported.

        The returned SSL socket is tied to the context, its settings and
        certificates. The socket object originally passed to this method
        should not be used again: attempting to use it in any way will lead
        to undefined behaviour, especially across different TLS
        implementations. To get the original socket object back once it has
        been wrapped in TLS, see the ``unwrap`` method of the
        TLSWrappedSocket.
        &quot;&quot;&quot;
        buffer = self.wrap_buffers()
        return TLSWrappedSocket(socket, buffer)

    &#64;abstractmethod
    def wrap_buffers(self) -&gt; TLSWrappedBuffer:
        &quot;&quot;&quot;
        Create an in-memory stream for TLS, using memory buffers to store
        incoming and outgoing ciphertext. The TLS routines will read
        received TLS data from one buffer, and write TLS data that needs to
        be emitted to another buffer.

        The implementation details of how this buffering works are up to
        the individual TLS implementation. This allows TLS libraries that
        have their own specialised support to continue to do so, while
        allowing those without to use whatever Python objects they see fit.
        &quot;&quot;&quot;
</pre>
</div>
<div class="section" id="buffer">
<h3><a class="toc-backref" href="#id45">Buffer</a></h3>
<p>The buffer-wrapper ABC will be defined by the <tt class="docutils literal">TLSWrappedBuffer</tt> ABC, which
has the following definition:</p>
<pre class="literal-block">
class TLSWrappedBuffer(metaclass=ABCMeta):
    &#64;abstractmethod
    def read(self, amt: int) -&gt; bytes:
        &quot;&quot;&quot;
        Read up to ``amt`` bytes of data from the input buffer and return
        the result as a ``bytes`` instance.

        Once EOF is reached, all further calls to this method return the
        empty byte string ``b''``.

        May read &quot;short&quot;: that is, fewer bytes may be returned than were
        requested.

        Raise ``WantReadError`` or ``WantWriteError`` if there is
        insufficient data in either the input or output buffer and the
        operation would have caused data to be written or read.

        May raise ``RaggedEOF`` if the connection has been closed without a
        graceful TLS shutdown. Whether this is an exception that should be
        ignored or not is up to the specific application.

        As at any time a re-negotiation is possible, a call to ``read()``
        can also cause write operations.
        &quot;&quot;&quot;

    &#64;abstractmethod
    def readinto(self, buffer: Any, amt: int) -&gt; int:
        &quot;&quot;&quot;
        Read up to ``amt`` bytes of data from the input buffer into
        ``buffer``, which must be an object that implements the buffer
        protocol. Returns the number of bytes read.

        Once EOF is reached, all further calls to this method return the
        empty byte string ``b''``.

        Raises ``WantReadError`` or ``WantWriteError`` if there is
        insufficient data in either the input or output buffer and the
        operation would have caused data to be written or read.

        May read &quot;short&quot;: that is, fewer bytes may be read than were
        requested.

        May raise ``RaggedEOF`` if the connection has been closed without a
        graceful TLS shutdown. Whether this is an exception that should be
        ignored or not is up to the specific application.

        As at any time a re-negotiation is possible, a call to
        ``readinto()`` can also cause write operations.
        &quot;&quot;&quot;

    &#64;abstractmethod
    def write(self, buf: Any) -&gt; int:
        &quot;&quot;&quot;
        Write ``buf`` in encrypted form to the output buffer and return the
        number of bytes written. The ``buf`` argument must be an object
        supporting the buffer interface.

        Raise ``WantReadError`` or ``WantWriteError`` if there is
        insufficient data in either the input or output buffer and the
        operation would have caused data to be written or read. In either
        case, users should endeavour to resolve that situation and then
        re-call this method. When re-calling this method users *should*
        re-use the exact same ``buf`` object, as some backends require that
        the exact same buffer be used.

        This operation may write &quot;short&quot;: that is, fewer bytes may be
        written than were in the buffer.

        As at any time a re-negotiation is possible, a call to ``write()``
        can also cause read operations.
        &quot;&quot;&quot;

    &#64;abstractmethod
    def do_handshake(self) -&gt; None:
        &quot;&quot;&quot;
        Performs the TLS handshake. Also performs certificate validation
        and hostname verification.
        &quot;&quot;&quot;

    &#64;abstractmethod
    def cipher(self) -&gt; Optional[Union[CipherSuite, int]]:
        &quot;&quot;&quot;
        Returns the CipherSuite entry for the cipher that has been
        negotiated on the connection. If no connection has been negotiated,
        returns ``None``. If the cipher negotiated is not defined in
        CipherSuite, returns the 16-bit integer representing that cipher
        directly.
        &quot;&quot;&quot;

    &#64;abstractmethod
    def negotiated_protocol(self) -&gt; Optional[Union[NextProtocol, bytes]]:
        &quot;&quot;&quot;
        Returns the protocol that was selected during the TLS handshake.
        This selection may have been made using ALPN, NPN, or some future
        negotiation mechanism.

        If the negotiated protocol is one of the protocols defined in the
        ``NextProtocol`` enum, the value from that enum will be returned.
        Otherwise, the raw bytestring of the negotiated protocol will be
        returned.

        If ``Context.set_inner_protocols()`` was not called, if the other
        party does not support protocol negotiation, if this socket does
        not support any of the peer's proposed protocols, or if the
        handshake has not happened yet, ``None`` is returned.
        &quot;&quot;&quot;

    &#64;property
    &#64;abstractmethod
    def context(self) -&gt; Context:
        &quot;&quot;&quot;
        The ``Context`` object this buffer is tied to.
        &quot;&quot;&quot;

    &#64;abstractproperty
    def negotiated_tls_version(self) -&gt; Optional[TLSVersion]:
        &quot;&quot;&quot;
        The version of TLS that has been negotiated on this connection.
        &quot;&quot;&quot;

    &#64;abstractmethod
    def shutdown(self) -&gt; None:
        &quot;&quot;&quot;
        Performs a clean TLS shut down. This should generally be used
        whenever possible to signal to the remote peer that the content is
        finished.
        &quot;&quot;&quot;

    &#64;abstractmethod
    def receive_from_network(self, data):
        &quot;&quot;&quot;
        Receives some TLS data from the network and stores it in an
        internal buffer.
        &quot;&quot;&quot;

    &#64;abstractmethod
    def peek_outgoing(self, amt):
        &quot;&quot;&quot;
        Returns the next ``amt`` bytes of data that should be written to
        the network from the outgoing data buffer, without removing it from
        the internal buffer.
        &quot;&quot;&quot;

    &#64;abstractmethod
    def consume_outgoing(self, amt):
        &quot;&quot;&quot;
        Discard the next ``amt`` bytes from the outgoing data buffer. This
        should be used when ``amt`` bytes have been sent on the network, to
        signal that the data no longer needs to be buffered.
        &quot;&quot;&quot;
</pre>
</div>
<div class="section" id="socket">
<h3><a class="toc-backref" href="#id46">Socket</a></h3>
<p>The socket-wrapper class will be a concrete class that accepts two items in its
constructor: a regular socket object, and a <tt class="docutils literal">TLSWrappedBuffer</tt> object. This
object will be too large to recreate in this PEP, but will be submitted as part
of the work to build the module.</p>
<p>The wrapped socket will implement all of the socket API, though it will have
stub implementations of methods that only work for sockets with types other
than <tt class="docutils literal">SOCK_STREAM</tt> (e.g. <tt class="docutils literal">sendto</tt>/<tt class="docutils literal">recvfrom</tt>). That limitation can be
lifted as-and-when support for DTLS is added to this module.</p>
<p>In addition, the socket class will include the following <em>extra</em> methods on top
of the regular socket methods:</p>
<pre class="literal-block">
class TLSWrappedSocket:
    def do_handshake(self) -&gt; None:
        &quot;&quot;&quot;
        Performs the TLS handshake. Also performs certificate validation
        and hostname verification. This must be called after the socket has
        connected (either via ``connect`` or ``accept``), before any other
        operation is performed on the socket.
        &quot;&quot;&quot;

    def cipher(self) -&gt; Optional[Union[CipherSuite, int]]:
        &quot;&quot;&quot;
        Returns the CipherSuite entry for the cipher that has been
        negotiated on the connection. If no connection has been negotiated,
        returns ``None``. If the cipher negotiated is not defined in
        CipherSuite, returns the 16-bit integer representing that cipher
        directly.
        &quot;&quot;&quot;

    def negotiated_protocol(self) -&gt; Optional[Union[NextProtocol, bytes]]:
        &quot;&quot;&quot;
        Returns the protocol that was selected during the TLS handshake.
        This selection may have been made using ALPN, NPN, or some future
        negotiation mechanism.

        If the negotiated protocol is one of the protocols defined in the
        ``NextProtocol`` enum, the value from that enum will be returned.
        Otherwise, the raw bytestring of the negotiated protocol will be
        returned.

        If ``Context.set_inner_protocols()`` was not called, if the other
        party does not support protocol negotiation, if this socket does
        not support any of the peer's proposed protocols, or if the
        handshake has not happened yet, ``None`` is returned.
        &quot;&quot;&quot;

    &#64;property
    def context(self) -&gt; Context:
        &quot;&quot;&quot;
        The ``Context`` object this socket is tied to.
        &quot;&quot;&quot;

    def negotiated_tls_version(self) -&gt; Optional[TLSVersion]:
        &quot;&quot;&quot;
        The version of TLS that has been negotiated on this connection.
        &quot;&quot;&quot;

    def unwrap(self) -&gt; socket.socket:
        &quot;&quot;&quot;
        Cleanly terminate the TLS connection on this wrapped socket. Once
        called, this ``TLSWrappedSocket`` can no longer be used to transmit
        data. Returns the socket that was wrapped with TLS.
        &quot;&quot;&quot;
</pre>
</div>
<div class="section" id="cipher-suites">
<h3><a class="toc-backref" href="#id47">Cipher Suites</a></h3>
<p>Supporting cipher suites in a truly library-agnostic fashion is a remarkably
difficult undertaking. Different TLS implementations often have <em>radically</em>
different APIs for specifying cipher suites, but more problematically these
APIs frequently differ in capability as well as in style. Some examples are
shown below:</p>
<div class="section" id="openssl">
<h4><a class="toc-backref" href="#id48">OpenSSL</a></h4>
<p>OpenSSL uses a well-known cipher string format. This format has been adopted as
a configuration language by most products that use OpenSSL, including Python.
This format is relatively easy to read, but has a number of downsides: it is
a string, which makes it remarkably easy to provide bad inputs; it lacks much
detailed validation, meaning that it is possible to configure OpenSSL in a way
that doesn't allow it to negotiate any cipher at all; and it allows specifying
cipher suites in a number of different ways that make it tricky to parse. The
biggest problem with this format is that there is no formal specification for
it, meaning that the only way to parse a given string the way OpenSSL would is
to get OpenSSL to parse it.</p>
<p>OpenSSL's cipher strings can look like this:</p>
<pre class="literal-block">
'ECDH+AESGCM:ECDH+CHACHA20:DH+AESGCM:DH+CHACHA20:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:RSA+AESGCM:RSA+AES:!aNULL:!eNULL:!MD5'
</pre>
<p>This string demonstrates some of the complexity of the OpenSSL format. For
example, it is possible for one entry to specify multiple cipher suites: the
entry <tt class="docutils literal">ECDH+AESGCM</tt> means &quot;all ciphers suites that include both
elliptic-curve Diffie-Hellman key exchange and AES in Galois Counter Mode&quot;.
More explicitly, that will expand to four cipher suites:</p>
<pre class="literal-block">
&quot;ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256&quot;
</pre>
<p>That makes parsing a complete OpenSSL cipher string extremely tricky. Add to
the fact that there are other meta-characters, such as &quot;!&quot; (exclude all cipher
suites that match this criterion, even if they would otherwise be included:
&quot;!MD5&quot; means that no cipher suites using the MD5 hash algorithm should be
included), &quot;-&quot; (exclude matching ciphers if they were already included, but
allow them to be re-added later if they get included again), and &quot;+&quot; (include
the matching ciphers, but place them at the end of the list), and you get an
<em>extremely</em> complex format to parse. On top of this complexity it should be
noted that the actual result depends on the OpenSSL version, as an OpenSSL
cipher string is valid so long as it contains at least one cipher that OpenSSL
recognises.</p>
<p>OpenSSL also uses different names for its ciphers than the names used in the
relevant specifications. See the manual page for <tt class="docutils literal">ciphers(1)</tt> for more
details.</p>
<p>The actual API inside OpenSSL for the cipher string is simple:</p>
<pre class="literal-block">
char *cipher_list = &lt;some cipher list&gt;;
int rc = SSL_CTX_set_cipher_list(context, cipher_list);
</pre>
<p>This means that any format that is used by this module must be able to be
converted to an OpenSSL cipher string for use with OpenSSL.</p>
</div>
<div class="section" id="securetransport">
<h4><a class="toc-backref" href="#id49">SecureTransport</a></h4>
<p>SecureTransport is the macOS system TLS library. This library is substantially
more restricted than OpenSSL in many ways, as it has a much more restricted
class of users. One of these substantial restrictions is in controlling
supported cipher suites.</p>
<p>Ciphers in SecureTransport are represented by a C <tt class="docutils literal">enum</tt>. This enum has one
entry per cipher suite, with no aggregate entries, meaning that it is not
possible to reproduce the meaning of an OpenSSL cipher string like
&quot;ECDH+AESGCM&quot; without hand-coding which categories each enum member falls into.</p>
<p>However, the names of most of the enum members are in line with the formal
names of the cipher suites: that is, the cipher suite that OpenSSL calls
&quot;ECDHE-ECDSA-AES256-GCM-SHA384&quot; is called
&quot;TLS_ECDHE_ECDHSA_WITH_AES_256_GCM_SHA384&quot; in SecureTransport.</p>
<p>The API for configuring cipher suites inside SecureTransport is simple:</p>
<pre class="literal-block">
SSLCipherSuite ciphers[] = {TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, ...};
OSStatus status = SSLSetEnabledCiphers(context, ciphers, sizeof(ciphers));
</pre>
</div>
<div class="section" id="schannel">
<h4><a class="toc-backref" href="#id50">SChannel</a></h4>
<p>SChannel is the Windows system TLS library.</p>
<p>SChannel has extremely restrictive support for controlling available TLS
cipher suites, and additionally adopts a third method of expressing what TLS
cipher suites are supported.</p>
<p>Specifically, SChannel defines a set of <tt class="docutils literal">ALG_ID</tt> constants (C unsigned ints).
Each of these constants does not refer to an entire cipher suite, but instead
an individual algorithm. Some examples are <tt class="docutils literal">CALG_3DES</tt> and <tt class="docutils literal">CALG_AES_256</tt>,
which refer to the bulk encryption algorithm used in a cipher suite,
<tt class="docutils literal">CALG_DH_EPHEM</tt> and <tt class="docutils literal">CALG_RSA_KEYX</tt> which refer to part of the key exchange
algorithm used in a cipher suite, <tt class="docutils literal">CALG_SHA1</tt> and <tt class="docutils literal">CALG_MD5</tt> which refer to
the message authentication code used in a cipher suite, and <tt class="docutils literal">CALG_ECDSA</tt> and
<tt class="docutils literal">CALG_RSA_SIGN</tt> which refer to the signing portions of the key exchange
algorithm.</p>
<p>This can be thought of as the half of OpenSSL's functionality that
SecureTransport doesn't have: SecureTransport only allows specifying exact
cipher suites, while SChannel only allows specifying <em>parts</em> of the cipher
suite, while OpenSSL allows both.</p>
<p>Determining which cipher suites are allowed on a given connection is done by
providing a pointer to an array of these <tt class="docutils literal">ALG_ID</tt> constants. This means that
any suitable API must allow the Python code to determine which <tt class="docutils literal">ALG_ID</tt>
constants must be provided.</p>
</div>
<div class="section" id="network-security-services-nss">
<h4><a class="toc-backref" href="#id51">Network Security Services (NSS)</a></h4>
<p>NSS is Mozilla's crypto and TLS library. It's used in Firefox, Thunderbird,
and as alternative to OpenSSL in multiple libraries, e.g. curl.</p>
<p>By default, NSS comes with secure configuration of allowed ciphers. On some
platforms such as Fedora, the list of enabled ciphers is globally configured
in a system policy. Generally, applications should not modify cipher suites
unless they have specific reasons to do so.</p>
<p>NSS has both process global and per-connection settings for cipher suites. It
does not have a concept of SSLContext like OpenSSL. A SSLContext-like behavior
can be easily emulated. Specifically, ciphers can be enabled or disabled
globally with <tt class="docutils literal">`SSL_CipherPrefSetDefault(PRInt32 cipher, PRBool enabled)`</tt>,
and <tt class="docutils literal">`SSL_CipherPrefSet(PRFileDesc *fd, PRInt32 cipher, PRBool enabled)`</tt>
for a connection. The cipher <tt class="docutils literal">`PRInt32`</tt> number is a signed 32bit integer
that directly corresponds to an registered IANA id, e.g. <tt class="docutils literal">`0x1301`</tt>
is <tt class="docutils literal">`TLS_AES_128_GCM_SHA256`</tt>. Contrary to OpenSSL, the preference order
of ciphers is fixed and cannot be modified at runtime.</p>
<p>Like SecureTransport, NSS has no API for aggregated entries. Some consumers
of NSS have implemented custom mappings from OpenSSL cipher names and rules
to NSS ciphers, e.g. <tt class="docutils literal">`mod_nss`</tt>.</p>
</div>
<div class="section" id="proposed-interface">
<h4><a class="toc-backref" href="#id52">Proposed Interface</a></h4>
<p>The proposed interface for the new module is influenced by the combined set of
limitations of the above implementations. Specifically, as every implementation
<em>except</em> OpenSSL requires that each individual cipher be provided, there is no
option but to provide that lowest-common denominator approach.</p>
<p>The simplest approach is to provide an enumerated type that includes a large
subset of the cipher suites defined for TLS. The values of the enum members
will be their two-octet cipher identifier as used in the TLS handshake,
stored as a 16 bit integer. The names of the enum members will be their
IANA-registered cipher suite names.</p>
<p>As of now, the <a class="reference external" href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4">IANA cipher suite registry</a> <a class="footnote-reference" href="#id29" id="id30">[11]</a> contains over 320 cipher suites.
A large portion of the cipher suites are irrelevant for TLS connections to
network services. Other suites specify deprecated and insecure algorithms
that are no longer provided by recent versions of implementations. The enum
does not contain ciphers with:</p>
<ul class="simple">
<li>key exchange: NULL, Kerberos (KRB5), pre-shared key (PSK), secure remote
transport (TLS-SRP)</li>
<li>authentication: NULL, anonymous, export grade, Kerberos (KRB5),
pre-shared key (PSK), secure remote transport (TLS-SRP), DSA cert (DSS)</li>
<li>encryption: NULL, ARIA, DES, RC2, export grade 40bit</li>
<li>PRF: MD5</li>
<li>SCSV cipher suites</li>
</ul>
<p>3DES, RC4, SEED, and IDEA are included for legacy applications. Further more
five additional cipher suites from the TLS 1.3 draft (draft-ietf-tls-tls13-18)
are included, too. TLS 1.3 does not share any cipher suites with TLS 1.2 and
earlier. The resulting enum will contain roughly 110 suites.</p>
<p>Because of these limitations, and because the enum doesn't contain every
defined cipher, and also to allow for forward-looking applications, all parts
of this API that accept <tt class="docutils literal">CipherSuite</tt> objects will also accept raw 16-bit
integers directly.</p>
<p>Rather than populate this enum by hand, we have a <a class="reference external" href="https://github.com/tiran/tlsdb/blob/master/tlspep_ciphersuite.py">TLS enum script</a> <a class="footnote-reference" href="#id25" id="id26">[9]</a> that
builds it from Christian Heimes' <a class="reference external" href="https://github.com/tiran/tlsdb/blob/master/tlsdb.json">tlsdb JSON file</a> <a class="footnote-reference" href="#id27" id="id28">[10]</a> (warning:
large file) and <a class="reference external" href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4">IANA cipher suite registry</a> <a class="footnote-reference" href="#id29" id="id31">[11]</a>. The TLSDB also opens up the
possibility of extending the API with additional querying function,
such as determining which TLS versions support which ciphers, if that
functionality is found to be useful or necessary.</p>
<p>If users find this approach to be onerous, a future extension to this API can
provide helpers that can reintroduce OpenSSL's aggregation functionality.</p>
<pre class="literal-block">
class CipherSuite(IntEnum):
    TLS_RSA_WITH_RC4_128_SHA = 0x0005
    TLS_RSA_WITH_IDEA_CBC_SHA = 0x0007
    TLS_RSA_WITH_3DES_EDE_CBC_SHA = 0x000a
    TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = 0x0010
    TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = 0x0016
    TLS_RSA_WITH_AES_128_CBC_SHA = 0x002f
    TLS_DH_RSA_WITH_AES_128_CBC_SHA = 0x0031
    TLS_DHE_RSA_WITH_AES_128_CBC_SHA = 0x0033
    TLS_RSA_WITH_AES_256_CBC_SHA = 0x0035
    TLS_DH_RSA_WITH_AES_256_CBC_SHA = 0x0037
    TLS_DHE_RSA_WITH_AES_256_CBC_SHA = 0x0039
    TLS_RSA_WITH_AES_128_CBC_SHA256 = 0x003c
    TLS_RSA_WITH_AES_256_CBC_SHA256 = 0x003d
    TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = 0x003f
    TLS_RSA_WITH_CAMELLIA_128_CBC_SHA = 0x0041
    TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = 0x0043
    TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = 0x0045
    TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = 0x0067
    TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = 0x0069
    TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = 0x006b
    TLS_RSA_WITH_CAMELLIA_256_CBC_SHA = 0x0084
    TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = 0x0086
    TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = 0x0088
    TLS_RSA_WITH_SEED_CBC_SHA = 0x0096
    TLS_DH_RSA_WITH_SEED_CBC_SHA = 0x0098
    TLS_DHE_RSA_WITH_SEED_CBC_SHA = 0x009a
    TLS_RSA_WITH_AES_128_GCM_SHA256 = 0x009c
    TLS_RSA_WITH_AES_256_GCM_SHA384 = 0x009d
    TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = 0x009e
    TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = 0x009f
    TLS_DH_RSA_WITH_AES_128_GCM_SHA256 = 0x00a0
    TLS_DH_RSA_WITH_AES_256_GCM_SHA384 = 0x00a1
    TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 0x00ba
    TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 0x00bc
    TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 0x00be
    TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 = 0x00c0
    TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 = 0x00c2
    TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = 0x00c4
    TLS_AES_128_GCM_SHA256 = 0x1301
    TLS_AES_256_GCM_SHA384 = 0x1302
    TLS_CHACHA20_POLY1305_SHA256 = 0x1303
    TLS_AES_128_CCM_SHA256 = 0x1304
    TLS_AES_128_CCM_8_SHA256 = 0x1305
    TLS_ECDH_ECDSA_WITH_RC4_128_SHA = 0xc002
    TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = 0xc003
    TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = 0xc004
    TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = 0xc005
    TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = 0xc007
    TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = 0xc008
    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = 0xc009
    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = 0xc00a
    TLS_ECDH_RSA_WITH_RC4_128_SHA = 0xc00c
    TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = 0xc00d
    TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = 0xc00e
    TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = 0xc00f
    TLS_ECDHE_RSA_WITH_RC4_128_SHA = 0xc011
    TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = 0xc012
    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = 0xc013
    TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = 0xc014
    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = 0xc023
    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = 0xc024
    TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = 0xc025
    TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = 0xc026
    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = 0xc027
    TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = 0xc028
    TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = 0xc029
    TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = 0xc02a
    TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = 0xc02b
    TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = 0xc02c
    TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = 0xc02d
    TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = 0xc02e
    TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = 0xc02f
    TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = 0xc030
    TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = 0xc031
    TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = 0xc032
    TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = 0xc072
    TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = 0xc073
    TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = 0xc074
    TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = 0xc075
    TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 0xc076
    TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = 0xc077
    TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 0xc078
    TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 = 0xc079
    TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xc07a
    TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xc07b
    TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xc07c
    TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xc07d
    TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xc07e
    TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xc07f
    TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xc086
    TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xc087
    TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xc088
    TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xc089
    TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xc08a
    TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xc08b
    TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xc08c
    TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xc08d
    TLS_RSA_WITH_AES_128_CCM = 0xc09c
    TLS_RSA_WITH_AES_256_CCM = 0xc09d
    TLS_DHE_RSA_WITH_AES_128_CCM = 0xc09e
    TLS_DHE_RSA_WITH_AES_256_CCM = 0xc09f
    TLS_RSA_WITH_AES_128_CCM_8 = 0xc0a0
    TLS_RSA_WITH_AES_256_CCM_8 = 0xc0a1
    TLS_DHE_RSA_WITH_AES_128_CCM_8 = 0xc0a2
    TLS_DHE_RSA_WITH_AES_256_CCM_8 = 0xc0a3
    TLS_ECDHE_ECDSA_WITH_AES_128_CCM = 0xc0ac
    TLS_ECDHE_ECDSA_WITH_AES_256_CCM = 0xc0ad
    TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 = 0xc0ae
    TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = 0xc0af
    TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = 0xcca8
    TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = 0xcca9
    TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = 0xccaa
</pre>
<p>Enum members can be mapped to OpenSSL cipher names:</p>
<pre class="literal-block">
&gt;&gt;&gt; import ssl
&gt;&gt;&gt; ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)
&gt;&gt;&gt; ctx.set_ciphers('ALL:COMPLEMENTOFALL')
&gt;&gt;&gt; ciphers = {c['id'] &amp; 0xffff: c['name'] for c in ctx.get_ciphers()}
&gt;&gt;&gt; ciphers[CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256]
'ECDHE-RSA-AES128-GCM-SHA256'
</pre>
<p>For SecureTransport, these enum members directly refer to the values of the
cipher suite constants. For example, SecureTransport defines the cipher suite
enum member <tt class="docutils literal">TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384</tt> as having the value
<tt class="docutils literal">0xC02C</tt>. Not coincidentally, that is identical to its value in the above
enum. This makes mapping between SecureTransport and the above enum very easy
indeed.</p>
<p>For SChannel there is no easy direct mapping, due to the fact that SChannel
configures ciphers, instead of cipher suites. This represents an ongoing
concern with SChannel, which is that it is very difficult to configure in a
specific manner compared to other TLS implementations.</p>
<p>For the purposes of this PEP, any SChannel implementation will need to
determine which ciphers to choose based on the enum members. This may be more
open than the actual cipher suite list actually wants to allow, or it may be
more restrictive, depending on the choices of the implementation. This PEP
recommends that it be more restrictive, but of course this cannot be enforced.</p>
</div>
</div>
<div class="section" id="protocol-negotiation">
<h3><a class="toc-backref" href="#id53">Protocol Negotiation</a></h3>
<p>Both NPN and ALPN allow for protocol negotiation as part of the HTTP/2
handshake. While NPN and ALPN are, at their fundamental level, built on top of
bytestrings, string-based APIs are frequently problematic as they allow for
errors in typing that can be hard to detect.</p>
<p>For this reason, this module would define a type that protocol negotiation
implementations can pass and be passed. This type would wrap a bytestring to
allow for aliases for well-known protocols. This allows us to avoid the
problems inherent in typos for well-known protocols, while allowing the full
extensibility of the protocol negotiation layer if needed by letting users pass
byte strings directly.</p>
<pre class="literal-block">
class NextProtocol(Enum):
    H2 = b'h2'
    H2C = b'h2c'
    HTTP1 = b'http/1.1'
    WEBRTC = b'webrtc'
    C_WEBRTC = b'c-webrtc'
    FTP = b'ftp'
    STUN = b'stun.nat-discovery'
    TURN = b'stun.turn'
</pre>
</div>
<div class="section" id="tls-versions">
<h3><a class="toc-backref" href="#id54">TLS Versions</a></h3>
<p>It is often useful to be able to restrict the versions of TLS you're willing to
support. There are many security advantages in refusing to use old versions of
TLS, and some misbehaving servers will mishandle TLS clients advertising
support for newer versions.</p>
<p>The following enumerated type can be used to gate TLS versions. Forward-looking
applications should almost never set a maximum TLS version unless they
absolutely must, as a TLS backend that is newer than the Python that uses it
may support TLS versions that are not in this enumerated type.</p>
<p>Additionally, this enumerated type defines two additional flags that can always
be used to request either the lowest or highest TLS version supported by an
implementation.</p>
<pre class="literal-block">
class TLSVersion(Enum):
    MINIMUM_SUPPORTED = auto()
    SSLv2 = auto()
    SSLv3 = auto()
    TLSv1 = auto()
    TLSv1_1 = auto()
    TLSv1_2 = auto()
    TLSv1_3 = auto()
    MAXIMUM_SUPPORTED = auto()
</pre>
</div>
<div class="section" id="errors">
<h3><a class="toc-backref" href="#id55">Errors</a></h3>
<p>This module would define four base classes for use with error handling. Unlike
many of the the other classes defined here, these classes are not abstract, as
they have no behaviour. They exist simply to signal certain common behaviours.
Backends should subclass these exceptions in their own packages, but needn't
define any behaviour for them.</p>
<p>In general, concrete implementations should subclass these exceptions rather
than throw them directly. This makes it moderately easier to determine which
concrete TLS implementation is in use during debugging of unexpected errors.
However, this is not mandatory.</p>
<p>The definitions of the errors are below:</p>
<pre class="literal-block">
class TLSError(Exception):
    &quot;&quot;&quot;
    The base exception for all TLS related errors from any backend.
    Catching this error should be sufficient to catch *all* TLS errors,
    regardless of what backend is used.
    &quot;&quot;&quot;

class WantWriteError(TLSError):
    &quot;&quot;&quot;
    A special signaling exception used only when non-blocking or
    buffer-only I/O is used. This error signals that the requested
    operation cannot complete until more data is written to the network,
    or until the output buffer is drained.

    This error is should only be raised when it is completely impossible
    to write any data. If a partial write is achievable then this should
    not be raised.
    &quot;&quot;&quot;

class WantReadError(TLSError):
    &quot;&quot;&quot;
    A special signaling exception used only when non-blocking or
    buffer-only I/O is used. This error signals that the requested
    operation cannot complete until more data is read from the network, or
    until more data is available in the input buffer.

    This error should only be raised when it is completely impossible to
    write any data. If a partial write is achievable then this should not
    be raised.
    &quot;&quot;&quot;

class RaggedEOF(TLSError):
    &quot;&quot;&quot;
    A special signaling exception used when a TLS connection has been
    closed gracelessly: that is, when a TLS CloseNotify was not received
    from the peer before the underlying TCP socket reached EOF. This is a
    so-called &quot;ragged EOF&quot;.

    This exception is not guaranteed to be raised in the face of a ragged
    EOF: some implementations may not be able to detect or report the
    ragged EOF.

    This exception is not always a problem. Ragged EOFs are a concern only
    when protocols are vulnerable to length truncation attacks. Any
    protocol that can detect length truncation attacks at the application
    layer (e.g. HTTP/1.1 and HTTP/2) is not vulnerable to this kind of
    attack and so can ignore this exception.
    &quot;&quot;&quot;
</pre>
</div>
<div class="section" id="certificates">
<h3><a class="toc-backref" href="#id56">Certificates</a></h3>
<p>This module would define an abstract X509 certificate class. This class would
have almost no behaviour, as the goal of this module is not to provide all
possible relevant cryptographic functionality that could be provided by X509
certificates. Instead, all we need is the ability to signal the source of a
certificate to a concrete implementation.</p>
<p>For that reason, this certificate implementation defines only constructors. In
essence, the certificate object in this module could be as abstract as a handle
that can be used to locate a specific certificate.</p>
<p>Concrete implementations may choose to provide alternative constructors, e.g.
to load certificates from HSMs. If a common interface emerges for doing this,
this module may be updated to provide a standard constructor for this use-case
as well.</p>
<p>Concrete implementations should aim to have Certificate objects be hashable if
at all possible. This will help ensure that TLSConfiguration objects used with
an individual concrete implementation are also hashable.</p>
<pre class="literal-block">
class Certificate(metaclass=ABCMeta):
    &#64;abstractclassmethod
    def from_buffer(cls, buffer: bytes):
        &quot;&quot;&quot;
        Creates a Certificate object from a byte buffer. This byte buffer
        may be either PEM-encoded or DER-encoded. If the buffer is PEM
        encoded it *must* begin with the standard PEM preamble (a series of
        dashes followed by the ASCII bytes &quot;BEGIN CERTIFICATE&quot; and another
        series of dashes). In the absence of that preamble, the
        implementation may assume that the certificate is DER-encoded
        instead.
        &quot;&quot;&quot;

    &#64;abstractclassmethod
    def from_file(cls, path: Union[pathlib.Path, AnyStr]):
        &quot;&quot;&quot;
        Creates a Certificate object from a file on disk. This method may
        be a convenience method that wraps ``open`` and ``from_buffer``,
        but some TLS implementations may be able to provide more-secure or
        faster methods of loading certificates that do not involve Python
        code.
        &quot;&quot;&quot;
</pre>
</div>
<div class="section" id="private-keys">
<h3><a class="toc-backref" href="#id57">Private Keys</a></h3>
<p>This module would define an abstract private key class. Much like the
Certificate class, this class has almost no behaviour in order to give as much
freedom as possible to the concrete implementations to treat keys carefully.</p>
<p>This class has all the caveats of the <tt class="docutils literal">Certificate</tt> class.</p>
<pre class="literal-block">
class PrivateKey(metaclass=ABCMeta):
    &#64;abstractclassmethod
    def from_buffer(cls,
                    buffer: bytes,
                    password: Optional[Union[Callable[[], Union[bytes, bytearray]], bytes, bytearray]] = None):
        &quot;&quot;&quot;
        Creates a PrivateKey object from a byte buffer. This byte buffer
        may be either PEM-encoded or DER-encoded. If the buffer is PEM
        encoded it *must* begin with the standard PEM preamble (a series of
        dashes followed by the ASCII bytes &quot;BEGIN&quot;, the key type, and
        another series of dashes). In the absence of that preamble, the
        implementation may assume that the certificate is DER-encoded
        instead.

        The key may additionally be encrypted. If it is, the ``password``
        argument can be used to decrypt the key. The ``password`` argument
        may be a function to call to get the password for decrypting the
        private key. It will only be called if the private key is encrypted
        and a password is necessary. It will be called with no arguments,
        and it should return either bytes or bytearray containing the
        password. Alternatively a bytes, or bytearray value may be supplied
        directly as the password argument. It will be ignored if the
        private key is not encrypted and no password is needed.
        &quot;&quot;&quot;

    &#64;abstractclassmethod
    def from_file(cls,
                  path: Union[pathlib.Path, bytes, str],
                  password: Optional[Union[Callable[[], Union[bytes, bytearray]], bytes, bytearray]] = None):
        &quot;&quot;&quot;
        Creates a PrivateKey object from a file on disk. This method may
        be a convenience method that wraps ``open`` and ``from_buffer``,
        but some TLS implementations may be able to provide more-secure or
        faster methods of loading certificates that do not involve Python
        code.

        The ``password`` parameter behaves exactly as the equivalent
        parameter on ``from_buffer``.
        &quot;&quot;&quot;
</pre>
</div>
<div class="section" id="trust-store">
<h3><a class="toc-backref" href="#id58">Trust Store</a></h3>
<p>As discussed above, loading a trust store represents an issue because different
TLS implementations vary wildly in how they allow users to select trust stores.
For this reason, we need to provide a model that assumes very little about the
form that trust stores take.</p>
<p>This problem is the same as the one that the Certificate and PrivateKey types
need to solve. For this reason, we use the exact same model, by creating an
opaque type that can encapsulate the various means that TLS backends may open
a trust store.</p>
<p>A given TLS implementation is not required to implement all of the
constructors. However, it is strongly recommended that a given TLS
implementation provide the <tt class="docutils literal">system</tt> constructor if at all possible, as this
is the most common validation trust store that is used. Concrete
implementations may also add their own constructors.</p>
<p>Concrete implementations should aim to have TrustStore objects be hashable if
at all possible. This will help ensure that TLSConfiguration objects used with
an individual concrete implementation are also hashable.</p>
<pre class="literal-block">
class TrustStore(metaclass=ABCMeta):
    &#64;abstractclassmethod
    def system(cls) -&gt; TrustStore:
        &quot;&quot;&quot;
        Returns a TrustStore object that represents the system trust
        database.
        &quot;&quot;&quot;

    &#64;abstractclassmethod
    def from_pem_file(cls, path: Union[pathlib.Path, bytes, str]) -&gt; TrustStore:
        &quot;&quot;&quot;
        Initializes a trust store from a single file full of PEMs.
        &quot;&quot;&quot;
</pre>
</div>
<div class="section" id="runtime-access">
<h3><a class="toc-backref" href="#id59">Runtime Access</a></h3>
<p>A not-uncommon use case for library users is to want to allow the library to
control the TLS configuration, but to want to select what backend is in use.
For example, users of Requests may want to be able to select between OpenSSL or
a platform-native solution on Windows and macOS, or between OpenSSL and NSS on
some Linux platforms. These users, however, may not care about exactly how
their TLS configuration is done.</p>
<p>This poses a problem: given an arbitrary concrete implementation, how can a
library work out how to load certificates into the trust store? There are two
options: either all concrete implementations can be required to fit into a
specific naming scheme, or we can provide an API that makes it possible to grab
these objects.</p>
<p>This PEP proposes that we use the second approach. This grants the greatest
freedom to concrete implementations to structure their code as they see fit,
requiring only that they provide a single object that has the appropriate
properties in place. Users can then pass this &quot;backend&quot; object to libraries
that support it, and those libraries can take care of configuring and using the
concrete implementation.</p>
<p>All concrete implementations must provide a method of obtaining a <tt class="docutils literal">Backend</tt>
object. The <tt class="docutils literal">Backend</tt> object can be a global singleton or can be created by a
callable if there is an advantage in doing that.</p>
<p>The <tt class="docutils literal">Backend</tt> object has the following definition:</p>
<pre class="literal-block">
Backend = namedtuple(
    'Backend',
    ['client_context', 'server_context',
     'certificate', 'private_key', 'trust_store']
)
</pre>
<p>Each of the properties must provide the concrete implementation of the relevant
ABC. This ensures that code like this will work for any backend:</p>
<pre class="literal-block">
trust_store = backend.trust_store.system()
</pre>
</div>
</div>
</div>
<div class="section" id="changes-to-the-standard-library">
<h1><a class="toc-backref" href="#id60">Changes to the Standard Library</a></h1>
<p>The portions of the standard library that interact with TLS should be revised
to use these ABCs. This will allow them to function with other TLS backends.
This includes the following modules:</p>
<ul class="simple">
<li>asyncio</li>
<li>ftplib</li>
<li>http</li>
<li>imaplib</li>
<li>nntplib</li>
<li>poplib</li>
<li>smtplib</li>
<li>urllib</li>
</ul>
<div class="section" id="migration-of-the-ssl-module">
<h2><a class="toc-backref" href="#id61">Migration of the ssl module</a></h2>
<p>Naturally, we will need to extend the <tt class="docutils literal">ssl</tt> module itself to conform to these
ABCs. This extension will take the form of new classes, potentially in an
entirely new module. This will allow applications that take advantage of the
current <tt class="docutils literal">ssl</tt> module to continue to do so, while enabling the new APIs for
applications and libraries that want to use them.</p>
<p>In general, migrating from the <tt class="docutils literal">ssl</tt> module to the new ABCs is not expected
to be one-to-one. This is normally acceptable: most tools that use the <tt class="docutils literal">ssl</tt>
module hide it from the user, and so refactoring to use the new module should
be invisible.</p>
<p>However, a specific problem comes from libraries or applications that leak
exceptions from the <tt class="docutils literal">ssl</tt> module, either as part of their defined API or by
accident (which is easily done). Users of those tools may have written code
that tolerates and handles exceptions from the <tt class="docutils literal">ssl</tt> module being raised:
migrating to the ABCs presented here would potentially cause the exceptions
defined above to be thrown instead, and existing <tt class="docutils literal">except</tt> blocks will not
catch them.</p>
<p>For this reason, part of the migration of the <tt class="docutils literal">ssl</tt> module would require that
the exceptions in the <tt class="docutils literal">ssl</tt> module alias those defined above. That is, they
would require the following statements to all succeed:</p>
<pre class="literal-block">
assert ssl.SSLError is tls.TLSError
assert ssl.SSLWantReadError is tls.WantReadError
assert ssl.SSLWantWriteError is tls.WantWriteError
</pre>
<p>The exact mechanics of how this will be done are beyond the scope of this PEP,
as they are made more complex due to the fact that the current <tt class="docutils literal">ssl</tt>
exceptions are defined in C code, but more details can be found in
<a class="reference external" href="https://mail.python.org/pipermail/security-sig/2017-January/000213.html">an email sent to the Security-SIG by Christian Heimes</a> <a class="footnote-reference" href="#id32" id="id33">[12]</a>.</p>
</div>
</div>
<div class="section" id="future">
<h1><a class="toc-backref" href="#id62">Future</a></h1>
<p>Major future TLS features may require revisions of these ABCs. These revisions
should be made cautiously: many backends may not be able to move forward
swiftly, and will be invalidated by changes in these ABCs. This is acceptable,
but wherever possible features that are specific to individual implementations
should not be added to the ABCs. The ABCs should restrict themselves to
high-level descriptions of IETF-specified features.</p>
<p>However, well-justified extensions to this API absolutely should be made. The
focus of this API is to provide a unifying lowest-common-denominator
configuration option for the Python community. TLS is not a static target, and
as TLS evolves so must this API.</p>
</div>
<div class="section" id="credits">
<h1><a class="toc-backref" href="#id63">Credits</a></h1>
<p>This document has received extensive review from a number of individuals in the
community who have substantially helped shape it. Detailed review was provided
by:</p>
<ul class="simple">
<li>Alex Chan</li>
<li>Alex Gaynor</li>
<li>Antoine Pitrou</li>
<li>Ashwini Oruganti</li>
<li>Donald Stufft</li>
<li>Ethan Furman</li>
<li>Glyph</li>
<li>Hynek Schlawack</li>
<li>Jim J Jewett</li>
<li>Nathaniel J. Smith</li>
<li>Nick Coghlan</li>
<li>Paul Kehrer</li>
<li>Steve Dower</li>
<li>Steven Fackler</li>
<li>Wes Turner</li>
<li>Will Bond</li>
</ul>
<p>Further review was provided by the Security-SIG and python-ideas mailing lists.</p>
</div>
<div class="section" id="id1">
<h1><a class="toc-backref" href="#id64">References</a></h1>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td><a class="reference external" href="https://docs.python.org/3/library/ssl.html">https://docs.python.org/3/library/ssl.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[2]</a></td><td><a class="reference external" href="https://www.openssl.org/">https://www.openssl.org/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[3]</a></td><td><a class="reference external" href="https://pypi.org/project/pyOpenSSL/">https://pypi.org/project/pyOpenSSL/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td><em>(<a class="fn-backref" href="#id9">1</a>, <a class="fn-backref" href="#id10">2</a>, <a class="fn-backref" href="#id11">3</a>, <a class="fn-backref" href="#id12">4</a>)</em> <a class="reference external" href="https://pypi.org/project/certifi/">https://pypi.org/project/certifi/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td><em>(<a class="fn-backref" href="#id14">1</a>, <a class="fn-backref" href="#id15">2</a>, <a class="fn-backref" href="#id16">3</a>, <a class="fn-backref" href="#id17">4</a>, <a class="fn-backref" href="#id18">5</a>)</em> <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext">https://docs.python.org/3/library/ssl.html#ssl.SSLContext</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id20">[6]</a></td><td><a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLSocket">https://docs.python.org/3/library/ssl.html#ssl.SSLSocket</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id22">[7]</a></td><td><a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLObject">https://docs.python.org/3/library/ssl.html#ssl.SSLObject</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id23" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id24">[8]</a></td><td><a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLError">https://docs.python.org/3/library/ssl.html#ssl.SSLError</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id25" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id26">[9]</a></td><td><a class="reference external" href="https://github.com/tiran/tlsdb/blob/master/tlspep_ciphersuite.py">https://github.com/tiran/tlsdb/blob/master/tlspep_ciphersuite.py</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id27" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id28">[10]</a></td><td><a class="reference external" href="https://github.com/tiran/tlsdb/blob/master/tlsdb.json">https://github.com/tiran/tlsdb/blob/master/tlsdb.json</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id29" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[11]</td><td><em>(<a class="fn-backref" href="#id30">1</a>, <a class="fn-backref" href="#id31">2</a>)</em> <a class="reference external" href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4">https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id32" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id33">[12]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/security-sig/2017-January/000213.html">https://mail.python.org/pipermail/security-sig/2017-January/000213.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id34" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id35">[13]</a></td><td><a class="reference external" href="https://github.com/awslabs/s2n">https://github.com/awslabs/s2n</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id36" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id37">[14]</a></td><td><a class="reference external" href="https://github.com/awslabs/s2n/issues/358">https://github.com/awslabs/s2n/issues/358</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id65">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

