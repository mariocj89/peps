<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">201</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Lockstep Iteration</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0201.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">barry&#32;&#97;t&#32;python.org (Barry Warsaw)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">13-Jul-2000</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.0</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">27-Jul-2000</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id5">Introduction</a></li>
<li><a class="reference internal" href="#motivation" id="id6">Motivation</a></li>
<li><a class="reference internal" href="#lockstep-for-loops" id="id7">Lockstep For-Loops</a></li>
<li><a class="reference internal" href="#the-proposed-solution" id="id8">The Proposed Solution</a></li>
<li><a class="reference internal" href="#return-value" id="id9">Return Value</a></li>
<li><a class="reference internal" href="#examples" id="id10">Examples</a></li>
<li><a class="reference internal" href="#reference-implementation" id="id11">Reference Implementation</a></li>
<li><a class="reference internal" href="#bdfl-pronouncements" id="id12">BDFL Pronouncements</a></li>
<li><a class="reference internal" href="#subsequent-change-to-zip" id="id13">Subsequent Change to <tt class="docutils literal">zip()</tt></a></li>
<li><a class="reference internal" href="#other-changes" id="id14">Other Changes</a></li>
<li><a class="reference internal" href="#references" id="id15">References</a></li>
<li><a class="reference internal" href="#copyright" id="id16">Copyright</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id5">Introduction</a></h1>
<p>This PEP describes the 'lockstep iteration' proposal.  This PEP tracks
the status and ownership of this feature, slated for introduction in
Python 2.0.  It contains a description of the feature and outlines
changes necessary to support the feature. This PEP summarizes
discussions held in mailing list forums, and provides URLs for further
information, where appropriate.  The CVS revision history of this file
contains the definitive historical record.</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id6">Motivation</a></h1>
<p>Standard for-loops in Python iterate over every element in a sequence
until the sequence is exhausted <a class="footnote-reference" href="#id3" id="id1">[1]</a>.  However, for-loops iterate over
only a single sequence, and it is often desirable to loop over more
than one sequence in a lock-step fashion.  In other words, in a way
such that the i-th iteration through the loop returns an object
containing the i-th element from each sequence.</p>
<p>The common idioms used to accomplish this are unintuitive.  This PEP
proposes a standard way of performing such iterations by introducing a
new builtin function called <tt class="docutils literal">zip</tt>.</p>
<p>While the primary motivation for zip() comes from lock-step iteration,
by implementing zip() as a built-in function, it has additional
utility in contexts other than for-loops.</p>
</div>
<div class="section" id="lockstep-for-loops">
<h1><a class="toc-backref" href="#id7">Lockstep For-Loops</a></h1>
<p>Lockstep for-loops are non-nested iterations over two or more
sequences, such that at each pass through the loop, one element from
each sequence is taken to compose the target.  This behavior can
already be accomplished in Python through the use of the map() built-
in function:</p>
<pre class="literal-block">
&gt;&gt;&gt; a = (1, 2, 3)
&gt;&gt;&gt; b = (4, 5, 6)
&gt;&gt;&gt; for i in map(None, a, b): print i
...
(1, 4)
(2, 5)
(3, 6)
&gt;&gt;&gt; map(None, a, b)
[(1, 4), (2, 5), (3, 6)]
</pre>
<p>The for-loop simply iterates over this list as normal.</p>
<p>While the map() idiom is a common one in Python, it has several
disadvantages:</p>
<ul>
<li><p class="first">It is non-obvious to programmers without a functional programming
background.</p>
</li>
<li><p class="first">The use of the magic <tt class="docutils literal">None</tt> first argument is non-obvious.</p>
</li>
<li><p class="first">It has arbitrary, often unintended, and inflexible semantics when
the lists are not of the same length: the shorter sequences are
padded with <tt class="docutils literal">None</tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; c = (4, 5, 6, 7)
&gt;&gt;&gt; map(None, a, c)
[(1, 4), (2, 5), (3, 6), (None, 7)]
</pre>
</li>
</ul>
<p>For these reasons, several proposals were floated in the Python 2.0
beta time frame for syntactic support of lockstep for-loops. Here are
two suggestions:</p>
<pre class="literal-block">
for x in seq1, y in seq2:
  # stuff
</pre>
<pre class="literal-block">
for x, y in seq1, seq2:
  # stuff
</pre>
<p>Neither of these forms would work, since they both already mean
something in Python and changing the meanings would break existing
code.  All other suggestions for new syntax suffered the same problem,
or were in conflict with other another proposed feature called 'list
comprehensions' (see <a class="reference external" href="/dev/peps/pep-0202">PEP 202</a>).</p>
</div>
<div class="section" id="the-proposed-solution">
<h1><a class="toc-backref" href="#id8">The Proposed Solution</a></h1>
<p>The proposed solution is to introduce a new built-in sequence
generator function, available in the <tt class="docutils literal">__builtin__</tt> module.  This
function is to be called <tt class="docutils literal">zip</tt> and has the following signature:</p>
<pre class="literal-block">
zip(seqa, [seqb, [...]])
</pre>
<p><tt class="docutils literal">zip()</tt> takes one or more sequences and weaves their elements
together, just as <tt class="docutils literal">map(None, <span class="pre">...)</span></tt> does with sequences of equal
length.  The weaving stops when the shortest sequence is exhausted.</p>
</div>
<div class="section" id="return-value">
<h1><a class="toc-backref" href="#id9">Return Value</a></h1>
<p><tt class="docutils literal">zip()</tt> returns a real Python list, the same way <tt class="docutils literal">map()</tt> does.</p>
</div>
<div class="section" id="examples">
<h1><a class="toc-backref" href="#id10">Examples</a></h1>
<p>Here are some examples, based on the reference implementation below:</p>
<pre class="literal-block">
&gt;&gt;&gt; a = (1, 2, 3, 4)
&gt;&gt;&gt; b = (5, 6, 7, 8)
&gt;&gt;&gt; c = (9, 10, 11)
&gt;&gt;&gt; d = (12, 13)

&gt;&gt;&gt; zip(a, b)
[(1, 5), (2, 6), (3, 7), (4, 8)]

&gt;&gt;&gt; zip(a, d)
[(1, 12), (2, 13)]

&gt;&gt;&gt; zip(a, b, c, d)
[(1, 5, 9, 12), (2, 6, 10, 13)]
</pre>
<p>Note that when the sequences are of the same length, <tt class="docutils literal">zip()</tt> is
reversible:</p>
<pre class="literal-block">
&gt;&gt;&gt; a = (1, 2, 3)
&gt;&gt;&gt; b = (4, 5, 6)
&gt;&gt;&gt; x = zip(a, b)
&gt;&gt;&gt; y = zip(*x) # alternatively, apply(zip, x)
&gt;&gt;&gt; z = zip(*y) # alternatively, apply(zip, y)
&gt;&gt;&gt; x
[(1, 4), (2, 5), (3, 6)]
&gt;&gt;&gt; y
[(1, 2, 3), (4, 5, 6)]
&gt;&gt;&gt; z
[(1, 4), (2, 5), (3, 6)]
&gt;&gt;&gt; x == z
1
</pre>
<p>It is not possible to reverse zip this way when the sequences are not
all the same length.</p>
</div>
<div class="section" id="reference-implementation">
<h1><a class="toc-backref" href="#id11">Reference Implementation</a></h1>
<p>Here is a reference implementation, in Python of the zip() built-in
function.  This will be replaced with a C implementation after final
approval:</p>
<pre class="literal-block">
def zip(*args):
    if not args:
        raise TypeError('zip() expects one or more sequence arguments')
    ret = []
    i = 0
    try:
        while 1:
            item = []
            for s in args:
                item.append(s[i])
            ret.append(tuple(item))
            i = i + 1
    except IndexError:
        return ret
</pre>
</div>
<div class="section" id="bdfl-pronouncements">
<h1><a class="toc-backref" href="#id12">BDFL Pronouncements</a></h1>
<p>Note: the BDFL refers to Guido van Rossum, Python's Benevolent
Dictator For Life.</p>
<ul class="simple">
<li>The function's name.  An earlier version of this PEP included an
open issue listing 20+ proposed alternative names to <tt class="docutils literal">zip()</tt>.  In
the face of no overwhelmingly better choice, the BDFL strongly
prefers <tt class="docutils literal">zip()</tt> due to its Haskell <a class="footnote-reference" href="#id4" id="id2">[2]</a> heritage.  See version 1.7
of this PEP for the list of alternatives.</li>
<li><tt class="docutils literal">zip()</tt> shall be a built-in function.</li>
<li>Optional padding.  An earlier version of this PEP proposed an
optional <tt class="docutils literal">pad</tt> keyword argument, which would be used when the
argument sequences were not the same length.  This is similar
behavior to the <tt class="docutils literal">map(None, <span class="pre">...)</span></tt> semantics except that the user
would be able to specify pad object.  This has been rejected by the
BDFL in favor of always truncating to the shortest sequence, because
of the KISS principle.  If there's a true need, it is easier to add
later.  If it is not needed, it would still be impossible to delete
it in the future.</li>
<li>Lazy evaluation.  An earlier version of this PEP proposed that
<tt class="docutils literal">zip()</tt> return a built-in object that performed lazy evaluation
using <tt class="docutils literal">__getitem__()</tt> protocol.  This has been strongly rejected
by the BDFL in favor of returning a real Python list.  If lazy
evaluation is desired in the future, the BDFL suggests an <tt class="docutils literal">xzip()</tt>
function be added.</li>
<li><tt class="docutils literal">zip()</tt> with no arguments.  the BDFL strongly prefers this raise a
TypeError exception.</li>
<li><tt class="docutils literal">zip()</tt> with one argument.  the BDFL strongly prefers that this
return a list of 1-tuples.</li>
<li>Inner and outer container control.  An earlier version of this PEP
contains a rather lengthy discussion on a feature that some people
wanted, namely the ability to control what the inner and outer
container types were (they are tuples and list respectively in this
version of the PEP).  Given the simplified API and implementation,
this elaboration is rejected.  For a more detailed analysis, see
version 1.7 of this PEP.</li>
</ul>
</div>
<div class="section" id="subsequent-change-to-zip">
<h1><a class="toc-backref" href="#id13">Subsequent Change to <tt class="docutils literal">zip()</tt></a></h1>
<p>In Python 2.4, zip() with no arguments was modified to return an empty
list rather than raising a TypeError exception.  The rationale for the
original behavior was that the absence of arguments was thought to
indicate a programming error.  However, that thinking did not
anticipate the use of zip() with the <tt class="docutils literal">*</tt> operator for unpacking
variable length argument lists.  For example, the inverse of zip could
be defined as:  <tt class="docutils literal">unzip = lambda s: <span class="pre">zip(*s)</span></tt>.  That transformation
also defines a matrix transpose or an equivalent row/column swap for
tables defined as lists of tuples.  The latter transformation is
commonly used when reading data files with records as rows and fields
as columns.  For example, the code:</p>
<pre class="literal-block">
date, rain, high, low = zip(*csv.reader(file(&quot;weather.csv&quot;)))
</pre>
<p>rearranges columnar data so that each field is collected into
individual tuples for straightforward looping and summarization:</p>
<pre class="literal-block">
print &quot;Total rainfall&quot;, sum(rain)
</pre>
<p>Using <tt class="docutils literal"><span class="pre">zip(*args)</span></tt> is more easily coded if <tt class="docutils literal"><span class="pre">zip(*[])</span></tt> is handled
as an allowable case rather than an exception.  This is especially
helpful when data is either built up from or recursed down to a null
case with no records.</p>
<p>Seeing this possibility, the BDFL agreed (with some misgivings) to
have the behavior changed for Py2.4.</p>
</div>
<div class="section" id="other-changes">
<h1><a class="toc-backref" href="#id14">Other Changes</a></h1>
<ul>
<li><p class="first">The <tt class="docutils literal">xzip()</tt> function discussed above was implemented in Py2.3 in
the <tt class="docutils literal">itertools</tt> module as <tt class="docutils literal">itertools.izip()</tt>.  This function
provides lazy behavior, consuming single elements and producing a
single tuple on each pass.  The &quot;just-in-time&quot; style saves memory
and runs faster than its list based counterpart, <tt class="docutils literal">zip()</tt>.</p>
</li>
<li><p class="first">The <tt class="docutils literal">itertools</tt> module also added <tt class="docutils literal">itertools.repeat()</tt> and
<tt class="docutils literal">itertools.chain()</tt>.  These tools can be used together to pad
sequences with <tt class="docutils literal">None</tt> (to match the behavior of <tt class="docutils literal">map(None,
seqn)</tt>):</p>
<pre class="literal-block">
zip(firstseq, chain(secondseq, repeat(None)))
</pre>
</li>
</ul>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id15">References</a></h1>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://docs.python.org/reference/compound_stmts.html#for">http://docs.python.org/reference/compound_stmts.html#for</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="http://www.haskell.org/onlinereport/standard-prelude.html#$vzip">http://www.haskell.org/onlinereport/standard-prelude.html#$vzip</a></td></tr>
</tbody>
</table>
<p>Greg Wilson's questionaire on proposed syntax to some CS grad students
<a class="reference external" href="http://www.python.org/pipermail/python-dev/2000-July/013139.html">http://www.python.org/pipermail/python-dev/2000-July/013139.html</a></p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id16">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

