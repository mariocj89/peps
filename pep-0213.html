<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">213</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Attribute Access Handlers</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0213.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">paul&#32;&#97;t&#32;prescod.net (Paul Prescod)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Deferred</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">21-Jul-2000</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.1</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id2">Introduction</a></li>
<li><a class="reference internal" href="#justification" id="id3">Justification</a><ul>
<li><a class="reference internal" href="#scenario-1" id="id4">Scenario 1</a></li>
<li><a class="reference internal" href="#scenario-2" id="id5">Scenario 2</a></li>
<li><a class="reference internal" href="#scenario-3" id="id6">Scenario 3</a></li>
</ul>
</li>
<li><a class="reference internal" href="#current-solution" id="id7">Current Solution</a></li>
<li><a class="reference internal" href="#proposed-syntax" id="id8">Proposed Syntax</a></li>
<li><a class="reference internal" href="#semantics" id="id9">Semantics</a></li>
<li><a class="reference internal" href="#proposed-implementation" id="id10">Proposed Implementation</a></li>
<li><a class="reference internal" href="#caveats" id="id11">Caveats</a></li>
<li><a class="reference internal" href="#note" id="id12">Note</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id2">Introduction</a></h1>
<p>It is possible (and even relatively common) in Python code and
in extension modules to &quot;trap&quot; when an instance's client code
attempts to set an attribute and execute code instead. In other
words, it is possible to allow users to use attribute assignment/
retrieval/deletion syntax even though the underlying implementation
is doing some computation rather than directly modifying a
binding.</p>
<p>This PEP describes a feature that makes it easier, more efficient
and safer to implement these handlers for Python instances.</p>
</div>
<div class="section" id="justification">
<h1><a class="toc-backref" href="#id3">Justification</a></h1>
<div class="section" id="scenario-1">
<h2><a class="toc-backref" href="#id4">Scenario 1</a></h2>
<p>You have a deployed class that works on an attribute named
&quot;stdout&quot;. After a while, you think it would be better to
check that stdout is really an object with a &quot;write&quot; method
at the moment of assignment. Rather than change to a
setstdout method (which would be incompatible with deployed
code) you would rather trap the assignment and check the
object's type.</p>
</div>
<div class="section" id="scenario-2">
<h2><a class="toc-backref" href="#id5">Scenario 2</a></h2>
<p>You want to be as compatible as possible with an object
model that has a concept of attribute assignment. It could
be the W3C Document Object Model or a particular COM
interface (e.g. the PowerPoint interface). In that case
you may well want attributes in the model to show up as
attributes in the Python interface, even though the
underlying implementation may not use attributes at all.</p>
</div>
<div class="section" id="scenario-3">
<h2><a class="toc-backref" href="#id6">Scenario 3</a></h2>
<p>A user wants to make an attribute read-only.</p>
<p>In short, this feature allows programmers to separate the
interface of their module from the underlying implementation
for whatever purpose. Again, this is not a new feature but
merely a new syntax for an existing convention.</p>
</div>
</div>
<div class="section" id="current-solution">
<h1><a class="toc-backref" href="#id7">Current Solution</a></h1>
<p>To make some attributes read-only:</p>
<pre class="literal-block">
class foo:
    def __setattr__( self, name, val ):
        if name==&quot;readonlyattr&quot;:
            raise TypeError
        elif name==&quot;readonlyattr2&quot;:
            raise TypeError
    ...
    else:
        self.__dict__[&quot;name&quot;]=val
</pre>
<p>This has the following problems:</p>
<ol class="arabic simple">
<li>The creator of the method must be intimately aware of whether
somewhere else in the class hierarchy <tt class="docutils literal">__setattr__</tt> has also been
trapped for any particular purpose. If so, she must specifically
call that method rather than assigning to the dictionary. There
are many different reasons to overload <tt class="docutils literal">__setattr__</tt> so there is a
decent potential for clashes. For instance object database
implementations often overload setattr for an entirely unrelated
purpose.</li>
<li>The string-based switch statement forces all attribute handlers
to be specified in one place in the code. They may then dispatch
to task-specific methods (for modularity) but this could cause
performance problems.</li>
<li>Logic for the setting, getting and deleting must live in
<tt class="docutils literal">__getattr__</tt>, <tt class="docutils literal">__setattr__</tt> and <tt class="docutils literal">__delattr__</tt>. Once again, this can
be mitigated through an extra level of method call but this is
inefficient.</li>
</ol>
</div>
<div class="section" id="proposed-syntax">
<h1><a class="toc-backref" href="#id8">Proposed Syntax</a></h1>
<p>Special methods should declare themselves with declarations of the
following form:</p>
<pre class="literal-block">
class x:
    def __attr_XXX__(self, op, val ):
        if op==&quot;get&quot;:
            return someComputedValue(self.internal)
        elif op==&quot;set&quot;:
            self.internal=someComputedValue(val)
        elif op==&quot;del&quot;:
            del self.internal
</pre>
<p>Client code looks like this:</p>
<pre class="literal-block">
fooval=x.foo
x.foo=fooval+5
del x.foo
</pre>
</div>
<div class="section" id="semantics">
<h1><a class="toc-backref" href="#id9">Semantics</a></h1>
<p>Attribute references of all three kinds should call the method.
The op parameter can be &quot;get&quot;/&quot;set&quot;/&quot;del&quot;. Of course this string
will be interned so the actual checks for the string will be
very fast.</p>
<p>It is disallowed to actually have an attribute named XXX in the
same instance as a method named __attr_XXX__.</p>
<p>An implementation of __attr_XXX__ takes precedence over an
implementation of <tt class="docutils literal">__getattr__</tt> based on the principle that
<tt class="docutils literal">__getattr__</tt> is supposed to be invoked only after finding an
appropriate attribute has failed.</p>
<p>An implementation of __attr_XXX__ takes precedence over an
implementation of <tt class="docutils literal">__setattr__</tt> in order to be consistent. The
opposite choice seems fairly feasible also, however. The same
goes for __del_y__.</p>
</div>
<div class="section" id="proposed-implementation">
<h1><a class="toc-backref" href="#id10">Proposed Implementation</a></h1>
<p>There is a new object type called an attribute access handler.
Objects of this type have the following attributes:</p>
<pre class="literal-block">
name (e.g. XXX, not __attr__XXX__)
method (pointer to a method object)
</pre>
<p>In PyClass_New, methods of the appropriate form will be detected and
converted into objects (just like unbound method objects). These are
stored in the class <tt class="docutils literal">__dict__</tt> under the name XXX. The original method
is stored as an unbound method under its original name.</p>
<p>If there are any attribute access handlers in an instance at all,
a flag is set. Let's call it &quot;I_have_computed_attributes&quot; for
now. Derived classes inherit the flag from base classes. Instances
inherit the flag from classes.</p>
<p>A get proceeds as usual until just before the object is returned.
In addition to the current check whether the returned object is a
method it would also check whether a returned object is an access
handler. If so, it would invoke the getter method and return
the value. To remove an attribute access handler you could directly
fiddle with the dictionary.</p>
<p>A set proceeds by checking the &quot;I_have_computed_attributes&quot; flag. If
it is not set, everything proceeds as it does today. If it is set
then we must do a dictionary get on the requested object name. If it
returns an attribute access handler then we call the setter function
with the value. If it returns any other object then we discard the
result and continue as we do today. Note that having an attribute
access handler will mildly affect attribute &quot;setting&quot; performance for
all sets on a particular instance, but no more so than today, using
<tt class="docutils literal">__setattr__</tt>. Gets are more efficient than they are today with
<tt class="docutils literal">__getattr__</tt>.</p>
<p>The I_have_computed_attributes flag is intended to eliminate the
performance degradation of an extra &quot;get&quot; per &quot;set&quot; for objects not
using this feature. Checking this flag should have minuscule
performance implications for all objects.</p>
<p>The implementation of delete is analogous to the implementation
of set.</p>
</div>
<div class="section" id="caveats">
<h1><a class="toc-backref" href="#id11">Caveats</a></h1>
<ol class="arabic">
<li><p class="first">You might note that I have not proposed any logic to keep
the I_have_computed_attributes flag up to date as attributes
are added and removed from the instance's dictionary. This is
consistent with current Python. If you add a <tt class="docutils literal">__setattr__</tt> method
to an object after it is in use, that method will not behave as
it would if it were available at &quot;compile&quot; time. The dynamism is
arguably not worth the extra implementation effort. This snippet
demonstrates the current behavior:</p>
<pre class="literal-block">
&gt;&gt;&gt; def prn(*args):print args
&gt;&gt;&gt; class a:

...    __setattr__=prn
&gt;&gt;&gt; a().foo=5
(&lt;__main__.a instance at 882890&gt;, 'foo', 5)

&gt;&gt;&gt; class b: pass
&gt;&gt;&gt; bi=b()
&gt;&gt;&gt; bi.__setattr__=prn
&gt;&gt;&gt; b.foo=5
</pre>
</li>
<li><p class="first">Assignment to __dict__[&quot;XXX&quot;] can overwrite the attribute
access handler for __attr_XXX__. Typically the access handlers will
store information away in private __XXX variables</p>
</li>
<li><p class="first">An attribute access handler that attempts to call setattr or getattr
on the object itself can cause an infinite loop (as with <tt class="docutils literal">__getattr__</tt>)
Once again, the solution is to use a special (typically private)
variable such as __XXX.</p>
</li>
</ol>
</div>
<div class="section" id="note">
<h1><a class="toc-backref" href="#id12">Note</a></h1>
<p>The descriptor mechanism described in <a class="reference external" href="/dev/peps/pep-0252">PEP 252</a> is powerful enough
to support this more directly.  A 'getset' constructor may be
added to the language making this possible:</p>
<pre class="literal-block">
class C:
    def get_x(self):
        return self.__x
    def set_x(self, v):
        self.__x = v
    x = getset(get_x, set_x)
</pre>
<p>Additional syntactic sugar might be added, or a naming convention
could be recognized.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

