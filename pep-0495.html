<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">495</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Local Time Disambiguation</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0495.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Alexander Belopolsky &lt;alexander.belopolsky&#32;&#97;t&#32;gmail.com&gt;, Tim Peters &lt;tim.peters&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Discussions-To:</th><td class="field-body">Datetime-SIG &lt;<a class="reference external" href="mailto:datetime-sig&#64;python.org?subject=PEP%20495">datetime-sig&#32;&#97;t&#32;python.org</a>&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">02-Aug-2015</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.6</td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/datetime-sig/2015-September/000900.html">https://mail.python.org/pipermail/datetime-sig/2015-September/000900.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id24">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id25">Rationale</a></li>
<li><a class="reference internal" href="#terminology" id="id26">Terminology</a></li>
<li><a class="reference internal" href="#proposal" id="id27">Proposal</a><ul>
<li><a class="reference internal" href="#the-fold-attribute" id="id28">The &quot;fold&quot; attribute</a></li>
<li><a class="reference internal" href="#affected-apis" id="id29">Affected APIs</a><ul>
<li><a class="reference internal" href="#attributes" id="id30">Attributes</a></li>
<li><a class="reference internal" href="#constructors" id="id31">Constructors</a></li>
<li><a class="reference internal" href="#methods" id="id32">Methods</a></li>
<li><a class="reference internal" href="#c-api" id="id33">C-API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#affected-behaviors" id="id34">Affected Behaviors</a><ul>
<li><a class="reference internal" href="#what-time-is-it" id="id35">What time is it?</a></li>
<li><a class="reference internal" href="#conversion-from-naive-to-aware" id="id36">Conversion from naive to aware</a></li>
<li><a class="reference internal" href="#conversion-from-posix-seconds-from-epoch" id="id37">Conversion from POSIX seconds from EPOCH</a></li>
<li><a class="reference internal" href="#conversion-to-posix-seconds-from-epoch" id="id38">Conversion to POSIX seconds from EPOCH</a></li>
<li><a class="reference internal" href="#aware-datetime-instances" id="id39">Aware datetime instances</a></li>
<li><a class="reference internal" href="#combining-and-splitting-date-and-time" id="id40">Combining and splitting date and time</a></li>
<li><a class="reference internal" href="#pickles" id="id41">Pickles</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#implementations-of-tzinfo-in-the-standard-library" id="id42">Implementations of tzinfo in the Standard Library</a></li>
<li><a class="reference internal" href="#guidelines-for-new-tzinfo-implementations" id="id43">Guidelines for New tzinfo Implementations</a><ul>
<li><a class="reference internal" href="#ignorance-is-bliss" id="id44">Ignorance is Bliss</a></li>
<li><a class="reference internal" href="#in-the-fold" id="id45">In the Fold</a></li>
<li><a class="reference internal" href="#mind-the-gap" id="id46">Mind the Gap</a></li>
<li><a class="reference internal" href="#summary-of-rules-at-a-transition" id="id47">Summary of Rules at a Transition</a></li>
<li><a class="reference internal" href="#the-dst-transitions" id="id48">The DST Transitions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#temporal-arithmetic-and-comparison-operators" id="id49">Temporal Arithmetic and Comparison Operators</a><ul>
<li><a class="reference internal" href="#aware-datetime-equality-comparison" id="id50">Aware datetime Equality Comparison</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backward-and-forward-compatibility" id="id51">Backward and Forward Compatibility</a></li>
<li><a class="reference internal" href="#questions-and-answers" id="id52">Questions and Answers</a><ul>
<li><a class="reference internal" href="#why-not-call-the-new-flag-isdst" id="id53">Why not call the new flag &quot;isdst&quot;?</a><ul>
<li><a class="reference internal" href="#a-non-technical-answer" id="id54">A non-technical answer</a></li>
<li><a class="reference internal" href="#a-technical-reason" id="id55">A technical reason</a></li>
</ul>
</li>
<li><a class="reference internal" href="#why-fold" id="id56">Why &quot;fold&quot;?</a></li>
<li><a class="reference internal" href="#what-is-first" id="id57">What is &quot;first&quot;?</a></li>
<li><a class="reference internal" href="#are-two-values-enough" id="id58">Are two values enough?</a><ul>
<li><a class="reference internal" href="#backward-compatibility" id="id59">Backward Compatibility</a></li>
<li><a class="reference internal" href="#analogy-with-tm-isdst" id="id60">Analogy with tm_isdst</a></li>
<li><a class="reference internal" href="#strict-invalid-time-checking" id="id61">Strict Invalid Time Checking</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#implementation" id="id62">Implementation</a></li>
<li><a class="reference internal" href="#id13" id="id63">References</a></li>
<li><a class="reference internal" href="#copyright" id="id64">Copyright</a></li>
<li><a class="reference internal" href="#picture-credit" id="id65">Picture Credit</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id24">Abstract</a></h1>
<p>This PEP adds a new attribute <tt class="docutils literal">fold</tt> to instances of the
<tt class="docutils literal">datetime.time</tt> and <tt class="docutils literal">datetime.datetime</tt> classes that can be used
to differentiate between two moments in time for which local times are
the same.  The allowed values for the <tt class="docutils literal">fold</tt> attribute will be 0 and 1
with 0 corresponding to the earlier and 1 to the later of the two
possible readings of an ambiguous local time.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id25">Rationale</a></h1>
<p>In most world locations, there have been and will be times when
local clocks are moved back. <a class="footnote-reference" href="#id2" id="id1">[1]</a> In those times, intervals are
introduced in which local clocks show the same time twice in the same
day.  In these situations, the information displayed on a local clock
(or stored in a Python datetime instance) is insufficient to identify
a particular moment in time.  The proposed solution is to add an
attribute to the <tt class="docutils literal">datetime</tt> instances taking values of 0 and 1 that
will enumerate the two ambiguous times.</p>
<img alt="pep-0495-daylightsavings.png" class="align-center" src="pep-0495-daylightsavings.png" style="width: 30%;" />
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><p class="first">People who live in locations observing the Daylight Saving
Time (DST) move their clocks back (usually one hour) every Fall.</p>
<p>It is less common, but occasionally clocks can be moved back for
other reasons.  For example, Ukraine skipped the spring-forward
transition in March 1990 and instead, moved their clocks back on
July 1, 1990, switching from Moscow Time to Eastern European Time.
In that case, standard (winter) time was in effect before and after
the transition.</p>
<p class="last">Both DST and standard time changes may result in time shifts other
than an hour.</p>
</td></tr>
</tbody>
</table>
</div>
<div class="section" id="terminology">
<h1><a class="toc-backref" href="#id26">Terminology</a></h1>
<p>When clocks are moved back, we say that a <em>fold</em> <a class="footnote-reference" href="#id4" id="id3">[2]</a> is created in time.
When the clocks are moved forward, a <em>gap</em> is created.  A local time
that falls in the fold is called <em>ambiguous</em>.  A local time that falls
in the gap is called <em>missing</em>.</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>The term &quot;fall-backward fold&quot; was invented in 1990s by Paul Eggert
of UCLA who used it in various Internet discussions related to the C language
standard that culminated in a <a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg14/docs/rr/dr_136.html">Defect Report #139</a> <a class="footnote-reference" href="#id14" id="id15">[7]</a>.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id27">Proposal</a></h1>
<div class="section" id="the-fold-attribute">
<h2><a class="toc-backref" href="#id28">The &quot;fold&quot; attribute</a></h2>
<p>We propose adding an attribute called <tt class="docutils literal">fold</tt> to instances of the
<tt class="docutils literal">datetime.time</tt> and <tt class="docutils literal">datetime.datetime</tt> classes.  This attribute
should have the value 0 for all instances except those that represent
the second (chronologically) moment in time in an ambiguous case. For
those instances, the value will be 1. <a class="footnote-reference" href="#id6" id="id5">[3]</a></p>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[3]</a></td><td>An instance that has <tt class="docutils literal">fold=1</tt> in a non-ambiguous case is
said to represent an invalid time (or is invalid for short), but
users are not prevented from creating invalid instances by passing
<tt class="docutils literal">fold=1</tt> to a constructor or to a <tt class="docutils literal">replace()</tt> method.  This
is similar to the current situation with the instances that fall in
the spring-forward gap.  Such instances don't represent any valid
time, but neither the constructors nor the <tt class="docutils literal">replace()</tt> methods
check whether the instances that they produce are valid.  Moreover,
this PEP specifies how various functions should behave when given an
invalid instance.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="affected-apis">
<h2><a class="toc-backref" href="#id29">Affected APIs</a></h2>
<div class="section" id="attributes">
<h3><a class="toc-backref" href="#id30">Attributes</a></h3>
<p>Instances of <tt class="docutils literal">datetime.time</tt> and <tt class="docutils literal">datetime.datetime</tt> classes will
get a new attribute <tt class="docutils literal">fold</tt> with two possible values: 0 and 1.</p>
</div>
<div class="section" id="constructors">
<h3><a class="toc-backref" href="#id31">Constructors</a></h3>
<p>The <tt class="docutils literal">__new__</tt> methods of the <tt class="docutils literal">datetime.time</tt> and
<tt class="docutils literal">datetime.datetime</tt> classes will get a new keyword-only argument
called <tt class="docutils literal">fold</tt> with the default value 0.  The value of the
<tt class="docutils literal">fold</tt> argument will be used to initialize the value of the
<tt class="docutils literal">fold</tt> attribute in the returned instance.</p>
</div>
<div class="section" id="methods">
<h3><a class="toc-backref" href="#id32">Methods</a></h3>
<p>The <tt class="docutils literal">replace()</tt> methods of the <tt class="docutils literal">datetime.time</tt> and
<tt class="docutils literal">datetime.datetime</tt> classes will get a new keyword-only argument
called <tt class="docutils literal">fold</tt>.  It will behave similarly to the other <tt class="docutils literal">replace()</tt>
arguments: if the <tt class="docutils literal">fold</tt> argument is specified and given a value 0
or 1, the new instance returned by <tt class="docutils literal">replace()</tt> will have its
<tt class="docutils literal">fold</tt> attribute set to that value.  In CPython, any non-integer
value of <tt class="docutils literal">fold</tt> will raise a <tt class="docutils literal">TypeError</tt>, but other
implementations may allow the value <tt class="docutils literal">None</tt> to behave the same as
when <tt class="docutils literal">fold</tt> is not given. <a class="footnote-reference" href="#id8" id="id7">[4]</a>  (This is
a nod to the existing difference in treatment of <tt class="docutils literal">None</tt> arguments
in other positions of this method across Python implementations;
it is not intended to leave the door open for future alternative
interpretation of <tt class="docutils literal">fold=None</tt>.)  If the <tt class="docutils literal">fold</tt> argument is not
specified, the original value of the <tt class="docutils literal">fold</tt> attribute is copied to
the result.</p>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[4]</a></td><td>PyPy and pure Python implementation distributed with CPython
already allow <tt class="docutils literal">None</tt> to mean &quot;no change to existing
attribute&quot; for all other attributes in <tt class="docutils literal">replace()</tt>.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="c-api">
<h3><a class="toc-backref" href="#id33">C-API</a></h3>
<p>Access macros will be defined to extract the value of <tt class="docutils literal">fold</tt> from
<tt class="docutils literal">PyDateTime_DateTime</tt> and <tt class="docutils literal">PyDateTime_Time</tt> objects.</p>
<pre class="code literal-block">
int PyDateTime_GET_FOLD(PyDateTime_DateTime *o)
</pre>
<p>Return the value of <tt class="docutils literal">fold</tt> as a C <tt class="docutils literal">int</tt>.</p>
<pre class="code literal-block">
int PyDateTime_TIME_GET_FOLD(PyDateTime_Time *o)
</pre>
<p>Return the value of <tt class="docutils literal">fold</tt> as a C <tt class="docutils literal">int</tt>.</p>
<p>New constructors will be defined that will take an additional
argument to specify the value of <tt class="docutils literal">fold</tt> in the created
instance:</p>
<pre class="code literal-block">
PyObject* PyDateTime_FromDateAndTimeAndFold(
    int year, int month, int day, int hour, int minute,
    int second, int usecond, int fold)
</pre>
<p>Return a <tt class="docutils literal">datetime.datetime</tt> object with the specified year, month,
day, hour, minute, second, microsecond and fold.</p>
<pre class="code literal-block">
PyObject* PyTime_FromTimeAndFold(
    int hour, int minute, int second, int usecond, int fold)
</pre>
<p>Return a <tt class="docutils literal">datetime.time</tt> object with the specified hour, minute,
second, microsecond and fold.</p>
</div>
</div>
<div class="section" id="affected-behaviors">
<h2><a class="toc-backref" href="#id34">Affected Behaviors</a></h2>
<div class="section" id="what-time-is-it">
<h3><a class="toc-backref" href="#id35">What time is it?</a></h3>
<p>The <tt class="docutils literal">datetime.now()</tt> method called without arguments will set
<tt class="docutils literal">fold=1</tt> when returning the second of the two ambiguous times in a
system local time fold.  When called with a <tt class="docutils literal">tzinfo</tt> argument, the
value of the <tt class="docutils literal">fold</tt> will be determined by the <tt class="docutils literal">tzinfo.fromutc()</tt>
implementation.  When an instance of the <tt class="docutils literal">datetime.timezone</tt> class
(the stdlib's fixed-offset <tt class="docutils literal">tzinfo</tt> subclass,
<em>e.g.</em> <tt class="docutils literal">datetime.timezone.utc</tt>) is passed as <tt class="docutils literal">tzinfo</tt>, the
returned datetime instance will always have <tt class="docutils literal">fold=0</tt>.
The <tt class="docutils literal">datetime.utcnow()</tt> method is unaffected.</p>
</div>
<div class="section" id="conversion-from-naive-to-aware">
<h3><a class="toc-backref" href="#id36">Conversion from naive to aware</a></h3>
<p>A new feature is proposed to facilitate conversion from naive datetime
instances to aware.</p>
<p>The <tt class="docutils literal">astimezone()</tt> method will now work for naive <tt class="docutils literal">self</tt>.  The
system local timezone will be assumed in this case and the <tt class="docutils literal">fold</tt>
flag will be used to determine which local timezone is in effect
in the ambiguous case.</p>
<p>For example, on a system set to US/Eastern timezone:</p>
<pre class="literal-block">
&gt;&gt;&gt; dt = datetime(2014, 11, 2, 1, 30)
&gt;&gt;&gt; dt.astimezone().strftime('%D %T %Z%z')
'11/02/14 01:30:00 EDT-0400'
&gt;&gt;&gt; dt.replace(fold=1).astimezone().strftime('%D %T %Z%z')
'11/02/14 01:30:00 EST-0500'
</pre>
<p>An implication is that <tt class="docutils literal">datetime.now(tz)</tt> is fully equivalent to
<tt class="docutils literal"><span class="pre">datetime.now().astimezone(tz)</span></tt> (assuming <tt class="docutils literal">tz</tt> is an instance of a
post-PEP <tt class="docutils literal">tzinfo</tt> implementation, i.e. one that correctly handles
and sets <tt class="docutils literal">fold</tt>).</p>
</div>
<div class="section" id="conversion-from-posix-seconds-from-epoch">
<h3><a class="toc-backref" href="#id37">Conversion from POSIX seconds from EPOCH</a></h3>
<p>The <tt class="docutils literal">fromtimestamp()</tt> static method of <tt class="docutils literal">datetime.datetime</tt> will
set the <tt class="docutils literal">fold</tt> attribute appropriately in the returned object.</p>
<p>For example, on a system set to US/Eastern timezone:</p>
<pre class="literal-block">
&gt;&gt;&gt; datetime.fromtimestamp(1414906200)
datetime.datetime(2014, 11, 2, 1, 30)
&gt;&gt;&gt; datetime.fromtimestamp(1414906200 + 3600)
datetime.datetime(2014, 11, 2, 1, 30, fold=1)
</pre>
</div>
<div class="section" id="conversion-to-posix-seconds-from-epoch">
<h3><a class="toc-backref" href="#id38">Conversion to POSIX seconds from EPOCH</a></h3>
<p>The <tt class="docutils literal">timestamp()</tt> method of <tt class="docutils literal">datetime.datetime</tt> will return different
values for <tt class="docutils literal">datetime.datetime</tt> instances that differ only by the value
of their <tt class="docutils literal">fold</tt> attribute if and only if these instances represent an
ambiguous or a missing time.</p>
<p>When a <tt class="docutils literal">datetime.datetime</tt> instance <tt class="docutils literal">dt</tt> represents an ambiguous
time, there are two values <tt class="docutils literal">s0</tt> and <tt class="docutils literal">s1</tt> such that:</p>
<pre class="literal-block">
datetime.fromtimestamp(s0) == datetime.fromtimestamp(s1) == dt
</pre>
<p>(This is because <tt class="docutils literal">==</tt> disregards the value of fold -- see below.)</p>
<p>In this case, <tt class="docutils literal">dt.timestamp()</tt> will return the smaller of <tt class="docutils literal">s0</tt>
and <tt class="docutils literal">s1</tt> values if <tt class="docutils literal">dt.fold == 0</tt> and the larger otherwise.</p>
<p>For example, on a system set to US/Eastern timezone:</p>
<pre class="literal-block">
&gt;&gt;&gt; datetime(2014, 11, 2, 1, 30, fold=0).timestamp()
1414906200.0
&gt;&gt;&gt; datetime(2014, 11, 2, 1, 30, fold=1).timestamp()
1414909800.0
</pre>
<p>When a <tt class="docutils literal">datetime.datetime</tt> instance <tt class="docutils literal">dt</tt> represents a missing
time, there is no value <tt class="docutils literal">s</tt> for which:</p>
<pre class="literal-block">
datetime.fromtimestamp(s) == dt
</pre>
<p>but we can form two &quot;nice to know&quot; values of <tt class="docutils literal">s</tt> that differ
by the size of the gap in seconds.  One is the value of <tt class="docutils literal">s</tt>
that would correspond to <tt class="docutils literal">dt</tt> in a timezone where the UTC offset
is always the same as the offset right before the gap and the
other is the similar value but in a timezone the  UTC offset
is always the same as the offset right after the gap.</p>
<p>The value returned by <tt class="docutils literal">dt.timestamp()</tt> given a missing
<tt class="docutils literal">dt</tt> will be the greater of the two &quot;nice to know&quot; values
if <tt class="docutils literal">dt.fold == 0</tt> and the smaller otherwise.
(This is not a typo -- it's intentionally backwards from the rule for
ambiguous times.)</p>
<p>For example, on a system set to US/Eastern timezone:</p>
<pre class="literal-block">
&gt;&gt;&gt; datetime(2015, 3, 8, 2, 30, fold=0).timestamp()
1425799800.0
&gt;&gt;&gt; datetime(2015, 3, 8, 2, 30, fold=1).timestamp()
1425796200.0
</pre>
</div>
<div class="section" id="aware-datetime-instances">
<h3><a class="toc-backref" href="#id39">Aware datetime instances</a></h3>
<p>Users of pre-PEP implementations of <tt class="docutils literal">tzinfo</tt> will not see any
changes in the behavior of their aware datetime instances.  Two such
instances that differ only by the value of the <tt class="docutils literal">fold</tt> attribute will
not be distinguishable by any means other than an explicit access to
the <tt class="docutils literal">fold</tt> value.  (This is because these pre-PEP implementations
are not using the <tt class="docutils literal">fold</tt> attribute.)</p>
<p>On the other hand, if an object's <tt class="docutils literal">tzinfo</tt> is set to a fold-aware
implementation, then in a fold or gap the value of <tt class="docutils literal">fold</tt> will
affect the result of several methods:
<tt class="docutils literal">utcoffset()</tt>, <tt class="docutils literal">dst()</tt>, <tt class="docutils literal">tzname()</tt>, <tt class="docutils literal">astimezone()</tt>,
<tt class="docutils literal">strftime()</tt> (if the &quot;%Z&quot; or &quot;%z&quot; directive is used in the format
specification), <tt class="docutils literal">isoformat()</tt>, and <tt class="docutils literal">timetuple()</tt>.</p>
</div>
<div class="section" id="combining-and-splitting-date-and-time">
<h3><a class="toc-backref" href="#id40">Combining and splitting date and time</a></h3>
<p>The <tt class="docutils literal">datetime.datetime.combine()</tt> method will copy the value of the
<tt class="docutils literal">fold</tt> attribute to the resulting <tt class="docutils literal">datetime.datetime</tt> instance.</p>
<p>The <tt class="docutils literal">datetime.datetime.time()</tt> method will copy the value of the
<tt class="docutils literal">fold</tt> attribute to the resulting <tt class="docutils literal">datetime.time</tt> instance.</p>
</div>
<div class="section" id="pickles">
<h3><a class="toc-backref" href="#id41">Pickles</a></h3>
<p>The value of the fold attribute will only be saved in pickles created
with protocol version 4 (introduced in Python 3.4) or greater.</p>
<p>Pickle sizes for the <tt class="docutils literal">datetime.datetime</tt> and <tt class="docutils literal">datetime.time</tt>
objects will not change.  The <tt class="docutils literal">fold</tt> value will be encoded in the
first bit of the 3rd byte of the <tt class="docutils literal">datetime.datetime</tt>
pickle payload; and in the first bit of the 1st byte of the
<tt class="docutils literal">datetime.time</tt> payload.  In the <a class="reference external" href="https://hg.python.org/cpython/file/v3.5.0/Include/datetime.h#l10">current implementation</a> <a class="footnote-reference" href="#id16" id="id17">[8]</a>
these bytes are used to store the month (1-12) and hour (0-23) values
and the first bit is always 0.  We picked these bytes because they are
the only bytes that are checked by the current unpickle code.  Thus
loading post-PEP <tt class="docutils literal">fold=1</tt> pickles in a pre-PEP Python will result in
an exception rather than an instance with out of range components.</p>
</div>
</div>
</div>
<div class="section" id="implementations-of-tzinfo-in-the-standard-library">
<h1><a class="toc-backref" href="#id42">Implementations of tzinfo in the Standard Library</a></h1>
<p>No new implementations of <tt class="docutils literal">datetime.tzinfo</tt> abstract class are
proposed in this PEP.  The existing (fixed offset) timezones do
not introduce ambiguous local times and their <tt class="docutils literal">utcoffset()</tt>
implementation will return the same constant value as they do now
regardless of the value of <tt class="docutils literal">fold</tt>.</p>
<p>The basic implementation of <tt class="docutils literal">fromutc()</tt> in the abstract
<tt class="docutils literal">datetime.tzinfo</tt> class will not change.  It is currently not used
anywhere in the stdlib because the only included <tt class="docutils literal">tzinfo</tt>
implementation (the <tt class="docutils literal">datetime.timezone</tt> class implementing fixed
offset timezones) overrides <tt class="docutils literal">fromutc()</tt>.  Keeping the default
implementation unchanged has the benefit that pre-PEP 3rd party
implementations that inherit the default <tt class="docutils literal">fromutc()</tt> are not
accidentally affected.</p>
</div>
<div class="section" id="guidelines-for-new-tzinfo-implementations">
<h1><a class="toc-backref" href="#id43">Guidelines for New tzinfo Implementations</a></h1>
<p>Implementors of concrete <tt class="docutils literal">datetime.tzinfo</tt> subclasses who want to
support variable UTC offsets (due to DST and other causes) should follow
these guidelines.</p>
<div class="section" id="ignorance-is-bliss">
<h2><a class="toc-backref" href="#id44">Ignorance is Bliss</a></h2>
<p>New implementations of <tt class="docutils literal">utcoffset()</tt>, <tt class="docutils literal">tzname()</tt> and <tt class="docutils literal">dst()</tt>
methods should ignore the value of <tt class="docutils literal">fold</tt> unless they are called on
the ambiguous or missing times.</p>
</div>
<div class="section" id="in-the-fold">
<h2><a class="toc-backref" href="#id45">In the Fold</a></h2>
<p>New subclasses should override the base-class <tt class="docutils literal">fromutc()</tt> method and
implement it so that in all cases where two different UTC times <tt class="docutils literal">u0</tt> and
<tt class="docutils literal">u1</tt> (<tt class="docutils literal">u0</tt> &lt;<tt class="docutils literal">u1</tt>) correspond to the same local time <tt class="docutils literal">t</tt>,
<tt class="docutils literal">fromutc(u0)</tt> will return an instance with <tt class="docutils literal">fold=0</tt> and
<tt class="docutils literal">fromutc(u1)</tt> will return an instance with <tt class="docutils literal">fold=1</tt>.  In all
other cases the returned instance should have <tt class="docutils literal">fold=0</tt>.</p>
<p>The <tt class="docutils literal">utcoffset()</tt>, <tt class="docutils literal">tzname()</tt> and <tt class="docutils literal">dst()</tt> methods should use the
value of the fold attribute to determine whether an otherwise
ambiguous time <tt class="docutils literal">t</tt> corresponds to the time before or after the
transition.  By definition, <tt class="docutils literal">utcoffset()</tt> is greater before and
smaller after any transition that creates a fold.  The values returned
by <tt class="docutils literal">tzname()</tt> and <tt class="docutils literal">dst()</tt> may or may not depend on the value of
the <tt class="docutils literal">fold</tt> attribute depending on the kind of the transition.</p>
<img alt="pep-0495-fold-2.png" class="align-center" src="pep-0495-fold-2.png" style="width: 60%;" />
<p>The sketch above illustrates the relationship between the UTC and
local time around a fall-back transition.  The zig-zag line is a graph
of the function implemented by <tt class="docutils literal">fromutc()</tt>.  Two intervals on the
UTC axis adjacent to the transition point and having the size of the
time shift at the transition are mapped to the same interval on the
local axis.  New implementations of <tt class="docutils literal">fromutc()</tt> method should set
the fold attribute to 1 when <tt class="docutils literal">self</tt> is in the region marked in
yellow on the UTC axis.  (All intervals should be treated as closed on
the left and open on the right.)</p>
</div>
<div class="section" id="mind-the-gap">
<h2><a class="toc-backref" href="#id46">Mind the Gap</a></h2>
<p>The <tt class="docutils literal">fromutc()</tt> method should never produce a time in the gap.</p>
<p>If the <tt class="docutils literal">utcoffset()</tt>, <tt class="docutils literal">tzname()</tt> or <tt class="docutils literal">dst()</tt> method is called on a
local time that falls in a gap, the rules in effect before the
transition should be used if <tt class="docutils literal">fold=0</tt>.  Otherwise, the rules in
effect after the transition should be used.</p>
<img alt="pep-0495-gap.png" class="align-center" src="pep-0495-gap.png" style="width: 60%;" />
<p>The sketch above illustrates the relationship between the UTC and
local time around a spring-forward transition.  At the transition, the
local clock is advanced skipping the times in the gap.  For the
purposes of determining the values of <tt class="docutils literal">utcoffset()</tt>, <tt class="docutils literal">tzname()</tt>
and <tt class="docutils literal">dst()</tt>, the line before the transition is extended forward to
find the UTC time corresponding to the time in the gap with <tt class="docutils literal">fold=0</tt>
and for instances with <tt class="docutils literal">fold=1</tt>, the line after the transition is
extended back.</p>
</div>
<div class="section" id="summary-of-rules-at-a-transition">
<h2><a class="toc-backref" href="#id47">Summary of Rules at a Transition</a></h2>
<p>On ambiguous/missing times <tt class="docutils literal">utcoffset()</tt> should return values
according to the following table:</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="26%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head">fold=0</th>
<th class="head">fold=1</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Fold</td>
<td>oldoff</td>
<td>newoff = oldoff - delta</td>
</tr>
<tr><td>Gap</td>
<td>oldoff</td>
<td>newoff = oldoff + delta</td>
</tr>
</tbody>
</table>
<p>where <tt class="docutils literal">oldoff</tt> (<tt class="docutils literal">newoff</tt>) is the UTC offset before (after) the
transition and <tt class="docutils literal">delta</tt> is the absolute size of the fold or the gap.</p>
<p>Note that the interpretation of the fold attribute is consistent in
the fold and gap cases.  In both cases, <tt class="docutils literal">fold=0</tt> (<tt class="docutils literal">fold=1</tt>) means
use <tt class="docutils literal">fromutc()</tt> line before (after) the transition to find the UTC
time.  Only in the &quot;Fold&quot; case, the UTC times <tt class="docutils literal">u0</tt> and <tt class="docutils literal">u1</tt> are
&quot;real&quot; solutions for the equation <tt class="docutils literal">fromutc(u) == t</tt>, while in the
&quot;Gap&quot; case they are &quot;imaginary&quot; solutions.</p>
</div>
<div class="section" id="the-dst-transitions">
<h2><a class="toc-backref" href="#id48">The DST Transitions</a></h2>
<p>On a missing time introduced at the start of DST, the values returned
by <tt class="docutils literal">utcoffset()</tt> and <tt class="docutils literal">dst()</tt> methods should be as follows</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="31%" />
<col width="35%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head">fold=0</th>
<th class="head">fold=1</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>utcoffset()</td>
<td>stdoff</td>
<td>stdoff + dstoff</td>
</tr>
<tr><td>dst()</td>
<td>zero</td>
<td>dstoff</td>
</tr>
</tbody>
</table>
<p>On an ambiguous time introduced at the end of DST, the values returned
by <tt class="docutils literal">utcoffset()</tt> and <tt class="docutils literal">dst()</tt> methods should be as follows</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="31%" />
<col width="35%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head">fold=0</th>
<th class="head">fold=1</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>utcoffset()</td>
<td>stdoff + dstoff</td>
<td>stdoff</td>
</tr>
<tr><td>dst()</td>
<td>dstoff</td>
<td>zero</td>
</tr>
</tbody>
</table>
<p>where <tt class="docutils literal">stdoff</tt> is the standard (non-DST) offset, <tt class="docutils literal">dstoff</tt> is the
DST correction (typically <tt class="docutils literal">dstoff = timedelta(hours=1)</tt>) and <tt class="docutils literal">zero
= timedelta(0)</tt>.</p>
</div>
</div>
<div class="section" id="temporal-arithmetic-and-comparison-operators">
<h1><a class="toc-backref" href="#id49">Temporal Arithmetic and Comparison Operators</a></h1>
<blockquote class="epigraph">
<div class="line-block">
<div class="line">In <em>mathematicks</em> he was greater</div>
<div class="line">Than Tycho Brahe, or Erra Pater:</div>
<div class="line">For he, by geometric scale,</div>
<div class="line">Could take the size of pots of ale;</div>
<div class="line">Resolve, by sines and tangents straight,</div>
<div class="line">If bread or butter wanted weight,</div>
<div class="line">And wisely tell what hour o' th' day</div>
<div class="line">The clock does strike by algebra.</div>
</div>
<blockquote>
-- &quot;Hudibras&quot; by Samuel Butler</blockquote>
</blockquote>
<p>The value of the <tt class="docutils literal">fold</tt> attribute will be ignored in all operations
with naive datetime instances.  As a consequence, naive
<tt class="docutils literal">datetime.datetime</tt> or <tt class="docutils literal">datetime.time</tt> instances that differ only
by the value of <tt class="docutils literal">fold</tt> will compare as equal.  Applications that
need to differentiate between such instances should check the value of
<tt class="docutils literal">fold</tt> explicitly or convert those instances to a timezone that does
not have ambiguous times (such as UTC).</p>
<p>The value of <tt class="docutils literal">fold</tt> will also be ignored whenever a timedelta is
added to or subtracted from a datetime instance which may be either
aware or naive.  The result of addition (subtraction) of a timedelta
to (from) a datetime will always have <tt class="docutils literal">fold</tt> set to 0 even if the
original datetime instance had <tt class="docutils literal">fold=1</tt>.</p>
<p>No changes are proposed to the way the difference <tt class="docutils literal">t - s</tt> is
computed for datetime instances <tt class="docutils literal">t</tt> and <tt class="docutils literal">s</tt>.  If both instances
are naive or <tt class="docutils literal">t.tzinfo</tt> is the same instance as <tt class="docutils literal">s.tzinfo</tt>
(<tt class="docutils literal">t.tzinfo is s.tzinfo</tt> evaluates to <tt class="docutils literal">True</tt>) then <tt class="docutils literal">t - s</tt> is a
timedelta <tt class="docutils literal">d</tt> such that <tt class="docutils literal">s + d == t</tt>.  As explained in the
previous paragraph, timedelta addition ignores both <tt class="docutils literal">fold</tt> and
<tt class="docutils literal">tzinfo</tt> attributes and so does intra-zone or naive datetime
subtraction.</p>
<p>Naive and intra-zone comparisons will ignore the value of <tt class="docutils literal">fold</tt> and
return the same results as they do now.  (This is the only way to
preserve backward compatibility.  If you need an aware intra-zone
comparison that uses the fold, convert both sides to UTC first.)</p>
<p>The inter-zone subtraction will be defined as it is now: <tt class="docutils literal">t - s</tt> is
computed as <tt class="docutils literal">(t - <span class="pre">t.utcoffset())</span> - (s -
<span class="pre">s.utcoffset()).replace(tzinfo=t.tzinfo)</span></tt>, but the result will
depend on the values of <tt class="docutils literal">t.fold</tt> and <tt class="docutils literal">s.fold</tt> when either
<tt class="docutils literal">t.tzinfo</tt> or <tt class="docutils literal">s.tzinfo</tt> is post-PEP. <a class="footnote-reference" href="#id10" id="id9">[5]</a></p>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[5]</a></td><td>Note that the new rules may result in a paradoxical situation
when <tt class="docutils literal">s == t</tt> but <tt class="docutils literal">s - u != t - u</tt>.  Such paradoxes are
not really new and are inherent in the overloading of the minus
operator differently for intra- and inter-zone operations.  For
example, one can easily construct datetime instances <tt class="docutils literal">t</tt> and <tt class="docutils literal">s</tt>
with some variable offset <tt class="docutils literal">tzinfo</tt> and a datetime <tt class="docutils literal">u</tt> with
<tt class="docutils literal">tzinfo=timezone.utc</tt> such that <tt class="docutils literal">(t - u) - (s - u) != t - s</tt>.
The explanation for this paradox is that the minuses inside the
parentheses and the two other minuses are really three different
operations: inter-zone datetime subtraction, timedelta subtraction,
and intra-zone datetime subtraction, which each have the mathematical
properties of subtraction separately, but not when combined in a
single expression.</td></tr>
</tbody>
</table>
<div class="section" id="aware-datetime-equality-comparison">
<h2><a class="toc-backref" href="#id50">Aware datetime Equality Comparison</a></h2>
<p>The aware datetime comparison operators will work the same as they do
now, with results indirectly affected by the value of <tt class="docutils literal">fold</tt> whenever
the <tt class="docutils literal">utcoffset()</tt> value of one of the operands depends on it, with one
exception.  Whenever one or both of the operands in inter-zone comparison is
such that its <tt class="docutils literal">utcoffset()</tt> depends on the value of its <tt class="docutils literal">fold</tt>
fold attribute, the result is <tt class="docutils literal">False</tt>. <a class="footnote-reference" href="#id12" id="id11">[6]</a></p>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[6]</a></td><td>This exception is designed to preserve the hash and equivalence
invariants in the face of paradoxes of inter-zone arithmetic.</td></tr>
</tbody>
</table>
<p>Formally, <tt class="docutils literal">t == s</tt> when <tt class="docutils literal">t.tzinfo is s.tzinfo</tt> evaluates to
<tt class="docutils literal">False</tt> can be defined as follows.  Let <tt class="docutils literal">toutc(t, fold)</tt> be a
function that takes an aware datetime instance <tt class="docutils literal">t</tt> and returns a
naive instance representing the same time in UTC assuming a given
value of <tt class="docutils literal">fold</tt>:</p>
<pre class="code literal-block">
def toutc(t, fold):
    u = t - t.replace(fold=fold).utcoffset()
    return u.replace(tzinfo=None)
</pre>
<p>Then <tt class="docutils literal">t == s</tt> is equivalent to</p>
<pre class="code literal-block">
toutc(t, fold=0) == toutc(t, fold=1) == toutc(s, fold=0) == toutc(s, fold=1)
</pre>
</div>
</div>
<div class="section" id="backward-and-forward-compatibility">
<h1><a class="toc-backref" href="#id51">Backward and Forward Compatibility</a></h1>
<p>This proposal will have little effect on the programs that do not read
the <tt class="docutils literal">fold</tt> flag explicitly or use tzinfo implementations that do.
The only visible change for such programs will be that conversions to
and from POSIX timestamps will now round-trip correctly (up to
floating point rounding).  Programs that implemented a work-around to
the old incorrect behavior may need to be modified.</p>
<p>Pickles produced by older programs will remain fully forward
compatible.  Only datetime/time instances with <tt class="docutils literal">fold=1</tt> pickled
in the new versions will become unreadable by the older Python
versions.  Pickles of instances with <tt class="docutils literal">fold=0</tt> (which is the
default) will remain unchanged.</p>
</div>
<div class="section" id="questions-and-answers">
<h1><a class="toc-backref" href="#id52">Questions and Answers</a></h1>
<div class="section" id="why-not-call-the-new-flag-isdst">
<h2><a class="toc-backref" href="#id53">Why not call the new flag &quot;isdst&quot;?</a></h2>
<div class="section" id="a-non-technical-answer">
<h3><a class="toc-backref" href="#id54">A non-technical answer</a></h3>
<ul class="simple">
<li>Alice: Bob - let's have a stargazing party at 01:30 AM tomorrow!</li>
<li>Bob: Should I presume initially that Daylight Saving Time is or is
not in effect for the specified time?</li>
<li>Alice: Huh?</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li>Bob: Alice - let's have a stargazing party at 01:30 AM tomorrow!</li>
<li>Alice: You know, Bob, 01:30 AM will happen twice tomorrow. Which time do you have in mind?</li>
<li>Bob:  I did not think about it, but let's pick the first.</li>
</ul>
<hr class="docutils" />
<p>(same characters, an hour later)</p>
<hr class="docutils" />
<ul class="simple">
<li>Bob: Alice - this Py-O-Clock gadget of mine asks me to choose
between fold=0 and fold=1 when I set it for tomorrow 01:30 AM.
What should I do?</li>
<li>Alice: I've never hear of a Py-O-Clock, but I guess fold=0 is
the first 01:30 AM and fold=1 is the second.</li>
</ul>
</div>
<div class="section" id="a-technical-reason">
<h3><a class="toc-backref" href="#id55">A technical reason</a></h3>
<p>While the <tt class="docutils literal">tm_isdst</tt> field of the <tt class="docutils literal">time.struct_time</tt> object can be
used to disambiguate local times in the fold, the semantics of such
disambiguation are completely different from the proposal in this PEP.</p>
<p>The main problem with the <tt class="docutils literal">tm_isdst</tt> field is that it is impossible
to know what value is appropriate for <tt class="docutils literal">tm_isdst</tt> without knowing the
details about the time zone that are only available to the <tt class="docutils literal">tzinfo</tt>
implementation.  Thus while <tt class="docutils literal">tm_isdst</tt> is useful in the <em>output</em> of
methods such as <tt class="docutils literal">time.localtime</tt>, it is cumbersome as an <em>input</em> of
methods such as <tt class="docutils literal">time.mktime</tt>.</p>
<p>If the programmer misspecified a non-negative value of <tt class="docutils literal">tm_isdst</tt> to
<tt class="docutils literal">time.mktime</tt>, the result will be time that is 1 hour off and since
there is rarely a way to know anything about DST <em>before</em> a call to
<tt class="docutils literal">time.mktime</tt> is made, the only sane choice is usually
<tt class="docutils literal"><span class="pre">tm_isdst=-1</span></tt>.</p>
<p>Unlike <tt class="docutils literal">tm_isdst</tt>, the proposed <tt class="docutils literal">fold</tt> attribute has no effect on
the interpretation of the datetime instance unless without that
attribute two (or no) interpretations are possible.</p>
<p>Since it would be very confusing to have something called <tt class="docutils literal">isdst</tt>
that does not have the same semantics as <tt class="docutils literal">tm_isdst</tt>, we need a
different name.  Moreover, the <tt class="docutils literal">datetime.datetime</tt> class already has
a method called <tt class="docutils literal">dst()</tt> and if we called <tt class="docutils literal">fold</tt> &quot;isdst&quot;, we would
necessarily have situations when &quot;isdst&quot; is zero but <tt class="docutils literal">dst()</tt> is not
or the other way around.</p>
</div>
</div>
<div class="section" id="why-fold">
<h2><a class="toc-backref" href="#id56">Why &quot;fold&quot;?</a></h2>
<p>Suggested by Guido van Rossum and favored by one (but initially
disfavored by another) author.  A consensus was reached after the
allowed values for the attribute were changed from False/True to 0/1.
The noun &quot;fold&quot; has correct connotations and easy mnemonic rules, but
at the same time does not invite unbased assumptions.</p>
</div>
<div class="section" id="what-is-first">
<h2><a class="toc-backref" href="#id57">What is &quot;first&quot;?</a></h2>
<p>This was a working name of the attribute chosen initially because the
obvious alternative (&quot;second&quot;) conflicts with the existing attribute.
It was rejected mostly on the grounds that it would make True a
default value.</p>
<p>The following alternative names have also been considered:</p>
<dl class="docutils">
<dt><strong>later</strong></dt>
<dd>A close contender to &quot;fold&quot;.  One author dislikes it because
it is confusable with equally fitting &quot;latter,&quot; but in the age
of auto-completion everywhere this is a small consideration.  A
stronger objection may be that in the case of missing time, we
will have <tt class="docutils literal">later=True</tt> instance converted to an earlier time by
<tt class="docutils literal">.astimezone(timezone.utc)</tt> that that with <tt class="docutils literal">later=False</tt>.
Yet again, this can be interpreted as a desirable indication that
the original time is invalid.</dd>
<dt><strong>which</strong></dt>
<dd>The <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2015-April/139099.html">original</a> <a class="footnote-reference" href="#id18" id="id19">[9]</a> placeholder name for the <cite>localtime</cite> function
branch index was <a class="reference external" href="https://mail.python.org/pipermail/datetime-sig/2015-August/000479.html">independently proposed</a> <a class="footnote-reference" href="#id20" id="id21">[10]</a> for the name of the
disambiguation attribute and received <a class="reference external" href="https://mail.python.org/pipermail/datetime-sig/2015-August/000483.html">some support</a> <a class="footnote-reference" href="#id22" id="id23">[11]</a>.</dd>
<dt><strong>repeated</strong></dt>
<dd>Did not receive any support on the mailing list.</dd>
<dt><strong>ltdf</strong></dt>
<dd>(Local Time Disambiguation Flag) - short and no-one will attempt
to guess what it means without reading the docs.  (This abbreviation
was used in PEP discussions with the meaning <tt class="docutils literal">ltdf=False</tt> is the
earlier by those who didn't want to endorse any of the alternatives.)</dd>
</dl>
</div>
<div class="section" id="are-two-values-enough">
<h2><a class="toc-backref" href="#id58">Are two values enough?</a></h2>
<p>Several reasons have been raised to allow a <tt class="docutils literal">None</tt> or -1 value for
the <tt class="docutils literal">fold</tt> attribute: backward compatibility, analogy with <tt class="docutils literal">tm_isdst</tt>
and strict checking for invalid times.</p>
<div class="section" id="backward-compatibility">
<h3><a class="toc-backref" href="#id59">Backward Compatibility</a></h3>
<p>It has been suggested that backward compatibility can be improved if
the default value of the <tt class="docutils literal">fold</tt> flag was <tt class="docutils literal">None</tt> which would
signal that pre-PEP behavior is requested.  Based on the analysis
below, we believe that the proposed changes with the <tt class="docutils literal">fold=0</tt>
default are sufficiently backward compatible.</p>
<p>This PEP provides only three ways for a program to discover that two
otherwise identical datetime instances have different values of
<tt class="docutils literal">fold</tt>: (1) an explicit check of the <tt class="docutils literal">fold</tt> attribute; (2) if
the instances are naive - conversion to another timezone using the
<tt class="docutils literal">astimezone()</tt> method; and (3) conversion to <tt class="docutils literal">float</tt> using the
<tt class="docutils literal">timestamp()</tt> method.</p>
<p>Since <tt class="docutils literal">fold</tt> is a new attribute, the first option is not available
to the existing programs.  Note that option (2) only works for naive
datetimes that happen to be in a fold or a gap in the system time
zone.  In all other cases, the value of <tt class="docutils literal">fold</tt> will be ignored in
the conversion unless the instances use a <tt class="docutils literal">fold</tt>-aware <tt class="docutils literal">tzinfo</tt>
which would not be available in a pre-PEP program.  Similarly, the
<tt class="docutils literal">astimezone()</tt> called on a naive instance will not be available in
such program because <tt class="docutils literal">astimezone()</tt> does not currently work with
naive datetimes.</p>
<p>This leaves us with only one situation where an existing program can
start producing different results after the implementation of this PEP:
when a <tt class="docutils literal">datetime.timestamp()</tt> method is called on a naive datetime
instance that happen to be in the fold or the gap.  In the current
implementation, the result is undefined.  Depending on the system
<tt class="docutils literal">mktime</tt> implementation, the programs can see different results or
errors in those cases.  With this PEP in place, the value of timestamp
will be well-defined in those cases but will depend on the value of
the <tt class="docutils literal">fold</tt> flag.  We consider the change in
<tt class="docutils literal">datetime.timestamp()</tt> method behavior a bug fix enabled by this
PEP.  The old behavior can still be emulated by the users who depend
on it by writing <tt class="docutils literal"><span class="pre">time.mktime(dt.timetuple())</span> + <span class="pre">1e-6*dt.microsecond</span></tt>
instead of <tt class="docutils literal">dt.timestamp()</tt>.</p>
</div>
<div class="section" id="analogy-with-tm-isdst">
<h3><a class="toc-backref" href="#id60">Analogy with tm_isdst</a></h3>
<p>The <tt class="docutils literal">time.mktime</tt> interface allows three values for the <tt class="docutils literal">tm_isdst</tt>
flag: -1, 0, and 1.  As we explained above, -1 (asking <tt class="docutils literal">mktime</tt> to
determine whether DST is in effect for the given time from the rest of
the fields) is the only choice that is useful in practice.</p>
<p>With the <tt class="docutils literal">fold</tt> flag, however, <tt class="docutils literal">datetime.timestamp()</tt> will return
the same value as <tt class="docutils literal">mktime</tt> with <tt class="docutils literal"><span class="pre">tm_isdst=-1</span></tt> in 99.98% of the
time for most time zones with DST transitions.  Moreover,
<tt class="docutils literal"><span class="pre">tm_isdst=-1</span></tt>-like behavior is specified <em>regardless</em> of the value
of <tt class="docutils literal">fold</tt>.</p>
<p>It is only in the 0.02% cases (2 hours per year) that the
<tt class="docutils literal">datetime.timestamp()</tt> and <tt class="docutils literal">mktime</tt> with <tt class="docutils literal"><span class="pre">tm_isdst=-1</span></tt> may
disagree.  However, even in this case, most of the <tt class="docutils literal">mktime</tt>
implementations will return the <tt class="docutils literal">fold=0</tt> or the <tt class="docutils literal">fold=1</tt>
value even though relevant standards allow <tt class="docutils literal">mktime</tt> to return -1 and
set an error code in those cases.</p>
<p>In other words, <tt class="docutils literal"><span class="pre">tm_isdst=-1</span></tt> behavior is not missing from this PEP.
To the contrary, it is the only behavior provided in two different
well-defined flavors.  The behavior that is missing is when a given
local hour is interpreted as a different local hour because of the
misspecified <tt class="docutils literal">tm_isdst</tt>.</p>
<p>For example, in the DST-observing time zones in the Northern
hemisphere (where DST is in effect in June) one can get</p>
<pre class="code literal-block">
&gt;&gt;&gt; from time import mktime, localtime
&gt;&gt;&gt; t = mktime((2015, 6, 1, 12, 0, 0, -1, -1, 0))
&gt;&gt;&gt; localtime(t)[:]
(2015, 6, 1, 13, 0, 0, 0, 152, 1)
</pre>
<p>Note that 12:00 was interpreted as 13:00 by <tt class="docutils literal">mktime</tt>.  With the
<tt class="docutils literal">datetime.timestamp</tt>, <tt class="docutils literal">datetime.fromtimestamp</tt>, it is currently
guaranteed that</p>
<pre class="code literal-block">
&gt;&gt;&gt; t = datetime.datetime(2015, 6, 1, 12).timestamp()
&gt;&gt;&gt; datetime.datetime.fromtimestamp(t)
datetime.datetime(2015, 6, 1, 12, 0)
</pre>
<p>This PEP extends the same guarantee to both values of <tt class="docutils literal">fold</tt>:</p>
<pre class="code literal-block">
&gt;&gt;&gt; t = datetime.datetime(2015, 6, 1, 12, fold=0).timestamp()
&gt;&gt;&gt; datetime.datetime.fromtimestamp(t)
datetime.datetime(2015, 6, 1, 12, 0)
</pre>
<pre class="code literal-block">
&gt;&gt;&gt; t = datetime.datetime(2015, 6, 1, 12, fold=1).timestamp()
&gt;&gt;&gt; datetime.datetime.fromtimestamp(t)
datetime.datetime(2015, 6, 1, 12, 0)
</pre>
<p>Thus one of the suggested uses for <tt class="docutils literal"><span class="pre">fold=-1</span></tt> -- to match the legacy
behavior -- is not needed.  Either choice of <tt class="docutils literal">fold</tt> will match the
old behavior except in the few cases where the old behavior was
undefined.</p>
</div>
<div class="section" id="strict-invalid-time-checking">
<h3><a class="toc-backref" href="#id61">Strict Invalid Time Checking</a></h3>
<p>Another suggestion was to use <tt class="docutils literal"><span class="pre">fold=-1</span></tt> or <tt class="docutils literal">fold=None</tt> to
indicate that the program truly has no means to deal with the folds
and gaps and <tt class="docutils literal">dt.utcoffset()</tt> should raise an error whenever <tt class="docutils literal">dt</tt>
represents an ambiguous or missing local time.</p>
<p>The main problem with this proposal, is that <tt class="docutils literal">dt.utcoffset()</tt> is
used internally in situations where raising an error is not an option:
for example, in dictionary lookups or list/set membership checks.  So
strict gap/fold checking behavior would need to be controlled by a
separate flag, say <tt class="docutils literal">dt.utcoffset(raise_on_gap=True,
raise_on_fold=False)</tt>.  However, this functionality can be easily
implemented in user code:</p>
<pre class="code literal-block">
def utcoffset(dt, raise_on_gap=True, raise_on_fold=False):
    u = dt.utcoffset()
    v = dt.replace(fold=not dt.fold).utcoffset()
    if u == v:
        return u
    if (u &lt; v) == dt.fold:
        if raise_on_fold:
            raise AmbiguousTimeError
    else:
        if raise_on_gap:
            raise MissingTimeError
    return u
</pre>
<p>Moreover, raising an error in the problem cases is only one of many
possible solutions.  An interactive program can ask the user for
additional input, while a server process may log a warning and take an
appropriate default action.  We cannot possibly provide functions for
all possible user requirements, but this PEP provides the means to
implement any desired behavior in a few lines of code.</p>
</div>
</div>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id62">Implementation</a></h1>
<ul class="simple">
<li>Github fork: <a class="reference external" href="https://github.com/abalkin/cpython/tree/issue24773-s3">https://github.com/abalkin/cpython/tree/issue24773-s3</a></li>
<li>Tracker issue: <a class="reference external" href="http://bugs.python.org/issue24773">http://bugs.python.org/issue24773</a></li>
</ul>
</div>
<div class="section" id="id13">
<h1><a class="toc-backref" href="#id63">References</a></h1>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[7]</a></td><td><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg14/docs/rr/dr_136.html">http://www.open-std.org/jtc1/sc22/wg14/docs/rr/dr_136.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[8]</a></td><td><a class="reference external" href="https://hg.python.org/cpython/file/v3.5.0/Include/datetime.h#l10">https://hg.python.org/cpython/file/v3.5.0/Include/datetime.h#l10</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id19">[9]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2015-April/139099.html">https://mail.python.org/pipermail/python-dev/2015-April/139099.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id21">[10]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/datetime-sig/2015-August/000479.html">https://mail.python.org/pipermail/datetime-sig/2015-August/000479.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id23">[11]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/datetime-sig/2015-August/000483.html">https://mail.python.org/pipermail/datetime-sig/2015-August/000483.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id64">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
</div>
<div class="section" id="picture-credit">
<h1><a class="toc-backref" href="#id65">Picture Credit</a></h1>
<p>This image is a work of a U.S. military or Department of Defense
employee, taken or made as part of that person's official duties. As a
work of the U.S. federal government, the image is in the public
domain.</p>
</div>

