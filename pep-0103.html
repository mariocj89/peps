<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">103</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Collecting information about git</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0103.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Oleg Broytman &lt;phd&#32;&#97;t&#32;phdru.name&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Withdrawn</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Informational</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">01-Jun-2015</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">12-Sep-2015</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#withdrawal" id="id5">Withdrawal</a></li>
<li><a class="reference internal" href="#abstract" id="id6">Abstract</a></li>
<li><a class="reference internal" href="#documentation" id="id7">Documentation</a><ul>
<li><a class="reference internal" href="#documentation-for-starters" id="id8">Documentation for starters</a></li>
<li><a class="reference internal" href="#advanced-documentation" id="id9">Advanced documentation</a></li>
<li><a class="reference internal" href="#offline-documentation" id="id10">Offline documentation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#quick-start" id="id11">Quick start</a><ul>
<li><a class="reference internal" href="#download-and-installation" id="id12">Download and installation</a></li>
<li><a class="reference internal" href="#initial-configuration" id="id13">Initial configuration</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples-in-this-pep" id="id14">Examples in this PEP</a></li>
<li><a class="reference internal" href="#branches-and-branches" id="id15">Branches and branches</a></li>
<li><a class="reference internal" href="#remote-repositories-and-remote-branches" id="id16">Remote repositories and remote branches</a><ul>
<li><a class="reference internal" href="#updating-local-and-remote-tracking-branches" id="id17">Updating local and remote-tracking branches</a><ul>
<li><a class="reference internal" href="#fetch-and-pull" id="id18">Fetch and pull</a></li>
<li><a class="reference internal" href="#push" id="id19">Push</a></li>
<li><a class="reference internal" href="#tags" id="id20">Tags</a></li>
<li><a class="reference internal" href="#private-information" id="id21">Private information</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#commit-editing-and-caveats" id="id22">Commit editing and caveats</a></li>
<li><a class="reference internal" href="#undo" id="id23">Undo</a><ul>
<li><a class="reference internal" href="#git-checkout-restore-file-s-content" id="id24">git checkout: restore file's content</a></li>
<li><a class="reference internal" href="#git-reset-remove-non-pushed-commits" id="id25">git reset: remove (non-pushed) commits</a><ul>
<li><a class="reference internal" href="#unstaging" id="id26">Unstaging</a></li>
</ul>
</li>
<li><a class="reference internal" href="#git-reflog-reference-log" id="id27">git reflog: reference log</a></li>
<li><a class="reference internal" href="#git-revert-revert-a-commit" id="id28">git revert: revert a commit</a></li>
<li><a class="reference internal" href="#one-thing-that-cannot-be-undone" id="id29">One thing that cannot be undone</a></li>
</ul>
</li>
<li><a class="reference internal" href="#merge-or-rebase" id="id30">Merge or rebase?</a></li>
<li><a class="reference internal" href="#null-merges" id="id31">Null-merges</a></li>
<li><a class="reference internal" href="#branching-models" id="id32">Branching models</a></li>
<li><a class="reference internal" href="#advanced-configuration" id="id33">Advanced configuration</a><ul>
<li><a class="reference internal" href="#line-endings" id="id34">Line endings</a></li>
<li><a class="reference internal" href="#useful-assets" id="id35">Useful assets</a></li>
</ul>
</li>
<li><a class="reference internal" href="#advanced-topics" id="id36">Advanced topics</a><ul>
<li><a class="reference internal" href="#staging-area" id="id37">Staging area</a></li>
<li><a class="reference internal" href="#root" id="id38">Root</a></li>
<li><a class="reference internal" href="#rerere" id="id39">ReReRe</a></li>
<li><a class="reference internal" href="#database-maintenance" id="id40">Database maintenance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tips-and-tricks" id="id41">Tips and tricks</a><ul>
<li><a class="reference internal" href="#command-line-options-and-arguments" id="id42">Command-line options and arguments</a></li>
<li><a class="reference internal" href="#bash-zsh-completion" id="id43">bash/zsh completion</a></li>
<li><a class="reference internal" href="#bash-zsh-prompt" id="id44">bash/zsh prompt</a></li>
<li><a class="reference internal" href="#ssh-connection-sharing" id="id45">SSH connection sharing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#git-on-server" id="id46">git on server</a></li>
<li><a class="reference internal" href="#from-mercurial-to-git" id="id47">From Mercurial to git</a></li>
<li><a class="reference internal" href="#git-and-github" id="id48">Git and GitHub</a></li>
<li><a class="reference internal" href="#id2" id="id49">References</a></li>
<li><a class="reference internal" href="#copyright" id="id50">Copyright</a></li>
</ul>
</div>
<div class="section" id="withdrawal">
<h1><a class="toc-backref" href="#id5">Withdrawal</a></h1>
<p>This PEP was withdrawn as it's too generic and doesn't really deals
with Python development. It is no longer updated.</p>
<p>The content was moved to <a class="reference external" href="https://wiki.python.org/moin/Git">Python Wiki</a> <a class="footnote-reference" href="#id3" id="id4">[1]</a>. Make further updates in the
wiki.</p>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id6">Abstract</a></h1>
<p>This Informational PEP collects information about git. There is, of
course, a lot of documentation for git, so the PEP concentrates on
more complex (and more related to Python development) issues,
scenarios and examples.</p>
<p>The plan is to extend the PEP in the future collecting information
about equivalence of Mercurial and git scenarios to help migrating
Python development from Mercurial to git.</p>
<p>The author of the PEP doesn't currently plan to write a Process PEP on
migration Python development from Mercurial to git.</p>
</div>
<div class="section" id="documentation">
<h1><a class="toc-backref" href="#id7">Documentation</a></h1>
<p>Git is accompanied with a lot of documentation, both online and
offline.</p>
<div class="section" id="documentation-for-starters">
<h2><a class="toc-backref" href="#id8">Documentation for starters</a></h2>
<p>Git Tutorial: <a class="reference external" href="https://www.kernel.org/pub/software/scm/git/docs/gittutorial.html">part 1</a>,
<a class="reference external" href="https://www.kernel.org/pub/software/scm/git/docs/gittutorial-2.html">part 2</a>.</p>
<p><a class="reference external" href="https://www.kernel.org/pub/software/scm/git/docs/user-manual.html">Git User's manual</a>.
<a class="reference external" href="https://www.kernel.org/pub/software/scm/git/docs/giteveryday.html">Everyday GIT With 20 Commands Or So</a>.
<a class="reference external" href="https://www.kernel.org/pub/software/scm/git/docs/gitworkflows.html">Git workflows</a>.</p>
</div>
<div class="section" id="advanced-documentation">
<h2><a class="toc-backref" href="#id9">Advanced documentation</a></h2>
<p><a class="reference external" href="http://www-cs-students.stanford.edu/~blynn/gitmagic/index.html">Git Magic</a>,
with a number of translations.</p>
<p><a class="reference external" href="https://git-scm.com/book">Pro Git</a>. The Book about git. Buy it at
Amazon or download in PDF, mobi, or ePub form. It has translations to
many different languages. Download Russian translation from <a class="reference external" href="https://github.com/GArik/progit/wiki">GArik</a>.</p>
<p><a class="reference external" href="https://git.wiki.kernel.org/index.php/Main_Page">Git Wiki</a>.</p>
<p><a class="reference external" href="http://gitbu.ch/index.html">Git Buch</a> (German).</p>
</div>
<div class="section" id="offline-documentation">
<h2><a class="toc-backref" href="#id10">Offline documentation</a></h2>
<p>Git has builtin help: run <tt class="docutils literal">git help $TOPIC</tt>. For example, run
<tt class="docutils literal">git help git</tt> or <tt class="docutils literal">git help help</tt>.</p>
</div>
</div>
<div class="section" id="quick-start">
<h1><a class="toc-backref" href="#id11">Quick start</a></h1>
<div class="section" id="download-and-installation">
<h2><a class="toc-backref" href="#id12">Download and installation</a></h2>
<p>Unix users: <a class="reference external" href="https://git-scm.com/download/linux">download and install using your package manager</a>.</p>
<p>Microsoft Windows: download <a class="reference external" href="https://github.com/git-for-windows/git/releases">git-for-windows</a>.</p>
<p>MacOS X: use git installed with <a class="reference external" href="https://developer.apple.com/xcode/">XCode</a> or download from <a class="reference external" href="https://www.macports.org/ports.php?by=name&amp;substr=git">MacPorts</a> or
<a class="reference external" href="http://sourceforge.net/projects/git-osx-installer/files/">git-osx-installer</a> or
install git with <a class="reference external" href="http://brew.sh/">Homebrew</a>: <tt class="docutils literal">brew install git</tt>.</p>
<p><a class="reference external" href="https://git-cola.github.io/index.html">git-cola</a> (<a class="reference external" href="https://github.com/git-cola/git-cola">repository</a>) is a Git GUI written in
Python and GPL licensed. Linux, Windows, MacOS X.</p>
<p><a class="reference external" href="https://tortoisegit.org/">TortoiseGit</a> is a Windows Shell Interface
to Git based on TortoiseSVN; open source.</p>
</div>
<div class="section" id="initial-configuration">
<h2><a class="toc-backref" href="#id13">Initial configuration</a></h2>
<p>This simple code is often appears in documentation, but it is
important so let repeat it here. Git stores author and committer
names/emails in every commit, so configure your real name and
preferred email:</p>
<pre class="literal-block">
$ git config --global user.name &quot;User Name&quot;
$ git config --global user.email user.name&#64;example.org
</pre>
</div>
</div>
<div class="section" id="examples-in-this-pep">
<h1><a class="toc-backref" href="#id14">Examples in this PEP</a></h1>
<p>Examples of git commands in this PEP use the following approach. It is
supposed that you, the user, works with a local repository named
<tt class="docutils literal">python</tt> that has an upstream remote repo named <tt class="docutils literal">origin</tt>. Your
local repo has two branches <tt class="docutils literal">v1</tt> and <tt class="docutils literal">master</tt>. For most examples
the currently checked out branch is <tt class="docutils literal">master</tt>. That is, it's assumed
you have done something like that:</p>
<pre class="literal-block">
$ git clone https://git.python.org/python.git
$ cd python
$ git branch v1 origin/v1
</pre>
<p>The first command clones remote repository into local directory
<cite>python`</cite>, creates a new local branch master, sets
remotes/origin/master as its upstream remote-tracking branch and
checks it out into the working directory.</p>
<p>The last command creates a new local branch v1 and sets
remotes/origin/v1 as its upstream remote-tracking branch.</p>
<p>The same result can be achieved with commands:</p>
<pre class="literal-block">
$ git clone -b v1 https://git.python.org/python.git
$ cd python
$ git checkout --track origin/master
</pre>
<p>The last command creates a new local branch master, sets
remotes/origin/master as its upstream remote-tracking branch and
checks it out into the working directory.</p>
</div>
<div class="section" id="branches-and-branches">
<h1><a class="toc-backref" href="#id15">Branches and branches</a></h1>
<p>Git terminology can be a bit misleading. Take, for example, the term
&quot;branch&quot;. In git it has two meanings. A branch is a directed line of
commits (possibly with merges). And a branch is a label or a pointer
assigned to a line of commits. It is important to distinguish when you
talk about commits and when about their labels. Lines of commits are
by itself unnamed and are usually only lengthening and merging.
Labels, on the other hand, can be created, moved, renamed and deleted
freely.</p>
</div>
<div class="section" id="remote-repositories-and-remote-branches">
<h1><a class="toc-backref" href="#id16">Remote repositories and remote branches</a></h1>
<p>Remote-tracking branches are branches (pointers to commits) in your
local repository. They are there for git (and for you) to remember
what branches and commits have been pulled from and pushed to what
remote repos (you can pull from and push to many remotes).
Remote-tracking branches live under <tt class="docutils literal"><span class="pre">remotes/$REMOTE</span></tt> namespaces,
e.g. <tt class="docutils literal">remotes/origin/master</tt>.</p>
<p>To see the status of remote-tracking branches run:</p>
<pre class="literal-block">
$ git branch -rv
</pre>
<p>To see local and remote-tracking branches (and tags) pointing to
commits:</p>
<pre class="literal-block">
$ git log --decorate
</pre>
<p>You never do your own development on remote-tracking branches. You
create a local branch that has a remote branch as upstream and do
development on that local branch. On push git pushes commits to the
remote repo and updates remote-tracking branches, on pull git fetches
commits from the remote repo, updates remote-tracking branches and
fast-forwards, merges or rebases local branches.</p>
<p>When you do an initial clone like this:</p>
<pre class="literal-block">
$ git clone -b v1 https://git.python.org/python.git
</pre>
<p>git clones remote repository <tt class="docutils literal"><span class="pre">https://git.python.org/python.git</span></tt> to
directory <tt class="docutils literal">python</tt>, creates a remote named <tt class="docutils literal">origin</tt>, creates
remote-tracking branches, creates a local branch <tt class="docutils literal">v1</tt>, configure it
to track upstream remotes/origin/v1 branch and checks out <tt class="docutils literal">v1</tt> into
the working directory.</p>
<p>Some commands, like <tt class="docutils literal">git status <span class="pre">--branch</span></tt> and <tt class="docutils literal">git branch <span class="pre">--verbose</span></tt>,
report the difference between local and remote branches.
Please remember they only do comparison with remote-tracking branches
in your local repository, and the state of those remote-tracking
branches can be outdated. To update remote-tracking branches you
either fetch and merge (or rebase) commits from the remote repository
or update remote-tracking branches without updating local branches.</p>
<div class="section" id="updating-local-and-remote-tracking-branches">
<h2><a class="toc-backref" href="#id17">Updating local and remote-tracking branches</a></h2>
<p>To update remote-tracking branches without updating local branches run
<tt class="docutils literal">git remote update <span class="pre">[$REMOTE...]</span></tt>. For example:</p>
<pre class="literal-block">
$ git remote update
$ git remote update origin
</pre>
<div class="section" id="fetch-and-pull">
<h3><a class="toc-backref" href="#id18">Fetch and pull</a></h3>
<p>There is a major difference between</p>
<pre class="literal-block">
$ git fetch $REMOTE $BRANCH
</pre>
<p>and</p>
<pre class="literal-block">
$ git fetch $REMOTE $BRANCH:$BRANCH
</pre>
<p>The first command fetches commits from the named $BRANCH in the
$REMOTE repository that are not in your repository, updates
remote-tracking branch and leaves the id (the hash) of the head commit
in file .git/FETCH_HEAD.</p>
<p>The second command fetches commits from the named $BRANCH in the
$REMOTE repository that are not in your repository and updates both
the local branch $BRANCH and its upstream remote-tracking branch. But
it refuses to update branches in case of non-fast-forward. And it
refuses to update the current branch (currently checked out branch,
where HEAD is pointing to).</p>
<p>The first command is used internally by <tt class="docutils literal">git pull</tt>.</p>
<pre class="literal-block">
$ git pull $REMOTE $BRANCH
</pre>
<p>is equivalent to</p>
<pre class="literal-block">
$ git fetch $REMOTE $BRANCH
$ git merge FETCH_HEAD
</pre>
<p>Certainly, $BRANCH in that case should be your current branch. If you
want to merge a different branch into your current branch first update
that non-current branch and then merge:</p>
<pre class="literal-block">
$ git fetch origin v1:v1  # Update v1
$ git pull --rebase origin master  # Update the current branch master
                                   # using rebase instead of merge
$ git merge v1
</pre>
<p>If you have not yet pushed commits on <tt class="docutils literal">v1</tt>, though, the scenario has
to become a bit more complex. Git refuses to update
non-fast-forwardable branch, and you don't want to do force-pull
because that would remove your non-pushed commits and you would need
to recover. So you want to rebase <tt class="docutils literal">v1</tt> but you cannot rebase
non-current branch. Hence, checkout <tt class="docutils literal">v1</tt> and rebase it before
merging:</p>
<pre class="literal-block">
$ git checkout v1
$ git pull --rebase origin v1
$ git checkout master
$ git pull --rebase origin master
$ git merge v1
</pre>
<p>It is possible to configure git to make it fetch/pull a few branches
or all branches at once, so you can simply run</p>
<pre class="literal-block">
$ git pull origin
</pre>
<p>or even</p>
<pre class="literal-block">
$ git pull
</pre>
<p>Default remote repository for fetching/pulling is <tt class="docutils literal">origin</tt>. Default
set of references to fetch is calculated using matching algorithm: git
fetches all branches having the same name on both ends.</p>
</div>
<div class="section" id="push">
<h3><a class="toc-backref" href="#id19">Push</a></h3>
<p>Pushing is a bit simpler. There is only one command <tt class="docutils literal">push</tt>. When you
run</p>
<pre class="literal-block">
$ git push origin v1 master
</pre>
<p>git pushes local v1 to remote v1 and local master to remote master.
The same as:</p>
<pre class="literal-block">
$ git push origin v1:v1 master:master
</pre>
<p>Git pushes commits to the remote repo and updates remote-tracking
branches. Git refuses to push commits that aren't fast-forwardable.
You can force-push anyway, but please remember - you can force-push to
your own repositories but don't force-push to public or shared repos.
If you find git refuses to push commits that aren't fast-forwardable,
better fetch and merge commits from the remote repo (or rebase your
commits on top of the fetched commits), then push. Only force-push if
you know what you do and why you do it. See the section <a class="reference internal" href="#commit-editing-and-caveats">Commit
editing and caveats</a> below.</p>
<p>It is possible to configure git to make it push a few branches or all
branches at once, so you can simply run</p>
<pre class="literal-block">
$ git push origin
</pre>
<p>or even</p>
<pre class="literal-block">
$ git push
</pre>
<p>Default remote repository for pushing is <tt class="docutils literal">origin</tt>. Default set of
references to push in git before 2.0 is calculated using matching
algorithm: git pushes all branches having the same name on both ends.
Default set of references to push in git 2.0+ is calculated using
simple algorithm: git pushes the current branch back to its
&#64;{upstream}.</p>
<p>To configure git before 2.0 to the new behaviour run:</p>
<pre class="literal-block">
$ git config push.default simple
</pre>
<p>To configure git 2.0+ to the old behaviour run:</p>
<pre class="literal-block">
$ git config push.default matching
</pre>
<p>Git doesn't allow to push a branch if it's the current branch in the
remote non-bare repository: git refuses to update remote working
directory. You really should push only to bare repositories. For
non-bare repositories git prefers pull-based workflow.</p>
<p>When you want to deploy code on a remote host and can only use push
(because your workstation is behind a firewall and you cannot pull
from it) you do that in two steps using two repositories: you push
from the workstation to a bare repo on the remote host, ssh to the
remote host and pull from the bare repo to a non-bare deployment repo.</p>
<p>That changed in git 2.3, but see <a class="reference external" href="https://github.com/blog/1957-git-2-3-has-been-released#push-to-deploy">the blog post</a>
for caveats; in 2.4 the push-to-deploy feature was <a class="reference external" href="https://github.com/blog/1994-git-2-4-atomic-pushes-push-to-deploy-and-more#push-to-deploy-improvements">further improved</a>.</p>
</div>
<div class="section" id="tags">
<h3><a class="toc-backref" href="#id20">Tags</a></h3>
<p>Git automatically fetches tags that point to commits being fetched
during fetch/pull. To fetch all tags (and commits they point to) run
<tt class="docutils literal">git fetch <span class="pre">--tags</span> origin</tt>. To fetch some specific tags fetch them
explicitly:</p>
<pre class="literal-block">
$ git fetch origin tag $TAG1 tag $TAG2...
</pre>
<p>For example:</p>
<pre class="literal-block">
$ git fetch origin tag 1.4.2
$ git fetch origin v1:v1 tag 2.1.7
</pre>
<p>Git doesn't automatically pushes tags. That allows you to have private
tags. To push tags list them explicitly:</p>
<pre class="literal-block">
$ git push origin tag 1.4.2
$ git push origin v1 master tag 2.1.7
</pre>
<p>Or push all tags at once:</p>
<pre class="literal-block">
$ git push --tags origin
</pre>
<p>Don't move tags with <tt class="docutils literal">git tag <span class="pre">-f</span></tt> or remove tags with <tt class="docutils literal">git tag <span class="pre">-d</span></tt>
after they have been published.</p>
</div>
<div class="section" id="private-information">
<h3><a class="toc-backref" href="#id21">Private information</a></h3>
<p>When cloning/fetching/pulling/pushing git copies only database objects
(commits, trees, files and tags) and symbolic references (branches and
lightweight tags). Everything else is private to the repository and
never cloned, updated or pushed. It's your config, your hooks, your
private exclude file.</p>
<p>If you want to distribute hooks, copy them to the working tree, add,
commit, push and instruct the team to update and install the hooks
manually.</p>
</div>
</div>
</div>
<div class="section" id="commit-editing-and-caveats">
<h1><a class="toc-backref" href="#id22">Commit editing and caveats</a></h1>
<p>A warning not to edit published (pushed) commits also appears in
documentation but it's repeated here anyway as it's very important.</p>
<p>It is possible to recover from a forced push but it's PITA for the
entire team. Please avoid it.</p>
<p>To see what commits have not been published yet compare the head of the
branch with its upstream remote-tracking branch:</p>
<pre class="literal-block">
$ git log origin/master..  # from origin/master to HEAD (of master)
$ git log origin/v1..v1  # from origin/v1 to the head of v1
</pre>
<p>For every branch that has an upstream remote-tracking branch git
maintains an alias &#64;{upstream} (short version &#64;{u}), so the commands
above can be given as:</p>
<pre class="literal-block">
$ git log &#64;{u}..
$ git log v1&#64;{u}..v1
</pre>
<p>To see the status of all branches:</p>
<pre class="literal-block">
$ git branch -avv
</pre>
<p>To compare the status of local branches with a remote repo:</p>
<pre class="literal-block">
$ git remote show origin
</pre>
<p>Read <a class="reference external" href="https://git-scm.com/docs/git-rebase#_recovering_from_upstream_rebase">how to recover from upstream rebase</a>.
It is in <tt class="docutils literal">git help rebase</tt>.</p>
<p>On the other hand, don't be too afraid about commit editing. You can
safely edit, reorder, remove, combine and split commits that haven't
been pushed yet. You can even push commits to your own (backup) repo,
edit them later and force-push edited commits to replace what have
already been pushed. Not a problem until commits are in a public
or shared repository.</p>
</div>
<div class="section" id="undo">
<h1><a class="toc-backref" href="#id23">Undo</a></h1>
<p>Whatever you do, don't panic. Almost anything in git can be undone.</p>
<div class="section" id="git-checkout-restore-file-s-content">
<h2><a class="toc-backref" href="#id24">git checkout: restore file's content</a></h2>
<p><tt class="docutils literal">git checkout</tt>, for example, can be used to restore the content of
file(s) to that one of a commit. Like this:</p>
<pre class="literal-block">
git checkout HEAD~ README
</pre>
<p>The commands restores the contents of README file to the last but one
commit in the current branch. By default the commit ID is simply HEAD;
i.e. <tt class="docutils literal">git checkout README</tt> restores README to the latest commit.</p>
<p>(Do not use <tt class="docutils literal">git checkout</tt> to view a content of a file in a commit,
use <tt class="docutils literal">git <span class="pre">cat-file</span> <span class="pre">-p</span></tt>; e.g. <tt class="docutils literal">git <span class="pre">cat-file</span> <span class="pre">-p</span> <span class="pre">HEAD~:path/to/README</span></tt>).</p>
</div>
<div class="section" id="git-reset-remove-non-pushed-commits">
<h2><a class="toc-backref" href="#id25">git reset: remove (non-pushed) commits</a></h2>
<p><tt class="docutils literal">git reset</tt> moves the head of the current branch. The head can be
moved to point to any commit but it's often used to remove a commit or
a few (preferably, non-pushed ones) from the top of the branch - that
is, to move the branch backward in order to undo a few (non-pushed)
commits.</p>
<p><tt class="docutils literal">git reset</tt> has three modes of operation - soft, hard and mixed.
Default is mixed. ProGit <a class="reference external" href="https://git-scm.com/book/en/Git-Tools-Reset-Demystified">explains</a> the
difference very clearly. Bare repositories don't have indices or
working trees so in a bare repo only soft reset is possible.</p>
<div class="section" id="unstaging">
<h3><a class="toc-backref" href="#id26">Unstaging</a></h3>
<p>Mixed mode reset with a path or paths can be used to unstage changes -
that is, to remove from index changes added with <tt class="docutils literal">git add</tt> for
committing. See <a class="reference external" href="https://git-scm.com/book/en/Git-Basics-Undoing-Things">The Book</a> for details
about unstaging and other undo tricks.</p>
</div>
</div>
<div class="section" id="git-reflog-reference-log">
<h2><a class="toc-backref" href="#id27">git reflog: reference log</a></h2>
<p>Removing commits with <tt class="docutils literal">git reset</tt> or moving the head of a branch
sounds dangerous and it is. But there is a way to undo: another
reset back to the original commit. Git doesn't remove commits
immediately; unreferenced commits (in git terminology they are called
&quot;dangling commits&quot;) stay in the database for some time (default is two
weeks) so you can reset back to it or create a new branch pointing to
the original commit.</p>
<p>For every move of a branch's head - with <tt class="docutils literal">git commit</tt>, <tt class="docutils literal">git
checkout</tt>, <tt class="docutils literal">git fetch</tt>, <tt class="docutils literal">git pull</tt>, <tt class="docutils literal">git rebase</tt>, <tt class="docutils literal">git reset</tt>
and so on - git stores a reference log (reflog for short). For every
move git stores where the head was. Command <tt class="docutils literal">git reflog</tt> can be used
to view (and manipulate) the log.</p>
<p>In addition to the moves of the head of every branch git stores the
moves of the HEAD - a symbolic reference that (usually) names the
current branch. HEAD is changed with <tt class="docutils literal">git checkout $BRANCH</tt>.</p>
<p>By default <tt class="docutils literal">git reflog</tt> shows the moves of the HEAD, i.e. the
command is equivalent to <tt class="docutils literal">git reflog HEAD</tt>. To show the moves of the
head of a branch use the command <tt class="docutils literal">git reflog $BRANCH</tt>.</p>
<p>So to undo a <tt class="docutils literal">git reset</tt> lookup the original commit in <tt class="docutils literal">git
reflog</tt>, verify it with <tt class="docutils literal">git show</tt> or <tt class="docutils literal">git log</tt> and run <tt class="docutils literal">git
reset $COMMIT_ID</tt>. Git stores the move of the branch's head in
reflog, so you can undo that undo later again.</p>
<p>In a more complex situation you'd want to move some commits along with
resetting the head of the branch. Cherry-pick them to the new branch.
For example, if you want to reset the branch <tt class="docutils literal">master</tt> back to the
original commit but preserve two commits created in the current branch
do something like:</p>
<pre class="literal-block">
$ git branch save-master  # create a new branch saving master
$ git reflog  # find the original place of master
$ git reset $COMMIT_ID
$ git cherry-pick save-master~ save-master
$ git branch -D save-master  # remove temporary branch
</pre>
</div>
<div class="section" id="git-revert-revert-a-commit">
<h2><a class="toc-backref" href="#id28">git revert: revert a commit</a></h2>
<p><tt class="docutils literal">git revert</tt> reverts a commit or commits, that is, it creates a new
commit or commits that revert(s) the effects of the given commits.
It's the only way to undo published commits (<tt class="docutils literal">git commit <span class="pre">--amend</span></tt>,
<tt class="docutils literal">git rebase</tt> and <tt class="docutils literal">git reset</tt> change the branch in
non-fast-forwardable ways so they should only be used for non-pushed
commits.)</p>
<p>There is a problem with reverting a merge commit. <tt class="docutils literal">git revert</tt> can
undo the code created by the merge commit but it cannot undo the fact
of merge. See the discussion <a class="reference external" href="https://www.kernel.org/pub/software/scm/git/docs/howto/revert-a-faulty-merge.html">How to revert a faulty merge</a>.</p>
</div>
<div class="section" id="one-thing-that-cannot-be-undone">
<h2><a class="toc-backref" href="#id29">One thing that cannot be undone</a></h2>
<p>Whatever you undo, there is one thing that cannot be undone -
overwritten uncommitted changes. Uncommitted changes don't belong to
git so git cannot help preserving them.</p>
<p>Most of the time git warns you when you're going to execute a command
that overwrites uncommitted changes. Git doesn't allow you to switch
branches with <tt class="docutils literal">git checkout</tt>. It stops you when you're going to
rebase with non-clean working tree. It refuses to pull new commits
over non-committed files.</p>
<p>But there are commands that do exactly that - overwrite files in the
working tree. Commands like <tt class="docutils literal">git checkout $PATHs</tt> or <tt class="docutils literal">git reset
<span class="pre">--hard</span></tt> silently overwrite files including your uncommitted changes.</p>
<p>With that in mind you can understand the stance &quot;commit early, commit
often&quot;. Commit as often as possible. Commit on every save in your
editor or IDE. You can edit your commits before pushing - edit commit
messages, change commits, reorder, combine, split, remove. But save
your changes in git database, either commit changes or at least stash
them with <tt class="docutils literal">git stash</tt>.</p>
</div>
</div>
<div class="section" id="merge-or-rebase">
<h1><a class="toc-backref" href="#id30">Merge or rebase?</a></h1>
<p>Internet is full of heated discussions on the topic: &quot;merge or
rebase?&quot; Most of them are meaningless. When a DVCS is being used in a
big team with a big and complex project with many branches there is
simply no way to avoid merges. So the question's diminished to
&quot;whether to use rebase, and if yes - when to use rebase?&quot; Considering
that it is very much recommended not to rebase published commits the
question's diminished even further: &quot;whether to use rebase on
non-pushed commits?&quot;</p>
<p>That small question is for the team to decide. To preserve the beauty
of linear history it's recommended to use rebase when pulling, i.e. do
<tt class="docutils literal">git pull <span class="pre">--rebase</span></tt> or even configure automatic setup of rebase for
every new branch:</p>
<pre class="literal-block">
$ git config branch.autosetuprebase always
</pre>
<p>and configure rebase for existing branches:</p>
<pre class="literal-block">
$ git config branch.$NAME.rebase true
</pre>
<p>For example:</p>
<pre class="literal-block">
$ git config branch.v1.rebase true
$ git config branch.master.rebase true
</pre>
<p>After that <tt class="docutils literal">git pull origin master</tt> becomes equivalent to <tt class="docutils literal">git pull
<span class="pre">--rebase</span> origin master</tt>.</p>
<p>It is recommended to create new commits in a separate feature or topic
branch while using rebase to update the mainline branch. When the
topic branch is ready merge it into mainline. To avoid a tedious task
of resolving large number of conflicts at once you can merge the topic
branch to the mainline from time to time and switch back to the topic
branch to continue working on it. The entire workflow would be
something like:</p>
<pre class="literal-block">
$ git checkout -b issue-42  # create a new issue branch and switch to it
    ...edit/test/commit...
$ git checkout master
$ git pull --rebase origin master  # update master from the upstream
$ git merge issue-42
$ git branch -d issue-42  # delete the topic branch
$ git push origin master
</pre>
<p>When the topic branch is deleted only the label is removed, commits
are stayed in the database, they are now merged into master:</p>
<pre class="literal-block">
o--o--o--o--o--M--&lt; master - the mainline branch
    \         /
     --*--*--*             - the topic branch, now unnamed
</pre>
<p>The topic branch is deleted to avoid cluttering branch namespace with
small topic branches. Information on what issue was fixed or what
feature was implemented should be in the commit messages.</p>
<p>But even that small amount of rebasing could be too big in case of
long-lived merged branches. Imagine you're doing work in both <tt class="docutils literal">v1</tt>
and <tt class="docutils literal">master</tt> branches, regularly merging <tt class="docutils literal">v1</tt> into <tt class="docutils literal">master</tt>.
After some time you will have a lot of merge and non-merge commits in
<tt class="docutils literal">master</tt>. Then you want to push your finished work to a shared
repository and find someone has pushed a few commits to <tt class="docutils literal">v1</tt>. Now
you have a choice of two equally bad alternatives: either you fetch
and rebase <tt class="docutils literal">v1</tt> and then have to recreate all you work in <tt class="docutils literal">master</tt>
(reset <tt class="docutils literal">master</tt> to the origin, merge <tt class="docutils literal">v1</tt> and cherry-pick all
non-merge commits from the old master); or merge the new <tt class="docutils literal">v1</tt> and
loose the beauty of linear history.</p>
</div>
<div class="section" id="null-merges">
<h1><a class="toc-backref" href="#id31">Null-merges</a></h1>
<p>Git has a builtin merge strategy for what Python core developers call
&quot;null-merge&quot;:</p>
<pre class="literal-block">
$ git merge -s ours v1  # null-merge v1 into master
</pre>
</div>
<div class="section" id="branching-models">
<h1><a class="toc-backref" href="#id32">Branching models</a></h1>
<p>Git doesn't assume any particular development model regarding
branching and merging. Some projects prefer to graduate patches from
the oldest branch to the newest, some prefer to cherry-pick commits
backwards, some use squashing (combining a number of commits into
one). Anything is possible.</p>
<p>There are a few examples to start with. <a class="reference external" href="https://www.kernel.org/pub/software/scm/git/docs/gitworkflows.html">git help workflows</a>
describes how the very git authors develop git.</p>
<p>ProGit book has a few chapters devoted to branch management in
different projects: <a class="reference external" href="https://git-scm.com/book/en/Git-Branching-Branching-Workflows">Git Branching - Branching Workflows</a> and
<a class="reference external" href="https://git-scm.com/book/en/Distributed-Git-Contributing-to-a-Project">Distributed Git - Contributing to a Project</a>.</p>
<p>There is also a well-known article <a class="reference external" href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a> by Vincent
Driessen. It recommends a set of very detailed rules on creating and
managing mainline, topic and bugfix branches. To support the model the
author implemented <a class="reference external" href="https://github.com/nvie/gitflow">git flow</a>
extension.</p>
</div>
<div class="section" id="advanced-configuration">
<h1><a class="toc-backref" href="#id33">Advanced configuration</a></h1>
<div class="section" id="line-endings">
<h2><a class="toc-backref" href="#id34">Line endings</a></h2>
<p>Git has builtin mechanisms to handle line endings between platforms
with different end-of-line styles. To allow git to do CRLF conversion
assign <tt class="docutils literal">text</tt> attribute to files using <a class="reference external" href="https://www.kernel.org/pub/software/scm/git/docs/gitattributes.html">.gitattributes</a>.
For files that have to have specific line endings assign <tt class="docutils literal">eol</tt>
attribute. For binary files the attribute is, naturally, <tt class="docutils literal">binary</tt>.</p>
<p>For example:</p>
<pre class="literal-block">
$ cat .gitattributes
*.py text
*.txt text
*.png binary
/readme.txt eol=CRLF
</pre>
<p>To check what attributes git uses for files use <tt class="docutils literal">git <span class="pre">check-attr</span></tt>
command. For example:</p>
<pre class="literal-block">
$ git check-attr -a -- \*.py
</pre>
</div>
<div class="section" id="useful-assets">
<h2><a class="toc-backref" href="#id35">Useful assets</a></h2>
<p><a class="reference external" href="http://gitalias.com/">GitAlias</a> (<a class="reference external" href="https://github.com/GitAlias/gitalias">repository</a>) is a big collection of
aliases. A careful selection of aliases for frequently used commands
could save you a lot of keystrokes!</p>
<p><a class="reference external" href="https://www.gitignore.io/">GitIgnore</a> and
<a class="reference external" href="https://github.com/github/gitignore">https://github.com/github/gitignore</a> are collections of <tt class="docutils literal">.gitignore</tt>
files for all kinds of IDEs and programming languages. Python
included!</p>
<p><a class="reference external" href="http://pre-commit.com/">pre-commit</a> (<a class="reference external" href="https://github.com/pre-commit">repositories</a>) is a framework for managing and
maintaining multi-language pre-commit hooks. The framework is written
in Python and has a lot of plugins for many programming languages.</p>
</div>
</div>
<div class="section" id="advanced-topics">
<h1><a class="toc-backref" href="#id36">Advanced topics</a></h1>
<div class="section" id="staging-area">
<h2><a class="toc-backref" href="#id37">Staging area</a></h2>
<p>Staging area aka index aka cache is a distinguishing feature of git.
Staging area is where git collects patches before committing them.
Separation between collecting patches and commit phases provides a
very useful feature of git: you can review collected patches before
commit and even edit them - remove some hunks, add new hunks and
review again.</p>
<p>To add files to the index use <tt class="docutils literal">git add</tt>. Collecting patches before
committing means you need to do that for every change, not only to add
new (untracked) files. To simplify committing in case you just want to
commit everything without reviewing run <tt class="docutils literal">git commit <span class="pre">--all</span></tt> (or just
<tt class="docutils literal"><span class="pre">-a</span></tt>) - the command adds every changed tracked file to the index and
then commit. To commit a file or files regardless of patches collected
in the index run <tt class="docutils literal">git commit <span class="pre">[--only|-o]</span> <span class="pre">--</span> <span class="pre">$FILE...</span></tt>.</p>
<p>To add hunks of patches to the index use <tt class="docutils literal">git add <span class="pre">--patch</span></tt> (or just
<tt class="docutils literal"><span class="pre">-p</span></tt>). To remove collected files from the index use <tt class="docutils literal">git reset HEAD
<span class="pre">--</span> <span class="pre">$FILE...</span></tt> To add/inspect/remove collected hunks use <tt class="docutils literal">git add
<span class="pre">--interactive</span></tt> (<tt class="docutils literal"><span class="pre">-i</span></tt>).</p>
<p>To see the diff between the index and the last commit (i.e., collected
patches) use <tt class="docutils literal">git diff <span class="pre">--cached</span></tt>. To see the diff between the
working tree and the index (i.e., uncollected patches) use just <tt class="docutils literal">git
diff</tt>. To see the diff between the working tree and the last commit
(i.e., both collected and uncollected patches) run <tt class="docutils literal">git diff HEAD</tt>.</p>
<p>See <a class="reference external" href="https://git.wiki.kernel.org/index.php/WhatIsTheIndex">WhatIsTheIndex</a> and
<a class="reference external" href="https://git.wiki.kernel.org/index.php/IndexCommandQuickref">IndexCommandQuickref</a> in Git
Wiki.</p>
</div>
<div class="section" id="root">
<h2><a class="toc-backref" href="#id38">Root</a></h2>
<p>Git switches to the root (top-level directory of the project where
<tt class="docutils literal">.git</tt> subdirectory exists) before running any command. Git
remembers though the directory that was current before the switch.
Some programs take into account the current directory. E.g., <tt class="docutils literal">git
status</tt> shows file paths of changed and unknown files relative to the
current directory; <tt class="docutils literal">git grep</tt> searches below the current directory;
<tt class="docutils literal">git apply</tt> applies only those hunks from the patch that touch files
below the current directory.</p>
<p>But most commands run from the root and ignore the current directory.
Imagine, for example, that you have two work trees, one for the branch
<tt class="docutils literal">v1</tt> and the other for <tt class="docutils literal">master</tt>. If you want to merge <tt class="docutils literal">v1</tt> from
a subdirectory inside the second work tree you must write commands as
if you're in the top-level dir. Let take two work trees,
<tt class="docutils literal"><span class="pre">project-v1</span></tt> and <tt class="docutils literal">project</tt>, for example:</p>
<pre class="literal-block">
$ cd project/subdirectory
$ git fetch ../project-v1 v1:v1
$ git merge v1
</pre>
<p>Please note the path in <tt class="docutils literal">git fetch <span class="pre">../project-v1</span> v1:v1</tt> is
<tt class="docutils literal"><span class="pre">../project-v1</span></tt> and not <tt class="docutils literal"><span class="pre">../../project-v1</span></tt> despite the fact that
we run the commands from a subdirectory, not from the root.</p>
</div>
<div class="section" id="rerere">
<h2><a class="toc-backref" href="#id39">ReReRe</a></h2>
<p>Rerere is a mechanism that helps to resolve repeated merge conflicts.
The most frequent source of recurring merge conflicts are topic
branches that are merged into mainline and then the merge commits are
removed; that's often performed to test the topic branches and train
rerere; merge commits are removed to have clean linear history and
finish the topic branch with only one last merge commit.</p>
<p>Rerere works by remembering the states of tree before and after a
successful commit. That way rerere can automatically resolve conflicts
if they appear in the same files.</p>
<p>Rerere can be used manually with <tt class="docutils literal">git rerere</tt> command but most often
it's used automatically. Enable rerere with these commands in a
working tree:</p>
<pre class="literal-block">
$ git config rerere.enabled true
$ git config rerere.autoupdate true
</pre>
<p>You don't need to turn rerere on globally - you don't want rerere in
bare repositories or single-branch repositories; you only need rerere
in repos where you often perform merges and resolve merge conflicts.</p>
<p>See <a class="reference external" href="https://git-scm.com/book/en/Git-Tools-Rerere">Rerere</a> in The
Book.</p>
</div>
<div class="section" id="database-maintenance">
<h2><a class="toc-backref" href="#id40">Database maintenance</a></h2>
<p>Git object database and other files/directories under <tt class="docutils literal">.git</tt> require
periodic maintenance and cleanup. For example, commit editing left
unreferenced objects (dangling objects, in git terminology) and these
objects should be pruned to avoid collecting cruft in the DB. The
command <tt class="docutils literal">git gc</tt> is used for maintenance. Git automatically runs
<tt class="docutils literal">git gc <span class="pre">--auto</span></tt> as a part of some commands to do quick maintenance.
Users are recommended to run <tt class="docutils literal">git gc <span class="pre">--aggressive</span></tt> from time to
time; <tt class="docutils literal">git help gc</tt> recommends to run it  every few hundred
changesets; for more intensive projects it should be something like
once a week and less frequently (biweekly or monthly) for lesser
active projects.</p>
<p><tt class="docutils literal">git gc <span class="pre">--aggressive</span></tt> not only removes dangling objects, it also
repacks object database into indexed and better optimized pack(s); it
also packs symbolic references (branches and tags). Another way to do
it is to run <tt class="docutils literal">git repack</tt>.</p>
<p>There is a well-known <a class="reference external" href="https://gcc.gnu.org/ml/gcc/2007-12/msg00165.html">message</a> from Linus
Torvalds regarding &quot;stupidity&quot; of <tt class="docutils literal">git gc <span class="pre">--aggressive</span></tt>. The message
can safely be ignored now. It is old and outdated, <tt class="docutils literal">git gc
<span class="pre">--aggressive</span></tt> became much better since that time.</p>
<p>For those who still prefer <tt class="docutils literal">git repack</tt> over <tt class="docutils literal">git gc <span class="pre">--aggressive</span></tt>
the recommended parameters are <tt class="docutils literal">git repack <span class="pre">-a</span> <span class="pre">-d</span> <span class="pre">-f</span> <span class="pre">--depth=20</span>
<span class="pre">--window=250</span></tt>. See <a class="reference external" href="http://vcscompare.blogspot.ru/2008/06/git-repack-parameters.html">this detailed experiment</a>
for explanation of the effects of these parameters.</p>
<p>From time to time run <tt class="docutils literal">git fsck <span class="pre">[--strict]</span></tt> to verify integrity of
the database. <tt class="docutils literal">git fsck</tt> may produce a list of dangling objects;
that's not an error, just a reminder to perform regular maintenance.</p>
</div>
</div>
<div class="section" id="tips-and-tricks">
<h1><a class="toc-backref" href="#id41">Tips and tricks</a></h1>
<div class="section" id="command-line-options-and-arguments">
<h2><a class="toc-backref" href="#id42">Command-line options and arguments</a></h2>
<p><a class="reference external" href="https://www.kernel.org/pub/software/scm/git/docs/gitcli.html">git help cli</a>
recommends not to combine short options/flags. Most of the times
combining works: <tt class="docutils literal">git commit <span class="pre">-av</span></tt> works perfectly, but there are
situations when it doesn't. E.g., <tt class="docutils literal">git log <span class="pre">-p</span> <span class="pre">-5</span></tt> cannot be combined
as <tt class="docutils literal">git log <span class="pre">-p5</span></tt>.</p>
<p>Some options have arguments, some even have default arguments. In that
case the argument for such option must be spelled in a sticky way:
<tt class="docutils literal"><span class="pre">-Oarg</span></tt>, never <tt class="docutils literal"><span class="pre">-O</span> arg</tt> because for an option that has a default
argument the latter means &quot;use default value for option <tt class="docutils literal"><span class="pre">-O</span></tt> and
pass <tt class="docutils literal">arg</tt> further to the option parser&quot;. For example, <tt class="docutils literal">git grep</tt>
has an option <tt class="docutils literal"><span class="pre">-O</span></tt> that passes a list of names of the found files to
a program; default program for <tt class="docutils literal"><span class="pre">-O</span></tt> is a pager (usually <tt class="docutils literal">less</tt>),
but you can use your editor:</p>
<pre class="literal-block">
$ git grep -Ovim  # but not -O vim
</pre>
<p>BTW, if git is instructed to use <tt class="docutils literal">less</tt> as the pager (i.e., if pager
is not configured in git at all it uses <tt class="docutils literal">less</tt> by default, or if it
gets <tt class="docutils literal">less</tt> from GIT_PAGER or PAGER environment variables, or if it
was configured with <tt class="docutils literal">git config <span class="pre">[--global]</span> core.pager less</tt>, or
<tt class="docutils literal">less</tt> is used in the command <tt class="docutils literal">git grep <span class="pre">-Oless</span></tt>) <tt class="docutils literal">git grep</tt>
passes <tt class="docutils literal"><span class="pre">+/$pattern</span></tt> option to <tt class="docutils literal">less</tt> which is quite convenient.
Unfortunately, <tt class="docutils literal">git grep</tt> doesn't pass the pattern if the pager is
not exactly <tt class="docutils literal">less</tt>, even if it's <tt class="docutils literal">less</tt> with parameters (something
like <tt class="docutils literal">git config <span class="pre">[--global]</span> core.pager less <span class="pre">-FRSXgimq</span></tt>); fortunately,
<tt class="docutils literal">git grep <span class="pre">-Oless</span></tt> always passes the pattern.</p>
</div>
<div class="section" id="bash-zsh-completion">
<h2><a class="toc-backref" href="#id43">bash/zsh completion</a></h2>
<p>It's a bit hard to type <tt class="docutils literal">git rebase <span class="pre">--interactive</span> <span class="pre">--preserve-merges</span>
HEAD~5</tt> manually even for those who are happy to use command-line,
and this is where shell completion is of great help. Bash/zsh come
with programmable completion, often automatically installed and
enabled, so if you have bash/zsh and git installed, chances are you
are already done - just go and use it at the command-line.</p>
<p>If you don't have necessary bits installed, install and enable
bash_completion package. If you want to upgrade your git completion to
the latest and greatest download necessary file from <a class="reference external" href="https://git.kernel.org/cgit/git/git.git/tree/contrib/completion">git contrib</a>.</p>
<p>Git-for-windows comes with git-bash for which bash completion is
installed and enabled.</p>
</div>
<div class="section" id="bash-zsh-prompt">
<h2><a class="toc-backref" href="#id44">bash/zsh prompt</a></h2>
<p>For command-line lovers shell prompt can carry a lot of useful
information. To include git information in the prompt use
<a class="reference external" href="https://git.kernel.org/cgit/git/git.git/tree/contrib/completion/git-prompt.sh">git-prompt.sh</a>.
Read the detailed instructions in the file.</p>
<p>Search the Net for &quot;git prompt&quot; to find other prompt variants.</p>
</div>
<div class="section" id="ssh-connection-sharing">
<h2><a class="toc-backref" href="#id45">SSH connection sharing</a></h2>
<p>SSH connection sharing is a feature of OpenSSH and perhaps derivatives
like PuTTY. SSH connection sharing is a way to decrease ssh client
startup time by establishing one connection and reusing it for all
subsequent clients connecting to the same server. SSH connection
sharing can be used to speedup a lot of short ssh sessions like scp,
sftp, rsync and of course git over ssh. If you regularly
fetch/pull/push from/to remote repositories accessible over ssh then
using ssh connection sharing is recommended.</p>
<p>To turn on ssh connection sharing add something like this to your
~/.ssh/config:</p>
<pre class="literal-block">
Host *
ControlMaster auto
ControlPath ~/.ssh/mux-%r&#64;%h:%p
ControlPersist 600
</pre>
<p>See <a class="reference external" href="https://en.wikibooks.org/wiki/OpenSSH/Cookbook/Multiplexing">OpenSSH wikibook</a> and
<a class="reference external" href="https://www.google.com/search?q=ssh+connection+sharing">search</a> for
more information.</p>
<p>SSH connection sharing can be used at GitHub, GitLab and SourceForge
repositories, but please be advised that BitBucket doesn't allow it
and forcibly closes master connection after a short inactivity period
so you will see errors like this from ssh: &quot;Connection to bitbucket.org
closed by remote host.&quot;</p>
</div>
</div>
<div class="section" id="git-on-server">
<h1><a class="toc-backref" href="#id46">git on server</a></h1>
<p>The simplest way to publish a repository or a group of repositories is
<tt class="docutils literal">git daemon</tt>. The daemon provides anonymous access, by default it is
read-only. The repositories are accessible by git protocol (git://
URLs). Write access can be enabled but the protocol lacks any
authentication means, so it should be enabled only within a trusted
LAN. See <tt class="docutils literal">git help daemon</tt> for details.</p>
<p>Git over ssh provides authentication and repo-level authorisation as
repositories can be made user- or group-writeable (see parameter
<tt class="docutils literal">core.sharedRepository</tt> in <tt class="docutils literal">git help config</tt>). If that's too
permissive or too restrictive for some project's needs there is a
wrapper <a class="reference external" href="http://gitolite.com/gitolite/index.html">gitolite</a> that can
be configured to allow access with great granularity; gitolite is
written in Perl and has a lot of documentation.</p>
<p>Web interface to browse repositories can be created using <a class="reference external" href="https://git.kernel.org/cgit/git/git.git/tree/gitweb">gitweb</a> or <a class="reference external" href="http://git.zx2c4.com/cgit/about/">cgit</a>. Both are CGI scripts (written in
Perl and C). In addition to web interface both provide read-only dumb
http access for git (http(s):// URLs). <a class="reference external" href="https://pypi.python.org/pypi/klaus">Klaus</a> is a small and simple WSGI web
server that implements both web interface and git smart HTTP
transport; supports Python 2 and Python 3, performs syntax
highlighting.</p>
<p>There are also more advanced web-based development environments that
include ability to manage users, groups and projects; private,
group-accessible and public repositories; they often include issue
trackers, wiki pages, pull requests and other tools for development
and communication. Among these environments are <a class="reference external" href="https://kallithea-scm.org/">Kallithea</a> and <a class="reference external" href="https://pagure.io/">pagure</a>,
both are written in Python; pagure was written by Fedora developers
and is being used to develop some Fedora projects. <a class="reference external" href="http://gitprep.yukikimoto.com/">GitPrep</a> is yet another GitHub clone,
written in Perl. <a class="reference external" href="https://gogs.io/">Gogs</a> is written in Go.
<a class="reference external" href="https://gitbucket.github.io/gitbucket-news/about/">GitBucket</a> is
written in Scala.</p>
<p>And last but not least, <a class="reference external" href="https://about.gitlab.com/">GitLab</a>. It's
perhaps the most advanced web-based development environment for git.
Written in Ruby, community edition is free and open source (MIT
license).</p>
</div>
<div class="section" id="from-mercurial-to-git">
<h1><a class="toc-backref" href="#id47">From Mercurial to git</a></h1>
<p>There are many tools to convert Mercurial repositories to git. The
most famous are, probably, <a class="reference external" href="https://hg-git.github.io/">hg-git</a> and
<a class="reference external" href="http://repo.or.cz/w/fast-export.git">fast-export</a> (many years ago
it was known under the name <tt class="docutils literal">hg2git</tt>).</p>
<p>But a better tool, perhaps the best, is <a class="reference external" href="https://github.com/felipec/git-remote-hg">git-remote-hg</a>. It provides transparent
bidirectional (pull and push) access to Mercurial repositories from
git. Its author wrote a <a class="reference external" href="https://github.com/felipec/git/wiki/Comparison-of-git-remote-hg-alternatives">comparison of alternatives</a>
that seems to be mostly objective.</p>
<p>To use git-remote-hg, install or clone it, add to your PATH (or copy
script <tt class="docutils literal"><span class="pre">git-remote-hg</span></tt> to a directory that's already in PATH) and
prepend <tt class="docutils literal">hg::</tt> to Mercurial URLs. For example:</p>
<pre class="literal-block">
$ git clone https://github.com/felipec/git-remote-hg.git
$ PATH=$PATH:&quot;`pwd`&quot;/git-remote-hg
$ git clone hg::https://hg.python.org/peps/ PEPs
</pre>
<p>To work with the repository just use regular git commands including
<tt class="docutils literal">git fetch/pull/push</tt>.</p>
<p>To start converting your Mercurial habits to git see the page
<a class="reference external" href="https://www.mercurial-scm.org/wiki/GitConcepts">Mercurial for Git users</a> at Mercurial wiki.
At the second half of the page there is a table that lists
corresponding Mercurial and git commands. Should work perfectly in
both directions.</p>
<p>Python Developer's Guide also has a chapter <a class="reference external" href="https://docs.python.org/devguide/gitdevs.html">Mercurial for git
developers</a> that
documents a few differences between git and hg.</p>
</div>
<div class="section" id="git-and-github">
<h1><a class="toc-backref" href="#id48">Git and GitHub</a></h1>
<p><a class="reference external" href="https://github.com/donnemartin/gitsome">gitsome</a> - Git/GitHub
command line interface (CLI). Written in Python, work on MacOS, Unix,
Windows. Git/GitHub CLI with autocomplete, includes many GitHub
integrated commands that work with all shells, builtin xonsh with
Python REPL to run Python commands alongside shell commands, command
history, customizable highlighting, thoroughly documented.</p>
</div>
<div class="section" id="id2">
<h1><a class="toc-backref" href="#id49">References</a></h1>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[1]</a></td><td><a class="reference external" href="https://wiki.python.org/moin/Git">https://wiki.python.org/moin/Git</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id50">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End:
vim: set fenc=us-ascii tw=70 : -->
</div>

