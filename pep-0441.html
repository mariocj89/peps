<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">441</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Improving Python ZIP Application Support</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0441.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Daniel Holth &lt;dholth&#32;&#97;t&#32;gmail.com&gt;,
Paul Moore &lt;p.f.moore&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Discussions-To:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2015-February/138277.html">https://mail.python.org/pipermail/python-dev/2015-February/138277.html</a></td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">30 March 2013</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">30 March 2013, 1 April 2013, 16 February 2015</td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2015-February/138578.html">https://mail.python.org/pipermail/python-dev/2015-February/138578.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#improving-python-zip-application-support" id="id13">Improving Python ZIP Application Support</a></li>
<li><a class="reference internal" href="#a-new-python-zip-application-extension" id="id14">A New Python ZIP Application Extension</a></li>
<li><a class="reference internal" href="#minimal-tooling-the-zipapp-module" id="id15">Minimal Tooling: The zipapp Module</a><ul>
<li><a class="reference internal" href="#module-interface" id="id16">Module Interface</a><ul>
<li><a class="reference internal" href="#create-archive-source-target-none-interpreter-none-main-none" id="id17"><tt class="docutils literal">create_archive(source, target=None, interpreter=None, main=None)</tt></a></li>
<li><a class="reference internal" href="#get-interpreter-archive" id="id18"><tt class="docutils literal">get_interpreter(archive)</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#command-line-usage" id="id19">Command Line Usage</a></li>
<li><a class="reference internal" href="#faq" id="id20">FAQ</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rejected-proposals" id="id21">Rejected Proposals</a><ul>
<li><a class="reference internal" href="#convenience-values-for-shebang-lines" id="id22">Convenience Values for Shebang Lines</a></li>
<li><a class="reference internal" href="#registering-pyz-as-a-media-type" id="id23">Registering <tt class="docutils literal">.pyz</tt> as a Media Type</a></li>
<li><a class="reference internal" href="#default-interpreter" id="id24">Default Interpreter</a></li>
<li><a class="reference internal" href="#command-line-tool-to-manage-shebang-lines" id="id25">Command Line Tool to Manage Shebang Lines</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference-implementation" id="id26">Reference Implementation</a></li>
<li><a class="reference internal" href="#references" id="id27">References</a></li>
<li><a class="reference internal" href="#copyright" id="id28">Copyright</a></li>
</ul>
</div>
<div class="section" id="improving-python-zip-application-support">
<h1><a class="toc-backref" href="#id13">Improving Python ZIP Application Support</a></h1>
<p>Python has had the ability to execute directories or ZIP-format
archives as scripts since version 2.6 <a class="footnote-reference" href="#id7" id="id1">[1]</a>.  When invoked with a zip
file or directory as its first argument the interpreter adds that
directory to sys.path and executes the <tt class="docutils literal">__main__</tt> module.  These
archives provide a great way to publish software that needs to be
distributed as a single file script but is complex enough to need to
be written as a collection of modules.</p>
<p>This feature is not as popular as it should be mainly because it was
not promoted as part of Python 2.6 <a class="footnote-reference" href="#id8" id="id2">[2]</a>, so that it is relatively
unknown, but also because the Windows installer does not register a
file extension (other than <tt class="docutils literal">.py</tt>) for this format of file, to associate
with the launcher.</p>
<p>This PEP proposes to fix these problems by re-publicising the feature,
defining the <tt class="docutils literal">.pyz</tt> and <tt class="docutils literal">.pyzw</tt> extensions as &quot;Python ZIP Applications&quot;
and &quot;Windowed Python ZIP Applications&quot;, and providing some simple
tooling to manage the format.</p>
</div>
<div class="section" id="a-new-python-zip-application-extension">
<h1><a class="toc-backref" href="#id14">A New Python ZIP Application Extension</a></h1>
<p>The terminology &quot;Python Zip Application&quot; will be the formal term used
for a zip-format archive that contains Python code in a form that can
be directly executed by Python (specifically, it must have a
<tt class="docutils literal">__main__.py</tt> file in the root directory of the archive).  The
extension <tt class="docutils literal">.pyz</tt> will be formally associated with such files.</p>
<p>The Python 3.5 installer will associate <tt class="docutils literal">.pyz</tt> and <tt class="docutils literal">.pyzw</tt> &quot;Python
Zip Applications&quot; with the platform launcher so they can be executed.
A <tt class="docutils literal">.pyz</tt> archive is a console application and a <tt class="docutils literal">.pyzw</tt> archive is a
windowed application, indicating whether the console should appear
when running the app.</p>
<p>On Unix, it would be ideal if the <tt class="docutils literal">.pyz</tt> extension and the name
&quot;Python Zip Application&quot; were registered (in the mime types database?).
However, such an association is out of scope for this PEP.</p>
<p>Python Zip applications can be prefixed with a <tt class="docutils literal">#!</tt> line
pointing to the correct Python interpreter and an optional
explanation:</p>
<pre class="literal-block">
#!/usr/bin/env python3
#  Python application packed with zipapp module
(binary contents of archive)
</pre>
<p>On Unix, this allows the OS to run the file with the correct
interpreter, via the standard &quot;shebang&quot; support.  On Windows, the
Python launcher implements shebang support.</p>
<p>However, it is always possible to execute a <tt class="docutils literal">.pyz</tt> application by
supplying the filename to the Python interpreter directly.</p>
<p>As background, ZIP archives are defined with a footer containing
relative offsets from the end of the file.  They remain valid when
concatenated to the end of any other file.  This feature is completely
standard and is how self-extracting ZIP archives and the bdist_wininst
installer format work.</p>
</div>
<div class="section" id="minimal-tooling-the-zipapp-module">
<h1><a class="toc-backref" href="#id15">Minimal Tooling: The zipapp Module</a></h1>
<p>This PEP also proposes including a module for working with these
archives.  The module will contain functions for working with Python
zip application archives, and a command line interface (via <tt class="docutils literal">python
<span class="pre">-m</span> zipapp</tt>) for their creation and manipulation.</p>
<p>More complete tools for managing Python Zip Applications are
encouraged as 3rd party applications on PyPI.  Currently, pyzzer <a class="footnote-reference" href="#id11" id="id3">[5]</a>
and pex <a class="footnote-reference" href="#id12" id="id4">[6]</a> are two such tools.</p>
<div class="section" id="module-interface">
<h2><a class="toc-backref" href="#id16">Module Interface</a></h2>
<p>The zipapp module will provide the following functions:</p>
<div class="section" id="create-archive-source-target-none-interpreter-none-main-none">
<h3><a class="toc-backref" href="#id17"><tt class="docutils literal">create_archive(source, target=None, interpreter=None, main=None)</tt></a></h3>
<p>Create an application archive from <em>source</em>.  The source can be any
of the following:</p>
<ul class="simple">
<li>The name of a directory, in which case a new application archive
will be created from the content of that directory.</li>
<li>The name of an existing application archive file, in which case the
file is copied to the target.  The file name should include the
<tt class="docutils literal">.pyz</tt> or <tt class="docutils literal">.pyzw</tt> extension, if required.</li>
<li>A file object open for reading in bytes mode.  The content of the
file should be an application archive, and the file object is
assumed to be positioned at the start of the archive.</li>
</ul>
<p>The <em>target</em> argument determines where the resulting archive will be
written:</p>
<ul class="simple">
<li>If it is the name of a file, the archive will be written to that
file.</li>
<li>If it is an open file object, the archive will be written to that
file object, which must be open for writing in bytes mode.</li>
<li>If the target is omitted (or None), the source must be a directory
and the target will be a file with the same name as the source, with
a <tt class="docutils literal">.pyz</tt> extension added.</li>
</ul>
<p>The <em>interpreter</em> argument specifies the name of the Python
interpreter with which the archive will be executed.  It is written as
a &quot;shebang&quot; line at the start of the archive.  On Unix, this will be
interpreted by the OS, and on Windows it will be handled by the Python
launcher.  Omitting the <em>interpreter</em> results in no shebang line being
written.  If an interpreter is specified, and the target is a
filename, the executable bit of the target file will be set.</p>
<p>The <em>main</em> argument specifies the name of a callable which will be
used as the main program for the archive.  It can only be specified if
the source is a directory, and the source does not already contain a
<tt class="docutils literal">__main__.py</tt> file.  The <em>main</em> argument should take the form
&quot;pkg.module:callable&quot; and the archive will be run by importing
&quot;pkg.module&quot; and executing the given callable with no arguments.  It
is an error to omit <em>main</em> if the source is a directory and does not
contain a <tt class="docutils literal">__main__.py</tt> file, as otherwise the resulting archive
would not be executable.</p>
<p>If a file object is specified for <em>source</em> or <em>target</em>, it is the
caller's responsibility to close it after calling create_archive.</p>
<p>When copying an existing archive, file objects supplied only need
<tt class="docutils literal">read</tt> and <tt class="docutils literal">readline</tt>, or <tt class="docutils literal">write</tt> methods.  When creating an
archive from a directory, if the target is a file object it will be
passed to the <tt class="docutils literal">zipfile.ZipFile</tt> class, and must supply the methods
needed by that class.</p>
</div>
<div class="section" id="get-interpreter-archive">
<h3><a class="toc-backref" href="#id18"><tt class="docutils literal">get_interpreter(archive)</tt></a></h3>
<p>Returns the interpreter specified in the shebang line of the
<em>archive</em>.  If there is no shebang, the function returns <tt class="docutils literal">None</tt>.
The <em>archive</em> argument can be a filename or a file-like object open
for reading in bytes mode.</p>
</div>
</div>
<div class="section" id="command-line-usage">
<h2><a class="toc-backref" href="#id19">Command Line Usage</a></h2>
<p>The zipapp module can be run with the python <tt class="docutils literal"><span class="pre">-m</span></tt> flag.  The command
line interface is as follows:</p>
<pre class="literal-block">
python -m zipapp directory [options]

    Create an archive from the given directory.  An archive will
    be created from the contents of that directory.  The archive
    will have the same name as the source directory with a .pyz
    extension.

    The following options can be specified:

    -o archive / --output archive

        The destination archive will have the specified name.  The
        given name will be used as written, so should include the
        &quot;.pyz&quot; or &quot;.pyzw&quot; extension.

    -p interpreter / --python interpreter

        The given interpreter will be written to the shebang line
        of the archive.  If this option is not given, the archive
        will have no shebang line.

    -m pkg.mod:fn / --main pkg.mod:fn

        The source directory must not have a __main__.py file. The
        archiver will write a __main__.py file into the target
        which calls fn from the module pkg.mod.
</pre>
<p>The behaviour of the command line interface matches that of
<tt class="docutils literal">zipapp.create_archive()</tt>.</p>
<p>In addition, it is possible to use the command line interface to work
with an existing archive:</p>
<pre class="literal-block">
python -m zipapp app.pyz --show

    Displays the shebang line of an archive.  Output is of the
    form

        Interpreter: /usr/bin/env
    or
        Interpreter: &lt;none&gt;

    and is intended for diagnostic use, not for scripts.

python -m zipapp app.pyz -o newapp.pyz [-p interpreter]

    Copy app.pyz to newapp.pyz, modifying the shebang line based
    on the -p option (as for creating an archive, no -p option
    means remove the shebang line).  Specifying a destination is
    mandatory.

    In-place modification of an archive is *not* supported, as the
    risk of damaging archives is too great for a simple tool.
</pre>
<p>As noted, the archives are standard zip files, and so can be unpacked
using any standard ZIP utility or Python's zipfile module.  For this
reason, no interfaces to list the contents of an archive, or unpack
them, are provided or needed.</p>
</div>
<div class="section" id="faq">
<h2><a class="toc-backref" href="#id20">FAQ</a></h2>
<dl class="docutils">
<dt>Are you sure a standard ZIP utility can handle <tt class="docutils literal">#!</tt> at the beginning?</dt>
<dd>Absolutely.  The zipfile specification allows for arbitrary data to
be prepended to a zipfile.  This feature is commonly used by
&quot;self-extracting zip&quot; programs.  If your archive program can't
handle this, it is a bug in your archive program.</dd>
<dt>Isn't zipapp just a very thin wrapper over the zipfile module?</dt>
<dd>Yes.  If you prefer to build your own Python zip application
archives using other tools, they will work just as well.  The
zipapp module is a convenience, nothing more.</dd>
<dt>Why not use just use a <tt class="docutils literal">.zip</tt> or <tt class="docutils literal">.py</tt> extension?</dt>
<dd>Users expect a <tt class="docutils literal">.zip</tt> file to be opened with an archive tool, and
expect a <tt class="docutils literal">.py</tt> file to contain readable text.  Both would be
confusing for this use case.</dd>
<dt>How does this compete with existing package formats?</dt>
<dd>The sdist, bdist and wheel formats are designed for packaging of
modules to be installed into an existing Python installation.
They are not intended to be used without installing.  The
executable zip format is specifically designed for standalone use,
without needing to be installed.  They are in effect a multi-file
version of a standalone Python script.</dd>
</dl>
</div>
</div>
<div class="section" id="rejected-proposals">
<h1><a class="toc-backref" href="#id21">Rejected Proposals</a></h1>
<div class="section" id="convenience-values-for-shebang-lines">
<h2><a class="toc-backref" href="#id22">Convenience Values for Shebang Lines</a></h2>
<p>Is it worth having &quot;convenience&quot; forms for any of the common
interpreter values? For example, <tt class="docutils literal"><span class="pre">-p</span> 3</tt> meaning the same as <tt class="docutils literal"><span class="pre">-p</span>
&quot;/usr/bin/env python3&quot;</tt>.  It would save a lot of typing for the
common cases, as well as giving cross-platform options for people who
don't want or need to understand the intricacies of shebang handling
on &quot;other&quot; platforms.</p>
<p>Downsides are that it's not obvious how to translate the
abbreviations.  For example, should &quot;3&quot; mean &quot;/usr/bin/env python3&quot;,
&quot;/usr/bin/python3&quot;, &quot;python3&quot;, or something else?  Also, there is no
obvious short form for the key case of &quot;/usr/bin/env python&quot; (any
available version of Python), which could easily result in scripts
being written with overly-restrictive shebang lines.</p>
<p>Overall, this seems like there are more problems than benefits, and as
a result has been dropped from consideration.</p>
</div>
<div class="section" id="registering-pyz-as-a-media-type">
<h2><a class="toc-backref" href="#id23">Registering <tt class="docutils literal">.pyz</tt> as a Media Type</a></h2>
<p>It was suggested <a class="footnote-reference" href="#id9" id="id5">[3]</a> that the <tt class="docutils literal">.pyz</tt> extension should be registered
in the Unix database of extensions.  While it makes sense to do this
as an equivalent of the Windows installer registering the extension,
the <tt class="docutils literal">.py</tt> extension is not listed in the media types database <a class="footnote-reference" href="#id10" id="id6">[4]</a>.
It doesn't seem reasonable to register <tt class="docutils literal">.pyz</tt> without <tt class="docutils literal">.py</tt>, so
this idea has been omitted from this PEP.  An interested party could
arrange for <em>both</em> <tt class="docutils literal">.py</tt> and <tt class="docutils literal">.pyz</tt> to be registered at a future
date.</p>
</div>
<div class="section" id="default-interpreter">
<h2><a class="toc-backref" href="#id24">Default Interpreter</a></h2>
<p>The initial draft of this PEP proposed using <tt class="docutils literal">/usr/bin/env python</tt>
as the default interpreter.  Unix users have problems with this
behaviour, as the default for the python command on many distributions
is Python 2, and it is felt that this PEP should prefer Python 3 by
default.  However, using a command of <tt class="docutils literal">python3</tt> can result in
unexpected behaviour for Windows users, where the default behaviour of
the launcher for the command <tt class="docutils literal">python</tt> is commonly customised by users,
but the behaviour of <tt class="docutils literal">python3</tt> may not be modified to match.</p>
<p>As a result, the principle &quot;in the face of ambiguity, refuse to guess&quot;
has been invoked, and archives have no shebang line unless explicitly
requested.  On Windows, the archives will still be run (with the
default Python) by the launcher, and on Unix, the archives can be run
by explicitly invoking the desired Python interpreter.</p>
</div>
<div class="section" id="command-line-tool-to-manage-shebang-lines">
<h2><a class="toc-backref" href="#id25">Command Line Tool to Manage Shebang Lines</a></h2>
<p>It is conceivable that users would want to modify the shebang line for
an existing archive, or even just display the current shebang line.
This is tricky to do so with existing tools (zip programs typically
ignore prepended data totally, and text editors can have trouble
editing files containing binary data).</p>
<p>The zipapp module provides functions to handle the shebang line, but
does not include a command line interface to that functionality.  This
is because it is not clear how to provide one without the resulting
interface being over-complex and potentially confusing.  Changing the
shebang line is expected to be an uncommon requirement.</p>
</div>
</div>
<div class="section" id="reference-implementation">
<h1><a class="toc-backref" href="#id26">Reference Implementation</a></h1>
<p>A reference implementation is at <a class="reference external" href="http://bugs.python.org/issue23491">http://bugs.python.org/issue23491</a>.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id27">References</a></h1>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Allow interpreter to execute a zip file
(<a class="reference external" href="http://bugs.python.org/issue1739468">http://bugs.python.org/issue1739468</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Feature is not documented
(<a class="reference external" href="http://bugs.python.org/issue17359">http://bugs.python.org/issue17359</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[3]</a></td><td>Discussion of adding a .pyz mime type on python-dev
(<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2015-February/138338.html">https://mail.python.org/pipermail/python-dev/2015-February/138338.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[4]</a></td><td>Register of media types
(<a class="reference external" href="http://www.iana.org/assignments/media-types/media-types.xhtml">http://www.iana.org/assignments/media-types/media-types.xhtml</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[5]</a></td><td>pyzzer - A tool for creating Python-executable archives
(<a class="reference external" href="https://pypi.python.org/pypi/pyzzer">https://pypi.python.org/pypi/pyzzer</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[6]</a></td><td>pex - The PEX packaging toolchain
(<a class="reference external" href="https://pypi.python.org/pypi/pex">https://pypi.python.org/pypi/pex</a>)</td></tr>
</tbody>
</table>
<p>The discussion of this PEP took place on the python-dev mailing list,
in the thread starting at
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2015-February/138277.html">https://mail.python.org/pipermail/python-dev/2015-February/138277.html</a></p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id28">Copyright</a></h1>
<p>This document has been placed into the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

