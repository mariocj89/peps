<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">235</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Import on Case-Insensitive Platforms</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0235.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Tim Peters &lt;tim.peters&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.1</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">16 February 2001</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#note" id="id2">Note</a></li>
<li><a class="reference internal" href="#motivation" id="id3">Motivation</a></li>
<li><a class="reference internal" href="#current-lower-left-semantics" id="id4">Current Lower-Left Semantics</a></li>
<li><a class="reference internal" href="#proposed-semantics" id="id5">Proposed Semantics</a></li>
</ul>
</div>
<div class="section" id="note">
<h1><a class="toc-backref" href="#id2">Note</a></h1>
<p>This is essentially a retroactive PEP: the issue came up too late
in the 2.1 release process to solicit wide opinion before deciding
what to do, and can't be put off until 2.2 without also delaying
the Cygwin and MacOS X ports.</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id3">Motivation</a></h1>
<p>File systems vary across platforms in whether or not they preserve
the case of filenames, and in whether or not the platform C
library file-opening functions do or don't insist on
case-sensitive matches:</p>
<pre class="literal-block">
                     case-preserving     case-destroying
                 +-------------------+------------------+
case-sensitive   | most Unix flavors | brrrrrrrrrr      |
                 +-------------------+------------------+
case-insensitive | Windows           | some unfortunate |
                 | MacOSX HFS+       | network schemes  |
                 | Cygwin            |                  |
                 |                   | OpenVMS          |
                 +-------------------+------------------+
</pre>
<p>In the upper left box, if you create &quot;fiLe&quot; it's stored as &quot;fiLe&quot;,
and only <tt class="docutils literal"><span class="pre">open(&quot;fiLe&quot;)</span></tt> will open it (<tt class="docutils literal"><span class="pre">open(&quot;file&quot;)</span></tt> will not, nor
will the 14 other variations on that theme).</p>
<p>In the lower right box, if you create &quot;fiLe&quot;, there's no telling
what it's stored as -- but most likely as &quot;FILE&quot; -- and any of the
16 obvious variations on <tt class="docutils literal"><span class="pre">open(&quot;FilE&quot;)</span></tt> will open it.</p>
<p>The lower left box is a mix: creating &quot;fiLe&quot; stores &quot;fiLe&quot; in the
platform directory, but you don't have to match case when opening
it; any of the 16 obvious variations on <tt class="docutils literal"><span class="pre">open(&quot;FILe&quot;)</span></tt> work.</p>
<p>NONE OF THAT IS CHANGING!  Python will continue to follow platform
conventions w.r.t. whether case is preserved when creating a file,
and w.r.t. whether <tt class="docutils literal">open()</tt> requires a case-sensitive match.  In
practice, you should always code as if matches were
case-sensitive, else your program won't be portable.</p>
<p>What's proposed is to change the semantics of Python &quot;import&quot;
statements, and there <em>only</em> in the lower left box.</p>
</div>
<div class="section" id="current-lower-left-semantics">
<h1><a class="toc-backref" href="#id4">Current Lower-Left Semantics</a></h1>
<p>Support for MacOSX HFS+, and for Cygwin, is new in 2.1, so nothing
is changing there.  What's changing is Windows behavior.  Here are
the current rules for import on Windows:</p>
<ol class="arabic">
<li><p class="first">Despite that the filesystem is case-insensitive, Python insists
on a case-sensitive match.  But not in the way the upper left
box works: if you have two files, <tt class="docutils literal">FiLe.py</tt> and <tt class="docutils literal">file.py</tt> on
<tt class="docutils literal">sys.path</tt>, and do</p>
<pre class="literal-block">
import file
</pre>
<p>then if Python finds <tt class="docutils literal">FiLe.py</tt> first, it raises a <tt class="docutils literal">NameError</tt>.
It does <em>not</em> go on to find <tt class="docutils literal">file.py</tt>; indeed, it's impossible to
import any but the first case-insensitive match on <tt class="docutils literal">sys.path</tt>,
and then only if case matches exactly in the first
case-insensitive match.</p>
</li>
<li><p class="first">An ugly exception: if the first case-insensitive match on
<tt class="docutils literal">sys.path</tt> is for a file whose name is entirely in upper case
(<tt class="docutils literal">FILE.PY</tt> or <tt class="docutils literal">FILE.PYC</tt> or <tt class="docutils literal">FILE.PYO</tt>), then the import silently
grabs that, no matter what mixture of case was used in the
import statement.  This is apparently to cater to miserable old
filesystems that really fit in the lower right box.  But this
exception is unique to Windows, for reasons that may or may not
exist.</p>
</li>
<li><p class="first">And another exception: if the environment variable <tt class="docutils literal">PYTHONCASEOK</tt>
exists, Python silently grabs the first case-insensitive match
of any kind.</p>
</li>
</ol>
<p>So these Windows rules are pretty complicated, and neither match
the Unix rules nor provide semantics natural for the native
filesystem.  That makes them hard to explain to Unix <em>or</em> Windows
users.  Nevertheless, they've worked fine for years, and in
isolation there's no compelling reason to change them.</p>
<p>However, that was before the MacOSX HFS+ and Cygwin ports arrived.
They also have case-preserving case-insensitive filesystems, but
the people doing the ports despised the Windows rules.  Indeed, a
patch to make HFS+ act like Unix for imports got past a reviewer
and into the code base, which incidentally made Cygwin also act
like Unix (but this met the unbounded approval of the Cygwin
folks, so they sure didn't complain -- they had patches of their
own pending to do this, but the reviewer for those balked).</p>
<p>At a higher level, we want to keep Python consistent, by following
the same rules on <em>all</em> platforms with case-preserving
case-insensitive filesystems.</p>
</div>
<div class="section" id="proposed-semantics">
<h1><a class="toc-backref" href="#id5">Proposed Semantics</a></h1>
<p>The proposed new semantics for the lower left box:</p>
<ol class="upperalpha simple">
<li>If the <tt class="docutils literal">PYTHONCASEOK</tt> environment variable exists, same as
before: silently accept the first case-insensitive match of any
kind; raise <tt class="docutils literal">ImportError</tt> if none found.</li>
<li>Else search <tt class="docutils literal">sys.path</tt> for the first case-sensitive match; raise
<tt class="docutils literal">ImportError</tt> if none found.</li>
</ol>
<p>#B is the same rule as is used on Unix, so this will improve cross-
platform portability.  That's good.  #B is also the rule the Mac
and Cygwin folks want (and wanted enough to implement themselves,
multiple times, which is a powerful argument in PythonLand).  It
can't cause any existing non-exceptional Windows import to fail,
because any existing non-exceptional Windows import finds a
case-sensitive match first in the path -- and it still will.  An
exceptional Windows import currently blows up with a <tt class="docutils literal">NameError</tt> or
<tt class="docutils literal">ImportError</tt>, in which latter case it still will, or in which
former case will continue searching, and either succeed or blow up
with an <tt class="docutils literal">ImportError</tt>.</p>
<p>#A is needed to cater to case-destroying filesystems mounted on Windows,
and <em>may</em> also be used by people so enamored of &quot;natural&quot; Windows
behavior that they're willing to set an environment variable to
get it.  I don't intend to implement #A for Unix too, but that's
just because I'm not clear on how I <em>could</em> do so efficiently (I'm
not going to slow imports under Unix just for theoretical purity).</p>
<p>The potential damage is here: #2 (matching on <tt class="docutils literal">ALLCAPS.PY</tt>) is
proposed to be dropped.  Case-destroying filesystems are a
vanishing breed, and support for them is ugly.  We're already
supporting (and will continue to support) <tt class="docutils literal">PYTHONCASEOK</tt> for their
benefit, but they don't deserve multiple hacks in 2001.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

