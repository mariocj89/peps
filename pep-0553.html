<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">553</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Built-in breakpoint()</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Barry Warsaw &lt;barry&#32;&#97;t&#32;python.org&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">2017-09-05</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.7</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">2017-09-05, 2017-09-07, 2017-09-13</td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2017-October/149705.html">https://mail.python.org/pipermail/python-dev/2017-October/149705.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id8">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id9">Rationale</a></li>
<li><a class="reference internal" href="#proposal" id="id10">Proposal</a></li>
<li><a class="reference internal" href="#environment-variable" id="id11">Environment variable</a></li>
<li><a class="reference internal" href="#implementation" id="id12">Implementation</a></li>
<li><a class="reference internal" href="#rejected-alternatives" id="id13">Rejected alternatives</a><ul>
<li><a class="reference internal" href="#a-new-keyword" id="id14">A new keyword</a></li>
<li><a class="reference internal" href="#sys-breakpoint" id="id15">sys.breakpoint()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#version-history" id="id16">Version History</a></li>
<li><a class="reference internal" href="#references" id="id17">References</a></li>
<li><a class="reference internal" href="#copyright" id="id18">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id8">Abstract</a></h1>
<p>This PEP proposes adding a new built-in function called <tt class="docutils literal">breakpoint()</tt> which
enters a Python debugger at the point of the call.  Additionally, two new
names are added to the <tt class="docutils literal">sys</tt> module to make the choice of which debugger is
entered configurable.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id9">Rationale</a></h1>
<p>Python has long had a great debugger in its standard library called <tt class="docutils literal">pdb</tt>.
Setting a break point is commonly written like this:</p>
<pre class="literal-block">
foo()
import pdb; pdb.set_trace()
bar()
</pre>
<p>Thus after executing <tt class="docutils literal">foo()</tt> and before executing <tt class="docutils literal">bar()</tt>, Python will
enter the debugger.  However this idiom has several disadvantages.</p>
<ul class="simple">
<li>It's a lot to type (27 characters).</li>
<li>It's easy to typo.  The PEP author often mistypes this line, e.g. omitting
the semicolon, or typing a dot instead of an underscore.</li>
<li>It ties debugging directly to the choice of pdb.  There might be other
debugging options, say if you're using an IDE or some other development
environment.</li>
<li>Python linters (e.g. flake8 <a class="citation-reference" href="#linters" id="id1">[linters]</a>) complain about this line because it
contains two statements.  Breaking the idiom up into two lines complicates
its use because there are more opportunities for mistakes at clean up time.
I.e. you might forget to delete one of those lines when you no longer need
to debug the code.</li>
</ul>
<p>Python developers also have many other debuggers to choose from, but
remembering how to invoke them can be problematic.  For example, even when
IDEs have user interface for setting breakpoints, it may still be more
convenient to just edit the code.  The APIs for entering the debugger
programmatically are inconsistent, so it can be difficult to remember exactly
what to type.</p>
<p>We can solve all these problems by providing a universal API for entering the
debugger, as proposed in this PEP.</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id10">Proposal</a></h1>
<p>The JavaScript language provides a <tt class="docutils literal">debugger</tt> statement <a class="citation-reference" href="#js-debugger" id="id2">[js-debugger]</a> which enters
the debugger at the point where the statement appears.</p>
<p>This PEP proposes a new built-in function called <tt class="docutils literal">breakpoint()</tt>
which enters a Python debugger at the call site.  Thus the example
above would be written like so:</p>
<pre class="literal-block">
foo()
breakpoint()
bar()
</pre>
<p>Further, this PEP proposes two new name bindings for the <tt class="docutils literal">sys</tt>
module, called <tt class="docutils literal">sys.breakpointhook()</tt> and
<tt class="docutils literal">sys.__breakpointhook__</tt>.  By default, <tt class="docutils literal">sys.breakpointhook()</tt>
implements the actual importing and entry into <tt class="docutils literal">pdb.set_trace()</tt>,
and it can be set to a different function to change the debugger that
<tt class="docutils literal">breakpoint()</tt> enters.</p>
<p><tt class="docutils literal">sys.__breakpointhook__</tt> is initialized to the same function as
<tt class="docutils literal">sys.breakpointhook()</tt> so that you can always easily reset
<tt class="docutils literal">sys.breakpointhook()</tt> to the default value (e.g. by doing
<tt class="docutils literal">sys.breakpointhook = sys.__breakpointhook__</tt>).  This is exactly the same as
how the the existing <tt class="docutils literal">sys.displayhook()</tt> / <tt class="docutils literal">sys.__displayhook__</tt> and
<tt class="docutils literal">sys.excepthook()</tt> / <tt class="docutils literal">sys.__excepthook__</tt> work <a class="citation-reference" href="#hooks" id="id3">[hooks]</a>.</p>
<p>The signature of the built-in is <tt class="docutils literal"><span class="pre">breakpoint(*args,</span> **kws)</tt>.  The positional
and keyword arguments are passed straight through to <tt class="docutils literal">sys.breakpointhook()</tt>
and the signatures must match or a <tt class="docutils literal">TypeError</tt> will be raised.  The return
from <tt class="docutils literal">sys.breakpointhook()</tt> is passed back up to, and returned from
<tt class="docutils literal">breakpoint()</tt>.</p>
<p>The rationale for this is based on the observation that the underlying
debuggers may accept additional optional arguments.  For example, IPython
allows you to specify a string that gets printed when the break point is
entered <a class="citation-reference" href="#ipython-embed" id="id4">[ipython-embed]</a>.  As of Python 3.7, the pdb module also supports an
optional <tt class="docutils literal">header</tt> argument <a class="citation-reference" href="#pdb-header" id="id5">[pdb-header]</a>.</p>
</div>
<div class="section" id="environment-variable">
<h1><a class="toc-backref" href="#id11">Environment variable</a></h1>
<p>The default implementation of <tt class="docutils literal">sys.breakpointhook()</tt> consults a new
environment variable called <tt class="docutils literal">PYTHONBREAKPOINT</tt>.  This environment variable
can have various values:</p>
<ul class="simple">
<li><tt class="docutils literal">PYTHONBREAKPOINT=0</tt> disables debugging.  Specifically, with this value
<tt class="docutils literal">sys.breakpointhook()</tt> returns <tt class="docutils literal">None</tt> immediately.</li>
<li><tt class="docutils literal">PYTHONBREAKPOINT=</tt> (i.e. the empty string).  This is the same as not
setting the environment variable at all, in which case <tt class="docutils literal">pdb.set_trace()</tt>
is run as usual.</li>
<li><tt class="docutils literal">PYTHONBREAKPOINT=some.importable.callable</tt>.  In this case,
<tt class="docutils literal">sys.breakpointhook()</tt> imports the <tt class="docutils literal">some.importable</tt> module and gets the
<tt class="docutils literal">callable</tt> object from the resulting module, which it then calls.  The
value may be a string with no dots, in which case it names a built-in
callable, e.g. <tt class="docutils literal">PYTHONBREAKPOINT=int</tt>.  (Guido has expressed the
preference for normal Python dotted-paths, not setuptools-style entry point
syntax <a class="citation-reference" href="#syntax" id="id6">[syntax]</a>.)</li>
</ul>
<p>This environment variable allows external processes to control how breakpoints
are handled.  Some uses cases include:</p>
<ul class="simple">
<li>Completely disabling all accidental <tt class="docutils literal">breakpoint()</tt> calls pushed to
production.  This could be accomplished by setting <tt class="docutils literal">PYTHONBREAKPOINT=0</tt> in
the execution environment.  Another suggestion by reviewers of the PEP was
to set <tt class="docutils literal">PYTHONBREAKPOINT=sys.exit</tt> in this case.</li>
<li>IDE integration with specialized debuggers for embedded execution.  The IDE
would run the program in its debugging environment with <tt class="docutils literal">PYTHONBREAKPOINT</tt>
set to their internal debugging hook.</li>
</ul>
<p><tt class="docutils literal">PYTHONBREAKPOINT</tt> is re-interpreted every time <tt class="docutils literal">sys.breakpointhook()</tt> is
reached.  This allows processes to change its value during the execution of a
program and have <tt class="docutils literal">breakpoint()</tt> respond to those changes.  It is not
considered a performance critical section since entering a debugger by
definition stops execution.  Thus, programs can do the following:</p>
<pre class="literal-block">
os.environ['PYTHONBREAKPOINT'] = 'foo.bar.baz'
breakpoint()    # Imports foo.bar and calls foo.bar.baz()
</pre>
<p>Overriding <tt class="docutils literal">sys.breakpointhook</tt> defeats the default consultation of
<tt class="docutils literal">PYTHONBREAKPOINT</tt>.  It is up to the overriding code to consult
<tt class="docutils literal">PYTHONBREAKPOINT</tt> if they want.</p>
<p>If access to the <tt class="docutils literal">PYTHONBREAKPOINT</tt> callable fails in any way (e.g. the
import fails, or the resulting module does not contain the callable), a
<tt class="docutils literal">RuntimeWarning</tt> is issued, and no breakpoint function is called.</p>
<p>Note that as with all other <tt class="docutils literal">PYTHON*</tt> environment variables,
<tt class="docutils literal">PYTHONBREAKPOINT</tt> is ignored when the interpreter is started with
<tt class="docutils literal"><span class="pre">-E</span></tt>.  This means the default behavior will occur
(i.e. <tt class="docutils literal">pdb.set_trace()</tt> will run).  There was some discussion about
alternatively treating <tt class="docutils literal">PYTHONBREAKPOINT=0</tt> when <tt class="docutils literal"><span class="pre">-E</span></tt> as in
effect, but the opinions were inconclusive, so it was decided that
this wasn't special enough for a special case.</p>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id12">Implementation</a></h1>
<p>A pull request exists with the proposed implementation <a class="citation-reference" href="#impl" id="id7">[impl]</a>.</p>
<p>While the actual implementation is in C, the Python pseudo-code for this
feature looks roughly like the following:</p>
<pre class="literal-block">
# In builtins.
def breakpoint(*args, **kws):
    import sys
    missing = object()
    hook = getattr(sys, 'breakpointhook', missing)
    if hook is missing:
        raise RuntimeError('lost sys.breakpointhook')
    return hook(*args, **kws)

# In sys.
def breakpointhook(*args, **kws):
    import importlib, os, warnings
    hookname = os.getenv('PYTHONBREAKPOINT')
    if hookname is None or len(hookname) == 0:
        hookname = 'pdb.set_trace'
    elif hookname == '0':
        return None
    modname, dot, funcname = hookname.rpartition('.')
    if dot == '':
        modname = 'builtins'
    try:
        module = importlib.import_module(modname)
        hook = getattr(module, funcname)
    except:
        warnings.warn(
            'Ignoring unimportable $PYTHONBREAKPOINT: {}'.format(
                hookname),
            RuntimeWarning)
    return hook(*args, **kws)

__breakpointhook__ = breakpointhook
</pre>
</div>
<div class="section" id="rejected-alternatives">
<h1><a class="toc-backref" href="#id13">Rejected alternatives</a></h1>
<div class="section" id="a-new-keyword">
<h2><a class="toc-backref" href="#id14">A new keyword</a></h2>
<p>Originally, the author considered a new keyword, or an extension to an
existing keyword such as <tt class="docutils literal">break here</tt>.  This is rejected on several fronts.</p>
<ul class="simple">
<li>A brand new keyword would require a <tt class="docutils literal">__future__</tt> to enable it since almost
any new keyword could conflict with existing code.  This negates the ease
with which you can enter the debugger.</li>
<li>An extended keyword such as <tt class="docutils literal">break here</tt>, while more readable and not
requiring a <tt class="docutils literal">__future__</tt> would tie the keyword extension to this new
feature, preventing more useful extensions such as those proposed in
<a class="reference external" href="/dev/peps/pep-0548">PEP 548</a>.</li>
<li>A new keyword would require a modified grammar and likely a new bytecode.
Each of these makes the implementation more complex.  A new built-in breaks
no existing code (since any existing module global would just shadow the
built-in) and is quite easy to implement.</li>
</ul>
</div>
<div class="section" id="sys-breakpoint">
<h2><a class="toc-backref" href="#id15">sys.breakpoint()</a></h2>
<p>Why not <tt class="docutils literal">sys.breakpoint()</tt>?  Requiring an import to invoke the debugger is
explicitly rejected because <tt class="docutils literal">sys</tt> is not imported in every module.  That
just requires more typing and would lead to:</p>
<pre class="literal-block">
import sys; sys.breakpoint()
</pre>
<p>which inherits several of the problems this PEP aims to solve.</p>
</div>
</div>
<div class="section" id="version-history">
<h1><a class="toc-backref" href="#id16">Version History</a></h1>
<ul class="simple">
<li>2017-09-13<ul>
<li>The <tt class="docutils literal">PYTHONBREAKPOINT</tt> environment variable is made a first class
feature.</li>
</ul>
</li>
<li>2017-09-07<ul>
<li><tt class="docutils literal">debug()</tt> renamed to <tt class="docutils literal">breakpoint()</tt></li>
<li>Signature changed to <tt class="docutils literal"><span class="pre">breakpoint(*args,</span> **kws)</tt> which is passed straight
through to <tt class="docutils literal">sys.breakpointhook()</tt>.</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id17">References</a></h1>
<table class="docutils citation" frame="void" id="ipython-embed" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[ipython-embed]</a></td><td><a class="reference external" href="http://ipython.readthedocs.io/en/stable/api/generated/IPython.terminal.embed.html">http://ipython.readthedocs.io/en/stable/api/generated/IPython.terminal.embed.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="pdb-header" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[pdb-header]</a></td><td><a class="reference external" href="https://docs.python.org/3.7/library/pdb.html#pdb.set_trace">https://docs.python.org/3.7/library/pdb.html#pdb.set_trace</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="linters" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[linters]</a></td><td><a class="reference external" href="http://flake8.readthedocs.io/en/latest/">http://flake8.readthedocs.io/en/latest/</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="js-debugger" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[js-debugger]</a></td><td><a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="hooks" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[hooks]</a></td><td><a class="reference external" href="https://docs.python.org/3/library/sys.html#sys.displayhook">https://docs.python.org/3/library/sys.html#sys.displayhook</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="syntax" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[syntax]</a></td><td><a class="reference external" href="http://setuptools.readthedocs.io/en/latest/setuptools.html?highlight=console#automatic-script-creation">http://setuptools.readthedocs.io/en/latest/setuptools.html?highlight=console#automatic-script-creation</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="impl" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[impl]</a></td><td><a class="reference external" href="https://github.com/python/cpython/pull/3355">https://github.com/python/cpython/pull/3355</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="envar" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[envar]</td><td><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2017-September/149447.html">https://mail.python.org/pipermail/python-dev/2017-September/149447.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id18">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

