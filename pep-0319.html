<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">319</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Python Synchronize/Asynchronize Block</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0319.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Michel Pelletier &lt;michel&#32;&#97;t&#32;users.sourceforge.net&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">24-Feb-2003</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.4?</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id9">Abstract</a></li>
<li><a class="reference internal" href="#pronouncement" id="id10">Pronouncement</a></li>
<li><a class="reference internal" href="#synchronization-targets" id="id11">Synchronization Targets</a></li>
<li><a class="reference internal" href="#other-patterns-that-synchronize" id="id12">Other Patterns that Synchronize</a></li>
<li><a class="reference internal" href="#formal-syntax" id="id13">Formal Syntax</a></li>
<li><a class="reference internal" href="#proposed-implementation" id="id14">Proposed Implementation</a></li>
<li><a class="reference internal" href="#backward-compatibility" id="id15">Backward Compatibility</a></li>
<li><a class="reference internal" href="#pep-310-reliable-acquisition-release-pairs" id="id16">PEP 310 Reliable Acquisition/Release Pairs</a></li>
<li><a class="reference internal" href="#how-java-does-it" id="id17">How Java Does It</a></li>
<li><a class="reference internal" href="#how-jython-does-it" id="id18">How Jython Does It</a></li>
<li><a class="reference internal" href="#summary-of-proposed-changes-to-python" id="id19">Summary of Proposed Changes to Python</a></li>
<li><a class="reference internal" href="#risks" id="id20">Risks</a></li>
<li><a class="reference internal" href="#dissenting-opinion" id="id21">Dissenting Opinion</a></li>
<li><a class="reference internal" href="#references" id="id22">References</a></li>
<li><a class="reference internal" href="#copyright" id="id23">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id9">Abstract</a></h1>
<p>This PEP proposes adding two new keywords to Python, 'synchronize'
and 'asynchronize'.</p>
</div>
<div class="section" id="pronouncement">
<h1><a class="toc-backref" href="#id10">Pronouncement</a></h1>
<p>This PEP is rejected in favor of <a class="reference external" href="/dev/peps/pep-0343">PEP 343</a>.</p>
<dl class="docutils">
<dt>The 'synchronize' Keyword</dt>
<dd><p class="first">The concept of code synchronization in Python is too low-level.
To synchronize code a programmer must be aware of the details of
the following pseudo-code pattern:</p>
<pre class="literal-block">
initialize_lock()

...

acquire_lock()
try:
    change_shared_data()
finally:
    release_lock()
</pre>
<p>This synchronized block pattern is not the only pattern (more
discussed below) but it is very common.  This PEP proposes
replacing the above code with the following equivalent:</p>
<pre class="literal-block">
synchronize:
    change_shared_data()
</pre>
<p class="last">The advantages of this scheme are simpler syntax and less room for
user error.  Currently users are required to write code about
acquiring and releasing thread locks in 'try/finally' blocks;
errors in this code can cause notoriously difficult concurrent
thread locking issues.</p>
</dd>
<dt>The 'asynchronize' Keyword</dt>
<dd><p class="first">While executing a 'synchronize' block of code a programmer may
want to &quot;drop back&quot; to running asynchronously momentarily to run
blocking input/output routines or something else that might take a
indeterminate amount of time and does not require synchronization.
This code usually follows the pattern:</p>
<pre class="literal-block">
initialize_lock()

...

acquire_lock()
try:
    change_shared_data()
    release_lock()             # become async
    do_blocking_io()
    acquire_lock()             # sync again
    change_shared_data2()

finally:
    release_lock()
</pre>
<p>The asynchronous section of the code is not very obvious visually,
so it is marked up with comments.  Using the proposed
'asynchronize' keyword this code becomes much cleaner, easier to
understand, and less prone to error:</p>
<pre class="literal-block">
synchronize:
    change_shared_data()

    asynchronize:
       do_blocking_io()

    change_shared_data2()
</pre>
<p>Encountering an 'asynchronize' keyword inside a non-synchronized
block can raise either an error or issue a warning (as all code
blocks are implicitly asynchronous anyway).  It is important to
note that the above example is <strong>not</strong> the same as:</p>
<pre class="literal-block">
synchronize:
    change_shared_data()

do_blocking_io()

synchronize:
    change_shared_data2()
</pre>
<p>Because both synchronized blocks of code may be running inside the
same iteration of a loop, Consider:</p>
<pre class="literal-block">
while in_main_loop():
    synchronize:
        change_shared_data()

        asynchronize:
           do_blocking_io()

        change_shared_data2()
</pre>
<p class="last">Many threads may be looping through this code.  Without the
'asynchronize' keyword one thread cannot stay in the loop and
release the lock at the same time while blocking IO is going on.
This pattern of releasing locks inside a main loop to do blocking
IO is used extensively inside the CPython interpreter itself.</p>
</dd>
</dl>
</div>
<div class="section" id="synchronization-targets">
<h1><a class="toc-backref" href="#id11">Synchronization Targets</a></h1>
<p>As proposed the 'synchronize' and 'asynchronize' keywords
synchronize a block of code.  However programmers may want to
specify a target object that threads synchronize on.  Any object
can be a synchronization target.</p>
<p>Consider a two-way queue object: two different objects are used by
the same 'synchronize' code block to synchronize both queues
separately in the 'get' method:</p>
<pre class="literal-block">
class TwoWayQueue:
    def __init__(self):
        self.front = []
        self.rear = []

    def putFront(self, item):
        self.put(item, self.front)

    def getFront(self):
        item = self.get(self.front)
        return item

    def putRear(self, item):
        self.put(item, self.rear)

    def getRear(self):
        item = self.get(self.rear)
        return item

    def put(self, item, queue):
        synchronize queue:
            queue.append(item)

    def get(self, queue):
        synchronize queue:
            item = queue[0]
            del queue[0]
            return item
</pre>
<p>Here is the equivalent code in Python as it is now without a
'synchronize' keyword:</p>
<pre class="literal-block">
import thread

class LockableQueue:

    def __init__(self):
        self.queue = []
        self.lock = thread.allocate_lock()

class TwoWayQueue:
    def __init__(self):
        self.front = LockableQueue()
        self.rear = LockableQueue()

    def putFront(self, item):
        self.put(item, self.front)

    def getFront(self):
        item = self.get(self.front)
        return item

    def putRear(self, item):
        self.put(item, self.rear)

    def getRear(self):
        item = self.get(self.rear)
        return item

    def put(self, item, queue):
        queue.lock.acquire()
        try:
            queue.append(item)
        finally:
            queue.lock.release()

    def get(self, queue):
        queue.lock.acquire()
        try:
            item = queue[0]
            del queue[0]
            return item
        finally:
            queue.lock.release()
</pre>
<p>The last example had to define an extra class to associate a lock
with the queue where the first example the 'synchronize' keyword
does this association internally and transparently.</p>
</div>
<div class="section" id="other-patterns-that-synchronize">
<h1><a class="toc-backref" href="#id12">Other Patterns that Synchronize</a></h1>
<p>There are some situations where the 'synchronize' and
'asynchronize' keywords cannot entirely replace the use of lock
methods like <tt class="docutils literal">acquire</tt> and <tt class="docutils literal">release</tt>.  Some examples are if the
programmer wants to provide arguments for <tt class="docutils literal">acquire</tt> or if a lock
is acquired in one code block but released in another, as shown
below.</p>
<p>Here is a class from Zope modified to use both the 'synchronize'
and 'asynchronize' keywords and also uses a pool of explicit locks
that are acquired and released in different code blocks and thus
don't use 'synchronize':</p>
<pre class="literal-block">
import thread
from ZServerPublisher import ZServerPublisher

class ZRendevous:

    def __init__(self, n=1):
        pool=[]
        self._lists=pool, [], []

        synchronize:
            while n &gt; 0:
                l=thread.allocate_lock()
                l.acquire()
                pool.append(l)
                thread.start_new_thread(ZServerPublisher,
                                        (self.accept,))
                n=n-1

    def accept(self):
        synchronize:
            pool, requests, ready = self._lists
            while not requests:
                l=pool[-1]
                del pool[-1]
                ready.append(l)

                asynchronize:
                    l.acquire()

                pool.append(l)

            r=requests[0]
            del requests[0]
            return r

    def handle(self, name, request, response):
        synchronize:
            pool, requests, ready = self._lists
            requests.append((name, request, response))
            if ready:
                l=ready[-1]
                del ready[-1]
                l.release()
</pre>
<p>Here is the original class as found in the
'Zope/ZServer/PubCore/ZRendevous.py' module.  The &quot;convenience&quot; of
the '_a' and '_r' shortcut names obscure the code:</p>
<pre class="literal-block">
import thread
from ZServerPublisher import ZServerPublisher

class ZRendevous:

    def __init__(self, n=1):
        sync=thread.allocate_lock()
        self._a=sync.acquire
        self._r=sync.release
        pool=[]
        self._lists=pool, [], []
        self._a()
        try:
            while n &gt; 0:
                l=thread.allocate_lock()
                l.acquire()
                pool.append(l)
                thread.start_new_thread(ZServerPublisher,
                                        (self.accept,))
                n=n-1
        finally: self._r()

    def accept(self):
        self._a()
        try:
            pool, requests, ready = self._lists
            while not requests:
                l=pool[-1]
                del pool[-1]
                ready.append(l)
                self._r()
                l.acquire()
                self._a()
                pool.append(l)

            r=requests[0]
            del requests[0]
            return r
        finally: self._r()

    def handle(self, name, request, response):
        self._a()
        try:
            pool, requests, ready = self._lists
            requests.append((name, request, response))
            if ready:
                l=ready[-1]
                del ready[-1]
                l.release()
        finally: self._r()
</pre>
<p>In particular the asynchronize section of the <tt class="docutils literal">accept</tt> method is
not very obvious.  To beginner programmers, 'synchronize' and
'asynchronize' remove many of the problems encountered when
juggling multiple <tt class="docutils literal">acquire</tt> and <tt class="docutils literal">release</tt> methods on different
locks in different <tt class="docutils literal">try/finally</tt> blocks.</p>
</div>
<div class="section" id="formal-syntax">
<h1><a class="toc-backref" href="#id13">Formal Syntax</a></h1>
<p>Python syntax is defined in a modified BNF grammar notation
described in the Python Language Reference <a class="footnote-reference" href="#id5" id="id1">[1]</a>.  This section
describes the proposed synchronization syntax using this grammar:</p>
<pre class="literal-block">
synchronize_stmt: 'synchronize' [test] ':' suite
asynchronize_stmt: 'asynchronize' [test] ':' suite
compound_stmt: ... | synchronized_stmt | asynchronize_stmt
</pre>
<p>(The '...' indicates other compound statements elided).</p>
</div>
<div class="section" id="proposed-implementation">
<h1><a class="toc-backref" href="#id14">Proposed Implementation</a></h1>
<p>The author of this PEP has not explored an implementation yet.
There are several implementation issues that must be resolved.
The main implementation issue is what exactly gets locked and
unlocked during a synchronized block.</p>
<p>During an unqualified synchronized block (the use of the
'synchronize' keyword without a target argument) a lock could be
created and associated with the synchronized code block object.
Any threads that are to execute the block must first acquire the
code block lock.</p>
<p>When an 'asynchronize' keyword is encountered in a 'synchronize'
block the code block lock is unlocked before the inner block is
executed and re-locked when the inner block terminates.</p>
<p>When a synchronized block target is specified the object is
associated with a lock.  How this is implemented cleanly is
probably the highest risk of this proposal.  Java Virtual Machines
typically associate a special hidden lock object with target
object and use it to synchronized the block around the target
only.</p>
</div>
<div class="section" id="backward-compatibility">
<h1><a class="toc-backref" href="#id15">Backward Compatibility</a></h1>
<p>Backward compatibility is solved with the new <tt class="docutils literal">from __future__</tt>
Python syntax <a class="footnote-reference" href="#id6" id="id2">[2]</a>, and the new warning framework <a class="footnote-reference" href="#id7" id="id3">[3]</a> to evolve the
Python language into phasing out any conflicting names that use
the new keywords 'synchronize' and 'asynchronize'.  To use the
syntax now, a developer could use the statement:</p>
<pre class="literal-block">
from __future__ import threadsync  # or whatever
</pre>
<p>In addition, any code that uses the keyword 'synchronize' or
'asynchronize' as an identifier will be issued a warning from
Python.  After the appropriate period of time, the syntax would
become standard, the above import statement would do nothing, and
any identifiers named 'synchronize' or 'asynchronize' would raise
an exception.</p>
</div>
<div class="section" id="pep-310-reliable-acquisition-release-pairs">
<h1><a class="reference external" href="/dev/peps/pep-0310">PEP 310</a> Reliable Acquisition/Release Pairs</h1>
<p><a class="reference external" href="/dev/peps/pep-0310">PEP 310</a> <a class="footnote-reference" href="#id8" id="id4">[4]</a> proposes the 'with' keyword that can serve the same
function as 'synchronize' (but no facility for 'asynchronize').
The pattern:</p>
<pre class="literal-block">
initialize_lock()

with the_lock:
    change_shared_data()
</pre>
<p>is equivalent to the proposed:</p>
<pre class="literal-block">
synchronize the_lock:
    change_shared_data()
</pre>
<p><a class="reference external" href="/dev/peps/pep-0310">PEP 310</a> must synchronize on an exsiting lock, while this PEP
proposes that unqualified 'synchronize' statements synchronize on
a global, internal, transparent lock in addition to qualifiled
'synchronize' statements.  The 'with' statement also requires lock
initialization, while the 'synchronize' statement can synchronize
on any target object <strong>including</strong> locks.</p>
<p>While limited in this fashion, the 'with' statement is more
abstract and serves more purposes than synchronization.  For
example, transactions could be used with the 'with' keyword:</p>
<pre class="literal-block">
initialize_transaction()

with my_transaction:
    do_in_transaction()

# when the block terminates, the transaction is committed.
</pre>
<p>The 'synchronize' and 'asynchronize' keywords cannot serve this or
any other general acquire/release pattern other than thread
synchronization.</p>
</div>
<div class="section" id="how-java-does-it">
<h1><a class="toc-backref" href="#id17">How Java Does It</a></h1>
<p>Java defines a 'synchronized' keyword (note the grammatical tense
different between the Java keyword and this PEP's 'synchronize')
which must be qualified on any object.  The syntax is:</p>
<pre class="literal-block">
synchronized (Expression) Block
</pre>
<p>Expression must yield a valid object (null raises an error and
exceptions during 'Expression' terminate the 'synchronized' block
for the same reason) upon which 'Block' is synchronized.</p>
</div>
<div class="section" id="how-jython-does-it">
<h1><a class="toc-backref" href="#id18">How Jython Does It</a></h1>
<p>Jython uses a 'synchronize' class with the static method
'make_synchronized' that accepts one callable argument and returns
a newly created, synchronized, callable &quot;wrapper&quot; around the
argument.</p>
</div>
<div class="section" id="summary-of-proposed-changes-to-python">
<h1><a class="toc-backref" href="#id19">Summary of Proposed Changes to Python</a></h1>
<p>Adding new 'synchronize' and 'asynchronize' keywords to the
language.</p>
</div>
<div class="section" id="risks">
<h1><a class="toc-backref" href="#id20">Risks</a></h1>
<p>This PEP proposes adding two keywords to the Python language. This
may break code.</p>
<p>There is no implementation to test.</p>
<p>It's not the most important problem facing Python programmers
today (although it is a fairly notorious one).</p>
<p>The equivalent Java keyword is the past participle 'synchronized'.
This PEP proposes the present tense, 'synchronize' as being more
in spirit with Python (there being less distinction between
compile-time and run-time in Python than Java).</p>
</div>
<div class="section" id="dissenting-opinion">
<h1><a class="toc-backref" href="#id21">Dissenting Opinion</a></h1>
<p>This PEP has not been discussed on python-dev.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id22">References</a></h1>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>The Python Language Reference
<a class="reference external" href="http://docs.python.org/reference/">http://docs.python.org/reference/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="/dev/peps/pep-0236">PEP 236</a>, Back to the __future__, Peters
<a class="reference external" href="http://www.python.org/dev/peps/pep-0236/">http://www.python.org/dev/peps/pep-0236/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="/dev/peps/pep-0230">PEP 230</a>, Warning Framework, van Rossum
<a class="reference external" href="http://www.python.org/dev/peps/pep-0230/">http://www.python.org/dev/peps/pep-0230/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td><a class="reference external" href="/dev/peps/pep-0310">PEP 310</a>, Reliable Acquisition/Release Pairs, Hudson, Moore
<a class="reference external" href="http://www.python.org/dev/peps/pep-0310/">http://www.python.org/dev/peps/pep-0310/</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id23">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>

