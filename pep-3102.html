<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">3102</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Keyword-Only Arguments</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-3102.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Talin &lt;viridia&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">22-Apr-2006</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.0</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">28-Apr-2006, May-19-2006</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id2">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id3">Rationale</a></li>
<li><a class="reference internal" href="#specification" id="id4">Specification</a></li>
<li><a class="reference internal" href="#function-calling-behavior" id="id5">Function Calling Behavior</a></li>
<li><a class="reference internal" href="#backwards-compatibility" id="id6">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#copyright" id="id7">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id2">Abstract</a></h1>
<p>This PEP proposes a change to the way that function arguments are
assigned to named parameter slots.  In particular, it enables the
declaration of &quot;keyword-only&quot; arguments: arguments that can only
be supplied by keyword and which will never be automatically
filled in by a positional argument.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id3">Rationale</a></h1>
<p>The current Python function-calling paradigm allows arguments to
be specified either by position or by keyword.  An argument can be
filled in either explicitly by name, or implicitly by position.</p>
<p>There are often cases where it is desirable for a function to take
a variable number of arguments.  The Python language supports this
using the 'varargs' syntax (<tt class="docutils literal">*name</tt>), which specifies that any
'left over' arguments be passed into the varargs parameter as a
tuple.</p>
<p>One limitation on this is that currently, all of the regular
argument slots must be filled before the vararg slot can be.</p>
<p>This is not always desirable.  One can easily envision a function
which takes a variable number of arguments, but also takes one
or more 'options' in the form of keyword arguments.  Currently,
the only way to do this is to define both a varargs argument,
and a 'keywords' argument (<tt class="docutils literal">**kwargs</tt>), and then manually extract
the desired keywords from the dictionary.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id4">Specification</a></h1>
<p>Syntactically, the proposed changes are fairly simple.  The first
change is to allow regular arguments to appear after a varargs
argument:</p>
<pre class="literal-block">
def sortwords(*wordlist, case_sensitive=False):
    ...
</pre>
<p>This function accepts any number of positional arguments, and it
also accepts a keyword option called 'case_sensitive'.  This
option will never be filled in by a positional argument, but
must be explicitly specified by name.</p>
<p>Keyword-only arguments are not required to have a default value.
Since Python requires that all arguments be bound to a value,
and since the only way to bind a value to a keyword-only argument
is via keyword, such arguments are therefore 'required keyword'
arguments.  Such arguments must be supplied by the caller, and
they must be supplied via keyword.</p>
<p>The second syntactical change is to allow the argument name to
be omitted for a varargs argument. The meaning of this is to
allow for keyword-only arguments for functions that would not
otherwise take a varargs argument:</p>
<pre class="literal-block">
def compare(a, b, *, key=None):
    ...
</pre>
<p>The reasoning behind this change is as follows.  Imagine for a
moment a function which takes several positional arguments, as
well as a keyword argument:</p>
<pre class="literal-block">
def compare(a, b, key=None):
    ...
</pre>
<p>Now, suppose you wanted to have 'key' be a keyword-only argument.
Under the above syntax, you could accomplish this by adding a
varargs argument immediately before the keyword argument:</p>
<pre class="literal-block">
def compare(a, b, *ignore, key=None):
    ...
</pre>
<p>Unfortunately, the 'ignore' argument will also suck up any
erroneous positional arguments that may have been supplied by the
caller.  Given that we'd prefer any unwanted arguments to raise an
error, we could do this:</p>
<pre class="literal-block">
def compare(a, b, *ignore, key=None):
    if ignore:  # If ignore is not empty
        raise TypeError
</pre>
<p>As a convenient shortcut, we can simply omit the 'ignore' name,
meaning 'don't allow any positional arguments beyond this point'.</p>
<p>(Note: After much discussion of alternative syntax proposals, the
BDFL has pronounced in favor of this 'single star' syntax for
indicating the end of positional parameters.)</p>
</div>
<div class="section" id="function-calling-behavior">
<h1><a class="toc-backref" href="#id5">Function Calling Behavior</a></h1>
<p>The previous section describes the difference between the old
behavior and the new.  However, it is also useful to have a
description of the new behavior that stands by itself, without
reference to the previous model.  So this next section will
attempt to provide such a description.</p>
<p>When a function is called, the input arguments are assigned to
formal parameters as follows:</p>
<ul class="simple">
<li>For each formal parameter, there is a slot which will be used
to contain the value of the argument assigned to that
parameter.</li>
<li>Slots which have had values assigned to them are marked as
'filled'.  Slots which have no value assigned to them yet are
considered 'empty'.</li>
<li>Initially, all slots are marked as empty.</li>
<li>Positional arguments are assigned first, followed by keyword
arguments.</li>
<li>For each positional argument:<ul>
<li>Attempt to bind the argument to the first unfilled
parameter slot.  If the slot is not a vararg slot, then
mark the slot as 'filled'.</li>
<li>If the next unfilled slot is a vararg slot, and it does
not have a name, then it is an error.</li>
<li>Otherwise, if the next unfilled slot is a vararg slot then
all remaining non-keyword arguments are placed into the
vararg slot.</li>
</ul>
</li>
<li>For each keyword argument:<ul>
<li>If there is a parameter with the same name as the keyword,
then the argument value is assigned to that parameter slot.
However, if the parameter slot is already filled, then that
is an error.</li>
<li>Otherwise, if there is a 'keyword dictionary' argument,
the argument is added to the dictionary using the keyword
name as the dictionary key, unless there is already an
entry with that key, in which case it is an error.</li>
<li>Otherwise, if there is no keyword dictionary, and no
matching named parameter, then it is an error.</li>
</ul>
</li>
<li>Finally:<ul>
<li>If the vararg slot is not yet filled, assign an empty tuple
as its value.</li>
<li>For each remaining empty slot: if there is a default value
for that slot, then fill the slot with the default value.
If there is no default value, then it is an error.</li>
</ul>
</li>
</ul>
<p>In accordance with the current Python implementation, any errors
encountered will be signaled by raising <tt class="docutils literal">TypeError</tt>.  (If you want
something different, that's a subject for a different PEP.)</p>
</div>
<div class="section" id="backwards-compatibility">
<h1><a class="toc-backref" href="#id6">Backwards Compatibility</a></h1>
<p>The function calling behavior specified in this PEP is a superset
of the existing behavior - that is, it is expected that any
existing programs will continue to work.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id7">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

