<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">3117</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Postfix type declarations</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-3117.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Georg Brandl &lt;georg&#32;&#97;t&#32;python.org&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">01-Apr-2007</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.0</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id13">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id14">Rationale</a></li>
<li><a class="reference internal" href="#specification" id="id15">Specification</a></li>
<li><a class="reference internal" href="#unicode-replacement-units" id="id16">Unicode replacement units</a></li>
<li><a class="reference internal" href="#the-typedef-statement" id="id17">The <tt class="docutils literal">typedef</tt> statement</a></li>
<li><a class="reference internal" href="#example" id="id18">Example</a></li>
<li><a class="reference internal" href="#compatibility-issues" id="id19">Compatibility issues</a></li>
<li><a class="reference internal" href="#rejection" id="id20">Rejection</a></li>
<li><a class="reference internal" href="#references" id="id21">References</a></li>
<li><a class="reference internal" href="#acknowledgements" id="id22">Acknowledgements</a></li>
<li><a class="reference internal" href="#copyright" id="id23">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id13">Abstract</a></h1>
<p>This PEP proposes the addition of a postfix type declaration syntax to
Python. It also specifies a new <tt class="docutils literal">typedef</tt> statement which is used to create
new mappings between types and declarators.</p>
<p>Its acceptance will greatly enhance the Python user experience as well as
eliminate one of the warts that deter users of other programming languages from
switching to Python.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id14">Rationale</a></h1>
<p>Python has long suffered from the lack of explicit type declarations.  Being one
of the few aspects in which the language deviates from its Zen, this wart has
sparked many a discussion between Python heretics and members of the PSU (for
a few examples, see <a class="citation-reference" href="#ex1" id="id1">[EX1]</a>, <a class="citation-reference" href="#ex2" id="id2">[EX2]</a> or <a class="citation-reference" href="#ex3" id="id3">[EX3]</a>), and it also made it a large-scale
enterprise success unlikely.</p>
<p>However, if one wants to put an end to this misery, a decent Pythonic syntax
must be found. In almost all languages that have them, type declarations lack
this quality: they are verbose, often needing <em>multiple words</em> for a single
type, or they are hard to comprehend (e.g., a certain language uses completely
unrelated <a class="footnote-reference" href="#id9" id="id4">[1]</a> adjectives like <tt class="docutils literal">dim</tt> for type declaration).</p>
<p>Therefore, this PEP combines the move to type declarations with another bold
move that will once again prove that Python is not only future-proof but
future-embracing: the introduction of Unicode characters as an integral
constituent of source code.</p>
<p>Unicode makes it possible to express much more with much less characters, which
is in accordance with the Zen (&quot;Readability counts.&quot;) <a class="citation-reference" href="#zen" id="id5">[ZEN]</a>. Additionally, it
eliminates the need for a separate type declaration statement, and last but not
least, it makes Python measure up to Perl 6, which already uses Unicode for its
operators. <a class="footnote-reference" href="#id10" id="id6">[2]</a></p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id15">Specification</a></h1>
<p>When the type declaration mode is in operation, the grammar is changed so that
each <tt class="docutils literal">NAME</tt> must consist of two parts: a name and a type declarator, which is
exactly one Unicode character.</p>
<p>The declarator uniquely specifies the type of the name, and if it occurs on the
left hand side of an expression, this type is enforced: an <tt class="docutils literal">InquisitionError</tt>
exception is raised if the returned type doesn't match the declared type. <a class="footnote-reference" href="#id11" id="id7">[3]</a></p>
<p>Also, function call result types have to be specified. If the result of the call
does not have the declared type, an <tt class="docutils literal">InquisitionError</tt> is raised.  Caution: the
declarator for the result should not be confused with the declarator for the
function object (see the example below).</p>
<p>Type declarators after names that are only read, not assigned to, are not strictly
necessary but enforced anyway (see the Python Zen: &quot;Explicit is better than
implicit.&quot;).</p>
<p>The mapping between types and declarators is not static. It can be completely
customized by the programmer, but for convenience there are some predefined
mappings for some built-in types:</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Type</th>
<th class="head">Declarator</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">object</tt></td>
<td>� (REPLACEMENT CHARACTER)</td>
</tr>
<tr><td><tt class="docutils literal">int</tt></td>
<td>ℕ (DOUBLE-STRUCK CAPITAL N)</td>
</tr>
<tr><td><tt class="docutils literal">float</tt></td>
<td>℮ (ESTIMATED SYMBOL)</td>
</tr>
<tr><td><tt class="docutils literal">bool</tt></td>
<td>✓ (CHECK MARK)</td>
</tr>
<tr><td><tt class="docutils literal">complex</tt></td>
<td>ℂ (DOUBLE-STRUCK CAPITAL C)</td>
</tr>
<tr><td><tt class="docutils literal">str</tt></td>
<td>✎ (LOWER RIGHT PENCIL)</td>
</tr>
<tr><td><tt class="docutils literal">unicode</tt></td>
<td>✒ (BLACK NIB)</td>
</tr>
<tr><td><tt class="docutils literal">tuple</tt></td>
<td>⒯ (PARENTHESIZED LATIN SMALL LETTER T)</td>
</tr>
<tr><td><tt class="docutils literal">list</tt></td>
<td>♨ (HOT SPRINGS)</td>
</tr>
<tr><td><tt class="docutils literal">dict</tt></td>
<td>⧟ (DOUBLE-ENDED MULTIMAP)</td>
</tr>
<tr><td><tt class="docutils literal">set</tt></td>
<td>∅ (EMPTY SET) (<em>Note:</em> this is also for full sets)</td>
</tr>
<tr><td><tt class="docutils literal">frozenset</tt></td>
<td>☃ (SNOWMAN)</td>
</tr>
<tr><td><tt class="docutils literal">datetime</tt></td>
<td>⌚ (WATCH)</td>
</tr>
<tr><td><tt class="docutils literal">function</tt></td>
<td>ƛ (LATIN SMALL LETTER LAMBDA WITH STROKE)</td>
</tr>
<tr><td><tt class="docutils literal">generator</tt></td>
<td>⚛ (ATOM SYMBOL)</td>
</tr>
<tr><td><tt class="docutils literal">Exception</tt></td>
<td>⌁ (ELECTRIC ARROW)</td>
</tr>
</tbody>
</table>
<p>The declarator for the <tt class="docutils literal">None</tt> type is a zero-width space.</p>
<p>These characters should be obvious and easy to remember and type for every
programmer.</p>
</div>
<div class="section" id="unicode-replacement-units">
<h1><a class="toc-backref" href="#id16">Unicode replacement units</a></h1>
<p>Since even in our modern, globalized world there are still some old-fashioned
rebels who can't or don't want to use Unicode in their source code, and since
Python is a forgiving language, a fallback is provided for those:</p>
<p>Instead of the single Unicode character, they can type <tt class="docutils literal"><span class="pre">name${UNICODE</span> NAME OF
THE DECLARATOR}$</tt>. For example, these two function definitions are equivalent:</p>
<pre class="literal-block">
def fooƛ(xℂ):
    return None
</pre>
<p>and</p>
<pre class="literal-block">
def foo${LATIN SMALL LETTER LAMBDA WITH STROKE}$(x${DOUBLE-STRUCK CAPITAL C}$):
    return None${ZERO WIDTH NO-BREAK SPACE}$
</pre>
<p>This is still easy to read and makes the full power of type-annotated Python
available to ASCII believers.</p>
</div>
<div class="section" id="the-typedef-statement">
<h1><a class="toc-backref" href="#id17">The <tt class="docutils literal">typedef</tt> statement</a></h1>
<p>The mapping between types and declarators can be extended with this new statement.</p>
<p>The syntax is as follows:</p>
<pre class="literal-block">
typedef_stmt  ::=  &quot;typedef&quot; expr DECLARATOR
</pre>
<p>where <tt class="docutils literal">expr</tt> resolves to a type object. For convenience, the <tt class="docutils literal">typedef</tt> statement
can also be mixed with the <tt class="docutils literal">class</tt> statement for new classes, like so:</p>
<pre class="literal-block">
typedef class Foo☺(object�):
    pass
</pre>
</div>
<div class="section" id="example">
<h1><a class="toc-backref" href="#id18">Example</a></h1>
<p>This is the standard <tt class="docutils literal">os.path.normpath</tt> function, converted to type declaration
syntax:</p>
<pre class="literal-block">
def normpathƛ(path✎)✎:
    &quot;&quot;&quot;Normalize path, eliminating double slashes, etc.&quot;&quot;&quot;
    if path✎ == '':
        return '.'
    initial_slashes✓ = path✎.startswithƛ('/')✓
    # POSIX allows one or two initial slashes, but treats three or more
    # as single slash.
    if (initial_slashes✓ and
        path✎.startswithƛ('//')✓ and not path✎.startswithƛ('///')✓)✓:
        initial_slashesℕ = 2
    comps♨ = path✎.splitƛ('/')♨
    new_comps♨ = []♨
    for comp✎ in comps♨:
        if comp✎ in ('', '.')⒯:
            continue
        if (comp✎ != '..' or (not initial_slashesℕ and not new_comps♨)✓ or
             (new_comps♨ and new_comps♨[-1]✎ == '..')✓)✓:
            new_comps♨.appendƛ(comp✎)
        elif new_comps♨:
            new_comps♨.popƛ()✎
    comps♨ = new_comps♨
    path✎ = '/'.join(comps♨)✎
    if initial_slashesℕ:
        path✎ = '/'*initial_slashesℕ + path✎
    return path✎ or '.'
</pre>
<p>As you can clearly see, the type declarations add expressiveness, while at the
same time they make the code look much more professional.</p>
</div>
<div class="section" id="compatibility-issues">
<h1><a class="toc-backref" href="#id19">Compatibility issues</a></h1>
<p>To enable type declaration mode, one has to write:</p>
<pre class="literal-block">
from __future__ import type_declarations
</pre>
<p>which enables Unicode parsing of the source <a class="footnote-reference" href="#id12" id="id8">[4]</a>, makes <tt class="docutils literal">typedef</tt> a keyword
and enforces correct types for all assignments and function calls.</p>
</div>
<div class="section" id="rejection">
<h1><a class="toc-backref" href="#id20">Rejection</a></h1>
<p>After careful considering, much soul-searching, gnashing of teeth and rending
of garments, it has been decided to reject this PEP.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id21">References</a></h1>
<table class="docutils citation" frame="void" id="ex1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[EX1]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-list/2003-June/210588.html">https://mail.python.org/pipermail/python-list/2003-June/210588.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ex2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[EX2]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-list/2000-May/034685.html">https://mail.python.org/pipermail/python-list/2000-May/034685.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ex3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[EX3]</a></td><td><a class="reference external" href="http://groups.google.com/group/comp.lang.python/browse_frm/thread/6ae8c6add913635a/de40d4ffe9bd4304?lnk=gst&amp;q=type+declarations&amp;rnum=6">http://groups.google.com/group/comp.lang.python/browse_frm/thread/6ae8c6add913635a/de40d4ffe9bd4304?lnk=gst&amp;q=type+declarations&amp;rnum=6</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[1]</a></td><td>Though, if you know the language in question, it may not be <em>that</em> unrelated.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="zen" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[ZEN]</a></td><td><a class="reference external" href="http://www.python.org/dev/peps/pep-0020/">http://www.python.org/dev/peps/pep-0020/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[2]</a></td><td>Well, it would, if there was a Perl 6.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[3]</a></td><td>Since the name <tt class="docutils literal">TypeError</tt> is already in use, this name has been chosen
for obvious reasons.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[4]</a></td><td>The encoding in which the code is written is read from a standard coding
cookie. There will also be an autodetection mechanism, invoked by <tt class="docutils literal">from
__future__ import encoding_hell</tt>.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="acknowledgements">
<h1><a class="toc-backref" href="#id22">Acknowledgements</a></h1>
<p>Many thanks go to Armin Ronacher, Alexander Schremmer and Marek Kubica who helped
find the most suitable and mnemonic declarator for built-in types.</p>
<p>Thanks also to the Unicode Consortium for including all those useful characters
in the Unicode standard.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id23">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
coding: utf-8
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>

