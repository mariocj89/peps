<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">269</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Pgen Module for Python</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0269.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">jriehl&#32;&#97;t&#32;spaceship.com (Jonathan Riehl)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Deferred</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">24-Aug-2001</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.2</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id11">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id12">Rationale</a></li>
<li><a class="reference internal" href="#specification" id="id13">Specification</a><ul>
<li><a class="reference internal" href="#parsegrammarfile-filename-ast" id="id14"><tt class="docutils literal">parseGrammarFile (fileName) <span class="pre">-&gt;</span> AST</tt></a></li>
<li><a class="reference internal" href="#parsegrammarstring-text-ast" id="id15"><tt class="docutils literal">parseGrammarString (text) <span class="pre">-&gt;</span> AST</tt></a></li>
<li><a class="reference internal" href="#buildparser-grammarast-dfa" id="id16"><tt class="docutils literal">buildParser (grammarAst) <span class="pre">-&gt;</span> DFA</tt></a></li>
<li><a class="reference internal" href="#parsefile-filename-dfa-start-ast" id="id17"><tt class="docutils literal">parseFile (fileName, dfa, start) <span class="pre">-&gt;</span> AST</tt></a></li>
<li><a class="reference internal" href="#parsestring-text-dfa-start-ast" id="id18"><tt class="docutils literal">parseString (text, dfa, start) <span class="pre">-&gt;</span> AST</tt></a></li>
<li><a class="reference internal" href="#symboltostringmap-dfa-dict" id="id19"><tt class="docutils literal">symbolToStringMap (dfa) <span class="pre">-&gt;</span> dict</tt></a></li>
<li><a class="reference internal" href="#stringtosymbolmap-dfa-dict" id="id20"><tt class="docutils literal">stringToSymbolMap (dfa) <span class="pre">-&gt;</span> dict</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-plan" id="id21">Implementation Plan</a></li>
<li><a class="reference internal" href="#limitations" id="id22">Limitations</a></li>
<li><a class="reference internal" href="#reference-implementation" id="id23">Reference Implementation</a></li>
<li><a class="reference internal" href="#references" id="id24">References</a></li>
<li><a class="reference internal" href="#copyright" id="id25">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id11">Abstract</a></h1>
<p>Much like the <tt class="docutils literal">parser</tt> module exposes the Python parser, this PEP
proposes that the parser generator used to create the Python
parser, <tt class="docutils literal">pgen</tt>, be exposed as a module in Python.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id12">Rationale</a></h1>
<p>Through the course of Pythonic history, there have been numerous
discussions about the creation of a Python compiler <a class="footnote-reference" href="#id6" id="id1">[1]</a>.  These
have resulted in several implementations of Python parsers, most
notably the <tt class="docutils literal">parser</tt> module currently provided in the Python
standard library <a class="footnote-reference" href="#id7" id="id2">[2]</a> and Jeremy Hylton's <tt class="docutils literal">compiler</tt> module <a class="footnote-reference" href="#id8" id="id3">[3]</a>.
However, while multiple language changes have been proposed
<a class="footnote-reference" href="#id9" id="id4">[4]</a> <a class="footnote-reference" href="#id10" id="id5">[5]</a>, experimentation with the Python syntax has lacked the
benefit of a Python binding to the actual parser generator used to
build Python.</p>
<p>By providing a Python wrapper analogous to Fred Drake Jr.'s parser
wrapper, but targeted at the <tt class="docutils literal">pgen</tt> library, the following
assertions are made:</p>
<ol class="arabic simple">
<li>Reference implementations of syntax changes will be easier to
develop.  Currently, a reference implementation of a syntax
change would require the developer to use the <tt class="docutils literal">pgen</tt> tool from
the command line.  The resulting parser data structure would
then either have to be reworked to interface with a custom
CPython implementation, or wrapped as a C extension module.</li>
<li>Reference implementations of syntax changes will be easier to
distribute.  Since the parser generator will be available in
Python, it should follow that the resulting parser will
accessible from Python.  Therefore, reference implementations
should be available as pure Python code, versus using custom
versions of the existing CPython distribution, or as compilable
extension modules.</li>
<li>Reference implementations of syntax changes will be easier to
discuss with a larger audience.  This somewhat falls out of the
second assertion, since the community of Python users is most
likely larger than the community of CPython developers.</li>
<li>Development of small languages in Python will be further
enhanced, since the additional module will be a fully
functional LL(1) parser generator.</li>
</ol>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id13">Specification</a></h1>
<p>The proposed module will be called <tt class="docutils literal">pgen</tt>.  The <tt class="docutils literal">pgen</tt> module will
contain the following functions:</p>
<div class="section" id="parsegrammarfile-filename-ast">
<h2><a class="toc-backref" href="#id14"><tt class="docutils literal">parseGrammarFile (fileName) <span class="pre">-&gt;</span> AST</tt></a></h2>
<p>The <tt class="docutils literal">parseGrammarFile()</tt> function will read the file pointed to
by fileName and create an AST object.  The AST nodes will
contain the nonterminal, numeric values of the parser
generator meta-grammar.  The output AST will be an instance of
the AST extension class as provided by the <tt class="docutils literal">parser</tt> module.
Syntax errors in the input file will cause the SyntaxError
exception to be raised.</p>
</div>
<div class="section" id="parsegrammarstring-text-ast">
<h2><a class="toc-backref" href="#id15"><tt class="docutils literal">parseGrammarString (text) <span class="pre">-&gt;</span> AST</tt></a></h2>
<p>The <tt class="docutils literal">parseGrammarString()</tt> function will follow the semantics of
the <tt class="docutils literal">parseGrammarFile()</tt>, but accept the grammar text as a
string for input, as opposed to the file name.</p>
</div>
<div class="section" id="buildparser-grammarast-dfa">
<h2><a class="toc-backref" href="#id16"><tt class="docutils literal">buildParser (grammarAst) <span class="pre">-&gt;</span> DFA</tt></a></h2>
<p>The <tt class="docutils literal">buildParser()</tt> function will accept an AST object for input
and return a DFA (deterministic finite automaton) data
structure.  The DFA data structure will be a C extension
class, much like the AST structure is provided in the <tt class="docutils literal">parser</tt>
module.  If the input AST does not conform to the nonterminal
codes defined for the <tt class="docutils literal">pgen</tt> meta-grammar, <tt class="docutils literal">buildParser()</tt> will
throw a <tt class="docutils literal">ValueError</tt> exception.</p>
</div>
<div class="section" id="parsefile-filename-dfa-start-ast">
<h2><a class="toc-backref" href="#id17"><tt class="docutils literal">parseFile (fileName, dfa, start) <span class="pre">-&gt;</span> AST</tt></a></h2>
<p>The <tt class="docutils literal">parseFile()</tt> function will essentially be a wrapper for the
<tt class="docutils literal">PyParser_ParseFile()</tt> C API function.  The wrapper code will
accept the DFA C extension class, and the file name.  An AST
instance that conforms to the lexical values in the <tt class="docutils literal">token</tt>
module and the nonterminal values contained in the DFA will be
output.</p>
</div>
<div class="section" id="parsestring-text-dfa-start-ast">
<h2><a class="toc-backref" href="#id18"><tt class="docutils literal">parseString (text, dfa, start) <span class="pre">-&gt;</span> AST</tt></a></h2>
<p>The <tt class="docutils literal">parseString()</tt> function will operate in a similar fashion
to the <tt class="docutils literal">parseFile()</tt> function, but accept the parse text as an
argument.  Much like <tt class="docutils literal">parseFile()</tt> will wrap the
<tt class="docutils literal">PyParser_ParseFile()</tt> C API function, <tt class="docutils literal">parseString()</tt> will wrap
the <tt class="docutils literal">PyParser_ParseString()</tt> function.</p>
</div>
<div class="section" id="symboltostringmap-dfa-dict">
<h2><a class="toc-backref" href="#id19"><tt class="docutils literal">symbolToStringMap (dfa) <span class="pre">-&gt;</span> dict</tt></a></h2>
<p>The <tt class="docutils literal">symbolToStringMap()</tt> function will accept a DFA instance
and return a dictionary object that maps from the DFA's
numeric values for its nonterminals to the string names of the
nonterminals as found in the original grammar specification
for the DFA.</p>
</div>
<div class="section" id="stringtosymbolmap-dfa-dict">
<h2><a class="toc-backref" href="#id20"><tt class="docutils literal">stringToSymbolMap (dfa) <span class="pre">-&gt;</span> dict</tt></a></h2>
<p>The <tt class="docutils literal">stringToSymbolMap()</tt> function output a dictionary mapping
the nonterminal names of the input DFA to their corresponding
numeric values.</p>
<p>Extra credit will be awarded if the map generation functions and
parsing functions are also methods of the DFA extension class.</p>
</div>
</div>
<div class="section" id="implementation-plan">
<h1><a class="toc-backref" href="#id21">Implementation Plan</a></h1>
<p>A cunning plan has been devised to accomplish this enhancement:</p>
<ol class="arabic simple">
<li>Rename the <tt class="docutils literal">pgen</tt> functions to conform to the CPython naming
standards.  This action may involve adding some header files to
the <tt class="docutils literal">Include</tt> subdirectory.</li>
<li>Move the <tt class="docutils literal">pgen</tt> C modules in the Makefile.pre.in from unique <tt class="docutils literal">pgen</tt>
elements to the Python C library.</li>
<li>Make any needed changes to the <tt class="docutils literal">parser</tt> module so the AST
extension class understands that there are AST types it may not
understand.  Cursory examination of the AST extension class
shows that it keeps track of whether the tree is a suite or an
expression.</li>
</ol>
<ol class="arabic simple" start="3">
<li>Code an additional C module in the <tt class="docutils literal">Modules</tt> directory.  The C
extension module will implement the DFA extension class and the
functions outlined in the previous section.</li>
<li>Add the new module to the build process.  Black magic, indeed.</li>
</ol>
</div>
<div class="section" id="limitations">
<h1><a class="toc-backref" href="#id22">Limitations</a></h1>
<p>Under this proposal, would be designers of Python 3000 will still
be constrained to Python's lexical conventions.  The addition,
subtraction or modification of the Python lexer is outside the
scope of this PEP.</p>
</div>
<div class="section" id="reference-implementation">
<h1><a class="toc-backref" href="#id23">Reference Implementation</a></h1>
<p>No reference implementation is currently provided. A patch
was provided at some point in
<a class="reference external" href="http://sourceforge.net/tracker/index.php?func=detail&amp;aid=599331&amp;group_id=5470&amp;atid=305470">http://sourceforge.net/tracker/index.php?func=detail&amp;aid=599331&amp;group_id=5470&amp;atid=305470</a>
but that patch is no longer maintained.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id24">References</a></h1>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>The (defunct) Python Compiler-SIG
<a class="reference external" href="http://www.python.org/sigs/compiler-sig/">http://www.python.org/sigs/compiler-sig/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Parser Module Documentation
<a class="reference external" href="http://docs.python.org/library/parser.html">http://docs.python.org/library/parser.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>Hylton, Jeremy.
<a class="reference external" href="http://docs.python.org/library/compiler.html">http://docs.python.org/library/compiler.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>Pelletier, Michel. &quot;Python Interface Syntax&quot;, PEP-245.
<a class="reference external" href="http://www.python.org/dev/peps/pep-0245/">http://www.python.org/dev/peps/pep-0245/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>The Python Types-SIG
<a class="reference external" href="http://www.python.org/sigs/types-sig/">http://www.python.org/sigs/types-sig/</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id25">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
fill-column: 70
End: -->
</div>

