<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">316</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Programming by Contract for Python</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0316.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Terence Way &lt;terry&#32;&#97;t&#32;wayforward.net&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Deferred</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">02-May-2003</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id10">Abstract</a></li>
<li><a class="reference internal" href="#motivation" id="id11">Motivation</a></li>
<li><a class="reference internal" href="#specification" id="id12">Specification</a><ul>
<li><a class="reference internal" href="#exceptions" id="id13">Exceptions</a></li>
<li><a class="reference internal" href="#inheritance" id="id14">Inheritance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rationale" id="id15">Rationale</a></li>
<li><a class="reference internal" href="#reference-implementation" id="id16">Reference Implementation</a></li>
<li><a class="reference internal" href="#references" id="id17">References</a></li>
<li><a class="reference internal" href="#copyright" id="id18">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id10">Abstract</a></h1>
<p>This submission describes programming by contract for Python.
Eiffel's Design By Contract(tm) is perhaps the most popular use of
programming contracts <a class="footnote-reference" href="#dbc" id="id1">[2]</a>.</p>
<p>Programming contracts extends the language to include invariant
expressions for classes and modules, and pre- and post-condition
expressions for functions and methods.</p>
<p>These expressions (contracts) are similar to assertions: they must be
true or the program is stopped, and run-time checking of the contracts
is typically only enabled while debugging.  Contracts are higher-level
than straight assertions and are typically included in documentation.</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id11">Motivation</a></h1>
<p>Python already has assertions, why add extra stuff to the language to
support something like contracts?  The two best reasons are 1) better,
more accurate documentation, and 2) easier testing.</p>
<p>Complex modules and classes never seem to be documented quite right.
The documentation provided may be enough to convince a programmer to
use a particular module or class over another, but the programmer
almost always has to read the source code when the real debugging
starts.</p>
<p>Contracts extend the excellent example provided by the <tt class="docutils literal">doctest</tt>
module <a class="footnote-reference" href="#doctest" id="id2">[4]</a>.  Documentation is readable by programmers, yet has
executable tests embedded in it.</p>
<p>Testing code with contracts is easier too.  Comprehensive contracts
are equivalent to unit tests <a class="footnote-reference" href="#xp" id="id3">[8]</a>.  Tests exercise the full range of
pre-conditions, and fail if the post-conditions are triggered.
Theoretically, a correctly specified function can be tested completely
randomly.</p>
<p>So why add this to the language?  Why not have several different
implementations, or let programmers implement their own assertions?
The answer is the behavior of contracts under inheritance.</p>
<p>Suppose Alice and Bob use different assertions packages.  If Alice
produces a class library protected by assertions, Bob cannot derive
classes from Alice's library and expect proper checking of
post-conditions and invariants.  If they both use the same assertions
package, then Bob can override Alice's methods yet still test against
Alice's contract assertions.  The natural place to find this
assertions system is in the language's run-time library.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id12">Specification</a></h1>
<p>The docstring of any module or class can include invariant contracts
marked off with a line that starts with the keyword <tt class="docutils literal">inv</tt> followed
by a colon (:).  Whitespace at the start of the line and around the
colon is ignored.  The colon is either immediately followed by a
single expression on the same line, or by a series of expressions on
following lines indented past the <tt class="docutils literal">inv</tt> keyword.  The normal Python
rules about implicit and explicit line continuations are followed
here.  Any number of invariant contracts can be in a docstring.</p>
<p>Some examples:</p>
<pre class="literal-block">
# state enumeration
START, CONNECTING, CONNECTED, CLOSING, CLOSED = range(5)

class conn:

    &quot;&quot;&quot;A network connection

    inv: self.state in [START, CLOSED,       # closed states
                        CONNECTING, CLOSING, # transition states
                        CONNECTED]

    inv: 0 &lt;= self.seqno &lt; 256
    &quot;&quot;&quot;

class circbuf:

    &quot;&quot;&quot;A circular buffer.

    inv:
        # there can be from 0 to max items on the buffer
        0 &lt;= self.len &lt;= len(self.buf)

        # g is a valid index into buf
        0 &lt;= self.g &lt; len(self.buf)

        # p is also a valid index into buf
        0 &lt;= self.p &lt; len(self.buf)

        # there are len items between get and put
        (self.p - self.g) % len(self.buf) == \
              self.len % len(self.buf)
    &quot;&quot;&quot;
</pre>
<p>Module invariants must be true after the module is loaded, and at the
entry and exit of every public function within the module.</p>
<p>Class invariants must be true after the <tt class="docutils literal">__init__</tt> function returns,
at the entry of the <tt class="docutils literal">__del__</tt> function, and at the entry and exit of
every other public method of the class.  Class invariants must use the
self variable to access instance variables.</p>
<p>A method or function is public if its name doesn't start with an
underscore (_), unless it starts and ends with '__' (two underscores).</p>
<p>The docstring of any function or method can have pre-conditions
documented with the keyword <tt class="docutils literal">pre</tt> following the same rules above.
Post-conditions are documented with the keyword <tt class="docutils literal">post</tt> optionally
followed by a list of variables.  The variables are in the same scope
as the body of the function or method.  This list declares the
variables that the function/method is allowed to modify.</p>
<p>An example:</p>
<pre class="literal-block">
class circbuf:

    def __init__(self, leng):
        &quot;&quot;&quot;Construct an empty circular buffer.

        pre: leng &gt; 0
        post[self]:
            self.is_empty()
            len(self.buf) == leng
        &quot;&quot;&quot;
</pre>
<p>A double-colon (::) can be used instead of a single colon (:) to
support docstrings written using reStructuredText <a class="footnote-reference" href="#rst" id="id4">[7]</a>.  For
example, the following two docstrings describe the same contract:</p>
<pre class="literal-block">
&quot;&quot;&quot;pre: leng &gt; 0&quot;&quot;&quot;
&quot;&quot;&quot;pre:: leng &gt; 0&quot;&quot;&quot;
</pre>
<p>Expressions in pre- and post-conditions are defined in the module
namespace -- they have access to nearly all the variables that the
function can access, except closure variables.</p>
<p>The contract expressions in post-conditions have access to two
additional variables: <tt class="docutils literal">__old__</tt> which is filled with shallow copies
of values declared in the variable list immediately following the post
keyword, and <tt class="docutils literal">__return__</tt> which is bound to the return value of the
function or method.</p>
<p>An example:</p>
<pre class="literal-block">
class circbuf:

    def get(self):
        &quot;&quot;&quot;Pull an entry from a non-empty circular buffer.

        pre: not self.is_empty()
        post[self.g, self.len]:
            __return__ == self.buf[__old__.self.g]
            self.len == __old__.self.len - 1
        &quot;&quot;&quot;
</pre>
<p>All contract expressions have access to some additional convenience
functions.  To make evaluating the truth of sequences easier, two
functions <tt class="docutils literal">forall</tt> and <tt class="docutils literal">exists</tt> are defined as:</p>
<pre class="literal-block">
def forall(a, fn = bool):
    &quot;&quot;&quot;Return True only if all elements in a are true.

    &gt;&gt;&gt; forall([])
    1
    &gt;&gt;&gt; even = lambda x: x % 2 == 0
    &gt;&gt;&gt; forall([2, 4, 6, 8], even)
    1
    &gt;&gt;&gt; forall('this is a test'.split(), lambda x: len(x) == 4)
    0
    &quot;&quot;&quot;

def exists(a, fn = bool):
    &quot;&quot;&quot;Returns True if there is at least one true value in a.

    &gt;&gt;&gt; exists([])
    0
    &gt;&gt;&gt; exists('this is a test'.split(), lambda x: len(x) == 4)
    1
    &quot;&quot;&quot;
</pre>
<p>An example:</p>
<pre class="literal-block">
def sort(a):
    &quot;&quot;&quot;Sort a list.

    pre: isinstance(a, type(list))
    post[a]:
        # array size is unchanged
        len(a) == len(__old__.a)

        # array is ordered
        forall([a[i] &gt;= a[i-1] for i in range(1, len(a))])

        # all the old elements are still in the array
        forall(__old__.a, lambda e: __old__.a.count(e) == a.count(e))
    &quot;&quot;&quot;
</pre>
<p>To make evaluating conditions easier, the function <tt class="docutils literal">implies</tt> is
defined.  With two arguments, this is similar to the logical implies
(=&gt;) operator.  With three arguments, this is similar to C's
conditional expression (x?a:b).  This is defined as:</p>
<pre class="literal-block">
implies(False, a) =&gt; True
implies(True, a) =&gt; a
implies(False, a, b) =&gt; b
implies(True, a, b) =&gt; a
</pre>
<p>On entry to a function, the function's pre-conditions are checked.  An
assertion error is raised if any pre-condition is false.  If the
function is public, then the class or module's invariants are also
checked.  Copies of variables declared in the post are saved, the
function is called, and if the function exits without raising an
exception, the post-conditions are checked.</p>
<div class="section" id="exceptions">
<h2><a class="toc-backref" href="#id13">Exceptions</a></h2>
<p>Class/module invariants are checked even if a function or method exits
by signalling an exception (post-conditions are not).</p>
<p>All failed contracts raise exceptions which are subclasses of the
<tt class="docutils literal">ContractViolationError</tt> exception, which is in turn a subclass of the
<tt class="docutils literal">AssertionError</tt> exception.  Failed pre-conditions raise a
<tt class="docutils literal">PreconditionViolationError</tt> exception.  Failed post-conditions raise
a <tt class="docutils literal">PostconditionViolationError</tt> exception, and failed invariants raise
a <tt class="docutils literal">InvariantViolationError</tt> exception.</p>
<p>The class hierarchy:</p>
<pre class="literal-block">
AssertionError
    ContractViolationError
        PreconditionViolationError
        PostconditionViolationError
        InvariantViolationError
        InvalidPreconditionError
</pre>
<p>The <tt class="docutils literal">InvalidPreconditionError</tt> is raised when pre-conditions are
illegally strengthened, see the next section on Inheritance.</p>
<p>Example:</p>
<pre class="literal-block">
try:
    some_func()
except contract.PreconditionViolationError:
    # failed pre-condition, ok
    pass
</pre>
</div>
<div class="section" id="inheritance">
<h2><a class="toc-backref" href="#id14">Inheritance</a></h2>
<p>A class's invariants include all the invariants for all super-classes
(class invariants are ANDed with super-class invariants).  These
invariants are checked in method-resolution order.</p>
<p>A method's post-conditions also include all overridden post-conditions
(method post-conditions are ANDed with all overridden method
post-conditions).</p>
<p>An overridden method's pre-conditions can be ignored if the overriding
method's pre-conditions are met.  However, if the overriding method's
pre-conditions fail, <em>all</em> of the overridden method's pre-conditions
must also fail.  If not, a separate exception is raised, the
InvalidPreconditionError.  This supports weakening pre-conditions.</p>
<p>A somewhat contrived example:</p>
<pre class="literal-block">
class SimpleMailClient:

    def send(self, msg, dest):
        &quot;&quot;&quot;Sends a message to a destination:

        pre: self.is_open() # we must have an open connection
        &quot;&quot;&quot;

    def recv(self):
        &quot;&quot;&quot;Gets the next unread mail message.

        Returns None if no message is available.

        pre: self.is_open() # we must have an open connection
        post: __return__ == None or isinstance(__return__, Message)
        &quot;&quot;&quot;

 class ComplexMailClient(SimpleMailClient):
    def send(self, msg, dest):
        &quot;&quot;&quot;Sends a message to a destination.

        The message is sent immediately if currently connected.
        Otherwise, the message is queued locally until a
        connection is made.

        pre: True # weakens the pre-condition from SimpleMailClient
        &quot;&quot;&quot;

    def recv(self):
        &quot;&quot;&quot;Gets the next unread mail message.

        Waits until a message is available.

        pre: True # can always be called
        post: isinstance(__return__, Message)
        &quot;&quot;&quot;
</pre>
<p>Because pre-conditions can only be weakened, a <tt class="docutils literal">ComplexMailClient</tt> can
replace a <tt class="docutils literal">SimpleMailClient</tt> with no fear of breaking existing code.</p>
</div>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id15">Rationale</a></h1>
<p>Except for the following differences, programming-by-contract for
Python mirrors the Eiffel DBC specification <a class="footnote-reference" href="#oosc" id="id5">[3]</a>.</p>
<p>Embedding contracts in docstrings is patterned after the doctest
module.  It removes the need for extra syntax, ensures that programs
with contracts are backwards-compatible, and no further work is
necessary to have the contracts included in the docs.</p>
<p>The keywords <tt class="docutils literal">pre</tt>, <tt class="docutils literal">post</tt>, and <tt class="docutils literal">inv</tt> were chosen instead of the
Eiffel-style <tt class="docutils literal">REQUIRE</tt>, <tt class="docutils literal">ENSURE</tt>, and <tt class="docutils literal">INVARIANT</tt> because
they're shorter, more in line with mathematical notation, and for a
more subtle reason: the word 'require' implies caller
responsibilities, while 'ensure' implies provider guarantees.  Yet
pre-conditions can fail through no fault of the caller when using
multiple inheritance, and post-conditions can fail through no fault of
the function when using multiple threads.</p>
<p>Loop invariants as used in Eiffel are unsupported.  They're a pain to
implement, and not part of the documentation anyway.</p>
<p>The variable names <tt class="docutils literal">__old__</tt> and <tt class="docutils literal">__return__</tt> were picked to avoid
conflicts with the <tt class="docutils literal">return</tt> keyword and to stay consistent with
Python naming conventions: they're public and provided by the Python
implementation.</p>
<p>Having variable declarations after a post keyword describes exactly
what the function or method is allowed to modify.  This removes the
need for the <tt class="docutils literal">NoChange</tt> syntax in Eiffel, and makes the
implementation of <tt class="docutils literal">__old__</tt> much easier.  It also is more in line
with Z schemas <a class="footnote-reference" href="#z" id="id6">[9]</a>, which are divided into two parts: declaring what
changes followed by limiting the changes.</p>
<p>Shallow copies of variables for the <tt class="docutils literal">__old__</tt> value prevent an
implementation of contract programming from slowing down a system too
much.  If a function changes values that wouldn't be caught by a
shallow copy, it can declare the changes like so:</p>
<pre class="literal-block">
post[self, self.obj, self.obj.p]
</pre>
<p>The <tt class="docutils literal">forall</tt>, <tt class="docutils literal">exists</tt>, and <tt class="docutils literal">implies</tt> functions were added after
spending some time documenting existing functions with contracts.
These capture a majority of common specification idioms.  It might
seem that defining <tt class="docutils literal">implies</tt> as a function might not work (the
arguments are evaluated whether needed or not, in contrast with other
boolean operators), but it works for contracts since there should be
no side-effects for any expression in a contract.</p>
</div>
<div class="section" id="reference-implementation">
<h1><a class="toc-backref" href="#id16">Reference Implementation</a></h1>
<p>A reference implementation is available <a class="footnote-reference" href="#imp" id="id7">[1]</a>.  It replaces existing
functions with new functions that do contract checking, by directly
changing the class' or module's namespace.</p>
<p>Other implementations exist that either hack <tt class="docutils literal">__getattr__</tt> <a class="footnote-reference" href="#dbc4p" id="id8">[5]</a>
or use <tt class="docutils literal">__metaclass__</tt> <a class="footnote-reference" href="#pydbc" id="id9">[6]</a>.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id17">References</a></h1>
<table class="docutils footnote" frame="void" id="imp" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[1]</a></td><td>Implementation described in this document.
(<a class="reference external" href="http://www.wayforward.net/pycontract/">http://www.wayforward.net/pycontract/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="dbc" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[2]</a></td><td>Design By Contract is a registered trademark of Eiffel
Software Inc.
(<a class="reference external" href="http://archive.eiffel.com/doc/manuals/technology/contract/">http://archive.eiffel.com/doc/manuals/technology/contract/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="oosc" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[3]</a></td><td>Object-oriented Software Construction,  Bertrand Meyer,
ISBN 0-13-629031-0</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="doctest" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[4]</a></td><td><a class="reference external" href="http://docs.python.org/library/doctest.html">http://docs.python.org/library/doctest.html</a>
doctest -- Test docstrings represent reality</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="dbc4p" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[5]</a></td><td>Design by Contract for Python, R. Plosch
<em>IEEE Proceedings of the Joint Asia Pacific Software Engineering
Conference (APSEC97/ICSC97), Hong Kong, December 2-5, 1997</em>
(<a class="reference external" href="http://www.swe.uni-linz.ac.at/publications/abstract/TR-SE-97.24.html">http://www.swe.uni-linz.ac.at/publications/abstract/TR-SE-97.24.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="pydbc" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[6]</a></td><td>PyDBC -- Design by Contract for Python 2.2+,
Daniel Arbuckle
(<a class="reference external" href="http://www.nongnu.org/pydbc/">http://www.nongnu.org/pydbc/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="rst" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[7]</a></td><td>ReStructuredText (<a class="reference external" href="http://docutils.sourceforge.net/rst.html">http://docutils.sourceforge.net/rst.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="xp" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[8]</a></td><td>Extreme Programming Explained, Kent Beck,
ISBN 0-201-61641-6</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="z" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[9]</a></td><td>The Z Notation, Second Edition, J.M. Spivey
ISBN 0-13-978529-9</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id18">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>

