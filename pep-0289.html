<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">289</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Generator Expressions</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0289.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">python&#32;&#97;t&#32;rcn.com (Raymond Hettinger)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">30-Jan-2002</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.4</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">22-Oct-2003</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id13">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id14">Rationale</a></li>
<li><a class="reference internal" href="#bdfl-pronouncements" id="id15">BDFL Pronouncements</a></li>
<li><a class="reference internal" href="#the-details" id="id16">The Details</a></li>
<li><a class="reference internal" href="#early-binding-versus-late-binding" id="id17">Early Binding versus Late Binding</a></li>
<li><a class="reference internal" href="#reduction-functions" id="id18">Reduction Functions</a></li>
<li><a class="reference internal" href="#acknowledgements" id="id19">Acknowledgements</a></li>
<li><a class="reference internal" href="#references" id="id20">References</a></li>
<li><a class="reference internal" href="#copyright" id="id21">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id13">Abstract</a></h1>
<p>This PEP introduces generator expressions as a high performance,
memory efficient generalization of list comprehensions <a class="footnote-reference" href="#id7" id="id1">[1]</a> and
generators <a class="footnote-reference" href="#id8" id="id2">[2]</a>.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id14">Rationale</a></h1>
<p>Experience with list comprehensions has shown their widespread
utility throughout Python.  However, many of the use cases do
not need to have a full list created in memory.  Instead, they
only need to iterate over the elements one at a time.</p>
<p>For instance, the following summation code will build a full list of
squares in memory, iterate over those values, and, when the reference
is no longer needed, delete the list:</p>
<pre class="literal-block">
sum([x*x for x in range(10)])
</pre>
<p>Memory is conserved by using a generator expression instead:</p>
<pre class="literal-block">
sum(x*x for x in range(10))
</pre>
<p>Similar benefits are conferred on constructors for container objects:</p>
<pre class="literal-block">
s = set(word  for line in page  for word in line.split())
d = dict( (k, func(k)) for k in keylist)
</pre>
<p>Generator expressions are especially useful with functions like sum(),
min(), and max() that reduce an iterable input to a single value:</p>
<pre class="literal-block">
max(len(line)  for line in file  if line.strip())
</pre>
<p>Generator expressions also address some examples of functionals coded
with lambda:</p>
<pre class="literal-block">
reduce(lambda s, a: s + a.myattr, data, 0)
reduce(lambda s, a: s + a[3], data, 0)
</pre>
<p>These simplify to:</p>
<pre class="literal-block">
sum(a.myattr for a in data)
sum(a[3] for a in data)
</pre>
<p>List comprehensions greatly reduced the need for filter() and map().
Likewise, generator expressions are expected to minimize the need
for itertools.ifilter() and itertools.imap().  In contrast, the
utility of other itertools will be enhanced by generator expressions:</p>
<pre class="literal-block">
dotproduct = sum(x*y for x,y in itertools.izip(x_vector, y_vector))
</pre>
<p>Having a syntax similar to list comprehensions also makes it easy to
convert existing code into a generator expression when scaling up
application.</p>
<p>Early timings showed that generators had a significant performance
advantage over list comprehensions.  However, the latter were highly
optimized for Py2.4 and now the performance is roughly comparable
for small to mid-sized data sets.  As the data volumes grow larger,
generator expressions tend to perform better because they do not
exhaust cache memory and they allow Python to re-use objects between
iterations.</p>
</div>
<div class="section" id="bdfl-pronouncements">
<h1><a class="toc-backref" href="#id15">BDFL Pronouncements</a></h1>
<p>This PEP is ACCEPTED for Py2.4.</p>
</div>
<div class="section" id="the-details">
<h1><a class="toc-backref" href="#id16">The Details</a></h1>
<p>(None of this is exact enough in the eye of a reader from Mars, but I
hope the examples convey the intention well enough for a discussion in
c.l.py.  The Python Reference Manual should contain a 100% exact
semantic and syntactic specification.)</p>
<ol class="arabic">
<li><p class="first">The semantics of a generator expression are equivalent to creating
an anonymous generator function and calling it.  For example:</p>
<pre class="literal-block">
g = (x**2 for x in range(10))
print g.next()
</pre>
<p>is equivalent to:</p>
<pre class="literal-block">
def __gen(exp):
    for x in exp:
        yield x**2
g = __gen(iter(range(10)))
print g.next()
</pre>
<p>Only the outermost for-expression is evaluated immediately, the other
expressions are deferred until the generator is run:</p>
<pre class="literal-block">
g = (tgtexp  for var1 in exp1 if exp2 for var2 in exp3 if exp4)
</pre>
<p>is equivalent to:</p>
<pre class="literal-block">
def __gen(bound_exp):
    for var1 in bound_exp:
        if exp2:
            for var2 in exp3:
                if exp4:
                    yield tgtexp
g = __gen(iter(exp1))
del __gen
</pre>
</li>
<li><p class="first">The syntax requires that a generator expression always needs to be
directly inside a set of parentheses and cannot have a comma on
either side.  With reference to the file Grammar/Grammar in CVS,
two rules change:</p>
<ol class="loweralpha">
<li><p class="first">The rule:</p>
<pre class="literal-block">
atom: '(' [testlist] ')'
</pre>
<p>changes to:</p>
<pre class="literal-block">
atom: '(' [testlist_gexp] ')'
</pre>
<p>where testlist_gexp is almost the same as listmaker, but only
allows a single test after 'for' ... 'in':</p>
<pre class="literal-block">
testlist_gexp: test ( gen_for | (',' test)* [','] )
</pre>
</li>
<li><p class="first">The rule for arglist needs similar changes.</p>
</li>
</ol>
<p>This means that you can write:</p>
<pre class="literal-block">
sum(x**2 for x in range(10))
</pre>
<p>but you would have to write:</p>
<pre class="literal-block">
reduce(operator.add, (x**2 for x in range(10)))
</pre>
<p>and also:</p>
<pre class="literal-block">
g = (x**2 for x in range(10))
</pre>
<p>i.e. if a function call has a single positional argument, it can be
a generator expression without extra parentheses, but in all other
cases you have to parenthesize it.</p>
<p>The exact details were checked in to Grammar/Grammar version 1.49.</p>
</li>
<li><p class="first">The loop variable (if it is a simple variable or a tuple of simple
variables) is not exposed to the surrounding function.  This
facilitates the implementation and makes typical use cases more
reliable.  In some future version of Python, list comprehensions
will also hide the induction variable from the surrounding code
(and, in Py2.4, warnings will be issued for code accessing the
induction variable).</p>
<p>For example:</p>
<pre class="literal-block">
x = &quot;hello&quot;
y = list(x for x in &quot;abc&quot;)
print x    # prints &quot;hello&quot;, not &quot;c&quot;
</pre>
</li>
<li><p class="first">List comprehensions will remain unchanged.  For example:</p>
<pre class="literal-block">
[x for x in S]    # This is a list comprehension.
[(x for x in S)]  # This is a list containing one generator
                  # expression.
</pre>
<p>Unfortunately, there is currently a slight syntactic difference.
The expression:</p>
<pre class="literal-block">
[x for x in 1, 2, 3]
</pre>
<p>is legal, meaning:</p>
<pre class="literal-block">
[x for x in (1, 2, 3)]
</pre>
<p>But generator expressions will not allow the former version:</p>
<pre class="literal-block">
(x for x in 1, 2, 3)
</pre>
<p>is illegal.</p>
<p>The former list comprehension syntax will become illegal in Python
3.0, and should be deprecated in Python 2.4 and beyond.</p>
<p>List comprehensions also &quot;leak&quot; their loop variable into the
surrounding scope.  This will also change in Python 3.0, so that
the semantic definition of a list comprehension in Python 3.0 will
be equivalent to list(&lt;generator expression&gt;).  Python 2.4 and
beyond should issue a deprecation warning if a list comprehension's
loop variable has the same name as a variable used in the
immediately surrounding scope.</p>
</li>
</ol>
</div>
<div class="section" id="early-binding-versus-late-binding">
<h1><a class="toc-backref" href="#id17">Early Binding versus Late Binding</a></h1>
<p>After much discussion, it was decided that the first (outermost)
for-expression should be evaluated immediately and that the remaining
expressions be evaluated when the generator is executed.</p>
<p>Asked to summarize the reasoning for binding the first expression,
Guido offered <a class="footnote-reference" href="#id11" id="id3">[5]</a>:</p>
<pre class="literal-block">
Consider sum(x for x in foo()). Now suppose there's a bug in foo()
that raises an exception, and a bug in sum() that raises an
exception before it starts iterating over its argument. Which
exception would you expect to see? I'd be surprised if the one in
sum() was raised rather the one in foo(), since the call to foo()
is part of the argument to sum(), and I expect arguments to be
processed before the function is called.

OTOH, in sum(bar(x) for x in foo()), where sum() and foo()
are bugfree, but bar() raises an exception, we have no choice but
to delay the call to bar() until sum() starts iterating -- that's
part of the contract of generators. (They do nothing until their
next() method is first called.)
</pre>
<p>Various use cases were proposed for binding all free variables when
the generator is defined.  And some proponents felt that the resulting
expressions would be easier to understand and debug if bound immediately.</p>
<p>However, Python takes a late binding approach to lambda expressions and
has no precedent for automatic, early binding.  It was felt that
introducing a new paradigm would unnecessarily introduce complexity.</p>
<p>After exploring many possibilities, a consensus emerged that binding
issues were hard to understand and that users should be strongly
encouraged to use generator expressions inside functions that consume
their arguments immediately.  For more complex applications, full
generator definitions are always superior in terms of being obvious
about scope, lifetime, and binding <a class="footnote-reference" href="#id12" id="id4">[6]</a>.</p>
</div>
<div class="section" id="reduction-functions">
<h1><a class="toc-backref" href="#id18">Reduction Functions</a></h1>
<p>The utility of generator expressions is greatly enhanced when combined
with reduction functions like sum(), min(), and max().  The heapq
module in Python 2.4 includes two new reduction functions: nlargest()
and nsmallest().  Both work well with generator expressions and keep
no more than n items in memory at one time.</p>
</div>
<div class="section" id="acknowledgements">
<h1><a class="toc-backref" href="#id19">Acknowledgements</a></h1>
<ul class="simple">
<li>Raymond Hettinger first proposed the idea of &quot;generator
comprehensions&quot; in January 2002.</li>
<li>Peter Norvig resurrected the discussion in his proposal for
Accumulation Displays.</li>
<li>Alex Martelli provided critical measurements that proved the
performance benefits of generator expressions.  He also provided
strong arguments that they were a desirable thing to have.</li>
<li>Phillip Eby suggested &quot;iterator expressions&quot; as the name.</li>
<li>Subsequently, Tim Peters suggested the name &quot;generator expressions&quot;.</li>
<li>Armin Rigo, Tim Peters, Guido van Rossum, Samuele Pedroni,
Hye-Shik Chang and Raymond Hettinger teased out the issues surrounding
early versus late binding <a class="footnote-reference" href="#id11" id="id5">[5]</a>.</li>
<li>Jiwon Seo single handedly implemented various versions of the proposal
including the final version loaded into CVS.  Along the way, there
were periodic code reviews by Hye-Shik Chang and Raymond Hettinger.
Guido van Rossum made the key design decisions after comments from
Armin Rigo and newsgroup discussions.  Raymond Hettinger provided
the test suite, documentation, tutorial, and examples <a class="footnote-reference" href="#id12" id="id6">[6]</a>.</li>
</ul>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id20">References</a></h1>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="/dev/peps/pep-0202">PEP 202</a> List Comprehensions
<a class="reference external" href="http://www.python.org/dev/peps/pep-0202/">http://www.python.org/dev/peps/pep-0202/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="/dev/peps/pep-0255">PEP 255</a> Simple Generators
<a class="reference external" href="http://www.python.org/dev/peps/pep-0255/">http://www.python.org/dev/peps/pep-0255/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>Peter Norvig's Accumulation Display Proposal
<a class="reference external" href="http://www.norvig.com/pyacc.html">http://www.norvig.com/pyacc.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td>Jeff Epler had worked up a patch demonstrating
the previously proposed bracket and yield syntax
<a class="reference external" href="http://python.org/sf/795947">http://python.org/sf/795947</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id5">2</a>)</em> Discussion over the relative merits of early versus late binding
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2004-April/044555.html">https://mail.python.org/pipermail/python-dev/2004-April/044555.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[6]</td><td><em>(<a class="fn-backref" href="#id4">1</a>, <a class="fn-backref" href="#id6">2</a>)</em> Patch discussion and alternative patches on Source Forge
<a class="reference external" href="http://www.python.org/sf/872326">http://www.python.org/sf/872326</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id21">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>

