<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">266</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Optimizing Global Variable/Attribute Access</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0266.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">skip&#32;&#97;t&#32;pobox.com (Skip Montanaro)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Withdrawn</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">13-Aug-2001</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.3</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id7">Abstract</a></li>
<li><a class="reference internal" href="#introduction" id="id8">Introduction</a></li>
<li><a class="reference internal" href="#proposed-change" id="id9">Proposed Change</a></li>
<li><a class="reference internal" href="#threads" id="id10">Threads</a></li>
<li><a class="reference internal" href="#rationale" id="id11">Rationale</a></li>
<li><a class="reference internal" href="#questions" id="id12">Questions</a><ul>
<li><a class="reference internal" href="#what-about-threads-what-if-math-sin-changes-while-in-cache" id="id13">What about threads?  What if <tt class="docutils literal">math.sin</tt> changes while in cache?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#unresolved-issues" id="id14">Unresolved Issues</a><ul>
<li><a class="reference internal" href="#threading" id="id15">Threading</a></li>
<li><a class="reference internal" href="#nested-scopes" id="id16">Nested Scopes</a></li>
<li><a class="reference internal" href="#missing-attributes" id="id17">Missing Attributes</a></li>
<li><a class="reference internal" href="#who-does-the-dirty-work" id="id18">Who does the dirty work?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#discussion" id="id19">Discussion</a></li>
<li><a class="reference internal" href="#backwards-compatibility" id="id20">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#implementation" id="id21">Implementation</a></li>
<li><a class="reference internal" href="#performance" id="id22">Performance</a></li>
<li><a class="reference internal" href="#references" id="id23">References</a></li>
<li><a class="reference internal" href="#copyright" id="id24">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id7">Abstract</a></h1>
<p>The bindings for most global variables and attributes of other modules
typically never change during the execution of a Python program, but because
of Python's dynamic nature, code which accesses such global objects must run
through a full lookup each time the object is needed.  This PEP proposes a
mechanism that allows code that accesses most global objects to treat them as
local objects and places the burden of updating references on the code that
changes the name bindings of such objects.</p>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id8">Introduction</a></h1>
<p>Consider the workhorse function <tt class="docutils literal">sre_compile._compile</tt>.  It is the internal
compilation function for the <tt class="docutils literal">sre</tt> module.  It consists almost entirely of a
loop over the elements of the pattern being compiled, comparing opcodes with
known constant values and appending tokens to an output list.  Most of the
comparisons are with constants imported from the <tt class="docutils literal">sre_constants</tt> module.
This means there are lots of <tt class="docutils literal">LOAD_GLOBAL</tt> bytecodes in the compiled output
of this module.  Just by reading the code it's apparent that the author
intended <tt class="docutils literal">LITERAL</tt>, <tt class="docutils literal">NOT_LITERAL</tt>, <tt class="docutils literal">OPCODES</tt> and many other symbols to
be constants.  Still, each time they are involved in an expression, they must
be looked up anew.</p>
<p>Most global accesses are actually to objects that are &quot;almost constants&quot;.
This includes global variables in the current module as well as the attributes
of other imported modules.  Since they rarely change, it seems reasonable to
place the burden of updating references to such objects on the code that
changes the name bindings.  If <tt class="docutils literal">sre_constants.LITERAL</tt> is changed to refer
to another object, perhaps it would be worthwhile for the code that modifies
the <tt class="docutils literal">sre_constants</tt> module dict to correct any active references to that
object.  By doing so, in many cases global variables and the attributes of
many objects could be cached as local variables.  If the bindings between the
names given to the objects and the objects themselves changes rarely, the cost
of keeping track of such objects should be low and the potential payoff fairly
large.</p>
<p>In an attempt to gauge the effect of this proposal, I modified the Pystone
benchmark program included in the Python distribution to cache global
functions.  Its main function, <tt class="docutils literal">Proc0</tt>, makes calls to ten different
functions inside its <tt class="docutils literal">for</tt> loop.  In addition, <tt class="docutils literal">Func2</tt> calls <tt class="docutils literal">Func1</tt>
repeatedly inside a loop.  If local copies of these 11 global idenfiers are
made before the functions' loops are entered, performance on this particular
benchmark improves by about two percent (from 5561 pystones to 5685 on my
laptop).  It gives some indication that performance would be improved by
caching most global variable access.  Note also that the pystone benchmark
makes essentially no accesses of global module attributes, an anticipated area
of improvement for this PEP.</p>
</div>
<div class="section" id="proposed-change">
<h1><a class="toc-backref" href="#id9">Proposed Change</a></h1>
<p>I propose that the Python virtual machine be modified to include
<tt class="docutils literal">TRACK_OBJECT</tt> and <tt class="docutils literal">UNTRACK_OBJECT</tt> opcodes.  <tt class="docutils literal">TRACK_OBJECT</tt> would
associate a global name or attribute of a global name with a slot in the local
variable array and perform an initial lookup of the associated object to fill
in the slot with a valid value.  The association it creates would be noted by
the code responsible for changing the name-to-object binding to cause the
associated local variable to be updated.  The <tt class="docutils literal">UNTRACK_OBJECT</tt> opcode would
delete any association between the name and the local variable slot.</p>
</div>
<div class="section" id="threads">
<h1><a class="toc-backref" href="#id10">Threads</a></h1>
<p>Operation of this code in threaded programs will be no different than in
unthreaded programs.  If you need to lock an object to access it, you would
have had to do that before <tt class="docutils literal">TRACK_OBJECT</tt> would have been executed and
retain that lock until after you stop using it.</p>
<p>FIXME: I suspect I need more here.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id11">Rationale</a></h1>
<p>Global variables and attributes rarely change.  For example, once a function
imports the math module, the binding between the name <em>math</em> and the
module it refers to aren't likely to change.  Similarly, if the function that
uses the <tt class="docutils literal">math</tt> module refers to its <em>sin</em> attribute, it's unlikely to
change.  Still, every time the module wants to call the <tt class="docutils literal">math.sin</tt> function,
it must first execute a pair of instructions:</p>
<pre class="literal-block">
LOAD_GLOBAL     math
LOAD_ATTR       sin
</pre>
<p>If the client module always assumed that <tt class="docutils literal">math.sin</tt> was a local constant and
it was the responsibility of &quot;external forces&quot; outside the function to keep
the reference correct, we might have code like this:</p>
<pre class="literal-block">
TRACK_OBJECT       math.sin
...
LOAD_FAST          math.sin
...
UNTRACK_OBJECT     math.sin
</pre>
<p>If the <tt class="docutils literal">LOAD_FAST</tt> was in a loop the payoff in reduced global loads and
attribute lookups could be significant.</p>
<p>This technique could, in theory, be applied to any global variable access or
attribute lookup.  Consider this code:</p>
<pre class="literal-block">
l = []
for i in range(10):
    l.append(math.sin(i))
return l
</pre>
<p>Even though <em>l</em> is a local variable, you still pay the cost of loading
<tt class="docutils literal">l.append</tt> ten times in the loop.  The compiler (or an optimizer) could
recognize that both <tt class="docutils literal">math.sin</tt> and <tt class="docutils literal">l.append</tt> are being called in the loop
and decide to generate the tracked local code, avoiding it for the builtin
<tt class="docutils literal">range()</tt> function because it's only called once during loop setup.
Performance issues related to accessing local variables make tracking
<tt class="docutils literal">l.append</tt> less attractive than tracking globals such as <tt class="docutils literal">math.sin</tt>.</p>
<p>According to a post to python-dev by Marc-Andre Lemburg <a class="footnote-reference" href="#id4" id="id1">[1]</a>, <tt class="docutils literal">LOAD_GLOBAL</tt>
opcodes account for over 7% of all instructions executed by the Python virtual
machine.  This can be a very expensive instruction, at least relative to a
<tt class="docutils literal">LOAD_FAST</tt> instruction, which is a simple array index and requires no extra
function calls by the virtual machine.  I believe many <tt class="docutils literal">LOAD_GLOBAL</tt>
instructions and <tt class="docutils literal">LOAD_GLOBAL/LOAD_ATTR</tt> pairs could be converted to
<tt class="docutils literal">LOAD_FAST</tt> instructions.</p>
<p>Code that uses global variables heavily often resorts to various tricks to
avoid global variable and attribute lookup.  The aforementioned
<tt class="docutils literal">sre_compile._compile</tt> function caches the <tt class="docutils literal">append</tt> method of the growing
output list.  Many people commonly abuse functions' default argument feature
to cache global variable lookups.  Both of these schemes are hackish and
rarely address all the available opportunities for optimization.  (For
example, <tt class="docutils literal">sre_compile._compile</tt> does not cache the two globals that it uses
most frequently: the builtin <tt class="docutils literal">len</tt> function and the global <tt class="docutils literal">OPCODES</tt> array
that it imports from <tt class="docutils literal">sre_constants.py</tt>.</p>
</div>
<div class="section" id="questions">
<h1><a class="toc-backref" href="#id12">Questions</a></h1>
<div class="section" id="what-about-threads-what-if-math-sin-changes-while-in-cache">
<h2><a class="toc-backref" href="#id13">What about threads?  What if <tt class="docutils literal">math.sin</tt> changes while in cache?</a></h2>
<p>I believe the global interpreter lock will protect values from being
corrupted.  In any case, the situation would be no worse than it is today.
If one thread modified <tt class="docutils literal">math.sin</tt> after another thread had already executed
<tt class="docutils literal">LOAD_GLOBAL math</tt>, but before it executed <tt class="docutils literal">LOAD_ATTR sin</tt>, the client
thread would see the old value of <tt class="docutils literal">math.sin</tt>.</p>
<p>The idea is this.  I use a multi-attribute load below as an example, not
because it would happen very often, but because by demonstrating the recursive
nature with an extra call hopefully it will become clearer what I have in
mind.  Suppose a function defined in module <tt class="docutils literal">foo</tt> wants to access
<tt class="docutils literal">spam.eggs.ham</tt> and that <tt class="docutils literal">spam</tt> is a module imported at the module level
in <tt class="docutils literal">foo</tt>:</p>
<pre class="literal-block">
import spam
...
def somefunc():
...
x = spam.eggs.ham
</pre>
<p>Upon entry to <tt class="docutils literal">somefunc</tt>, a <tt class="docutils literal">TRACK_GLOBAL</tt> instruction will be executed:</p>
<pre class="literal-block">
TRACK_GLOBAL spam.eggs.ham n
</pre>
<p><em>spam.eggs.ham</em> is a string literal stored in the function's constants
array.  <em>n</em> is a fastlocals index.  <tt class="docutils literal">&amp;fastlocals[n]</tt> is a reference to
slot <em>n</em> in the executing frame's <tt class="docutils literal">fastlocals</tt> array, the location in
which the <em>spam.eggs.ham</em> reference will be stored.  Here's what I envision
happening:</p>
<ol class="arabic">
<li><p class="first">The <tt class="docutils literal">TRACK_GLOBAL</tt> instruction locates the object referred to by the name
<em>spam</em> and finds it in its module scope.  It then executes a C function
like:</p>
<pre class="literal-block">
_PyObject_TrackName(m, &quot;spam.eggs.ham&quot;, &amp;fastlocals[n])
</pre>
<p>where <tt class="docutils literal">m</tt> is the module object with an attribute <tt class="docutils literal">spam</tt>.</p>
</li>
<li><p class="first">The module object strips the leading <em>spam.</em> and  stores the necessary
information (<em>eggs.ham</em> and <tt class="docutils literal">&amp;fastlocals[n]</tt>) in case its binding for the
name <em>eggs</em> changes.  It then locates the object referred to by the key
<em>eggs</em> in its dict and recursively calls:</p>
<pre class="literal-block">
_PyObject_TrackName(eggs, &quot;eggs.ham&quot;, &amp;fastlocals[n])
</pre>
</li>
<li><p class="first">The <tt class="docutils literal">eggs</tt> object strips the leading <em>eggs.</em>, stores the
(<em>ham</em>, &amp;fastlocals[n]) info, locates the object in its namespace called
<tt class="docutils literal">ham</tt> and calls <tt class="docutils literal">_PyObject_TrackName</tt> once again:</p>
<pre class="literal-block">
_PyObject_TrackName(ham, &quot;ham&quot;, &amp;fastlocals[n])
</pre>
</li>
<li><p class="first">The <tt class="docutils literal">ham</tt> object strips the leading string (no &quot;.&quot; this time, but that's
a minor point), sees that the result is empty, then uses its own value
(<tt class="docutils literal">self</tt>, probably) to update the location it was handed:</p>
<pre class="literal-block">
Py_XDECREF(&amp;fastlocals[n]);
&amp;fastlocals[n] = self;
Py_INCREF(&amp;fastlocals[n]);
</pre>
<p>At this point, each object involved in resolving <tt class="docutils literal">spam.eggs.ham</tt>
knows which entry in its namespace needs to be tracked and what location
to update if that name changes.  Furthermore, if the one name it is
tracking in its local storage changes, it can call <tt class="docutils literal">_PyObject_TrackName</tt>
using the new object once the change has been made.  At the bottom end of
the food chain, the last object will always strip a name, see the empty
string and know that its value should be stuffed into the location it's
been passed.</p>
<p>When the object referred to by the dotted expression <tt class="docutils literal">spam.eggs.ham</tt>
is going to go out of scope, an <tt class="docutils literal">UNTRACK_GLOBAL spam.eggs.ham n</tt>
instruction is executed.  It has the effect of deleting all the tracking
information that <tt class="docutils literal">TRACK_GLOBAL</tt> established.</p>
<p>The tracking operation may seem expensive, but recall that the objects
being tracked are assumed to be &quot;almost constant&quot;, so the setup cost will
be traded off against hopefully multiple local instead of global loads.
For globals with attributes the tracking setup cost grows but is offset by
avoiding the extra <tt class="docutils literal">LOAD_ATTR</tt> cost.  The <tt class="docutils literal">TRACK_GLOBAL</tt> instruction
needs to perform a <tt class="docutils literal">PyDict_GetItemString</tt> for the first name in the chain
to determine where the top-level object resides.  Each object in the chain
has to store a string and an address somewhere, probably in a dict that
uses storage locations as keys (e.g. the <tt class="docutils literal">&amp;fastlocals[n]</tt>) and strings as
values.  (This dict could possibly be a central dict of dicts whose keys
are object addresses instead of a per-object dict.)  It shouldn't be the
other way around because multiple active frames may want to track
<tt class="docutils literal">spam.eggs.ham</tt>, but only one frame will want to associate that name with
one of its fast locals slots.</p>
</li>
</ol>
</div>
</div>
<div class="section" id="unresolved-issues">
<h1><a class="toc-backref" href="#id14">Unresolved Issues</a></h1>
<div class="section" id="threading">
<h2><a class="toc-backref" href="#id15">Threading</a></h2>
<p>What about this (dumb) code?:</p>
<pre class="literal-block">
l = []
lock = threading.Lock()
...
def fill_l()::
   for i in range(1000)::
      lock.acquire()
      l.append(math.sin(i))
      lock.release()
...
def consume_l()::
   while 1::
      lock.acquire()
      if l::
         elt = l.pop()
      lock.release()
      fiddle(elt)
</pre>
<p>It's not clear from a static analysis of the code what the lock is protecting.
(You can't tell at compile-time that threads are even involved can you?)
Would or should it affect attempts to track <tt class="docutils literal">l.append</tt> or <tt class="docutils literal">math.sin</tt> in
the <tt class="docutils literal">fill_l</tt> function?</p>
<p>If we annotate the code with mythical <tt class="docutils literal">track_object</tt> and <tt class="docutils literal">untrack_object</tt>
builtins (I'm not proposing this, just illustrating where stuff would go!), we
get:</p>
<pre class="literal-block">
l = []
lock = threading.Lock()
...
def fill_l()::
   track_object(&quot;l.append&quot;, append)
   track_object(&quot;math.sin&quot;, sin)
   for i in range(1000)::
      lock.acquire()
      append(sin(i))
      lock.release()
   untrack_object(&quot;math.sin&quot;, sin)
   untrack_object(&quot;l.append&quot;, append)
...
def consume_l()::
   while 1::
      lock.acquire()
      if l::
         elt = l.pop()
      lock.release()
      fiddle(elt)
</pre>
<p>Is that correct both with and without threads (or at least equally incorrect
with and without threads)?</p>
</div>
<div class="section" id="nested-scopes">
<h2><a class="toc-backref" href="#id16">Nested Scopes</a></h2>
<p>The presence of nested scopes will affect where <tt class="docutils literal">TRACK_GLOBAL</tt> finds a
global variable, but shouldn't affect anything after that.  (I think.)</p>
</div>
<div class="section" id="missing-attributes">
<h2><a class="toc-backref" href="#id17">Missing Attributes</a></h2>
<p>Suppose I am tracking the object referred to by <tt class="docutils literal">spam.eggs.ham</tt> and
<tt class="docutils literal">spam.eggs</tt> is rebound to an object that does not have a <tt class="docutils literal">ham</tt> attribute.
It's clear this will be an <tt class="docutils literal">AttributeError</tt> if the programmer attempts to
resolve <tt class="docutils literal">spam.eggs.ham</tt> in the current Python virtual machine, but suppose
the programmer has anticipated this case:</p>
<pre class="literal-block">
if hasattr(spam.eggs, &quot;ham&quot;):
    print spam.eggs.ham
elif hasattr(spam.eggs, &quot;bacon&quot;):
    print spam.eggs.bacon
else:
    print &quot;what? no meat?&quot;
</pre>
<p>You can't raise an <tt class="docutils literal">AttributeError</tt> when the tracking information is
recalculated.  If it does not raise <tt class="docutils literal">AttributeError</tt> and instead lets the
tracking stand, it may be setting the programmer up for a very subtle error.</p>
<p>One solution to this problem would be to track the shortest possible root of
each dotted expression the function refers to directly.  In the above example,
<tt class="docutils literal">spam.eggs</tt> would be tracked, but <tt class="docutils literal">spam.eggs.ham</tt> and <tt class="docutils literal">spam.eggs.bacon</tt>
would not.</p>
</div>
<div class="section" id="who-does-the-dirty-work">
<h2><a class="toc-backref" href="#id18">Who does the dirty work?</a></h2>
<p>In the Questions section I postulated the existence of a
<tt class="docutils literal">_PyObject_TrackName</tt> function.  While the API is fairly easy to specify,
the implementation behind-the-scenes is not so obvious.  A central dictionary
could be used to track the name/location mappings, but it appears that all
<tt class="docutils literal">setattr</tt> functions might need to be modified to accommodate this new
functionality.</p>
<p>If all types used the <tt class="docutils literal">PyObject_GenericSetAttr</tt> function to set attributes
that would localize the update code somewhat.  They don't however (which is
not too surprising), so it seems that all <tt class="docutils literal">getattrfunc</tt> and <tt class="docutils literal">getattrofunc</tt>
functions will have to be updated.  In addition, this would place an absolute
requirement on C extension module authors to call some function when an
attribute changes value (<tt class="docutils literal">PyObject_TrackUpdate</tt>?).</p>
<p>Finally, it's quite possible that some attributes will be set by side effect
and not by any direct call to a <tt class="docutils literal">setattr</tt> method of some sort.  Consider a
device interface module that has an interrupt routine that copies the contents
of a device register into a slot in the object's <tt class="docutils literal">struct</tt> whenever it
changes.  In these situations, more extensive modifications would have to be
made by the module author.  To identify such situations at compile time would
be impossible.  I think an extra slot could be added to <tt class="docutils literal">PyTypeObjects</tt> to
indicate if an object's code is safe for global tracking.  It would have a
default value of 0 (<tt class="docutils literal">Py_TRACKING_NOT_SAFE</tt>).  If an extension module author
has implemented the necessary tracking support, that field could be
initialized to 1 (<tt class="docutils literal">Py_TRACKING_SAFE</tt>).  <tt class="docutils literal">_PyObject_TrackName</tt> could check
that field and issue a warning if it is asked to track an object that the
author has not explicitly said was safe for tracking.</p>
</div>
</div>
<div class="section" id="discussion">
<h1><a class="toc-backref" href="#id19">Discussion</a></h1>
<p>Jeremy Hylton has an alternate proposal on the table <a class="footnote-reference" href="#id5" id="id2">[2]</a>.  His proposal seeks
to create a hybrid dictionary/list object for use in global name lookups that
would make global variable access look more like local variable access.  While
there is no C code available to examine, the Python implementation given in
his proposal still appears to require dictionary key lookup.  It doesn't
appear that his proposal could speed local variable attribute lookup, which
might be worthwhile in some situations if potential performance burdens could
be addressed.</p>
</div>
<div class="section" id="backwards-compatibility">
<h1><a class="toc-backref" href="#id20">Backwards Compatibility</a></h1>
<p>I don't believe there will be any serious issues of backward compatibility.
Obviously, Python bytecode that contains <tt class="docutils literal">TRACK_OBJECT</tt> opcodes could not be
executed by earlier versions of the interpreter, but breakage at the bytecode
level is often assumed between versions.</p>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id21">Implementation</a></h1>
<p>TBD.  This is where I need help.  I believe there should be either a central
name/location registry or the code that modifies object attributes should be
modified, but I'm not sure the best way to go about this.  If you look at the
code that implements the <tt class="docutils literal">STORE_GLOBAL</tt> and <tt class="docutils literal">STORE_ATTR</tt> opcodes, it seems
likely that some changes will be required to <tt class="docutils literal">PyDict_SetItem</tt> and
<tt class="docutils literal">PyObject_SetAttr</tt> or their String variants.  Ideally, there'd be a fairly
central place to localize these changes.  If you begin considering tracking
attributes of local variables you get into issues of modifying <tt class="docutils literal">STORE_FAST</tt>
as well, which could be a problem, since the name bindings for local variables
are changed much more frequently.  (I think an optimizer could avoid inserting
the tracking code for the attributes for any local variables where the
variable's name binding changes.)</p>
</div>
<div class="section" id="performance">
<h1><a class="toc-backref" href="#id22">Performance</a></h1>
<p>I believe (though I have no code to prove it at this point), that implementing
<tt class="docutils literal">TRACK_OBJECT</tt> will generally not be much more expensive than a single
<tt class="docutils literal">LOAD_GLOBAL</tt> instruction or a <tt class="docutils literal">LOAD_GLOBAL</tt>/<tt class="docutils literal">LOAD_ATTR</tt> pair.  An
optimizer should be able to avoid converting <tt class="docutils literal">LOAD_GLOBAL</tt> and
<tt class="docutils literal">LOAD_GLOBAL</tt>/<tt class="docutils literal">LOAD_ATTR</tt> to the new scheme unless the object access
occurred within a loop.  Further down the line, a register-oriented
replacement for the current Python virtual machine <a class="footnote-reference" href="#id6" id="id3">[3]</a> could conceivably
eliminate most of the <tt class="docutils literal">LOAD_FAST</tt> instructions as well.</p>
<p>The number of tracked objects should be relatively small.  All active frames
of all active threads could conceivably be tracking objects, but this seems
small compared to the number of functions defined in a given application.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id23">References</a></h1>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2000-July/007609.html">https://mail.python.org/pipermail/python-dev/2000-July/007609.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="http://www.zope.org/Members/jeremy/CurrentAndFutureProjects/FastGlobalsPEP">http://www.zope.org/Members/jeremy/CurrentAndFutureProjects/FastGlobalsPEP</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="http://www.musi-cal.com/~skip/python/rattlesnake20010813.tar.gz">http://www.musi-cal.com/~skip/python/rattlesnake20010813.tar.gz</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id24">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
fill-column: 70
End: -->
</div>

