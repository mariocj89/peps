<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">230</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Warning Framework</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0230.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">guido&#32;&#97;t&#32;python.org (Guido van Rossum)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.1</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">05-Nov-2000</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id2">Abstract</a></li>
<li><a class="reference internal" href="#motivation" id="id3">Motivation</a></li>
<li><a class="reference internal" href="#apis-for-issuing-warnings" id="id4">APIs For Issuing Warnings</a></li>
<li><a class="reference internal" href="#warnings-categories" id="id5">Warnings Categories</a></li>
<li><a class="reference internal" href="#the-warnings-filter" id="id6">The Warnings Filter</a></li>
<li><a class="reference internal" href="#warnings-output-and-formatting-hooks" id="id7">Warnings Output And Formatting Hooks</a></li>
<li><a class="reference internal" href="#api-for-manipulating-warning-filters" id="id8">API For Manipulating Warning Filters</a></li>
<li><a class="reference internal" href="#command-line-syntax" id="id9">Command Line Syntax</a></li>
<li><a class="reference internal" href="#open-issues" id="id10">Open Issues</a></li>
<li><a class="reference internal" href="#rejected-concerns" id="id11">Rejected Concerns</a></li>
<li><a class="reference internal" href="#implementation" id="id12">Implementation</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id2">Abstract</a></h1>
<p>This PEP proposes a C and Python level API, as well as command
line flags, to issue warning messages and control what happens to
them.  This is mostly based on GvR's proposal posted to python-dev
on 05-Nov-2000, with some ideas (such as using classes to
categorize warnings) merged in from Paul Prescod's
counter-proposal posted on the same date.  Also, an attempt to
implement the proposal caused several small tweaks.</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id3">Motivation</a></h1>
<p>With Python 3000 looming, it is necessary to start issuing
warnings about the use of obsolete or deprecated features, in
addition to errors.  There are also lots of other reasons to be
able to issue warnings, both from C and from Python code, both at
compile time and at run time.</p>
<p>Warnings aren't fatal, and thus it's possible that a program
triggers the same warning many times during a single execution.
It would be annoying if a program emitted an endless stream of
identical warnings.  Therefore, a mechanism is needed that
suppresses multiple identical warnings.</p>
<p>It is also desirable to have user control over which warnings are
printed.  While in general it is useful to see all warnings all
the time, there may be times where it is impractical to fix the
code right away in a production program.  In this case, there
should be a way to suppress warnings.</p>
<p>It is also useful to be able to suppress specific warnings during
program development, e.g. when a warning is generated by a piece
of 3rd party code that cannot be fixed right away, or when there
is no way to fix the code (possibly a warning message is generated
for a perfectly fine piece of code).  It would be unwise to offer
to suppress all warnings in such cases: the developer would miss
warnings about the rest of the code.</p>
<p>On the other hand, there are also situations conceivable where
some or all warnings are better treated as errors.  For example,
it may be a local coding standard that a particular deprecated
feature should not be used.  In order to enforce this, it is
useful to be able to turn the warning about this particular
feature into an error, raising an exception (without necessarily
turning all warnings into errors).</p>
<p>Therefore, I propose to introduce a flexible &quot;warning filter&quot;
which can filter out warnings or change them into exceptions,
based on:</p>
<ul class="simple">
<li>Where in the code they are generated (per package, module, or
function)</li>
<li>The warning category (warning categories are discussed below)</li>
<li>A specific warning message</li>
</ul>
<p>The warning filter must be controllable both from the command line
and from Python code.</p>
</div>
<div class="section" id="apis-for-issuing-warnings">
<h1><a class="toc-backref" href="#id4">APIs For Issuing Warnings</a></h1>
<ul>
<li><p class="first">To issue a warning from Python:</p>
<pre class="literal-block">
import warnings
warnings.warn(message[, category[, stacklevel]])
</pre>
<p>The category argument, if given, must be a warning category
class (see below); it defaults to warnings.UserWarning.  This
may raise an exception if the particular warning issued is
changed into an error by the warnings filter.  The stacklevel
can be used by wrapper functions written in Python, like this:</p>
<pre class="literal-block">
def deprecation(message):
    warn(message, DeprecationWarning, level=2)
</pre>
<p>This makes the warning refer to the deprecation()'s caller,
rather than to the source of deprecation() itself (since the
latter would defeat the purpose of the warning message).</p>
</li>
<li><p class="first">To issue a warning from C:</p>
<pre class="literal-block">
int PyErr_Warn(PyObject *category, char *message);
</pre>
<p>Return 0 normally, 1 if an exception is raised (either because
the warning was transformed into an exception, or because of a
malfunction in the implementation, such as running out of
memory).  The category argument must be a warning category class
(see below) or <tt class="docutils literal">NULL</tt>, in which case it defaults to
<tt class="docutils literal">PyExc_RuntimeWarning</tt>.  When <tt class="docutils literal">PyErr_Warn()</tt> function returns 1, the
caller should do normal exception handling.</p>
<p>The current C implementation of <tt class="docutils literal">PyErr_Warn()</tt> imports the
warnings module (implemented in Python) and calls its <tt class="docutils literal">warn()</tt>
function.  This minimizes the amount of C code that needs to be
added to implement the warning feature.</p>
<p>[XXX Open Issue: what about issuing warnings during lexing or
parsing, which don't have the exception machinery available?]</p>
</li>
</ul>
</div>
<div class="section" id="warnings-categories">
<h1><a class="toc-backref" href="#id5">Warnings Categories</a></h1>
<p>There are a number of built-in exceptions that represent warning
categories.  This categorization is useful to be able to filter
out groups of warnings.  The following warnings category classes
are currently defined:</p>
<ul class="simple">
<li><tt class="docutils literal">Warning</tt> -- this is the base class of all warning category
classes and it itself a subclass of Exception</li>
<li><tt class="docutils literal">UserWarning</tt> -- the default category for <tt class="docutils literal">warnings.warn()</tt></li>
<li><tt class="docutils literal">DeprecationWarning</tt> -- base category for warnings about deprecated
features</li>
<li><tt class="docutils literal">SyntaxWarning</tt> -- base category for warnings about dubious
syntactic features</li>
<li><tt class="docutils literal">RuntimeWarning</tt> -- base category for warnings about dubious
runtime features</li>
</ul>
<p>[XXX: Other warning categories may be proposed during the review
period for this PEP.]</p>
<p>These standard warning categories are available from C as
<tt class="docutils literal">PyExc_Warning</tt>, <tt class="docutils literal">PyExc_UserWarning</tt>, etc.  From Python, they are
available in the <tt class="docutils literal">__builtin__</tt> module, so no import is necessary.</p>
<p>User code can define additional warning categories by subclassing
one of the standard warning categories.  A warning category must
always be a subclass of the Warning class.</p>
</div>
<div class="section" id="the-warnings-filter">
<h1><a class="toc-backref" href="#id6">The Warnings Filter</a></h1>
<p>The warnings filter control whether warnings are ignored,
displayed, or turned into errors (raising an exception).</p>
<p>There are three sides to the warnings filter:</p>
<ul class="simple">
<li>The data structures used to efficiently determine the
disposition of a particular <tt class="docutils literal">warnings.warn()</tt> or <tt class="docutils literal">PyErr_Warn()</tt>
call.</li>
<li>The API to control the filter from Python source code.</li>
<li>The command line switches to control the filter.</li>
</ul>
<p>The warnings filter works in several stages.  It is optimized for
the (expected to be common) case where the same warning is issued
from the same place in the code over and over.</p>
<p>First, the warning filter collects the module and line number
where the warning is issued; this information is readily available
through <tt class="docutils literal">sys._getframe()</tt>.</p>
<p>Conceptually, the warnings filter maintains an ordered list of
filter specifications; any specific warning is matched against
each filter specification in the list in turn until a match is
found; the match determines the disposition of the match.  Each
entry is a tuple as follows:</p>
<pre class="literal-block">
(category, message, module, lineno, action)
</pre>
<ul class="simple">
<li>category is a class (a subclass of <tt class="docutils literal">warnings.Warning</tt>) of which
the warning category must be a subclass in order to match</li>
<li>message is a compiled regular expression that the warning
message must match (the match is case-insensitive)</li>
<li>module is a compiled regular expression that the module name
must match</li>
<li>lineno is an integer that the line number where the warning
occurred must match, or 0 to match all line numbers</li>
<li>action is one of the following strings:<ul>
<li>&quot;error&quot; -- turn matching warnings into exceptions</li>
<li>&quot;ignore&quot; -- never print matching warnings</li>
<li>&quot;always&quot; -- always print matching warnings</li>
<li>&quot;default&quot; -- print the first occurrence of matching warnings
for each location where the warning is issued</li>
<li>&quot;module&quot; -- print the first occurrence of matching warnings
for each module where the warning is issued</li>
<li>&quot;once&quot; -- print only the first occurrence of matching
warnings</li>
</ul>
</li>
</ul>
<p>Since the <tt class="docutils literal">Warning</tt> class is derived from the built-in <tt class="docutils literal">Exception</tt>
class, to turn a warning into an error we simply raise
<tt class="docutils literal">category(message)</tt>.</p>
</div>
<div class="section" id="warnings-output-and-formatting-hooks">
<h1><a class="toc-backref" href="#id7">Warnings Output And Formatting Hooks</a></h1>
<p>When the warnings filter decides to issue a warning (but not when
it decides to raise an exception), it passes the information about
the function <tt class="docutils literal">warnings.showwarning(message, category, filename, lineno)</tt>.
The default implementation of this function writes the warning text
to <tt class="docutils literal">sys.stderr</tt>, and shows the source line of the filename.  It has
an optional 5th argument which can be used to specify a different
file than <tt class="docutils literal">sys.stderr</tt>.</p>
<p>The formatting of warnings is done by a separate function,
<tt class="docutils literal">warnings.formatwarning(message, category, filename, lineno)</tt>.  This
returns a string (that may contain newlines and ends in a newline)
that can be printed to get the identical effect of the
<tt class="docutils literal">showwarning()</tt> function.</p>
</div>
<div class="section" id="api-for-manipulating-warning-filters">
<h1><a class="toc-backref" href="#id8">API For Manipulating Warning Filters</a></h1>
<pre class="literal-block">
warnings.filterwarnings(message, category, module, lineno, action)
</pre>
<p>This checks the types of the arguments, compiles the message and
module regular expressions, and inserts them as a tuple in front
of the warnings filter.</p>
<pre class="literal-block">
warnings.resetwarnings()
</pre>
<p>Reset the warnings filter to empty.</p>
</div>
<div class="section" id="command-line-syntax">
<h1><a class="toc-backref" href="#id9">Command Line Syntax</a></h1>
<p>There should be command line options to specify the most common
filtering actions, which I expect to include at least:</p>
<ul class="simple">
<li>suppress all warnings</li>
<li>suppress a particular warning message everywhere</li>
<li>suppress all warnings in a particular module</li>
<li>turn all warnings into exceptions</li>
</ul>
<p>I propose the following command line option syntax:</p>
<pre class="literal-block">
-Waction[:message[:category[:module[:lineno]]]]
</pre>
<p>Where:</p>
<ul class="simple">
<li>'action' is an abbreviation of one of the allowed actions
(&quot;error&quot;, &quot;default&quot;, &quot;ignore&quot;, &quot;always&quot;, &quot;once&quot;, or &quot;module&quot;)</li>
<li>'message' is a message string; matches warnings whose message
text is an initial substring of 'message' (matching is
case-insensitive)</li>
<li>'category' is an abbreviation of a standard warning category
class name <strong>or</strong> a fully-qualified name for a user-defined
warning category class of the form [package.]module.classname</li>
<li>'module' is a module name (possibly package.module)</li>
<li>'lineno' is an integral line number</li>
</ul>
<p>All parts except 'action' may be omitted, where an empty value
after stripping whitespace is the same as an omitted value.</p>
<p>The C code that parses the Python command line saves the body of
all -W options in a list of strings, which is made available to
the warnings module as sys.warnoptions.  The warnings module
parses these when it is first imported.  Errors detected during
the parsing of sys.warnoptions are not fatal; a message is written
to sys.stderr and processing continues with the option.</p>
<p>Examples:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">-Werror</span></tt></dt>
<dd>Turn all warnings into errors</dd>
<dt><tt class="docutils literal"><span class="pre">-Wall</span></tt></dt>
<dd>Show all warnings</dd>
<dt><tt class="docutils literal"><span class="pre">-Wignore</span></tt></dt>
<dd>Ignore all warnings</dd>
<dt><tt class="docutils literal"><span class="pre">-Wi:hello</span></tt></dt>
<dd>Ignore warnings whose message text starts with &quot;hello&quot;</dd>
<dt><tt class="docutils literal"><span class="pre">-We::Deprecation</span></tt></dt>
<dd>Turn deprecation warnings into errors</dd>
<dt><tt class="docutils literal"><span class="pre">-Wi:::spam:10</span></tt></dt>
<dd>Ignore all warnings on line 10 of module spam</dd>
<dt><tt class="docutils literal"><span class="pre">-Wi:::spam</span> <span class="pre">-Wd:::spam:10</span></tt></dt>
<dd>Ignore all warnings in module spam except on line 10</dd>
<dt><tt class="docutils literal"><span class="pre">-We::Deprecation</span> <span class="pre">-Wd::Deprecation:spam</span></tt></dt>
<dd>Turn deprecation warnings into errors except in module spam</dd>
</dl>
</div>
<div class="section" id="open-issues">
<h1><a class="toc-backref" href="#id10">Open Issues</a></h1>
<p>Some open issues off the top of my head:</p>
<ul class="simple">
<li>What about issuing warnings during lexing or parsing, which
don't have the exception machinery available?</li>
<li>The proposed command line syntax is a bit ugly (although the
simple cases aren't so bad: <tt class="docutils literal"><span class="pre">-Werror</span></tt>, <tt class="docutils literal"><span class="pre">-Wignore</span></tt>, etc.).  Anybody
got a better idea?</li>
<li>I'm a bit worried that the filter specifications are too
complex.  Perhaps filtering only on category and module (not on
message text and line number) would be enough?</li>
<li>There's a bit of confusion between module names and file names.
The reporting uses file names, but the filter specification uses
module names.  Maybe it should allow filenames as well?</li>
<li>I'm not at all convinced that packages are handled right.</li>
<li>Do we need more standard warning categories?  Fewer?</li>
<li>In order to minimize the start-up overhead, the warnings module
is imported by the first call to <tt class="docutils literal">PyErr_Warn()</tt>.  It does the
command line parsing for <tt class="docutils literal"><span class="pre">-W</span></tt> options upon import.  Therefore, it
is possible that warning-free programs will not complain about
invalid <tt class="docutils literal"><span class="pre">-W</span></tt> options.</li>
</ul>
</div>
<div class="section" id="rejected-concerns">
<h1><a class="toc-backref" href="#id11">Rejected Concerns</a></h1>
<p>Paul Prescod, Barry Warsaw and Fred Drake have brought up several
additional concerns that I feel aren't critical.  I address them
here (the concerns are paraphrased, not exactly their words):</p>
<ul>
<li><p class="first">Paul: <tt class="docutils literal">warn()</tt> should be a built-in or a statement to make it easily
available.</p>
<p>Response: &quot;from warnings import warn&quot; is easy enough.</p>
</li>
<li><p class="first">Paul: What if I have a speed-critical module that triggers
warnings in an inner loop.  It should be possible to disable the
overhead for detecting the warning (not just suppress the
warning).</p>
<p>Response: rewrite the inner loop to avoid triggering the
warning.</p>
</li>
<li><p class="first">Paul: What if I want to see the full context of a warning?</p>
<p>Response: use <tt class="docutils literal"><span class="pre">-Werror</span></tt> to turn it into an exception.</p>
</li>
<li><p class="first">Paul: I prefer &quot;:*:*:&quot; to &quot;:::&quot; for leaving parts of the warning
spec out.</p>
<p>Response: I don't.</p>
</li>
<li><p class="first">Barry: It would be nice if lineno can be a range specification.</p>
<p>Response: Too much complexity already.</p>
</li>
<li><p class="first">Barry: I'd like to add my own warning action.  Maybe if 'action'
could be a callable as well as a string.  Then in my IDE, I
could set that to &quot;mygui.popupWarningsDialog&quot;.</p>
<p>Response: For that purpose you would override
<tt class="docutils literal">warnings.showwarning()</tt>.</p>
</li>
<li><p class="first">Fred: why do the Warning category classes have to be in
<tt class="docutils literal">__builtin__</tt>?</p>
<p>Response: that's the simplest implementation, given that the
warning categories must be available in C before the first
<tt class="docutils literal">PyErr_Warn()</tt> call, which imports the warnings module.  I see no
problem with making them available as built-ins.</p>
</li>
</ul>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id12">Implementation</a></h1>
<p>Here's a prototype implementation:
<a class="reference external" href="http://sourceforge.net/patch/?func=detailpatch&amp;patch_id=102715&amp;group_id=5470">http://sourceforge.net/patch/?func=detailpatch&amp;patch_id=102715&amp;group_id=5470</a></p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

