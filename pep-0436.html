<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">436</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">The Argument Clinic DSL</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0436.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Larry Hastings &lt;larry&#32;&#97;t&#32;hastings.org&gt;</td>
</tr>
<tr class="field"><th class="field-name">Discussions-To:</th><td class="field-body">Python-Dev &lt;<a class="reference external" href="mailto:python-dev&#64;python.org?subject=PEP%20436">python-dev&#32;&#97;t&#32;python.org</a>&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Draft</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">22-Feb-2013</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id14">Abstract</a></li>
<li><a class="reference internal" href="#rationale-and-goals" id="id15">Rationale and Goals</a></li>
<li><a class="reference internal" href="#dsl-syntax-summary" id="id16">DSL Syntax Summary</a><ul>
<li><a class="reference internal" href="#general-behavior-of-the-argument-clinic-dsl" id="id17">General Behavior Of the Argument Clinic DSL</a></li>
<li><a class="reference internal" href="#module-and-class-declarations" id="id18">Module and Class Declarations</a></li>
<li><a class="reference internal" href="#function-declaration" id="id19">Function Declaration</a></li>
<li><a class="reference internal" href="#parameter-declaration" id="id20">Parameter Declaration</a></li>
<li><a class="reference internal" href="#legacy-converters" id="id21">Legacy Converters</a></li>
<li><a class="reference internal" href="#parameter-docstrings" id="id22">Parameter Docstrings</a></li>
<li><a class="reference internal" href="#special-syntax-for-parameter-lines" id="id23">Special Syntax For Parameter Lines</a></li>
<li><a class="reference internal" href="#function-docstring" id="id24">Function Docstring</a></li>
<li><a class="reference internal" href="#converters" id="id25">Converters</a></li>
<li><a class="reference internal" href="#return-converters" id="id26">Return Converters</a></li>
<li><a class="reference internal" href="#directives" id="id27">Directives</a></li>
</ul>
</li>
<li><a class="reference internal" href="#python-code" id="id28">Python Code</a></li>
<li><a class="reference internal" href="#output" id="id29">Output</a></li>
<li><a class="reference internal" href="#functions-with-positional-only-parameters" id="id30">Functions With Positional-Only Parameters</a></li>
<li><a class="reference internal" href="#current-status" id="id31">Current Status</a><ul>
<li><a class="reference internal" href="#argument-clinic-programmatic-interfaces" id="id32">Argument Clinic Programmatic Interfaces</a></li>
</ul>
</li>
<li><a class="reference internal" href="#notes-tbd" id="id33">Notes / TBD</a></li>
<li><a class="reference internal" href="#acknowledgements" id="id34">Acknowledgements</a></li>
<li><a class="reference internal" href="#references" id="id35">References</a></li>
<li><a class="reference internal" href="#copyright" id="id36">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id14">Abstract</a></h1>
<p>This document proposes &quot;Argument Clinic&quot;, a DSL to facilitate
argument processing for built-in functions in the implementation of
CPython.</p>
</div>
<div class="section" id="rationale-and-goals">
<h1><a class="toc-backref" href="#id15">Rationale and Goals</a></h1>
<p>The primary implementation of Python, &quot;CPython&quot;, is written in a
mixture of Python and C.  One implementation detail of CPython
is what are called &quot;built-in&quot; functions -- functions available to
Python programs but written in C.  When a Python program calls a
built-in function and passes in arguments, those arguments must be
translated from Python values into C values.  This process is called
&quot;parsing arguments&quot;.</p>
<p>As of CPython 3.3, builtin functions nearly always parse their arguments
with one of two functions: the original <tt class="docutils literal">PyArg_ParseTuple()</tt>, <a class="footnote-reference" href="#id8" id="id1">[1]</a> and
the more modern <tt class="docutils literal">PyArg_ParseTupleAndKeywords()</tt>. <a class="footnote-reference" href="#id9" id="id2">[2]</a> The former
only handles positional parameters; the latter also accommodates keyword
and keyword-only parameters, and is preferred for new code.</p>
<p>With either function, the caller specifies the translation for
parsing arguments in a &quot;format string&quot;: <a class="footnote-reference" href="#id10" id="id3">[3]</a> each parameter corresponds
to a &quot;format unit&quot;, a short character sequence telling the parsing
function what Python types to accept and how to translate them into
the appropriate C value for that parameter.</p>
<p><tt class="docutils literal">PyArg_ParseTuple()</tt> was reasonable when it was first conceived.
There were only a dozen or so of these &quot;format units&quot;; each one
was distinct, and easy to understand and remember.
But over the years the <tt class="docutils literal">PyArg_Parse</tt> interface has been extended
in numerous ways.  The modern API is complex, to the point that it
is somewhat painful to use.  Consider:</p>
<ul class="simple">
<li>There are now forty different &quot;format units&quot;; a few are even three
characters long.  This makes it difficult for the programmer to
understand what the format string says--or even perhaps to parse
it--without constantly cross-indexing it with the documentation.</li>
<li>There are also six meta-format units that may be buried in the
format string.  (They are: <tt class="docutils literal"><span class="pre">&quot;()|$:;&quot;</span></tt>.)</li>
<li>The more format units are added, the less likely it is the
implementer can pick an easy-to-use mnemonic for the format unit,
because the character of choice is probably already in use.  In
other words, the more format units we have, the more obtuse the
format units become.</li>
<li>Several format units are nearly identical to others, having only
subtle differences.  This makes understanding the exact semantics
of the format string even harder, and can make it difficult to
figure out exactly which format unit you want.</li>
<li>The docstring is specified as a static C string, making it mildly
bothersome to read and edit since it must obey C string quoting rules.</li>
<li>When adding a new parameter to a function using
<tt class="docutils literal">PyArg_ParseTupleAndKeywords()</tt>, it's necessary to touch six
different places in the code: <a class="footnote-reference" href="#id11" id="id4">[4]</a><ul>
<li>Declaring the variable to store the argument.</li>
<li>Passing in a pointer to that variable in the correct spot in
<tt class="docutils literal">PyArg_ParseTupleAndKeywords()</tt>, also passing in any
&quot;length&quot; or &quot;converter&quot; arguments in the correct order.</li>
<li>Adding the name of the argument in the correct spot of the
&quot;keywords&quot; array passed in to
<tt class="docutils literal">PyArg_ParseTupleAndKeywords()</tt>.</li>
<li>Adding the format unit to the correct spot in the format
string.</li>
<li>Adding the parameter to the prototype in the docstring.</li>
<li>Documenting the parameter in the docstring.</li>
</ul>
</li>
<li>There is currently no mechanism for builtin functions to provide
their &quot;signature&quot; information (see <tt class="docutils literal">inspect.getfullargspec</tt> and
<tt class="docutils literal">inspect.Signature</tt>).  Adding this information using a mechanism
similar to the existing <tt class="docutils literal">PyArg_Parse</tt> functions would require
repeating ourselves yet again.</li>
</ul>
<p>The goal of Argument Clinic is to replace this API with a mechanism
inheriting none of these downsides:</p>
<ul class="simple">
<li>You need specify each parameter only once.</li>
<li>All information about a parameter is kept together in one place.</li>
<li>For each parameter, you specify a conversion function; Argument
Clinic handles the translation from Python value into C value for
you.</li>
<li>Argument Clinic also allows for fine-tuning of argument processing
behavior with parameterized conversion functions.</li>
<li>Docstrings are written in plain text.  Function docstrings are
required; per-parameter docstrings are encouraged.</li>
<li>From this, Argument Clinic generates for you all the mundane,
repetitious code and data structures CPython needs internally.
Once you've specified the interface, the next step is simply to
write your implementation using native C types.  Every detail of
argument parsing is handled for you.</li>
</ul>
<p>Argument Clinic is implemented as a preprocessor.  It draws inspiration
for its workflow directly from <a class="citation-reference" href="#cog" id="id5">[Cog]</a> by Ned Batchelder.  To use Clinic,
add a block comment to your C source code beginning and ending with
special text strings, then run Clinic on the file.  Clinic will find the
block comment, process the contents, and write the output back into your
C source file directly after the comment.  The intent is that Clinic's
output becomes part of your source code; it's checked in to revision
control, and distributed with source packages.  This means that Python
will still ship ready-to-build.  It does complicate development slightly;
in order to add a new function, or modify the arguments or documentation
of an existing function using Clinic, you'll need a working Python 3
interpreter.</p>
<p>Future goals of Argument Clinic include:</p>
<ul class="simple">
<li>providing signature information for builtins,</li>
<li>enabling alternative implementations of Python to create
automated library compatibility tests, and</li>
<li>speeding up argument parsing with improvements to the
generated code.</li>
</ul>
</div>
<div class="section" id="dsl-syntax-summary">
<h1><a class="toc-backref" href="#id16">DSL Syntax Summary</a></h1>
<p>The Argument Clinic DSL is specified as a comment embedded in a C
file, as follows.  The &quot;Example&quot; column on the right shows you sample
input to the Argument Clinic DSL, and the &quot;Section&quot; column on the left
specifies what each line represents in turn.</p>
<p>Argument Clinic's DSL syntax mirrors the Python <tt class="docutils literal">def</tt>
statement, lending it some familiarity to Python core developers.</p>
<pre class="literal-block">
+-----------------------+-----------------------------------------------------------------+
| Section               | Example                                                         |
+-----------------------+-----------------------------------------------------------------+
| Clinic DSL start      | /*[clinic]                                                      |
| Module declaration    | module module_name                                              |
| Class declaration     | class module_name.class_name                                    |
| Function declaration  | module_name.function_name  -&gt; return_annotation                 |
| Parameter declaration |       name : converter(param=value)                             |
| Parameter docstring   |           Lorem ipsum dolor sit amet, consectetur               |
|                       |           adipisicing elit, sed do eiusmod tempor               |
| Function docstring    | Lorem ipsum dolor sit amet, consectetur adipisicing             |
|                       | elit, sed do eiusmod tempor incididunt ut labore et             |
| Clinic DSL end        | [clinic]*/                                                      |
| Clinic output         | ...                                                             |
| Clinic output end     | /*[clinic end output:&lt;checksum&gt;]*/                              |
+-----------------------+-----------------------------------------------------------------+
</pre>
<p>To give some flavor of the proposed DSL syntax, here are some sample Clinic
code blocks.  This first block reflects the normally preferred style, including
blank lines between parameters and per-argument docstrings.
It also includes a user-defined converter (<tt class="docutils literal">path_t</tt>) created
locally:</p>
<pre class="literal-block">
/*[clinic]
os.stat as os_stat_fn -&gt; stat result

   path: path_t(allow_fd=1)
       Path to be examined; can be string, bytes, or open-file-descriptor int.

   *

   dir_fd: OS_STAT_DIR_FD_CONVERTER = DEFAULT_DIR_FD
       If not None, it should be a file descriptor open to a directory,
       and path should be a relative string; path will then be relative to
       that directory.

   follow_symlinks: bool = True
       If False, and the last element of the path is a symbolic link,
       stat will examine the symbolic link itself instead of the file
       the link points to.

Perform a stat system call on the given path.

{parameters}

dir_fd and follow_symlinks may not be implemented
  on your platform.  If they are unavailable, using them will raise a
  NotImplementedError.

It's an error to use dir_fd or follow_symlinks when specifying path as
  an open file descriptor.

[clinic]*/
</pre>
<p>This second example shows a minimal Clinic code block, omitting all
parameter docstrings and non-significant blank lines:</p>
<pre class="literal-block">
/*[clinic]
os.access
   path: path
   mode: int
   *
   dir_fd: OS_ACCESS_DIR_FD_CONVERTER = 1
   effective_ids: bool = False
   follow_symlinks: bool = True
Use the real uid/gid to test for access to a path.
Returns True if granted, False otherwise.

{parameters}

dir_fd, effective_ids, and follow_symlinks may not be implemented
  on your platform.  If they are unavailable, using them will raise a
  NotImplementedError.

Note that most operations will use the effective uid/gid, therefore this
  routine can be used in a suid/sgid environment to test if the invoking user
  has the specified access to the path.

[clinic]*/
</pre>
<p>This final example shows a Clinic code block handling groups of
optional parameters, including parameters on the left:</p>
<pre class="literal-block">
/*[clinic]
curses.window.addch

   [
   y: int
     Y-coordinate.

   x: int
     X-coordinate.
   ]

   ch: char
     Character to add.

   [
   attr: long
     Attributes for the character.
   ]

   /

Paint character ch at (y, x) with attributes attr,
overwriting any character previously painter at that location.
By default, the character position and attributes are the
current settings for the window object.
[clinic]*/
</pre>
<div class="section" id="general-behavior-of-the-argument-clinic-dsl">
<h2><a class="toc-backref" href="#id17">General Behavior Of the Argument Clinic DSL</a></h2>
<p>All lines support <tt class="docutils literal">#</tt> as a line comment delimiter <em>except</em>
docstrings.  Blank lines are always ignored.</p>
<p>Like Python itself, leading whitespace is significant in the Argument
Clinic DSL.  The first line of the &quot;function&quot; section is the
function declaration.  Indented lines below the function declaration
declare parameters, one per line; lines below those that are indented even
further are per-parameter docstrings.  Finally, the first line dedented
back to column 0 end parameter declarations and start the function docstring.</p>
<p>Parameter docstrings are optional; function docstrings are not.
Functions that specify no arguments may simply specify the function
declaration followed by the docstring.</p>
</div>
<div class="section" id="module-and-class-declarations">
<h2><a class="toc-backref" href="#id18">Module and Class Declarations</a></h2>
<p>When a C file implements a module or class, this should be declared to
Clinic.  The syntax is simple:</p>
<pre class="literal-block">
module module_name
</pre>
<p>or</p>
<pre class="literal-block">
class module_name.class_name
</pre>
<p>(Note that these are not actually special syntax; they are implemented
as <a class="reference internal" href="#directives">Directives</a>.)</p>
<p>The module name or class name should always be the full dotted path
from the top-level module.  Nested modules and classes are supported.</p>
</div>
<div class="section" id="function-declaration">
<h2><a class="toc-backref" href="#id19">Function Declaration</a></h2>
<p>The full form of the function declaration is as follows:</p>
<pre class="literal-block">
dotted.name [ as legal_c_id ] [ -&gt; return_annotation ]
</pre>
<p>The dotted name should be the full name of the function, starting
with the highest-level package (e.g. &quot;os.stat&quot; or &quot;curses.window.addch&quot;).</p>
<p>The &quot;as legal_c_id&quot; syntax is optional.
Argument Clinic uses the name of the function to create the names of
the generated C functions.  In some circumstances, the generated name
may collide with other global names in the C program's namespace.
The &quot;as legal_c_id&quot; syntax allows you to override the generated name
with your own; substitute &quot;legal_c_id&quot; with any legal C identifier.
If skipped, the &quot;as&quot; keyword must also be omitted.</p>
<p>The return annotation is also optional.  If skipped, the arrow (&quot;<tt class="docutils literal"><span class="pre">-&gt;</span></tt>&quot;)
must also be omitted.  If specified, the value for the return annotation
must be compatible with <tt class="docutils literal">ast.literal_eval</tt>, and it is interpreted as
a <em>return converter</em>.</p>
</div>
<div class="section" id="parameter-declaration">
<h2><a class="toc-backref" href="#id20">Parameter Declaration</a></h2>
<p>The full form of the parameter declaration line as follows:</p>
<pre class="literal-block">
name: converter [ (parameter=value [, parameter2=value2]) ] [ = default]
</pre>
<p>The &quot;name&quot; must be a legal C identifier.  Whitespace is permitted between
the name and the colon (though this is not the preferred style).  Whitespace
is permitted (and encouraged) between the colon and the converter.</p>
<p>The &quot;converter&quot; is the name of one of the &quot;converter functions&quot; registered
with Argument Clinic.  Clinic will ship with a number of built-in converters;
new converters can also be added dynamically.  In choosing a converter, you
are automatically constraining what Python types are permitted on the input,
and specifying what type the output variable (or variables) will be.  Although
many of the converters will resemble the names of C types or perhaps Python
types, the name of a converter may be any legal Python identifier.</p>
<p>If the converter is followed by parentheses, these parentheses enclose
parameter to the conversion function.  The syntax mirrors providing arguments
a Python function call: the parameter must always be named, as if they were
&quot;keyword-only parameters&quot;, and the values provided for the parameters will
syntactically resemble Python literal values.  These parameters are always
optional, permitting all conversion functions to be called without
any parameters.  In this case, you may also omit the parentheses entirely;
this is always equivalent to specifying empty parentheses.  The values
supplied for these parameters must be compatible with <tt class="docutils literal">ast.literal_eval</tt>.</p>
<p>The &quot;default&quot; is a Python literal value.  Default values are optional;
if not specified you must omit the equals sign too.  Parameters which
don't have a default are implicitly required.  The default value is
dynamically assigned, &quot;live&quot; in the generated C code, and although
it's specified as a Python value, it's translated into a native C
value in the generated C code.  Few default values are permitted,
owing to this manual translation step.</p>
<p>If this were a Python function declaration, a parameter declaration
would be delimited by either a trailing comma or an ending parenthesis.
However, Argument Clinic uses neither; parameter declarations are
delimited by a newline.  A trailing comma or right parenthesis is not
permitted.</p>
<p>The first parameter declaration establishes the indent for all parameter
declarations in a particular Clinic code block.  All subsequent parameters
must be indented to the same level.</p>
</div>
<div class="section" id="legacy-converters">
<h2><a class="toc-backref" href="#id21">Legacy Converters</a></h2>
<p>For convenience's sake in converting existing code to Argument Clinic,
Clinic provides a set of legacy converters that match <tt class="docutils literal">PyArg_ParseTuple</tt>
format units.  They are specified as a C string containing the format
unit.  For example, to specify a parameter &quot;foo&quot; as taking a Python
&quot;int&quot; and emitting a C int, you could specify:</p>
<pre class="literal-block">
foo : &quot;i&quot;
</pre>
<p>(To more closely resemble a C string, these must always use double quotes.)</p>
<p>Although these resemble <tt class="docutils literal">PyArg_ParseTuple</tt> format units, no guarantee is
made that the implementation will call a <tt class="docutils literal">PyArg_Parse</tt> function for parsing.</p>
<p>This syntax does not support parameters.  Therefore, it doesn't support any
of the format units that require input parameters (<tt class="docutils literal"><span class="pre">&quot;O!&quot;,</span> <span class="pre">&quot;O&amp;&quot;,</span> &quot;es&quot;, <span class="pre">&quot;es#&quot;,</span>
&quot;et&quot;, &quot;et#&quot;</tt>).  Parameters requiring one of these conversions cannot use the
legacy syntax.  (You may still, however, supply a default value.)</p>
</div>
<div class="section" id="parameter-docstrings">
<h2><a class="toc-backref" href="#id22">Parameter Docstrings</a></h2>
<p>All lines that appear below and are indented further than a parameter declaration
are the docstring for that parameter.  All such lines are &quot;dedented&quot; until the
first line is flush left.</p>
</div>
<div class="section" id="special-syntax-for-parameter-lines">
<h2><a class="toc-backref" href="#id23">Special Syntax For Parameter Lines</a></h2>
<p>There are four special symbols that may be used in the parameter section.  Each
of these must appear on a line by itself, indented to the same level as parameter
declarations.  The four symbols are:</p>
<dl class="docutils">
<dt><tt class="docutils literal">*</tt></dt>
<dd>Establishes that all subsequent parameters are keyword-only.</dd>
<dt><tt class="docutils literal">[</tt></dt>
<dd>Establishes the start of an optional &quot;group&quot; of parameters.
Note that &quot;groups&quot; may nest inside other &quot;groups&quot;.
See <a class="reference internal" href="#functions-with-positional-only-parameters">Functions With Positional-Only Parameters</a> below.
Note that currently <tt class="docutils literal">[</tt> is only legal for use in functions
where <em>all</em> parameters are marked positional-only, see
<tt class="docutils literal">/</tt> below.</dd>
<dt><tt class="docutils literal">]</tt></dt>
<dd>Ends an optional &quot;group&quot; of parameters.</dd>
<dt><tt class="docutils literal">/</tt></dt>
<dd>Establishes that all the <em>proceeding</em> arguments are
positional-only.  For now, Argument Clinic does not
support functions with both positional-only and
non-positional-only arguments.  Therefore: if <tt class="docutils literal">/</tt>
is specified for a function, it must currently always
be after the <em>last</em> parameter.  Also, Argument Clinic
does not currently support default values for
positional-only parameters.</dd>
</dl>
<p>(The semantics of <tt class="docutils literal">/</tt> follow a syntax for positional-only
parameters in Python once proposed by Guido. <a class="footnote-reference" href="#id12" id="id6">[5]</a> )</p>
</div>
<div class="section" id="function-docstring">
<h2><a class="toc-backref" href="#id24">Function Docstring</a></h2>
<p>The first line with no leading whitespace after the function declaration is the
first line of the function docstring.  All subsequent lines of the Clinic block
are considered part of the docstring, and their leading whitespace is preserved.</p>
<p>If the string <tt class="docutils literal">{parameters}</tt> appears on a line by itself inside the function
docstring, Argument Clinic will insert a list of all parameters that have
docstrings, each such parameter followed by its docstring.  The name of the
parameter is on a line by itself; the docstring starts on a subsequent line,
and all lines of the docstring are indented by two spaces.  (Parameters with
no per-parameter docstring are suppressed.)  The entire list is indented by the
leading whitespace that appeared before the <tt class="docutils literal">{parameters}</tt> token.</p>
<p>If the string <tt class="docutils literal">{parameters}</tt> doesn't appear in the docstring, Argument Clinic
will append one to the end of the docstring, inserting a blank line above it if
the docstring does not end with a blank line, and with the parameter list at
column 0.</p>
</div>
<div class="section" id="converters">
<h2><a class="toc-backref" href="#id25">Converters</a></h2>
<p>Argument Clinic contains a pre-initialized registry of converter functions.
Example converter functions:</p>
<dl class="docutils">
<dt><tt class="docutils literal">int</tt></dt>
<dd>Accepts a Python object implementing <tt class="docutils literal">__int__</tt>; emits a C <tt class="docutils literal">int</tt>.</dd>
<dt><tt class="docutils literal">byte</tt></dt>
<dd>Accepts a Python int; emits an <tt class="docutils literal">unsigned char</tt>.  The integer
must be in the range [0, 256).</dd>
<dt><tt class="docutils literal">str</tt></dt>
<dd>Accepts a Python str object; emits a C <tt class="docutils literal">char *</tt>.  Automatically
encodes the string using the <tt class="docutils literal">ascii</tt> codec.</dd>
<dt><tt class="docutils literal">PyObject</tt></dt>
<dd>Accepts any object; emits a C <tt class="docutils literal">PyObject *</tt> without any conversion.</dd>
</dl>
<p>All converters accept the following parameters:</p>
<dl class="docutils">
<dt><tt class="docutils literal">doc_default</tt></dt>
<dd>The Python value to use in place of the parameter's actual default
in Python contexts.  In other words: when specified, this value will
be used for the parameter's default in the docstring, and in the
<tt class="docutils literal">Signature</tt>.  (TBD alternative semantics: If the string is a valid
Python expression which can be rendered into a Python value using
<tt class="docutils literal">eval()</tt>, then the result of <tt class="docutils literal">eval()</tt> on it will be used as the
default in the <tt class="docutils literal">Signature</tt>.)  Ignored if there is no default.</dd>
<dt><tt class="docutils literal">required</tt></dt>
<dd>Normally any parameter that has a default value is automatically
optional.  A parameter that has &quot;required&quot; set will be considered
required (non-optional) even if it has a default value.  The
generated documentation will also not show any default value.</dd>
</dl>
<p>Additionally, converters may accept one or more of these optional
parameters, on an individual basis:</p>
<dl class="docutils">
<dt><tt class="docutils literal">annotation</tt></dt>
<dd>Explicitly specifies the per-parameter annotation for this
parameter.  Normally it's the responsibility of the conversion
function to generate the annotation (if any).</dd>
<dt><tt class="docutils literal">bitwise</tt></dt>
<dd>For converters that accept unsigned integers.  If the Python integer
passed in is signed, copy the bits directly even if it is negative.</dd>
<dt><tt class="docutils literal">encoding</tt></dt>
<dd>For converters that accept str.  Encoding to use when encoding a
Unicode string to a <tt class="docutils literal">char *</tt>.</dd>
<dt><tt class="docutils literal">immutable</tt></dt>
<dd>Only accept immutable values.</dd>
<dt><tt class="docutils literal">length</tt></dt>
<dd>For converters that accept iterable types.  Requests that the converter
also emit the length of the iterable, passed in to the <tt class="docutils literal">_impl</tt> function
in a <tt class="docutils literal">Py_ssize_t</tt> variable; its name will be this
parameter's name appended with &quot;<tt class="docutils literal">_length</tt>&quot;.</dd>
<dt><tt class="docutils literal">nullable</tt></dt>
<dd>This converter normally does not accept <tt class="docutils literal">None</tt>, but in this case
it should.  If <tt class="docutils literal">None</tt> is supplied on the Python side, the equivalent
C argument will be <tt class="docutils literal">NULL</tt>.  (The <tt class="docutils literal">_impl</tt> argument emitted by this
converter will presumably be a pointer type.)</dd>
<dt><tt class="docutils literal">types</tt></dt>
<dd><p class="first">A list of strings representing acceptable Python types for this object.
There are also four strings which represent Python protocols:</p>
<ul class="last simple">
<li>&quot;buffer&quot;</li>
<li>&quot;mapping&quot;</li>
<li>&quot;number&quot;</li>
<li>&quot;sequence&quot;</li>
</ul>
</dd>
<dt><tt class="docutils literal">zeroes</tt></dt>
<dd>For converters that accept string types.  The converted value should
be allowed to have embedded zeroes.</dd>
</dl>
</div>
<div class="section" id="return-converters">
<h2><a class="toc-backref" href="#id26">Return Converters</a></h2>
<p>A <em>return converter</em> conceptually performs the inverse operation of
a converter: it converts a native C value into its equivalent Python
value.</p>
</div>
<div class="section" id="directives">
<h2><a class="toc-backref" href="#id27">Directives</a></h2>
<p>Argument Clinic also permits &quot;directives&quot; in Clinic code blocks.
Directives are similar to <em>pragmas</em> in C; they are statements
that modify Argument Clinic's behavior.</p>
<p>The format of a directive is as follows:</p>
<pre class="literal-block">
directive_name [argument [second_argument [ ... ]]]
</pre>
<p>Directives only take positional arguments.</p>
<p>A Clinic code block must contain either one or more directives,
or a function declaration.  It may contain both, in which
case all directives must come before the function declaration.</p>
<p>Internally directives map directly to Python callables.
The directive's arguments are passed directly to the callable
as positional arguments of type <tt class="docutils literal">str()</tt>.</p>
<p>Example possible directives include the production,
suppression, or redirection of Clinic output.  Also, the
&quot;module&quot; and &quot;class&quot; keywords are implemented
as directives in the prototype.</p>
</div>
</div>
<div class="section" id="python-code">
<h1><a class="toc-backref" href="#id28">Python Code</a></h1>
<p>Argument Clinic also permits embedding Python code inside C files,
which is executed in-place when Argument Clinic processes the file.
Embedded code looks like this:</p>
<pre class="literal-block">
/*[python]

# this is python code!
print(&quot;/&quot; + &quot;* Hello world! *&quot; + &quot;/&quot;)

[python]*/
/* Hello world! */
/*[python end:da39a3ee5e6b4b0d3255bfef95601890afd80709]*/
</pre>
<p>The <tt class="docutils literal">&quot;/* Hello world! */&quot;</tt> line above was generated by running the Python
code in the preceding comment.</p>
<p>Any Python code is valid.  Python code sections in Argument Clinic can
also be used to directly interact with Clinic; see
<a class="reference internal" href="#argument-clinic-programmatic-interfaces">Argument Clinic Programmatic Interfaces</a>.</p>
</div>
<div class="section" id="output">
<h1><a class="toc-backref" href="#id29">Output</a></h1>
<p>Argument Clinic writes its output inline in the C file, immediately
after the section of Clinic code.  For &quot;python&quot; sections, the output
is everything printed using <tt class="docutils literal">builtins.print</tt>.  For &quot;clinic&quot;
sections, the output is valid C code, including:</p>
<ul class="simple">
<li>a <tt class="docutils literal">#define</tt> providing the correct <tt class="docutils literal">methoddef</tt> structure for the
function</li>
<li>a prototype for the &quot;impl&quot; function -- this is what you'll write
to implement this function</li>
<li>a function that handles all argument processing, which calls your
&quot;impl&quot; function</li>
<li>the definition line of the &quot;impl&quot; function</li>
<li>and a comment indicating the end of output.</li>
</ul>
<p>The intention is that you write the body of your impl function immediately
after the output -- as in, you write a left-curly-brace immediately after
the end-of-output comment and implement builtin in the body there.
(It's a bit strange at first, but oddly convenient.)</p>
<p>Argument Clinic will define the parameters of the impl function for
you.  The function will take the &quot;self&quot; parameter passed in
originally, all the parameters you define, and possibly some extra
generated parameters (&quot;length&quot; parameters; also &quot;group&quot; parameters,
see next section).</p>
<p>Argument Clinic also writes a checksum for the output section.  This
is a valuable safety feature: if you modify the output by hand, Clinic
will notice that the checksum doesn't match, and will refuse to
overwrite the file.  (You can force Clinic to overwrite with the
&quot;<tt class="docutils literal"><span class="pre">-f</span></tt>&quot; command-line argument; Clinic will also ignore the checksums
when using the &quot;<tt class="docutils literal"><span class="pre">-o</span></tt>&quot; command-line argument.)</p>
<p>Finally, Argument Clinic can also emit the boilerplate definition
of the PyMethodDef array for the defined classes and modules.</p>
</div>
<div class="section" id="functions-with-positional-only-parameters">
<h1><a class="toc-backref" href="#id30">Functions With Positional-Only Parameters</a></h1>
<p>A significant fraction of Python builtins implemented in C use the
older positional-only API for processing arguments
(<tt class="docutils literal">PyArg_ParseTuple()</tt>).  In some instances, these builtins parse
their arguments differently based on how many arguments were passed
in.  This can provide some bewildering flexibility: there may be
groups of optional parameters, which must either all be specified or
none specified.  And occasionally these groups are on the <em>left!</em> (A
representative example: <tt class="docutils literal">curses.window.addch()</tt>.)</p>
<p>Argument Clinic supports these legacy use-cases by allowing you to
specify parameters in groups.  Each optional group of parameters
is marked with square brackets.  Note that these groups are permitted
on the right <em>or left</em> of any required parameters!</p>
<p>The impl function generated by Clinic will add an extra parameter for
every group, &quot;<tt class="docutils literal">int group_{left|right}_&lt;x&gt;</tt>&quot;, where x is a monotonically
increasing number assigned to each group as it builds away from the
required arguments.  This argument will be nonzero if the group was
specified on this call, and zero if it was not.</p>
<p>Note that when operating in this mode, you cannot specify default
arguments.</p>
<p>Also, note that it's possible to specify a set of groups to a function
such that there are several valid mappings from the number of
arguments to a valid set of groups.  If this happens, Clinic will abort
with an error message.  This should not be a problem, as
positional-only operation is only intended for legacy use cases, and
all the legacy functions using this quirky behavior have unambiguous
mappings.</p>
</div>
<div class="section" id="current-status">
<h1><a class="toc-backref" href="#id31">Current Status</a></h1>
<p>As of this writing, there is a working prototype implementation of
Argument Clinic available online (though the syntax may be out of date
as you read this). <a class="footnote-reference" href="#id13" id="id7">[6]</a> The prototype generates code using the
existing <tt class="docutils literal">PyArg_Parse</tt> APIs.  It supports translating to all current
format units except the mysterious <tt class="docutils literal">&quot;w*&quot;</tt>.  Sample functions using
Argument Clinic exercise all major features, including positional-only
argument parsing.</p>
<div class="section" id="argument-clinic-programmatic-interfaces">
<h2><a class="toc-backref" href="#id32">Argument Clinic Programmatic Interfaces</a></h2>
<p>The prototype also currently provides an experimental extension
mechanism, allowing adding support for new types on-the-fly.  See
<tt class="docutils literal">Modules/posixmodule.c</tt> in the prototype for an example of its use.</p>
<p>In the future, Argument Clinic is expected to be automatable enough
to allow querying, modification, or outright new construction of
function declarations through Python code.  It may even permit
dynamically adding your own custom DSL!</p>
</div>
</div>
<div class="section" id="notes-tbd">
<h1><a class="toc-backref" href="#id33">Notes / TBD</a></h1>
<ul>
<li><p class="first">The API for supplying inspect.Signature metadata for builtins is
currently under discussion.  Argument Clinic will add support for
the prototype when it becomes viable.</p>
</li>
<li><p class="first">Nick Coghlan suggests that we a) only support at most one left-optional
group per function, and b) in the face of ambiguity, prefer the left
group over the right group.  This would solve all our existing use cases
including range().</p>
</li>
<li><p class="first">Optimally we'd want Argument Clinic run automatically as part of the
normal Python build process.  But this presents a bootstrapping problem;
if you don't have a system Python 3, you need a Python 3 executable to
build Python 3.  I'm sure this is a solvable problem, but I don't know
what the best solution might be.  (Supporting this will also require
a parallel solution for Windows.)</p>
</li>
<li><p class="first">On a related note: inspect.Signature has no way of representing
blocks of arguments, like the left-optional block of <tt class="docutils literal">y</tt> and <tt class="docutils literal">x</tt>
for <tt class="docutils literal">curses.window.addch</tt>.  How far are we going to go in supporting
this admittedly aberrant parameter paradigm?</p>
</li>
<li><p class="first">During the PyCon US 2013 Language Summit, there was discussion of having
Argument Clinic also generate the actual documentation (in ReST, processed
by Sphinx) for the function.  The logistics of this are TBD, but it would
require that the docstrings be written in ReST, and require that Python
ship a ReST -&gt; ascii converter.  It would be best to come to a decision
about this before we begin any large-scale conversion of the CPython
source tree to using Clinic.</p>
</li>
<li><p class="first">Guido proposed having the &quot;function docstring&quot; be hand-written inline,
in the middle of the output, something like this:</p>
<pre class="literal-block">
/*[clinic]
  ... prototype and parameters (including parameter docstrings) go here
[clinic]*/
... some output ...
/*[clinic docstring start]*/
... hand-edited function docstring goes here   &lt;-- you edit this by hand!
/*[clinic docstring end]*/
... more output
/*[clinic output end]*/
</pre>
<p>I tried it this way and don't like it -- I think it's clumsy.  I
prefer that everything you write goes in one place, rather than
having an island of hand-edited stuff in the middle of the DSL
output.</p>
</li>
<li><p class="first">Argument Clinic does not support automatic tuple unpacking
(the &quot;<tt class="docutils literal">(OOO)</tt>&quot; style format string for <tt class="docutils literal">PyArg_ParseTuple()</tt>.)</p>
</li>
<li><p class="first">Argument Clinic removes some dynamism / flexibility.  With
<tt class="docutils literal">PyArg_ParseTuple()</tt> one could theoretically pass in different
encodings at runtime for the &quot;<tt class="docutils literal">es</tt>&quot;/&quot;<tt class="docutils literal">et</tt>&quot; format units.
AFAICT CPython doesn't do this itself, however it's possible
external users might  do this.  (Trivia: there are no uses of
&quot;<tt class="docutils literal">es</tt>&quot; exercised by regrtest, and all the uses of &quot;<tt class="docutils literal">et</tt>&quot;
exercised are in socketmodule.c, except for one in _ssl.c.
They're all static, specifying the encoding <tt class="docutils literal">&quot;idna&quot;</tt>.)</p>
</li>
</ul>
</div>
<div class="section" id="acknowledgements">
<h1><a class="toc-backref" href="#id34">Acknowledgements</a></h1>
<p>The PEP author wishes to thank Ned Batchelder for permission to
shamelessly rip off his clever design for Cog--&quot;my favorite tool
that I've never gotten to use&quot;.  Thanks also to everyone who provided
feedback on the [bugtracker issue] and on python-dev.  Special thanks
to Nick Coglan and Guido van Rossum for a rousing two-hour in-person
deep dive on the topic at PyCon US 2013.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id35">References</a></h1>
<table class="docutils citation" frame="void" id="cog" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[Cog]</a></td><td><tt class="docutils literal">Cog</tt>:
<a class="reference external" href="http://nedbatchelder.com/code/cog/">http://nedbatchelder.com/code/cog/</a></td></tr>
</tbody>
</table>
<!-- [bugtracker issue] Issue 16612 on the python.org bug tracker:
http://bugs.python.org/issue16612 -->
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><tt class="docutils literal">PyArg_ParseTuple()</tt>:
<a class="reference external" href="http://docs.python.org/3/c-api/arg.html#PyArg_ParseTuple">http://docs.python.org/3/c-api/arg.html#PyArg_ParseTuple</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><tt class="docutils literal">PyArg_ParseTupleAndKeywords()</tt>:
<a class="reference external" href="http://docs.python.org/3/c-api/arg.html#PyArg_ParseTupleAndKeywords">http://docs.python.org/3/c-api/arg.html#PyArg_ParseTupleAndKeywords</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><tt class="docutils literal">PyArg_</tt> format units:
<a class="reference external" href="http://docs.python.org/3/c-api/arg.html#strings-and-buffers">http://docs.python.org/3/c-api/arg.html#strings-and-buffers</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>Keyword parameters for extension functions:
<a class="reference external" href="http://docs.python.org/3/extending/extending.html#keyword-parameters-for-extension-functions">http://docs.python.org/3/extending/extending.html#keyword-parameters-for-extension-functions</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[5]</a></td><td>Guido van Rossum, posting to python-ideas, March 2012:
<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2012-March/014364.html">https://mail.python.org/pipermail/python-ideas/2012-March/014364.html</a>
and
<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2012-March/014378.html">https://mail.python.org/pipermail/python-ideas/2012-March/014378.html</a>
and
<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2012-March/014417.html">https://mail.python.org/pipermail/python-ideas/2012-March/014417.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[6]</a></td><td>Argument Clinic prototype:
<a class="reference external" href="https://bitbucket.org/larry/python-clinic/">https://bitbucket.org/larry/python-clinic/</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id36">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

