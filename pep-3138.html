<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">3138</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">String representation in Python 3000</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-3138.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Atsuo Ishimoto &lt;ishimoto--at--gembook.org&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">05-May-2008</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">05-May-2008, 05-Jun-2008</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id5">Abstract</a></li>
<li><a class="reference internal" href="#motivation" id="id6">Motivation</a></li>
<li><a class="reference internal" href="#specification" id="id7">Specification</a></li>
<li><a class="reference internal" href="#rationale" id="id8">Rationale</a><ul>
<li><a class="reference internal" href="#alternate-solutions" id="id9">Alternate Solutions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility" id="id10">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#rejected-proposals" id="id11">Rejected Proposals</a></li>
<li><a class="reference internal" href="#implementation" id="id12">Implementation</a></li>
<li><a class="reference internal" href="#references" id="id13">References</a></li>
<li><a class="reference internal" href="#copyright" id="id14">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id5">Abstract</a></h1>
<p>This PEP proposes a new string representation form for Python 3000.
In Python prior to Python 3000, the repr() built-in function converted
arbitrary objects to printable ASCII strings for debugging and
logging.  For Python 3000, a wider range of characters, based on the
Unicode standard, should be considered 'printable'.</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id6">Motivation</a></h1>
<p>The current repr() converts 8-bit strings to ASCII using following
algorithm.</p>
<ul class="simple">
<li>Convert CR, LF, TAB and '\' to '\r', '\n', '\t', '\\'.</li>
<li>Convert other non-printable characters(0x00-0x1f, 0x7f) and
non-ASCII characters (&gt;= 0x80) to '\xXX'.</li>
<li>Backslash-escape quote characters (apostrophe, ') and add the quote
character at the beginning and the end.</li>
</ul>
<p>For Unicode strings, the following additional conversions are done.</p>
<ul class="simple">
<li>Convert leading surrogate pair characters without trailing character
(0xd800-0xdbff, but not followed by 0xdc00-0xdfff) to '\uXXXX'.</li>
<li>Convert 16-bit characters (&gt;= 0x100) to '\uXXXX'.</li>
<li>Convert 21-bit characters (&gt;= 0x10000) and surrogate pair characters
to '\U00xxxxxx'.</li>
</ul>
<p>This algorithm converts any string to printable ASCII, and repr() is
used as a handy and safe way to print strings for debugging or for
logging.  Although all non-ASCII characters are escaped, this does not
matter when most of the string's characters are ASCII.  But for other
languages, such as Japanese where most characters in a string are not
ASCII, this is very inconvenient.</p>
<p>We can use <tt class="docutils literal">print(aJapaneseString)</tt> to get a readable string, but we
don't have a similar workaround for printing strings from collections
such as lists or tuples.  <tt class="docutils literal">print(listOfJapaneseStrings)</tt> uses repr()
to build the string to be printed, so the resulting strings are always
hex-escaped.  Or when <tt class="docutils literal">open(japaneseFilemame)</tt> raises an exception,
the error message is something like <tt class="docutils literal">IOError: [Errno 2] No such file
or directory: '\u65e5\u672c\u8a9e'</tt>, which isn't helpful.</p>
<p>Python 3000 has a lot of nice features for non-Latin users such as
non-ASCII identifiers, so it would be helpful if Python could also
progress in a similar way for printable output.</p>
<p>Some users might be concerned that such output will mess up their
console if they print binary data like images.  But this is unlikely
to happen in practice because bytes and strings are different types in
Python 3000, so printing an image to the console won't mess it up.</p>
<p>This issue was once discussed by Hye-Shik Chang <a class="footnote-reference" href="#id3" id="id1">[1]</a>, but was rejected.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id7">Specification</a></h1>
<ul class="simple">
<li>Add a new function to the Python C API <tt class="docutils literal">int Py_UNICODE_ISPRINTABLE
(Py_UNICODE ch)</tt>.  This function returns 0 if repr() should escape
the Unicode character <tt class="docutils literal">ch</tt>; otherwise it returns 1.  Characters
that should be escaped are defined in the Unicode character database
as:<ul>
<li>Cc (Other, Control)</li>
<li>Cf (Other, Format)</li>
<li>Cs (Other, Surrogate)</li>
<li>Co (Other, Private Use)</li>
<li>Cn (Other, Not Assigned)</li>
<li>Zl (Separator, Line), refers to LINE SEPARATOR ('\u2028').</li>
<li>Zp (Separator, Paragraph), refers to PARAGRAPH SEPARATOR
('\u2029').</li>
<li>Zs (Separator, Space) other than ASCII space ('\x20').  Characters
in this category should be escaped to avoid ambiguity.</li>
</ul>
</li>
<li>The algorithm to build repr() strings should be changed to:<ul>
<li>Convert CR, LF, TAB and '\' to '\r', '\n', '\t', '\\'.</li>
<li>Convert non-printable ASCII characters (0x00-0x1f, 0x7f) to
'\xXX'.</li>
<li>Convert leading surrogate pair characters without trailing
character (0xd800-0xdbff, but not followed by 0xdc00-0xdfff) to
'\uXXXX'.</li>
<li>Convert non-printable characters (Py_UNICODE_ISPRINTABLE() returns
0) to 'xXX', '\uXXXX' or '\U00xxxxxx'.</li>
<li>Backslash-escape quote characters (apostrophe, 0x27) and add a
quote character at the beginning and the end.</li>
</ul>
</li>
<li>Set the Unicode error-handler for sys.stderr to 'backslashreplace'
by default.</li>
<li>Add a new function to the Python C API <tt class="docutils literal">PyObject *PyObject_ASCII
(PyObject *o)</tt>.  This function converts any python object to a
string using PyObject_Repr() and then hex-escapes all non-ASCII
characters.  <tt class="docutils literal">PyObject_ASCII()</tt> generates the same string as
<tt class="docutils literal">PyObject_Repr()</tt> in Python 2.</li>
<li>Add a new built-in function, <tt class="docutils literal">ascii()</tt>.  This function converts
any python object to a string using repr() and then hex-escapes all
non-ASCII characters.  <tt class="docutils literal">ascii()</tt> generates the same string as
<tt class="docutils literal">repr()</tt> in Python 2.</li>
<li>Add a <tt class="docutils literal">'%a'</tt> string format operator.  <tt class="docutils literal">'%a'</tt> converts any python
object to a string using repr() and then hex-escapes all non-ASCII
characters.  The <tt class="docutils literal">'%a'</tt> format operator generates the same string
as <tt class="docutils literal">'%r'</tt> in Python 2.  Also, add <tt class="docutils literal">'!a'</tt> conversion flags to the
<tt class="docutils literal">string.format()</tt> method and add <tt class="docutils literal">'%A'</tt> operator to the
PyUnicode_FromFormat().  They convert any object to an ASCII string
as <tt class="docutils literal">'%a'</tt> string format operator.</li>
<li>Add an <tt class="docutils literal">isprintable()</tt> method to the string type.
<tt class="docutils literal">str.isprintable()</tt> returns False if repr() would escape any
character in the string; otherwise returns True.  The
<tt class="docutils literal">isprintable()</tt> method calls the <tt class="docutils literal">Py_UNICODE_ISPRINTABLE()</tt>
function internally.</li>
</ul>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id8">Rationale</a></h1>
<p>The repr() in Python 3000 should be Unicode, not ASCII based, just
like Python 3000 strings.  Also, conversion should not be affected by
the locale setting, because the locale is not necessarily the same as
the output device's locale.  For example, it is common for a daemon
process to be invoked in an ASCII setting, but writes UTF-8 to its log
files.  Also, web applications might want to report the error
information in more readable form based on the HTML page's encoding.</p>
<p>Characters not supported by the user's console could be hex-escaped on
printing, by the Unicode encoder's error-handler.  If the
error-handler of the output file is 'backslashreplace', such
characters are hex-escaped without raising UnicodeEncodeError.  For
example, if the default encoding is ASCII, <tt class="docutils literal"><span class="pre">print('Hello</span> ¢')</tt> will
print 'Hello \xa2'.  If the encoding is ISO-8859-1, 'Hello ¢' will be
printed.</p>
<p>The default error-handler for sys.stdout is 'strict'.  Other
applications reading the output might not understand hex-escaped
characters, so unsupported characters should be trapped when writing.
If unsupported characters must be escaped, the error-handler should be
changed explicitly.  Unlike sys.stdout, sys.stderr doesn't raise
UnicodeEncodingError by default, because the default error-handler is
'backslashreplace'.  So printing error messages containing non-ASCII
characters to sys.stderr will not raise an exception.  Also,
information about uncaught exceptions (exception object, traceback) is
printed by the interpreter without raising exceptions.</p>
<div class="section" id="alternate-solutions">
<h2><a class="toc-backref" href="#id9">Alternate Solutions</a></h2>
<p>To help debugging in non-Latin languages without changing repr(),
other suggestions were made.</p>
<ul>
<li><p class="first">Supply a tool to print lists or dicts.</p>
<p>Strings to be printed for debugging are not only contained by lists
or dicts, but also in many other types of object.  File objects
contain a file name in Unicode, exception objects contain a message
in Unicode, etc.  These strings should be printed in readable form
when repr()ed.  It is unlikely to be possible to implement a tool to
print all possible object types.</p>
</li>
<li><p class="first">Use sys.displayhook and sys.excepthook.</p>
<p>For interactive sessions, we can write hooks to restore hex escaped
characters to the original characters.  But these hooks are called
only when printing the result of evaluating an expression entered in
an interactive Python session, and don't work for the <tt class="docutils literal">print()</tt>
function, for non-interactive sessions or for <tt class="docutils literal"><span class="pre">logging.debug(&quot;%r&quot;,</span>
<span class="pre">...)</span></tt>, etc.</p>
</li>
<li><p class="first">Subclass sys.stdout and sys.stderr.</p>
<p>It is difficult to implement a subclass to restore hex-escaped
characters since there isn't enough information left by the time
it's a string to undo the escaping correctly in all cases.  For
example, <tt class="docutils literal"><span class="pre">print(&quot;\\&quot;+&quot;u0041&quot;)</span></tt> should be printed as '\u0041', not
'A'. But there is no chance to tell file objects apart.</p>
</li>
<li><p class="first">Make the encoding used by unicode_repr() adjustable, and make the
existing repr() the default.</p>
<p>With adjustable repr(), the result of using repr() is unpredictable
and would make it impossible to write correct code involving repr().
And if current repr() is the default, then the old convention
remains intact and users may expect ASCII strings as the result of
repr().  Third party applications or libraries could be confused
when a custom repr() function is used.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="backwards-compatibility">
<h1><a class="toc-backref" href="#id10">Backwards Compatibility</a></h1>
<p>Changing repr() may break some existing code, especially testing code.
Five of Python's regression tests fail with this modification.  If you
need repr() strings without non-ASCII character as Python 2, you can
use the following function.</p>
<pre class="literal-block">
def repr_ascii(obj):
    return str(repr(obj).encode(&quot;ASCII&quot;, &quot;backslashreplace&quot;), &quot;ASCII&quot;)
</pre>
<p>For logging or for debugging, the following code can raise
UnicodeEncodeError.</p>
<pre class="literal-block">
log = open(&quot;logfile&quot;, &quot;w&quot;)
log.write(repr(data))     # UnicodeEncodeError will be raised
                          # if data contains unsupported characters.
</pre>
<p>To avoid exceptions being raised, you can explicitly specify the
error-handler.</p>
<pre class="literal-block">
log = open(&quot;logfile&quot;, &quot;w&quot;, errors=&quot;backslashreplace&quot;)
log.write(repr(data))  # Unsupported characters will be escaped.
</pre>
<p>For a console that uses a Unicode-based encoding, for example,
en_US.utf8 or de_DE.utf8, the backslashreplace trick doesn't work and
all printable characters are not escaped.  This will cause a problem
of similarly drawing characters in Western, Greek and Cyrillic
languages.  These languages use similar (but different) alphabets
(descended from a common ancestor) and contain letters that look
similar but have different character codes.  For example, it is hard
to distinguish Latin 'a', 'e' and 'o' from Cyrillic 'а', 'е' and 'о'.
(The visual representation, of course, very much depends on the fonts
used but usually these letters are almost indistinguishable.)  To
avoid the problem, the user can adjust the terminal encoding to get a
result suitable for their environment.</p>
</div>
<div class="section" id="rejected-proposals">
<h1><a class="toc-backref" href="#id11">Rejected Proposals</a></h1>
<ul>
<li><p class="first">Add encoding and errors arguments to the builtin print() function,
with defaults of sys.getfilesystemencoding() and 'backslashreplace'.</p>
<p>Complicated to implement, and in general, this is not seen as a good
idea. <a class="footnote-reference" href="#id4" id="id2">[2]</a></p>
</li>
<li><p class="first">Use character names to escape characters, instead of hex character
codes.  For example, <tt class="docutils literal"><span class="pre">repr('\u03b1')</span></tt> can be converted to
<tt class="docutils literal">&quot;\N{GREEK SMALL LETTER ALPHA}&quot;</tt>.</p>
<p>Using character names can be very verbose compared to hex-escape.
e.g., <tt class="docutils literal"><span class="pre">repr(&quot;\ufbf9&quot;)</span></tt> is converted to <tt class="docutils literal">&quot;\N{ARABIC LIGATURE
UIGHUR KIRGHIZ YEH WITH HAMZA ABOVE WITH ALEF MAKSURA ISOLATED
FORM}&quot;</tt>.</p>
</li>
<li><p class="first">Default error-handler of sys.stdout should be 'backslashreplace'.</p>
<p>Stuff written to stdout might be consumed by another program that
might misinterpret the \ escapes.  For interactive sessions, it is
possible to make the 'backslashreplace' error-handler the default,
but this may add confusion of the kind &quot;it works in interactive mode
but not when redirecting to a file&quot;.</p>
</li>
</ul>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id12">Implementation</a></h1>
<p>The author wrote a patch in <a class="reference external" href="http://bugs.python.org/issue2630">http://bugs.python.org/issue2630</a>; this was
committed to the Python 3.0 branch in revision 64138 on 06-11-2008.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id13">References</a></h1>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Multibyte string on string::string_print
(<a class="reference external" href="http://bugs.python.org/issue479898">http://bugs.python.org/issue479898</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>[Python-3000] Displaying strings containing unicode escapes
(<a class="reference external" href="https://mail.python.org/pipermail/python-3000/2008-April/013366.html">https://mail.python.org/pipermail/python-3000/2008-April/013366.html</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id14">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

