<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">225</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Elementwise/Objectwise Operators</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0225.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">hzhu&#32;&#97;t&#32;users.sourceforge.net (Huaiyu Zhu),
gregory.lielens&#32;&#97;t&#32;fft.be (Gregory Lielens)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">19-Sep-2000</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.1</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://www.python.org/dev/peps/pep-0465/#rejected-alternatives-to-adding-a-new-operator">https://www.python.org/dev/peps/pep-0465/#rejected-alternatives-to-adding-a-new-operator</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id3">Introduction</a></li>
<li><a class="reference internal" href="#background" id="id4">Background</a></li>
<li><a class="reference internal" href="#proposed-extension" id="id5">Proposed extension</a></li>
<li><a class="reference internal" href="#prototype-implementation" id="id6">Prototype Implementation</a></li>
<li><a class="reference internal" href="#alternatives-to-adding-new-operators" id="id7">Alternatives to adding new operators</a></li>
<li><a class="reference internal" href="#alternative-forms-of-infix-operators" id="id8">Alternative forms of infix operators</a></li>
<li><a class="reference internal" href="#semantics-of-new-operators" id="id9">Semantics of new operators</a></li>
<li><a class="reference internal" href="#examples" id="id10">Examples</a></li>
<li><a class="reference internal" href="#miscellaneous-issues" id="id11">Miscellaneous issues</a></li>
<li><a class="reference internal" href="#impact-on-general-elementization" id="id12">Impact on general elementization</a><ul>
<li><a class="reference internal" href="#notes" id="id13">Notes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#impact-on-named-operators" id="id14">Impact on named operators</a></li>
<li><a class="reference internal" href="#credits-and-archives" id="id15">Credits and archives</a></li>
<li><a class="reference internal" href="#additional-references" id="id16">Additional References</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id3">Introduction</a></h1>
<p>This PEP describes a proposal to add new operators to Python which are useful
for distinguishing elementwise and objectwise operations, and summarizes
discussions in the news group comp.lang.python on this topic.  See Credits and
Archives section at end.  Issues discussed here include:</p>
<ul class="simple">
<li>Background.</li>
<li>Description of proposed operators and implementation issues.</li>
<li>Analysis of alternatives to new operators.</li>
<li>Analysis of alternative forms.</li>
<li>Compatibility issues</li>
<li>Description of wider extensions and other related ideas.</li>
</ul>
<p>A substantial portion of this PEP describes ideas that do not go into the
proposed extension.  They are presented because the extension is essentially
syntactic sugar, so its adoption must be weighed against various possible
alternatives.  While many alternatives may be better in some aspects, the
current proposal appears to be overall advantageous.</p>
<p>The issues concerning elementwise-objectwise operations extends to wider areas
than numerical computation.  This document also describes how the current
proposal may be integrated with more general future extensions.</p>
</div>
<div class="section" id="background">
<h1><a class="toc-backref" href="#id4">Background</a></h1>
<p>Python provides six binary infix math operators: <tt class="docutils literal">+</tt> <tt class="docutils literal">-</tt> <tt class="docutils literal">*</tt> <tt class="docutils literal">/</tt> <tt class="docutils literal">%</tt>
<tt class="docutils literal">**</tt> hereafter generically represented by <tt class="docutils literal">op</tt>.  They can be overloaded
with new semantics for user-defined classes.  However, for objects composed of
homogeneous elements, such as arrays, vectors and matrices in numerical
computation, there are two essentially distinct flavors of semantics.  The
objectwise operations treat these objects as points in multidimensional spaces.
The elementwise operations treat them as collections of individual elements.
These two flavors of operations are often intermixed in the same formulas,
thereby requiring syntactical distinction.</p>
<p>Many numerical computation languages provide two sets of math operators.  For
example, in MatLab, the ordinary <tt class="docutils literal">op</tt> is used for objectwise operation while
<tt class="docutils literal">.op</tt> is used for elementwise operation. In R, <tt class="docutils literal">op</tt> stands for elementwise
operation while <tt class="docutils literal">%op%</tt> stands for objectwise operation.</p>
<p>In Python, there are other methods of representation, some of which already
used by available numerical packages, such as:</p>
<ul class="simple">
<li>function:   mul(a,b)</li>
<li>method:     a.mul(b)</li>
<li>casting:    a.E*b</li>
</ul>
<p>In several aspects these are not as adequate as infix operators. More details
will be shown later, but the key points are:</p>
<ul class="simple">
<li>Readability: Even for moderately complicated formulas, infix operators are
much cleaner than alternatives.</li>
<li>Familiarity: Users are familiar with ordinary math operators.</li>
<li>Implementation: New infix operators will not unduly clutter Python syntax.
They will greatly ease the implementation of numerical packages.</li>
</ul>
<p>While it is possible to assign current math operators to one flavor of
semantics, there is simply not enough infix operators to overload for the other
flavor.  It is also impossible to maintain visual symmetry between these two
flavors if one of them does not contain symbols for ordinary math operators.</p>
</div>
<div class="section" id="proposed-extension">
<h1><a class="toc-backref" href="#id5">Proposed extension</a></h1>
<ul class="simple">
<li>Six new binary infix operators <tt class="docutils literal">~+</tt> <tt class="docutils literal">~-</tt> <tt class="docutils literal">~*</tt> <tt class="docutils literal">~/</tt> <tt class="docutils literal">~%</tt> <tt class="docutils literal">~**</tt> are
added to core Python.  They parallel the existing operators <tt class="docutils literal">+</tt> <tt class="docutils literal">-</tt> <tt class="docutils literal">*</tt>
<tt class="docutils literal">/</tt> <tt class="docutils literal">%</tt> <tt class="docutils literal">**</tt>.</li>
<li>Six augmented assignment operators <tt class="docutils literal">~+=</tt> <tt class="docutils literal"><span class="pre">~-=</span></tt> <tt class="docutils literal">~*=</tt> <tt class="docutils literal">~/=</tt> <tt class="docutils literal">~%=</tt>
<tt class="docutils literal"><span class="pre">~**=</span></tt> are added to core Python.  They parallel the operators <tt class="docutils literal">+=</tt> <tt class="docutils literal"><span class="pre">-=</span></tt>
<tt class="docutils literal">*=</tt> <tt class="docutils literal">/=</tt> <tt class="docutils literal">%=</tt> <tt class="docutils literal">**=</tt> available in Python 2.0.</li>
<li>Operator <tt class="docutils literal">~op</tt> retains the syntactical properties of operator <tt class="docutils literal">op</tt>,
including precedence.</li>
<li>Operator <tt class="docutils literal">~op</tt> retains the semantical properties of operator <tt class="docutils literal">op</tt> on
built-in number types.</li>
<li>Operator <tt class="docutils literal">~op</tt> raise syntax error on non-number builtin types. This is
temporary until the proper behavior can be agreed upon.</li>
<li>These operators are overloadable in classes with names that prepend <em>t</em> (for
tilde) to names of ordinary math operators. For example, <tt class="docutils literal">__tadd__</tt> and
<tt class="docutils literal">__rtadd__</tt> work for <tt class="docutils literal">~+</tt> just as <tt class="docutils literal">__add__</tt> and <tt class="docutils literal">__radd__</tt> work for
<tt class="docutils literal">+</tt>.</li>
<li>As with existing operators, the <tt class="docutils literal">__r*__()</tt> methods are invoked when the
left operand does not provide the appropriate method.</li>
</ul>
<p>It is intended that one set of <tt class="docutils literal">op</tt> or <tt class="docutils literal">~op</tt> is used for elementwise
operations, the other for objectwise operations, but it is not specified which
version of operators stands for elementwise or objectwise operations, leaving
the decision to applications.</p>
<p>The proposed implementation is to patch several files relating to the
tokenizer, parser, grammar and compiler to duplicate the functionality of
corresponding existing operators as necessary. All new semantics are to be
implemented in the classes that overload them.</p>
<p>The symbol <tt class="docutils literal">~</tt> is already used in Python as the unary <em>bitwise not</em> operator.
Currently it is not allowed for binary operators.  The new operators are
completely backward compatible.</p>
</div>
<div class="section" id="prototype-implementation">
<h1><a class="toc-backref" href="#id6">Prototype Implementation</a></h1>
<p>Greg Lielens implemented the infix <tt class="docutils literal">~op</tt> as a patch against Python 2.0b1
source <a class="footnote-reference" href="#id2" id="id1">[1]</a>.</p>
<p>To allow <tt class="docutils literal">~</tt> to be part of binary operators, the tokenizer would treat <tt class="docutils literal">~+</tt>
as one token.  This means that currently valid expression <tt class="docutils literal">~+1</tt> would be
tokenized as <tt class="docutils literal">~+</tt> <tt class="docutils literal">1</tt> instead of <tt class="docutils literal">~ + 1</tt>.  The parser would then treat <tt class="docutils literal">~+</tt>
as composite of <tt class="docutils literal">~ +</tt>.  The effect is invisible to applications.</p>
<p>Notes about current patch:</p>
<ul class="simple">
<li>It does not include <tt class="docutils literal">~op=</tt> operators yet.</li>
<li>The <tt class="docutils literal">~op</tt> behaves the same as <tt class="docutils literal">op</tt> on lists, instead of raising
exceptions.</li>
</ul>
<p>These should be fixed when the final version of this proposal is ready.</p>
<ul>
<li><p class="first">It reserves <tt class="docutils literal">xor</tt> as an infix operator with the semantics equivalent to:</p>
<pre class="literal-block">
def __xor__(a, b):
    if not b: return a
    elif not a: return b
    else: 0
</pre>
</li>
</ul>
<p>This preserves true value as much as possible, otherwise preserve left hand
side value if possible.</p>
<p>This is done so that bitwise operators could be regarded as elementwise
logical operators in the future (see below).</p>
</div>
<div class="section" id="alternatives-to-adding-new-operators">
<h1><a class="toc-backref" href="#id7">Alternatives to adding new operators</a></h1>
<p>The discussions on comp.lang.python and python-dev mailing list explored many
alternatives.  Some of the leading alternatives are listed here, using the
multiplication operator as an example.</p>
<ol class="arabic">
<li><p class="first">Use function <tt class="docutils literal">mul(a,b)</tt>.</p>
<p>Advantage:</p>
<ul class="simple">
<li>No need for new operators.</li>
</ul>
<p>Disadvantage:</p>
<ul class="simple">
<li>Prefix forms are cumbersome for composite formulas.</li>
<li>Unfamiliar to the intended users.</li>
<li>Too verbose for the intended users.</li>
<li>Unable to use natural precedence rules.</li>
</ul>
</li>
<li><p class="first">Use method call <tt class="docutils literal">a.mul(b)</tt>.</p>
<p>Advantage:</p>
<ul class="simple">
<li>No need for new operators.</li>
</ul>
<p>Disadvantage:</p>
<ul class="simple">
<li>Asymmetric for both operands.</li>
<li>Unfamiliar to the intended users.</li>
<li>Too verbose for the intended users.</li>
<li>Unable to use natural precedence rules.</li>
</ul>
</li>
<li><p class="first">Use <em>shadow classes</em>.  For matrix class define a shadow array class
accessible through a method <tt class="docutils literal">.E</tt>, so that for matrices <em>a</em> and <em>b</em>,
<tt class="docutils literal">a.E*b</tt> would be a matrix object that is <tt class="docutils literal">elementwise_mul(a,b)</tt>.</p>
<p>Likewise define a shadow matrix class for arrays accessible through a method
<tt class="docutils literal">.M</tt> so that for arrays <em>a</em> and <em>b</em>, <tt class="docutils literal">a.M*b</tt> would be an array that is
<tt class="docutils literal">matrixwise_mul(a,b)</tt>.</p>
<p>Advantage:</p>
<ul class="simple">
<li>No need for new operators.</li>
<li>Benefits of infix operators with correct precedence rules.</li>
<li>Clean formulas in applications.</li>
</ul>
<p>Disadvantage:</p>
<ul class="simple">
<li>Hard to maintain in current Python because ordinary numbers cannot have
user defined class methods; i.e. <tt class="docutils literal">a.E*b</tt> will fail if a is a pure
number.</li>
<li>Difficult to implement, as this will interfere with existing method calls,
like <tt class="docutils literal">.T</tt> for transpose, etc.</li>
<li>Runtime overhead of object creation and method lookup.</li>
<li>The shadowing class cannot replace a true class, because it does not
return its own type.  So there need to be a <tt class="docutils literal">M</tt> class with shadow <tt class="docutils literal">E</tt>
class, and an <tt class="docutils literal">E</tt> class with shadow <tt class="docutils literal">M</tt> class.</li>
<li>Unnatural to mathematicians.</li>
</ul>
</li>
<li><p class="first">Implement matrixwise and elementwise classes with easy casting to the other
class.  So matrixwise operations for arrays would be like <tt class="docutils literal">a.M*b.M</tt> and
elementwise operations for matrices would be like <tt class="docutils literal">a.E*b.E</tt>.  For error
detection <tt class="docutils literal">a.E*b.M</tt> would raise exceptions.</p>
<p>Advantage:</p>
<ul class="simple">
<li>No need for new operators.</li>
<li>Similar to infix notation with correct precedence rules.</li>
</ul>
<p>Disadvantage:</p>
<ul class="simple">
<li>Similar difficulty due to lack of user-methods for pure numbers.</li>
<li>Runtime overhead of object creation and method lookup.</li>
<li>More cluttered formulas.</li>
<li>Switching of flavor of objects to facilitate operators becomes persistent.
This introduces long range context dependencies in application code that
would be extremely hard to maintain.</li>
</ul>
</li>
<li><p class="first">Using mini parser to parse formulas written in arbitrary extension placed in
quoted strings.</p>
<p>Advantage:</p>
<ul class="simple">
<li>Pure Python, without new operators</li>
</ul>
<p>Disadvantage:</p>
<ul class="simple">
<li>The actual syntax is within the quoted string, which does not resolve the
problem itself.</li>
<li>Introducing zones of special syntax.</li>
<li>Demanding on the mini-parser.</li>
</ul>
</li>
<li><p class="first">Introducing a single operator, such as <tt class="docutils literal">&#64;</tt>, for matrix multiplication.</p>
<p>Advantage:</p>
<ul class="simple">
<li>Introduces less operators</li>
</ul>
<p>Disadvantage:</p>
<ul class="simple">
<li>The distinctions for operators like <tt class="docutils literal">+</tt> <tt class="docutils literal">-</tt> <tt class="docutils literal">**</tt> are equally
important.  Their meaning in matrix or array-oriented packages would be
reversed (see below).</li>
<li>The new operator occupies a special character.</li>
<li>This does not work well with more general object-element issues.</li>
</ul>
</li>
</ol>
<p>Among these alternatives, the first and second are used in current applications
to some extent, but found inadequate.  The third is the most favorite for
applications, but it will incur huge implementation complexity.  The fourth
would make applications codes very context-sensitive and hard to maintain.
These two alternatives also share significant implementational difficulties due
to current type/class split.  The fifth appears to create more problems than it
would solve.  The sixth does not cover the same range of applications.</p>
</div>
<div class="section" id="alternative-forms-of-infix-operators">
<h1><a class="toc-backref" href="#id8">Alternative forms of infix operators</a></h1>
<p>Two major forms and several minor variants of new infix operators were
discussed:</p>
<ul>
<li><p class="first">Bracketed form:</p>
<pre class="literal-block">
(op)
[op]
{op}
&lt;op&gt;
:op:
~op~
%op%
</pre>
</li>
<li><p class="first">Meta character form:</p>
<pre class="literal-block">
.op
&#64;op
~op
</pre>
<p>Alternatively the meta character is put after the operator.</p>
</li>
<li><p class="first">Less consistent variations of these themes.  These are considered
unfavorably.  For completeness some are listed here:</p>
<ul class="simple">
<li>Use <tt class="docutils literal">&#64;/</tt> and <tt class="docutils literal">/&#64;</tt> for left and right division</li>
<li>Use <tt class="docutils literal">[*]</tt> and <tt class="docutils literal">(*)</tt> for outer and inner products</li>
<li>Use a single operator <tt class="docutils literal">&#64;</tt> for multiplication.</li>
</ul>
</li>
<li><p class="first">Use <tt class="docutils literal">__call__</tt> to simulate multiplication:</p>
<pre class="literal-block">
a(b) or (a)(b)
</pre>
</li>
</ul>
<p>Criteria for choosing among the representations include:</p>
<ul class="simple">
<li>No syntactical ambiguities with existing operators.</li>
<li>Higher readability in actual formulas.  This makes the bracketed forms
unfavorable.  See examples below.</li>
<li>Visually similar to existing math operators.</li>
<li>Syntactically simple, without blocking possible future extensions.</li>
</ul>
<p>With these criteria the overall winner in bracket form appear to be <tt class="docutils literal">{op}</tt>.
A clear winner in the meta character form is <tt class="docutils literal">~op</tt>. Comparing these it
appears that <tt class="docutils literal">~op</tt> is the favorite among them all.</p>
<p>Some analysis are as follows:</p>
<ul class="simple">
<li>The <tt class="docutils literal">.op</tt> form is ambiguous: <tt class="docutils literal"><span class="pre">1.+a</span></tt> would be different from <tt class="docutils literal">1 .+a</tt>.</li>
<li>The bracket type operators are most favorable when standing alone, but
not in formulas, as they interfere with visual parsing of parentheses for
precedence and function argument. This is so for <tt class="docutils literal">(op)</tt> and <tt class="docutils literal">[op]</tt>, and
somewhat less so for <tt class="docutils literal">{op}</tt> and <tt class="docutils literal">&lt;op&gt;</tt>.</li>
<li>The <tt class="docutils literal">&lt;op&gt;</tt> form has the potential to be confused with <tt class="docutils literal">&lt;</tt> <tt class="docutils literal">&gt;</tt> and <tt class="docutils literal">=</tt>.</li>
<li>The <tt class="docutils literal">&#64;op</tt> is not favored because <tt class="docutils literal">&#64;</tt> is visually heavy (dense, more like
a letter): <tt class="docutils literal"><span class="pre">a&#64;+b</span></tt> is more readily read as <tt class="docutils literal">a&#64; + b</tt> than <tt class="docutils literal">a &#64;+ b</tt>.</li>
<li>For choosing meta-characters: Most of existing ASCII symbols have already
been used.  The only three unused are <tt class="docutils literal">&#64;</tt> <tt class="docutils literal">$</tt> <tt class="docutils literal">?</tt>.</li>
</ul>
</div>
<div class="section" id="semantics-of-new-operators">
<h1><a class="toc-backref" href="#id9">Semantics of new operators</a></h1>
<p>There are convincing arguments for using either set of operators as objectwise
or elementwise.  Some of them are listed here:</p>
<ol class="arabic simple">
<li><tt class="docutils literal">op</tt> for element, <tt class="docutils literal">~op</tt> for object<ul>
<li>Consistent with current multiarray interface of Numeric package.</li>
<li>Consistent with some other languages.</li>
<li>Perception that elementwise operations are more natural.</li>
<li>Perception that elementwise operations are used more frequently</li>
</ul>
</li>
<li><tt class="docutils literal">op</tt> for object, <tt class="docutils literal">~op</tt> for element<ul>
<li>Consistent with current linear algebra interface of MatPy package.</li>
<li>Consistent with some other languages.</li>
<li>Perception that objectwise operations are more natural.</li>
<li>Perception that objectwise operations are used more frequently.</li>
<li>Consistent with the current behavior of operators on lists.</li>
<li>Allow <tt class="docutils literal">~</tt> to be a general elementwise meta-character in future
extensions.</li>
</ul>
</li>
</ol>
<p>It is generally agreed upon that</p>
<ul class="simple">
<li>There is no absolute reason to favor one or the other.</li>
<li>It is easy to cast from one representation to another in a sizable chunk of
code, so the other flavor of operators is always minority.</li>
<li>There are other semantic differences that favor existence of array-oriented
and matrix-oriented packages, even if their operators are unified.</li>
<li>Whatever the decision is taken, codes using existing interfaces should not be
broken for a very long time.</li>
</ul>
<p>Therefore, not much is lost, and much flexibility retained, if the semantic
flavors of these two sets of operators are not dictated by the core language.
The application packages are responsible for making the most suitable choice.
This is already the case for NumPy and MatPy which use opposite semantics.
Adding new operators will not break this.  See also observation after
subsection 2 in the Examples below.</p>
<p>The issue of numerical precision was raised, but if the semantics is left to
the applications, the actual precisions should also go there.</p>
</div>
<div class="section" id="examples">
<h1><a class="toc-backref" href="#id10">Examples</a></h1>
<p>Following are examples of the actual formulas that will appear using various
operators or other representations described above.</p>
<ol class="arabic">
<li><p class="first">The matrix inversion formula:</p>
<ul>
<li><p class="first">Using <tt class="docutils literal">op</tt> for object and <tt class="docutils literal">~op</tt> for element:</p>
<pre class="literal-block">
b = a.I - a.I * u / (c.I + v/a*u) * v / a

b = a.I - a.I * u * (c.I + v*a.I*u).I * v * a.I
</pre>
</li>
<li><p class="first">Using <tt class="docutils literal">op</tt> for element and <tt class="docutils literal">~op</tt> for object:</p>
<pre class="literal-block">
b = a.I &#64;- a.I &#64;* u &#64;/ (c.I &#64;+ v&#64;/a&#64;*u) &#64;* v &#64;/ a

b = a.I ~- a.I ~* u ~/ (c.I ~+ v~/a~*u) ~* v ~/ a

b = a.I (-) a.I (*) u (/) (c.I (+) v(/)a(*)u) (*) v (/) a

b = a.I [-] a.I [*] u [/] (c.I [+] v[/]a[*]u) [*] v [/] a

b = a.I &lt;-&gt; a.I &lt;*&gt; u &lt;/&gt; (c.I &lt;+&gt; v&lt;/&gt;a&lt;*&gt;u) &lt;*&gt; v &lt;/&gt; a

b = a.I {-} a.I {*} u {/} (c.I {+} v{/}a{*}u) {*} v {/} a
</pre>
</li>
</ul>
<p>Observation: For linear algebra using <tt class="docutils literal">op</tt> for object is preferable.</p>
<p>Observation: The <tt class="docutils literal">~op</tt> type operators look better than <tt class="docutils literal">(op)</tt> type in
complicated formulas.</p>
<ul>
<li><p class="first">using named operators:</p>
<pre class="literal-block">
b = a.I &#64;sub a.I &#64;mul u &#64;div (c.I &#64;add v &#64;div a &#64;mul u) &#64;mul v &#64;div a

b = a.I ~sub a.I ~mul u ~div (c.I ~add v ~div a ~mul u) ~mul v ~div a
</pre>
</li>
</ul>
<p>Observation: Named operators are not suitable for math formulas.</p>
</li>
<li><p class="first">Plotting a 3d graph</p>
<ul>
<li><p class="first">Using <tt class="docutils literal">op</tt> for object and <tt class="docutils literal">~op</tt> for element:</p>
<pre class="literal-block">
z = sin(x~**2 ~+ y~**2);    plot(x,y,z)
</pre>
</li>
<li><p class="first">Using op for element and ~op for object:</p>
<pre class="literal-block">
z = sin(x**2 + y**2);   plot(x,y,z)
</pre>
</li>
</ul>
<p>Observation: Elementwise operations with broadcasting allows much more
efficient implementation than MatLab.</p>
<p>Observation: It is useful to have two related classes with the semantics of
<tt class="docutils literal">op</tt> and <tt class="docutils literal">~op</tt> swapped.  Using these the <tt class="docutils literal">~op</tt> operators would only
need to appear in chunks of code where the other flavor dominates, while
maintaining consistent semantics of the code.</p>
</li>
<li><p class="first">Using <tt class="docutils literal">+</tt> and <tt class="docutils literal">-</tt> with automatic broadcasting:</p>
<pre class="literal-block">
a = b - c;  d = a.T*a
</pre>
<p>Observation: This would silently produce hard-to-trace bugs if one of <em>b</em> or
<em>c</em> is row vector while the other is column vector.</p>
</li>
</ol>
</div>
<div class="section" id="miscellaneous-issues">
<h1><a class="toc-backref" href="#id11">Miscellaneous issues</a></h1>
<ul>
<li><p class="first">Need for the <tt class="docutils literal">~+</tt> <tt class="docutils literal">~-</tt> operators.  The objectwise <tt class="docutils literal">+</tt> <tt class="docutils literal">-</tt> are
important because they provide important sanity checks as per linear algebra.
The elementwise <tt class="docutils literal">+</tt> <tt class="docutils literal">-</tt> are important because they allow broadcasting
that are very efficient in applications.</p>
</li>
<li><p class="first">Left division (solve).  For matrix, <tt class="docutils literal">a*x</tt> is not necessarily equal to
<tt class="docutils literal">x*a</tt>.  The solution of <tt class="docutils literal"><span class="pre">a*x==b</span></tt>, denoted <tt class="docutils literal">x=solve(a,b)</tt>, is therefore
different from the solution of <tt class="docutils literal"><span class="pre">x*a==b</span></tt>, denoted <tt class="docutils literal">x=div(b,a)</tt>.  There are
discussions about finding a new symbol for solve.  [Background: MatLab use
<tt class="docutils literal">b/a</tt> for <tt class="docutils literal">div(b,a)</tt> and <tt class="docutils literal">a\b</tt> for <tt class="docutils literal">solve(a,b)</tt>.]</p>
<p>It is recognized that Python provides a better solution without requiring a
new symbol: the <tt class="docutils literal">inverse</tt> method <tt class="docutils literal">.I</tt> can be made to be delayed so that
<tt class="docutils literal">a.I*b</tt> and <tt class="docutils literal">b*a.I</tt> are equivalent to Matlab's <tt class="docutils literal">a\b</tt> and <tt class="docutils literal">b/a</tt>.  The
implementation is quite simple and the resulting application code clean.</p>
</li>
<li><p class="first">Power operator.  Python's use of <tt class="docutils literal"><span class="pre">a**b</span></tt> as <tt class="docutils literal">pow(a,b)</tt> has two perceived
disadvantages:</p>
<ul class="simple">
<li>Most mathematicians are more familiar with <tt class="docutils literal">a^b</tt> for this purpose.</li>
<li>It results in long augmented assignment operator <tt class="docutils literal"><span class="pre">~**=</span></tt>.</li>
</ul>
<p>However, this issue is distinct from the main issue here.</p>
</li>
<li><p class="first">Additional multiplication operators.  Several forms of multiplications are
used in (multi-)linear algebra.  Most can be seen as variations of
multiplication in linear algebra sense (such as Kronecker product).  But two
forms appear to be more fundamental: outer product and inner product.
However, their specification includes indices, which can be either</p>
<ul class="simple">
<li>associated with the operator, or</li>
<li>associated with the objects.</li>
</ul>
<p>The latter (the Einstein notation) is used extensively on paper, and is also
the easier one to implement.  By implementing a tensor-with-indices class, a
general form of multiplication would cover both outer and inner products, and
specialize to linear algebra multiplication as well.  The index rule can be
defined as class methods, like:</p>
<pre class="literal-block">
a = b.i(1,2,-1,-2) * c.i(4,-2,3,-1)   # a_ijkl = b_ijmn c_lnkm
</pre>
<p>Therefore, one objectwise multiplication is sufficient.</p>
</li>
<li><p class="first">Bitwise operators.</p>
<ul class="simple">
<li>The proposed new math operators use the symbol ~ that is <em>bitwise not</em>
operator.  This poses no compatibility problem but somewhat complicates
implementation.</li>
<li>The symbol <tt class="docutils literal">^</tt> might be better used for <tt class="docutils literal">pow</tt> than bitwise <tt class="docutils literal">xor</tt>. But
this depends on the future of bitwise operators.  It does not immediately
impact on the proposed math operator.</li>
<li>The symbol <tt class="docutils literal">|</tt> was suggested to be used for matrix solve.  But the new
solution of using delayed <tt class="docutils literal">.I</tt> is better in several ways.</li>
<li>The current proposal fits in a larger and more general extension that will
remove the need for special bitwise operators.  (See elementization below.)</li>
</ul>
</li>
<li><p class="first">Alternative to special operator names used in definition,</p>
<pre class="literal-block">
def &quot;+&quot;(a, b)      in place of       def __add__(a, b)
</pre>
<p>This appears to require greater syntactical change, and would only be useful
when arbitrary additional operators are allowed.</p>
</li>
</ul>
</div>
<div class="section" id="impact-on-general-elementization">
<h1><a class="toc-backref" href="#id12">Impact on general elementization</a></h1>
<p>The distinction between objectwise and elementwise operations are meaningful in
other contexts as well, where an object can be conceptually regarded as a
collection of elements.  It is important that the current proposal does not
preclude possible future extensions.</p>
<p>One general future extension is to use <tt class="docutils literal">~</tt> as a meta operator to <em>elementize</em>
a given operator.  Several examples are listed here:</p>
<ol class="arabic">
<li><p class="first">Bitwise operators.  Currently Python assigns six operators to bitwise
operations: and (<tt class="docutils literal">&amp;</tt>), or (<tt class="docutils literal">|</tt>), xor (<tt class="docutils literal">^</tt>), complement (<tt class="docutils literal">~</tt>), left
shift (<tt class="docutils literal">&lt;&lt;</tt>) and right shift (<tt class="docutils literal">&gt;&gt;</tt>), with their own precedence levels.</p>
<p>Among them, the <tt class="docutils literal">&amp;</tt> <tt class="docutils literal">|</tt> <tt class="docutils literal">^</tt> <tt class="docutils literal">~</tt> operators can be regarded as
elementwise versions of lattice operators applied to integers regarded as
bit strings.:</p>
<pre class="literal-block">
5 and 6                # 6
5 or 6                 # 5

5 ~and 6               # 4
5 ~or 6                # 7
</pre>
<p>These can be regarded as general elementwise lattice operators, not
restricted to bits in integers.</p>
<p>In order to have named operators for <tt class="docutils literal">xor</tt> <tt class="docutils literal">~xor</tt>, it is necessary to
make <tt class="docutils literal">xor</tt> a reserved word.</p>
</li>
<li><p class="first">List arithmetics.:</p>
<pre class="literal-block">
[1, 2] + [3, 4]        # [1, 2, 3, 4]
[1, 2] ~+ [3, 4]       # [4, 6]

['a', 'b'] * 2         # ['a', 'b', 'a', 'b']
'ab' * 2               # 'abab'

['a', 'b'] ~* 2        # ['aa', 'bb']
[1, 2] ~* 2            # [2, 4]
</pre>
<p>It is also consistent to Cartesian product:</p>
<pre class="literal-block">
[1,2]*[3,4]            # [(1,3),(1,4),(2,3),(2,4)]
</pre>
</li>
<li><p class="first">List comprehension.:</p>
<pre class="literal-block">
a = [1, 2]; b = [3, 4]
~f(a,b)                # [f(x,y) for x, y in zip(a,b)]
~f(a*b)                # [f(x,y) for x in a for y in b]
a ~+ b                 # [x + y for x, y in zip(a,b)]
</pre>
</li>
<li><p class="first">Tuple generation (the zip function in Python 2.0):</p>
<pre class="literal-block">
[1, 2, 3], [4, 5, 6]   # ([1,2, 3], [4, 5, 6])
[1, 2, 3]~,[4, 5, 6]   # [(1,4), (2, 5), (3,6)]
</pre>
</li>
<li><p class="first">Using <tt class="docutils literal">~</tt> as generic elementwise meta-character to replace map:</p>
<pre class="literal-block">
~f(a, b)               # map(f, a, b)
~~f(a, b)              # map(lambda *x:map(f, *x), a, b)
</pre>
<p>More generally,:</p>
<pre class="literal-block">
def ~f(*x): return map(f, *x)
def ~~f(*x): return map(~f, *x)
...
</pre>
</li>
<li><p class="first">Elementwise format operator (with broadcasting):</p>
<pre class="literal-block">
a = [1,2,3,4,5]
print [&quot;%5d &quot;] ~% a
a = [[1,2],[3,4]]
print [&quot;%5d &quot;] ~~% a
</pre>
</li>
<li><p class="first">Rich comparison:</p>
<pre class="literal-block">
[1, 2, 3]  ~&lt; [3, 2, 1]  # [1, 0, 0]
[1, 2, 3] ~== [3, 2, 1]  # [0, 1, 0]
</pre>
</li>
<li><p class="first">Rich indexing:</p>
<pre class="literal-block">
[a, b, c, d] ~[2, 3, 1]  # [c, d, b]
</pre>
</li>
<li><p class="first">Tuple flattening:</p>
<pre class="literal-block">
a = (1,2);  b = (3,4)
f(~a, ~b)                # f(1,2,3,4)
</pre>
</li>
<li><p class="first">Copy operator:</p>
<pre class="literal-block">
a ~= b                   # a = b.copy()
</pre>
</li>
</ol>
<blockquote>
<p>There can be specific levels of deep copy:</p>
<pre class="literal-block">
a ~~= b                  # a = b.copy(2)
</pre>
</blockquote>
<div class="section" id="notes">
<h2><a class="toc-backref" href="#id13">Notes</a></h2>
<ol class="arabic simple">
<li>There are probably many other similar situations.  This general approach
seems well suited for most of them, in place of several separated extensions
for each of them (parallel and cross iteration, list comprehension, rich
comparison, etc).</li>
<li>The semantics of <em>elementwise</em> depends on applications.  For example, an
element of matrix is two levels down from the list-of-list point of view.
This requires more fundamental change than the current proposal.  In any
case, the current proposal will not negatively impact on future
possibilities of this nature.</li>
</ol>
<p>Note that this section describes a type of future extensions that is consistent
with current proposal, but may present additional compatibility or other
problems.  They are not tied to the current proposal.</p>
</div>
</div>
<div class="section" id="impact-on-named-operators">
<h1><a class="toc-backref" href="#id14">Impact on named operators</a></h1>
<p>The discussions made it generally clear that infix operators is a scarce
resource in Python, not only in numerical computation, but in other fields as
well.  Several proposals and ideas were put forward that would allow infix
operators be introduced in ways similar to named functions.  We show here that
the current extension does not negatively impact on future extensions in this
regard.</p>
<ol class="arabic">
<li><p class="first">Named infix operators.</p>
<p>Choose a meta character, say <tt class="docutils literal">&#64;</tt>, so that for any identifier <tt class="docutils literal">opname</tt>,
the combination <tt class="docutils literal">&#64;opname</tt> would be a binary infix operator, and:</p>
<pre class="literal-block">
a &#64;opname b == opname(a,b)
</pre>
<p>Other representations mentioned include:</p>
<pre class="literal-block">
.name ~name~ :name: (.name) %name%
</pre>
<p>and similar variations.  The pure bracket based operators cannot be used
this way.</p>
<p>This requires a change in the parser to recognize <tt class="docutils literal">&#64;opname</tt>, and parse it
into the same structure as a function call.  The precedence of all these
operators would have to be fixed at one level, so the implementation would
be different from additional math operators which keep the precedence of
existing math operators.</p>
<p>The current proposed extension do not limit possible future extensions of
such form in any way.</p>
</li>
<li><p class="first">More general symbolic operators.</p>
<p>One additional form of future extension is to use meta character and
operator symbols (symbols that cannot be used in syntactical structures
other than operators).  Suppose <tt class="docutils literal">&#64;</tt> is the meta character.  Then:</p>
<pre class="literal-block">
a + b,    a &#64;+ b,    a &#64;&#64;+ b,  a &#64;+- b
</pre>
<p>would all be operators with a hierarchy of precedence, defined by:</p>
<pre class="literal-block">
def &quot;+&quot;(a, b)
def &quot;&#64;+&quot;(a, b)
def &quot;&#64;&#64;+&quot;(a, b)
def &quot;&#64;+-&quot;(a, b)
</pre>
<p>One advantage compared with named operators is greater flexibility for
precedences based on either the meta character or the ordinary operator
symbols.  This also allows operator composition.  The disadvantage is that
they are more like <em>line noise</em>.  In any case the current proposal does not
impact its future possibility.</p>
<p>These kinds of future extensions may not be necessary when Unicode becomes
generally available.</p>
<p>Note that this section discusses compatibility of the proposed extension
with possible future extensions.  The desirability or compatibility of these
other extensions themselves are specifically not considered here.</p>
</li>
</ol>
</div>
<div class="section" id="credits-and-archives">
<h1><a class="toc-backref" href="#id15">Credits and archives</a></h1>
<p>The discussions mostly happened in July to August of 2000 on news group
comp.lang.python and the mailing list python-dev.  There are altogether several
hundred postings, most can be retrieved from these two pages (and searching
word &quot;operator&quot;):</p>
<blockquote>
<a class="reference external" href="http://www.python.org/pipermail/python-list/2000-July/">http://www.python.org/pipermail/python-list/2000-July/</a>
<a class="reference external" href="http://www.python.org/pipermail/python-list/2000-August/">http://www.python.org/pipermail/python-list/2000-August/</a></blockquote>
<p>The names of contributors are too numerous to mention here, suffice to say that
a large proportion of ideas discussed here are not our own.</p>
<p>Several key postings (from our point of view) that may help to navigate the
discussions include:</p>
<blockquote>
<p><a class="reference external" href="http://www.python.org/pipermail/python-list/2000-July/108893.html">http://www.python.org/pipermail/python-list/2000-July/108893.html</a>
<a class="reference external" href="http://www.python.org/pipermail/python-list/2000-July/108777.html">http://www.python.org/pipermail/python-list/2000-July/108777.html</a>
<a class="reference external" href="http://www.python.org/pipermail/python-list/2000-July/108848.html">http://www.python.org/pipermail/python-list/2000-July/108848.html</a>
<a class="reference external" href="http://www.python.org/pipermail/python-list/2000-July/109237.html">http://www.python.org/pipermail/python-list/2000-July/109237.html</a>
<a class="reference external" href="http://www.python.org/pipermail/python-list/2000-July/109250.html">http://www.python.org/pipermail/python-list/2000-July/109250.html</a>
<a class="reference external" href="http://www.python.org/pipermail/python-list/2000-July/109310.html">http://www.python.org/pipermail/python-list/2000-July/109310.html</a>
<a class="reference external" href="http://www.python.org/pipermail/python-list/2000-July/109448.html">http://www.python.org/pipermail/python-list/2000-July/109448.html</a>
<a class="reference external" href="http://www.python.org/pipermail/python-list/2000-July/109491.html">http://www.python.org/pipermail/python-list/2000-July/109491.html</a>
<a class="reference external" href="http://www.python.org/pipermail/python-list/2000-July/109537.html">http://www.python.org/pipermail/python-list/2000-July/109537.html</a>
<a class="reference external" href="http://www.python.org/pipermail/python-list/2000-July/109607.html">http://www.python.org/pipermail/python-list/2000-July/109607.html</a>
<a class="reference external" href="http://www.python.org/pipermail/python-list/2000-July/109709.html">http://www.python.org/pipermail/python-list/2000-July/109709.html</a>
<a class="reference external" href="http://www.python.org/pipermail/python-list/2000-July/109804.html">http://www.python.org/pipermail/python-list/2000-July/109804.html</a>
<a class="reference external" href="http://www.python.org/pipermail/python-list/2000-July/109857.html">http://www.python.org/pipermail/python-list/2000-July/109857.html</a>
<a class="reference external" href="http://www.python.org/pipermail/python-list/2000-July/110061.html">http://www.python.org/pipermail/python-list/2000-July/110061.html</a>
<a class="reference external" href="http://www.python.org/pipermail/python-list/2000-July/110208.html">http://www.python.org/pipermail/python-list/2000-July/110208.html</a>
<a class="reference external" href="http://www.python.org/pipermail/python-list/2000-August/111427.html">http://www.python.org/pipermail/python-list/2000-August/111427.html</a>
<a class="reference external" href="http://www.python.org/pipermail/python-list/2000-August/111558.html">http://www.python.org/pipermail/python-list/2000-August/111558.html</a>
<a class="reference external" href="http://www.python.org/pipermail/python-list/2000-August/112551.html">http://www.python.org/pipermail/python-list/2000-August/112551.html</a>
<a class="reference external" href="http://www.python.org/pipermail/python-list/2000-August/112606.html">http://www.python.org/pipermail/python-list/2000-August/112606.html</a>
<a class="reference external" href="http://www.python.org/pipermail/python-list/2000-August/112758.html">http://www.python.org/pipermail/python-list/2000-August/112758.html</a></p>
<p><a class="reference external" href="http://www.python.org/pipermail/python-dev/2000-July/013243.html">http://www.python.org/pipermail/python-dev/2000-July/013243.html</a>
<a class="reference external" href="http://www.python.org/pipermail/python-dev/2000-July/013364.html">http://www.python.org/pipermail/python-dev/2000-July/013364.html</a>
<a class="reference external" href="http://www.python.org/pipermail/python-dev/2000-August/014940.html">http://www.python.org/pipermail/python-dev/2000-August/014940.html</a></p>
</blockquote>
<p>These are earlier drafts of this PEP:</p>
<blockquote>
<a class="reference external" href="http://www.python.org/pipermail/python-list/2000-August/111785.html">http://www.python.org/pipermail/python-list/2000-August/111785.html</a>
<a class="reference external" href="http://www.python.org/pipermail/python-list/2000-August/112529.html">http://www.python.org/pipermail/python-list/2000-August/112529.html</a>
<a class="reference external" href="http://www.python.org/pipermail/python-dev/2000-August/014906.html">http://www.python.org/pipermail/python-dev/2000-August/014906.html</a></blockquote>
<p>There is an alternative PEP (officially, <a class="reference external" href="/dev/peps/pep-0211">PEP 211</a>) by Greg Wilson, titled
&quot;Adding New Linear Algebra Operators to Python&quot;.</p>
<p>Its first (and current) version is at:</p>
<blockquote>
<a class="reference external" href="http://www.python.org/pipermail/python-dev/2000-August/014876.html">http://www.python.org/pipermail/python-dev/2000-August/014876.html</a>
<a class="reference external" href="http://www.python.org/dev/peps/pep-0211/">http://www.python.org/dev/peps/pep-0211/</a></blockquote>
</div>
<div class="section" id="additional-references">
<h1><a class="toc-backref" href="#id16">Additional References</a></h1>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://MatPy.sourceforge.net/Misc/index.html">http://MatPy.sourceforge.net/Misc/index.html</a></td></tr>
</tbody>
</table>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

