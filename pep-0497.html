<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">497</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">A standard mechanism for backward compatibility</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0497.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Ed Schofield &lt;ed at pythoncharmers.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Draft</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Process</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">04-Aug-2015</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#scope" id="id2">Scope</a></li>
<li><a class="reference internal" href="#context" id="id3">Context</a></li>
<li><a class="reference internal" href="#the-current-situation" id="id4">The current situation</a></li>
<li><a class="reference internal" href="#problem" id="id5">Problem</a></li>
<li><a class="reference internal" href="#backward-compatibility-as-enabler-for-downhill-upgrades" id="id6">Backward compatibility as enabler for &quot;downhill upgrades&quot;</a></li>
<li><a class="reference internal" href="#proposal-part-1" id="id7">Proposal - part 1</a><ul>
<li><a class="reference internal" href="#example" id="id8">Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#proposal-part-2" id="id9">Proposal - part 2</a><ul>
<li><a class="reference internal" href="#counter-examples" id="id10">Counter-examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#benefits" id="id11">Benefits</a></li>
<li><a class="reference internal" href="#questions-and-answers" id="id12">Questions and answers</a></li>
<li><a class="reference internal" href="#copyright" id="id13">Copyright</a></li>
</ul>
</div>
<div class="section" id="scope">
<h1><a class="toc-backref" href="#id2">Scope</a></h1>
<p>This PEP is complementary to PEPs 5, 236, and 387, and shares similar
goals.</p>
<p>This PEP explains the need for an additional compatibility mechanism
in support of <a class="reference external" href="/dev/peps/pep-0005">PEP 5</a>, &quot;Guidelines for Language Evolution&quot;. <a class="reference external" href="/dev/peps/pep-0236">PEP 236</a>,
&quot;Back to the __future__&quot;, introduced a mechanism for forward
compatibility in support of <a class="reference external" href="/dev/peps/pep-0005">PEP 5</a> but noted that a new mechanism for
backward compatibility was outside the scope of that PEP. A related
PEP (in progress) introduces such a mechanism for backward
compatibility.</p>
<p><a class="reference external" href="/dev/peps/pep-0005">PEP 5</a>, &quot;Guidelines for Language Evolution&quot;, notes that &quot;This PEP [<a class="reference external" href="/dev/peps/pep-0005">PEP 5</a>]
does not replace or preclude other compatibility strategies such as
dynamic loading of backwards-compatible parsers.&quot;</p>
</div>
<div class="section" id="context">
<h1><a class="toc-backref" href="#id3">Context</a></h1>
<p>From <a class="reference external" href="/dev/peps/pep-0236">PEP 236</a>: &quot;From time to time, Python makes an incompatible change
to the advertised semantics of core language constructs, or changes
their accidental (implementation-dependent) behavior in some way.
While this is never done capriciously, and is always done with the aim
of improving the language over the long term, over the short term it's
contentious and disrupting. <a class="reference external" href="/dev/peps/pep-0005">PEP 5</a>, Guidelines for Language Evolution,
suggests ways to ease the pain, and this PEP [236] introduces some
machinery in support of that.&quot;</p>
<p>Also from <a class="reference external" href="/dev/peps/pep-0236">PEP 236</a>: &quot;The purpose of future_statement is to make life
easier for people who keep current with the latest release in a timely
fashion. We don't hate you if you don't, but your problems are much
harder to solve, and somebody with those problems will need to write a
PEP addressing them. future_statement is aimed at a different
audience.&quot;</p>
</div>
<div class="section" id="the-current-situation">
<h1><a class="toc-backref" href="#id4">The current situation</a></h1>
<p>When an incompatible change to core language syntax or semantics is
being made, Python currently provides the future_statement mechanism
for providing forward compatibility until the release that enforces
the new syntax or semantics, but provides no corresponding standard
mechanism for providing backward compatibility after this release.</p>
</div>
<div class="section" id="problem">
<h1><a class="toc-backref" href="#id5">Problem</a></h1>
<p>A consequence of this asymmetry is that, with respect to a breaking
change, the older (pre-breaking) version of the Python interpreter is
more capable than the newer (breaking) version; the older interpreter
can use both code designed prior to the change and newer code, whereas
the newer interpreter is only capable of using code that has been
upgraded to support the changed feature.</p>
<p>As an example, consider the changes to the division operator
introduced in <a class="reference external" href="/dev/peps/pep-0238">PEP 238</a> in 2001, soon after <a class="reference external" href="/dev/peps/pep-0236">PEP 236</a> introduced the
future_statement mechanism. <a class="reference external" href="/dev/peps/pep-0238">PEP 238</a> outlines a suite of useful
forward-compatibility mechanisms for &quot;true division&quot; in the Python 2.x
series but omits to include any backward-compatibility mechanisms for
after &quot;true division&quot; was first enforced in Python 3.0. Python versions
since 3.0 do not provide a backward compatibility mechanism such as
<tt class="docutils literal">from __past__ import division</tt> for code that expects the old
&quot;classic division&quot; semantics, whereas Python versions prior to 3.0 do
support both &quot;classic division&quot; code and also forward compatibility
with code expecting &quot;true division&quot;. A further consequence of this is
that the &quot;most compatible&quot; interpreter with respect to the variety of
division-related Python code in the wild is Python 2.7, the version
before the breaking change was first enforced.</p>
</div>
<div class="section" id="backward-compatibility-as-enabler-for-downhill-upgrades">
<h1><a class="toc-backref" href="#id6">Backward compatibility as enabler for &quot;downhill upgrades&quot;</a></h1>
<p>In contrast to this situation, newer versions of application software
such as office suites tend to be more capable than earlier versions
with respect to their support for loading different versions of their
data file formats. The pattern is usually that the newer application
versions can transparently load data from either their newer or their
older data formats, and that the newer version defaults to saving data
in the newer format. Newer application software versions tend to be
backward-compatible by default. Forward compatibility is relatively
rare.</p>
<p>This policy puts the user of the newer application software at an
advantage over the user of the older software, which is usually
incapable of loading data in the newer format. Sometimes it is
possible for a user of a newer software application version to export
data in an older version by choosing this option explicitly. In these
cases, the forward-compatibility this enables may or may not be
perfect; some features may be missing or the results may be otherwise
suboptimal. Upgrading is therefore easy, whereas downgrading is
harder.</p>
<p>The emergent behaviour over many users from such a policy of new
attractive features plus backward compatibility features is that a
natural pressure builds up on each individual user to upgrade his or
her own application version, and, the more other users an individual
exchanges data files with, the more acute this pressure becomes.</p>
</div>
<div class="section" id="proposal-part-1">
<h1><a class="toc-backref" href="#id7">Proposal - part 1</a></h1>
<p>This PEP makes two specific, related proposals. The first is that:</p>
<blockquote>
<a class="reference external" href="/dev/peps/pep-0005">PEP 5</a> be augmented with a 6th step in the section &quot;Steps for
Introducing Backwards-Incompatible Features&quot; to indicate that, when an
incompatible change to core language syntax or semantics is being
made, Python-dev's policy is to prefer and expect that, wherever
possible, a mechanism for backward compatibility be considered and
provided for future Python versions after the breaking change is
adopted by default, in addition to any mechanisms proposed for forward
compatibility such as new future_statements. Furthermore, <a class="reference external" href="/dev/peps/pep-0387">PEP 387</a>,
&quot;Backwards Compatibility Policy&quot; (if accepted) would be
augmented with the same 6th step.</blockquote>
<div class="section" id="example">
<h2><a class="toc-backref" href="#id8">Example</a></h2>
<p>As an example of how this PEP is to be applied, if the latest revision
of the &quot;true division&quot; PEP (238) were proposed today, it would be
considered incomplete. <a class="reference external" href="/dev/peps/pep-0238">PEP 238</a> notes the &quot;severe backwards
compatibility issues&quot; raised by the proposal and describes several
measures for forward compatibility in the Abstract and API Changes
sections. It also mentions some backward compatibility ideas raised on
c.l.py, including &quot;Use <tt class="docutils literal">from __past__ import division</tt> to use
classic division semantics in a module&quot;, but it does not put forward
any backward compatibility plan as part of the proposal.</p>
<p>If this PEP is accepted, it would be expected that a proposal such as
<a class="reference external" href="/dev/peps/pep-0238">PEP 238</a>, because of its large-scale compatibility implications, would
also be accompanied by a backward compatibility plan that enables
users of future Python versions after the breaking change has come
into effect to re-enable the classic division behaviour easily in
their code.</p>
</div>
</div>
<div class="section" id="proposal-part-2">
<h1><a class="toc-backref" href="#id9">Proposal - part 2</a></h1>
<p>The second proposal is that:</p>
<blockquote>
Python provide a standard backward compatibility mechanism in
parallel to the <tt class="docutils literal">__future__</tt> module mechanism for forward
compatibility.</blockquote>
<p>For reference, this document will refer to this as a &quot;<tt class="docutils literal">__past__</tt>&quot;
mechanism hereon, although it need not have all the characteristics
of the <tt class="docutils literal">__future__</tt> module and <tt class="docutils literal">future_statement</tt> mechanism.</p>
<p>The specific form and implementation of the <tt class="docutils literal">__past__</tt> mechanism is
the subject of a separate PEP (in progress).  However, this PEP
recommends that this <tt class="docutils literal">__past__</tt> mechanism be designed to meet
similar criteria to those outlined in <a class="reference external" href="/dev/peps/pep-0296">PEP 296</a> for <tt class="docutils literal">__future__</tt>.
Specifically:</p>
<p>a. It should enable individual modules to specify obsolete behaviours
to re-enable from older Python versions on a module-by-module basis.</p>
<p>b. It should be flexible enough for both Python 3.6+ and point
releases of earlier versions to reintroduce backward compatibility
with older Python syntax or semantics for user modules that invoke the
<tt class="docutils literal">__past__</tt> mechanism.</p>
<p>c. It should be possible to run older code augmented to invoke
<tt class="docutils literal">__past__</tt> behaviours on older Python versions such as 2.x that have
no knowledge of the specific <tt class="docutils literal">__past__</tt> features invoked, or even
that the <tt class="docutils literal">__past__</tt> mechanism for backward-compatibility exists.</p>
<div class="section" id="counter-examples">
<h2><a class="toc-backref" href="#id10">Counter-examples</a></h2>
<p>Some implementations of <tt class="docutils literal">__past__</tt> mechanisms that would violate
these criteria are:</p>
<p>a. Import hooks. These would normally fail to work on a
module-by-module basis; instead they apply recursively to all new
modules imported from within a module.</p>
<p>b. A new piece of syntax or new semantics for Python 3.6 that is
incompatible with prior versions.</p>
<p>c. A function added in Python 3.6 to a module in the Python standard
library that exists under the same name in prior Python versions.</p>
</div>
</div>
<div class="section" id="benefits">
<h1><a class="toc-backref" href="#id11">Benefits</a></h1>
<p>The benefit to Python-dev of adopting this proposal is that future
backward-incompatible changes can be less disruptive if these changes
each have a corresponding <tt class="docutils literal">__past__</tt> feature that has been
implemented and can be invoked easily by users of future Python
versions. This can help the language to evolve more quickly and more
effectively to correct for design mistakes.</p>
<p>The benefit to conservative users is obvious: they can add support for
the latest shiny compatibility-breaking Python version to their code
merely by adding a <tt class="docutils literal">__past__</tt> incantation (perhaps a single line) to
each module, and that this can be automated. They can then upgrade
their interpreter to the latest version and gain access to the latest
shiny Python features.</p>
<p>The benefit to the community is that, if ten thousand users rely on
package XYZ, and package XYZ can trivially add support for the latest
Python version, those ten thousand users can also upgrade to the
latest Python version quickly, without being held back waiting for
package XYZ to do this.</p>
</div>
<div class="section" id="questions-and-answers">
<h1><a class="toc-backref" href="#id12">Questions and answers</a></h1>
<p>Q1: Does this PEP require that Python keep two possible sets of semantics
for each backward-incompatible feature forever?</p>
<p>A1: Definitely not. Legacy features can still be phased out when
appropriate -- that is, when the majority of the user-base has
migrated to the newer Python version. This PEP merely proposes to
shift the emphasis of the development effort directed at compatibility
from 100% forwards to at least 50% backwards. Backwards compatibility
is the more powerful of the two concepts for allowing a user-base to
adopt the latest Python interpreter version.</p>
<p>Notice that it has been a long time since most users have cared about
backwards compatibility for non-nested scopes, because most users have
moved comfortably past Python 2.1.</p>
<p>Q2: But Python-dev is already overwhelmed and doesn't have the
bandwidth to implement / maintain the additional complexity!</p>
<p>A2: Python-dev can ask the community of developers to step up and
maintain backward compatibility in Python for legacy language features
they care about. When the community stops caring about a particular
obsolete behaviour, Python-dev can stop caring too.</p>
<p>The <tt class="docutils literal">__past__</tt> mechanism could possibly be designed to be extensible
by the community, e.g.  as a standard but &quot;blessed&quot; PyPI package, to
reduce the load on the core developers.</p>
<p>Q3: Won't backward compatibility features lead to lots of cruft and
bloat and baggage in Python?</p>
<p>A3: Not necessarily. First, proposals for new compatibility-breaking
features in Python could be evaluated partly on the simplicity and
maintainability of the implementation of their associated <tt class="docutils literal">__past__</tt>
feature up-front.</p>
<p>Second, some old features are simple to provide backward compatibility
for. Consider the &quot;classic division&quot; behaviour before Python 3.0. The
<tt class="docutils literal"><span class="pre">python-future</span></tt> project contains a compatible implementation of
classic division in the function <tt class="docutils literal">future.utils.old_div</tt>:</p>
<pre class="literal-block">
def old_div(a, b):
    &quot;&quot;&quot;
    Equivalent to ``a / b`` on Python 2 without ``from __future__ import
    division``.
    &quot;&quot;&quot;
    if isinstance(a, numbers.Integral) and isinstance(b, numbers.Integral):
        return a // b
    else:
        return a / b
</pre>
<p>Bundling such a function with Python 3.x versions, together with
a simple mechanism to invoke it for every appearance of <tt class="docutils literal">a
/ b</tt> after an appropriate <tt class="docutils literal">__past__</tt> invocation, need not be
onerous.</p>
<p>Q4: What about performance? Won't the performance of newer Python
versions suffer under the weight of legacy features?</p>
<p>A4: This can be evaluated on a case-by-case basis. The major potential
concern is that the performance with the new default behaviour does
not suffer unduly because of the presence of the legacy option. The
performance under the influence of the <tt class="docutils literal">__past__</tt> invocation is of
secondary importance.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id13">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8 -->
</div>

