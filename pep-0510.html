<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">510</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Specialize functions with guards</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0510.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Victor Stinner &lt;victor.stinner&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">4-January-2016</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.6</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#rejection-notice" id="id2">Rejection Notice</a></li>
<li><a class="reference internal" href="#abstract" id="id3">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id4">Rationale</a><ul>
<li><a class="reference internal" href="#python-semantics" id="id5">Python semantics</a></li>
<li><a class="reference internal" href="#why-not-a-jit-compiler" id="id6">Why not a JIT compiler?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples" id="id7">Examples</a><ul>
<li><a class="reference internal" href="#hypothetical-myoptimizer-module" id="id8">Hypothetical myoptimizer module</a></li>
<li><a class="reference internal" href="#using-bytecode" id="id9">Using bytecode</a></li>
<li><a class="reference internal" href="#using-builtin-function" id="id10">Using builtin function</a></li>
</ul>
</li>
<li><a class="reference internal" href="#choose-the-specialized-code" id="id11">Choose the specialized code</a></li>
<li><a class="reference internal" href="#changes" id="id12">Changes</a><ul>
<li><a class="reference internal" href="#function-guard" id="id13">Function guard</a></li>
<li><a class="reference internal" href="#specialized-code" id="id14">Specialized code</a></li>
<li><a class="reference internal" href="#function-methods" id="id15">Function methods</a><ul>
<li><a class="reference internal" href="#pyfunction-specialize" id="id16">PyFunction_Specialize</a></li>
<li><a class="reference internal" href="#pyfunction-getspecializedcodes" id="id17">PyFunction_GetSpecializedCodes</a></li>
<li><a class="reference internal" href="#pyfunction-getspecializedcode" id="id18">PyFunction_GetSpecializedCode</a></li>
<li><a class="reference internal" href="#pyfunction-removespecialized" id="id19">PyFunction_RemoveSpecialized</a></li>
<li><a class="reference internal" href="#pyfunction-removeallspecialized" id="id20">PyFunction_RemoveAllSpecialized</a></li>
</ul>
</li>
<li><a class="reference internal" href="#benchmark" id="id21">Benchmark</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation" id="id22">Implementation</a></li>
<li><a class="reference internal" href="#other-implementations-of-python" id="id23">Other implementations of Python</a></li>
<li><a class="reference internal" href="#discussion" id="id24">Discussion</a></li>
<li><a class="reference internal" href="#copyright" id="id25">Copyright</a></li>
</ul>
</div>
<div class="section" id="rejection-notice">
<h1><a class="toc-backref" href="#id2">Rejection Notice</a></h1>
<p>This PEP was rejected by its author since the design didn't show any
significant speedup, but also because of the lack of time to implement
the most advanced and complex optimizations.</p>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id3">Abstract</a></h1>
<p>Add functions to the Python C API to specialize pure Python functions:
add specialized codes with guards. It allows to implement static
optimizers respecting the Python semantics.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id4">Rationale</a></h1>
<div class="section" id="python-semantics">
<h2><a class="toc-backref" href="#id5">Python semantics</a></h2>
<p>Python is hard to optimize because almost everything is mutable: builtin
functions, function code, global variables, local variables, ... can be
modified at runtime. Implement optimizations respecting the Python
semantics requires to detect when &quot;something changes&quot;, we will call these
checks &quot;guards&quot;.</p>
<p>This PEP proposes to add a public API to the Python C API to add
specialized codes with guards to a function. When the function is
called, a specialized code is used if nothing changed, otherwise use the
original bytecode.</p>
<p>Even if guards help to respect most parts of the Python semantics, it's
hard to optimize Python without making subtle changes on the exact
behaviour. CPython has a long history and many applications rely on
implementation details. A compromise must be found between &quot;everything
is mutable&quot; and performance.</p>
<p>Writing an optimizer is out of the scope of this PEP.</p>
</div>
<div class="section" id="why-not-a-jit-compiler">
<h2><a class="toc-backref" href="#id6">Why not a JIT compiler?</a></h2>
<p>There are multiple JIT compilers for Python actively developed:</p>
<ul class="simple">
<li><a class="reference external" href="http://pypy.org/">PyPy</a></li>
<li><a class="reference external" href="https://github.com/dropbox/pyston">Pyston</a></li>
<li><a class="reference external" href="http://numba.pydata.org/">Numba</a></li>
<li><a class="reference external" href="https://github.com/microsoft/pyjion">Pyjion</a></li>
</ul>
<p>Numba is specific to numerical computation.  Pyston and Pyjion are still
young.  PyPy is the most complete Python interpreter, it is generally
faster than CPython in micro- and many macro-benchmarks and has a very
good compatibility with CPython (it respects the Python semantics).
There are still issues with Python JIT compilers which avoid them to be
widely used instead of CPython.</p>
<p>Many popular libraries like numpy, PyGTK, PyQt, PySide and wxPython are
implemented in C or C++ and use the Python C API. To have a small memory
footprint and better performances, Python JIT compilers do not use
reference counting to use a faster garbage collector, do not use C
structures of CPython objects and manage memory allocations differently.
PyPy has a <tt class="docutils literal">cpyext</tt> module which emulates the Python C API but it has
worse performances than CPython and does not support the full Python C
API.</p>
<p>New features are first developped in CPython. In January 2016, the
latest CPython stable version is 3.5, whereas PyPy only supports Python
2.7 and 3.2, and Pyston only supports Python 2.7.</p>
<p>Even if PyPy has a very good compatibility with Python, some modules are
still not compatible with PyPy: see <a class="reference external" href="https://bitbucket.org/pypy/compatibility/wiki/Home">PyPy Compatibility Wiki</a>. The incomplete
support of the Python C API is part of this problem. There are also
subtle differences between PyPy and CPython like reference counting:
object destructors are always called in PyPy, but can be called &quot;later&quot;
than in CPython. Using context managers helps to control when resources
are released.</p>
<p>Even if PyPy is much faster than CPython in a wide range of benchmarks,
some users still report worse performances than CPython on some specific
use cases or unstable performances.</p>
<p>When Python is used as a scripting program for programs running less
than 1 minute, JIT compilers can be slower because their startup time is
higher and the JIT compiler takes time to optimize the code. For
example, most Mercurial commands take a few seconds.</p>
<p>Numba now supports ahead of time compilation, but it requires decorator
to specify arguments types and it only supports numerical types.</p>
<p>CPython 3.5 has almost no optimization: the peephole optimizer only
implements basic optimizations. A static compiler is a compromise
between CPython 3.5 and PyPy.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There was also the Unladen Swallow project, but it was abandoned in
2011.</p>
</div>
</div>
</div>
<div class="section" id="examples">
<h1><a class="toc-backref" href="#id7">Examples</a></h1>
<p>Following examples are not written to show powerful optimizations
promising important speedup, but to be short and easy to understand,
just to explain the principle.</p>
<div class="section" id="hypothetical-myoptimizer-module">
<h2><a class="toc-backref" href="#id8">Hypothetical myoptimizer module</a></h2>
<p>Examples in this PEP uses a hypothetical <tt class="docutils literal">myoptimizer</tt> module which
provides the following functions and types:</p>
<ul class="simple">
<li><tt class="docutils literal">specialize(func, code, guards)</tt>: add the specialized code <cite>code</cite>
with guards <cite>guards</cite> to the function <cite>func</cite></li>
<li><tt class="docutils literal">get_specialized(func)</tt>: get the list of specialized codes as a list
of <tt class="docutils literal">(code, guards)</tt> tuples where <cite>code</cite> is a callable or code object
and <cite>guards</cite> is a list of a guards</li>
<li><tt class="docutils literal">GuardBuiltins(name)</tt>: guard watching for
<tt class="docutils literal">builtins.__dict__[name]</tt> and <tt class="docutils literal"><span class="pre">globals()[name]</span></tt>. The guard fails
if <tt class="docutils literal">builtins.__dict__[name]</tt> is replaced, or if <tt class="docutils literal"><span class="pre">globals()[name]</span></tt>
is set.</li>
</ul>
</div>
<div class="section" id="using-bytecode">
<h2><a class="toc-backref" href="#id9">Using bytecode</a></h2>
<p>Add specialized bytecode where the call to the pure builtin function
<tt class="docutils literal">chr(65)</tt> is replaced with its result <tt class="docutils literal">&quot;A&quot;</tt>:</p>
<pre class="literal-block">
import myoptimizer

def func():
    return chr(65)

def fast_func():
    return &quot;A&quot;

myoptimizer.specialize(func, fast_func.__code__,
                       [myoptimizer.GuardBuiltins(&quot;chr&quot;)])
del fast_func
</pre>
<p>Example showing the behaviour of the guard:</p>
<pre class="literal-block">
print(&quot;func(): %s&quot; % func())
print(&quot;#specialized: %s&quot; % len(myoptimizer.get_specialized(func)))
print()

import builtins
builtins.chr = lambda obj: &quot;mock&quot;

print(&quot;func(): %s&quot; % func())
print(&quot;#specialized: %s&quot; % len(myoptimizer.get_specialized(func)))
</pre>
<p>Output:</p>
<pre class="literal-block">
func(): A
#specialized: 1

func(): mock
#specialized: 0
</pre>
<p>The first call uses the specialized bytecode which returns the string
<tt class="docutils literal">&quot;A&quot;</tt>. The second call removes the specialized code because the
builtin <tt class="docutils literal">chr()</tt> function was replaced, and executes the original
bytecode calling <tt class="docutils literal">chr(65)</tt>.</p>
<p>On a microbenchmark, calling the specialized bytecode takes 88 ns,
whereas the original function takes 145 ns (+57 ns): 1.6 times as fast.</p>
</div>
<div class="section" id="using-builtin-function">
<h2><a class="toc-backref" href="#id10">Using builtin function</a></h2>
<p>Add the C builtin <tt class="docutils literal">chr()</tt> function as the specialized code instead of
a bytecode calling <tt class="docutils literal">chr(obj)</tt>:</p>
<pre class="literal-block">
import myoptimizer

def func(arg):
    return chr(arg)

myoptimizer.specialize(func, chr,
                       [myoptimizer.GuardBuiltins(&quot;chr&quot;)])
</pre>
<p>Example showing the behaviour of the guard:</p>
<pre class="literal-block">
print(&quot;func(65): %s&quot; % func(65))
print(&quot;#specialized: %s&quot; % len(myoptimizer.get_specialized(func)))
print()

import builtins
builtins.chr = lambda obj: &quot;mock&quot;

print(&quot;func(65): %s&quot; % func(65))
print(&quot;#specialized: %s&quot; % len(myoptimizer.get_specialized(func)))
</pre>
<p>Output:</p>
<pre class="literal-block">
func(): A
#specialized: 1

func(): mock
#specialized: 0
</pre>
<p>The first call calls the C builtin <tt class="docutils literal">chr()</tt> function (without creating
a Python frame). The second call removes the specialized code because
the builtin <tt class="docutils literal">chr()</tt> function was replaced, and executes the original
bytecode.</p>
<p>On a microbenchmark, calling the C builtin takes 95 ns, whereas the
original bytecode takes 155 ns (+60 ns): 1.6 times as fast. Calling
directly <tt class="docutils literal">chr(65)</tt> takes 76 ns.</p>
</div>
</div>
<div class="section" id="choose-the-specialized-code">
<h1><a class="toc-backref" href="#id11">Choose the specialized code</a></h1>
<p>Pseudo-code to choose the specialized code to call a pure Python
function:</p>
<pre class="literal-block">
def call_func(func, args, kwargs):
    specialized = myoptimizer.get_specialized(func)
    nspecialized = len(specialized)
    index = 0
    while index &lt; nspecialized:
        specialized_code, guards = specialized[index]

        for guard in guards:
            check = guard(args, kwargs)
            if check:
                break

        if not check:
            # all guards succeeded:
            # use the specialized code
            return specialized_code
        elif check == 1:
            # a guard failed temporarely:
            # try the next specialized code
            index += 1
        else:
            assert check == 2
            # a guard will always fail:
            # remove the specialized code
            del specialized[index]

    # if a guard of each specialized code failed, or if the function
    # has no specialized code, use original bytecode
    code = func.__code__
</pre>
</div>
<div class="section" id="changes">
<h1><a class="toc-backref" href="#id12">Changes</a></h1>
<p>Changes to the Python C API:</p>
<ul>
<li><p class="first">Add a <tt class="docutils literal">PyFuncGuardObject</tt> object and a <tt class="docutils literal">PyFuncGuard_Type</tt> type</p>
</li>
<li><p class="first">Add a <tt class="docutils literal">PySpecializedCode</tt> structure</p>
</li>
<li><p class="first">Add the following fields to the <tt class="docutils literal">PyFunctionObject</tt> structure:</p>
<pre class="literal-block">
Py_ssize_t nb_specialized;
PySpecializedCode *specialized;
</pre>
</li>
<li><p class="first">Add function methods:</p>
<ul class="simple">
<li><tt class="docutils literal">PyFunction_Specialize()</tt></li>
<li><tt class="docutils literal">PyFunction_GetSpecializedCodes()</tt></li>
<li><tt class="docutils literal">PyFunction_GetSpecializedCode()</tt></li>
<li><tt class="docutils literal">PyFunction_RemoveSpecialized()</tt></li>
<li><tt class="docutils literal">PyFunction_RemoveAllSpecialized()</tt></li>
</ul>
</li>
</ul>
<p>None of these function and types are exposed at the Python level.</p>
<p>All these additions are explicitly excluded of the stable ABI.</p>
<p>When a function code is replaced (<tt class="docutils literal">func.__code__ = new_code</tt>), all
specialized codes and guards are removed.</p>
<div class="section" id="function-guard">
<h2><a class="toc-backref" href="#id13">Function guard</a></h2>
<p>Add a function guard object:</p>
<pre class="literal-block">
typedef struct {
    PyObject ob_base;
    int (*init) (PyObject *guard, PyObject *func);
    int (*check) (PyObject *guard, PyObject **stack, int na, int nk);
} PyFuncGuardObject;
</pre>
<p>The <tt class="docutils literal">init()</tt> function initializes a guard:</p>
<ul class="simple">
<li>Return <tt class="docutils literal">0</tt> on success</li>
<li>Return <tt class="docutils literal">1</tt> if the guard will always fail: <tt class="docutils literal">PyFunction_Specialize()</tt>
must ignore the specialized code</li>
<li>Raise an exception and return <tt class="docutils literal"><span class="pre">-1</span></tt> on error</li>
</ul>
<p>The <tt class="docutils literal">check()</tt> function checks a guard:</p>
<ul class="simple">
<li>Return <tt class="docutils literal">0</tt> on success</li>
<li>Return <tt class="docutils literal">1</tt> if the guard failed temporarely</li>
<li>Return <tt class="docutils literal">2</tt> if the guard will always fail: the specialized code must
be removed</li>
<li>Raise an exception and return <tt class="docutils literal"><span class="pre">-1</span></tt> on error</li>
</ul>
<p><em>stack</em> is an array of arguments: indexed arguments followed by (<em>key</em>,
<em>value</em>) pairs of keyword arguments. <em>na</em> is the number of indexed
arguments. <em>nk</em> is the number of keyword arguments: the number of (<em>key</em>,
<em>value</em>) pairs. <cite>stack</cite> contains <tt class="docutils literal">na + nk * 2</tt> objects.</p>
</div>
<div class="section" id="specialized-code">
<h2><a class="toc-backref" href="#id14">Specialized code</a></h2>
<p>Add a specialized code structure:</p>
<pre class="literal-block">
typedef struct {
    PyObject *code;        /* callable or code object */
    Py_ssize_t nb_guard;
    PyObject **guards;     /* PyFuncGuardObject objects */
} PySpecializedCode;
</pre>
</div>
<div class="section" id="function-methods">
<h2><a class="toc-backref" href="#id15">Function methods</a></h2>
<div class="section" id="pyfunction-specialize">
<h3><a class="toc-backref" href="#id16">PyFunction_Specialize</a></h3>
<p>Add a function method to specialize the function, add a specialized code
with guards:</p>
<pre class="literal-block">
int PyFunction_Specialize(PyObject *func,
                          PyObject *code, PyObject *guards)
</pre>
<p>If <em>code</em> is a Python function, the code object of the <em>code</em> function
is used as the specialized code. The specialized Python function must
have the same parameter defaults, the same keyword parameter defaults,
and must not have specialized code.</p>
<p>If <em>code</em> is a Python function or a code object, a new code object is
created and the code name and first line number of the code object of
<em>func</em> are copied. The specialized code must have the same cell
variables and the same free variables.</p>
<p>Result:</p>
<ul class="simple">
<li>Return <tt class="docutils literal">0</tt> on success</li>
<li>Return <tt class="docutils literal">1</tt> if the specialization has been ignored</li>
<li>Raise an exception and return <tt class="docutils literal"><span class="pre">-1</span></tt> on error</li>
</ul>
</div>
<div class="section" id="pyfunction-getspecializedcodes">
<h3><a class="toc-backref" href="#id17">PyFunction_GetSpecializedCodes</a></h3>
<p>Add a function method to get the list of specialized codes:</p>
<pre class="literal-block">
PyObject* PyFunction_GetSpecializedCodes(PyObject *func)
</pre>
<p>Return a list of (<em>code</em>, <em>guards</em>) tuples where <em>code</em> is a callable or
code object and <em>guards</em> is a list of <tt class="docutils literal">PyFuncGuard</tt> objects. Raise an
exception and return <tt class="docutils literal">NULL</tt> on error.</p>
</div>
<div class="section" id="pyfunction-getspecializedcode">
<h3><a class="toc-backref" href="#id18">PyFunction_GetSpecializedCode</a></h3>
<p>Add a function method checking guards to choose a specialized code:</p>
<pre class="literal-block">
PyObject* PyFunction_GetSpecializedCode(PyObject *func,
                                        PyObject **stack,
                                        int na, int nk)
</pre>
<p>See <tt class="docutils literal">check()</tt> function of guards for <em>stack</em>, <em>na</em> and <em>nk</em> arguments.
Return a callable or a code object on success. Raise an exception and
return <tt class="docutils literal">NULL</tt> on error.</p>
</div>
<div class="section" id="pyfunction-removespecialized">
<h3><a class="toc-backref" href="#id19">PyFunction_RemoveSpecialized</a></h3>
<p>Add a function method to remove a specialized code with its guards by
its index:</p>
<pre class="literal-block">
int PyFunction_RemoveSpecialized(PyObject *func, Py_ssize_t index)
</pre>
<p>Return <tt class="docutils literal">0</tt> on success or if the index does not exist. Raise an exception and
return <tt class="docutils literal"><span class="pre">-1</span></tt> on error.</p>
</div>
<div class="section" id="pyfunction-removeallspecialized">
<h3><a class="toc-backref" href="#id20">PyFunction_RemoveAllSpecialized</a></h3>
<p>Add a function method to remove all specialized codes and guards of a
function:</p>
<pre class="literal-block">
int PyFunction_RemoveAllSpecialized(PyObject *func)
</pre>
<p>Return <tt class="docutils literal">0</tt> on success. Raise an exception and return <tt class="docutils literal"><span class="pre">-1</span></tt> if <em>func</em> is not
a function.</p>
</div>
</div>
<div class="section" id="benchmark">
<h2><a class="toc-backref" href="#id21">Benchmark</a></h2>
<p>Microbenchmark on <tt class="docutils literal">python3.6 <span class="pre">-m</span> timeit <span class="pre">-s</span> 'def <span class="pre">f():</span> pass' <span class="pre">'f()'</span></tt> (best
of 3 runs):</p>
<ul class="simple">
<li>Original Python: 79 ns</li>
<li>Patched Python: 79 ns</li>
</ul>
<p>According to this microbenchmark, the changes has no overhead on calling
a Python function without specialization.</p>
</div>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id22">Implementation</a></h1>
<p>The <a class="reference external" href="http://bugs.python.org/issue26098">issue #26098: PEP 510: Specialize functions with guards</a> contains a patch which implements
this PEP.</p>
</div>
<div class="section" id="other-implementations-of-python">
<h1><a class="toc-backref" href="#id23">Other implementations of Python</a></h1>
<p>This PEP only contains changes to the Python C API, the Python API is
unchanged. Other implementations of Python are free to not implement new
additions, or implement added functions as no-op:</p>
<ul class="simple">
<li><tt class="docutils literal">PyFunction_Specialize()</tt>: always return <tt class="docutils literal">1</tt> (the specialization
has been ignored)</li>
<li><tt class="docutils literal">PyFunction_GetSpecializedCodes()</tt>: always return an empty list</li>
<li><tt class="docutils literal">PyFunction_GetSpecializedCode()</tt>: return the function code object,
as the existing <tt class="docutils literal">PyFunction_GET_CODE()</tt> macro</li>
</ul>
</div>
<div class="section" id="discussion">
<h1><a class="toc-backref" href="#id24">Discussion</a></h1>
<p>Thread on the python-ideas mailing list: <a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2016-January/037703.html">RFC: PEP: Specialized
functions with guards</a>.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id25">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
</div>

