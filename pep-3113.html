<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">3113</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Removal of Tuple Parameter Unpacking</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-3113.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Brett Cannon &lt;brett&#32;&#97;t&#32;python.org&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">02-Mar-2007</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.0</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id7">Abstract</a></li>
<li><a class="reference internal" href="#why-they-should-go" id="id8">Why They Should Go</a><ul>
<li><a class="reference internal" href="#introspection-issues" id="id9">Introspection Issues</a></li>
<li><a class="reference internal" href="#no-loss-of-abilities-if-removed" id="id10">No Loss of Abilities If Removed</a></li>
<li><a class="reference internal" href="#exception-to-the-rule" id="id11">Exception To The Rule</a></li>
<li><a class="reference internal" href="#uninformative-error-messages" id="id12">Uninformative Error Messages</a></li>
<li><a class="reference internal" href="#little-usage" id="id13">Little Usage</a></li>
</ul>
</li>
<li><a class="reference internal" href="#why-they-should-supposedly-stay" id="id14">Why They Should (Supposedly) Stay</a><ul>
<li><a class="reference internal" href="#practical-use" id="id15">Practical Use</a></li>
<li><a class="reference internal" href="#self-documentation-for-parameters" id="id16">Self-Documentation For Parameters</a></li>
</ul>
</li>
<li><a class="reference internal" href="#transition-plan" id="id17">Transition Plan</a></li>
<li><a class="reference internal" href="#references" id="id18">References</a></li>
<li><a class="reference internal" href="#copyright" id="id19">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id7">Abstract</a></h1>
<p>Tuple parameter unpacking is the use of a tuple as a parameter in a
function signature so as to have a sequence argument automatically
unpacked.  An example is:</p>
<pre class="literal-block">
def fxn(a, (b, c), d):
    pass
</pre>
<p>The use of <tt class="docutils literal">(b, c)</tt> in the signature requires that the second
argument to the function be a sequence of length two (e.g.,
<tt class="docutils literal">[42, <span class="pre">-13]</span></tt>).  When such a sequence is passed it is unpacked and
has its values assigned to the parameters, just as if the statement
<tt class="docutils literal">b, c = [42, <span class="pre">-13]</span></tt> had been executed in the parameter.</p>
<p>Unfortunately this feature of Python's rich function signature
abilities, while handy in some situations, causes more issues than
they are worth.  Thus this PEP proposes their removal from the
language in Python 3.0.</p>
</div>
<div class="section" id="why-they-should-go">
<h1><a class="toc-backref" href="#id8">Why They Should Go</a></h1>
<div class="section" id="introspection-issues">
<h2><a class="toc-backref" href="#id9">Introspection Issues</a></h2>
<p>Python has very powerful introspection capabilities.  These extend to
function signatures.  There are no hidden details as to what a
function's call signature is.  In general it is fairly easy to figure
out various details about a function's signature by viewing the
function object and various attributes on it (including the function's
<tt class="docutils literal">func_code</tt> attribute).</p>
<p>But there is great difficulty when it comes to tuple parameters.  The
existence of a tuple parameter is denoted by its name being made of a
<tt class="docutils literal">.</tt> and a number in the <tt class="docutils literal">co_varnames</tt> attribute of the function's
code object.  This allows the tuple argument to be bound to a name
that only the bytecode is aware of and cannot be typed in Python
source.  But this does not specify the format of the tuple: its
length, whether there are nested tuples, etc.</p>
<p>In order to get all of the details about the tuple from the function
one must analyse the bytecode of the function.  This is because the
first bytecode in the function literally translates into the tuple
argument being unpacked.  Assuming the tuple parameter is
named <tt class="docutils literal">.1</tt> and is expected to unpack to variables <tt class="docutils literal">spam</tt> and
<tt class="docutils literal">monty</tt> (meaning it is the tuple <tt class="docutils literal">(spam, monty)</tt>), the first
bytecode in the function will be for the statement
<tt class="docutils literal">spam, monty = .1</tt>.  This means that to know all of the details of
the tuple parameter one must look at the initial bytecode of the
function to detect tuple unpacking for parameters formatted as
<tt class="docutils literal"><span class="pre">\.\d+</span></tt> and deduce any and all information about the expected
argument.  Bytecode analysis is how the <tt class="docutils literal">inspect.getargspec</tt>
function is able to provide information on tuple parameters.  This is
not easy to do and is burdensome on introspection tools as they must
know how Python bytecode works (an otherwise unneeded burden as all
other types of parameters do not require knowledge of Python
bytecode).</p>
<p>The difficulty of analysing bytecode not withstanding, there is
another issue with the dependency on using Python bytecode.
IronPython <a class="footnote-reference" href="#ironpython" id="id1">[3]</a> does not use Python's bytecode.  Because it
is based on the .NET framework it instead stores MSIL <a class="footnote-reference" href="#msil" id="id2">[4]</a> in
<tt class="docutils literal">func_code.co_code</tt> attribute of the function.  This fact prevents
the <tt class="docutils literal">inspect.getargspec</tt> function from working when run under
IronPython.  It is unknown whether other Python implementations are
affected but is reasonable to assume if the implementation is not just
a re-implementation of the Python virtual machine.</p>
</div>
<div class="section" id="no-loss-of-abilities-if-removed">
<h2><a class="toc-backref" href="#id10">No Loss of Abilities If Removed</a></h2>
<p>As mentioned in <a class="reference internal" href="#introspection-issues">Introspection Issues</a>, to handle tuple parameters
the function's bytecode starts with the bytecode required to unpack
the argument into the proper parameter names.  This means that there
is no special support required to implement tuple parameters and thus
there is no loss of abilities if they were to be removed, only a
possible convenience (which is addressed in
<a class="reference internal" href="#why-they-should-supposedly-stay">Why They Should (Supposedly) Stay</a>).</p>
<p>The example function at the beginning of this PEP could easily be
rewritten as:</p>
<pre class="literal-block">
def fxn(a, b_c, d):
    b, c = b_c
    pass
</pre>
<p>and in no way lose functionality.</p>
</div>
<div class="section" id="exception-to-the-rule">
<h2><a class="toc-backref" href="#id11">Exception To The Rule</a></h2>
<p>When looking at the various types of parameters that a Python function
can have, one will notice that tuple parameters tend to be an
exception rather than the rule.</p>
<p>Consider <a class="reference external" href="/dev/peps/pep-3102">PEP 3102</a> (keyword-only arguments) and <a class="reference external" href="/dev/peps/pep-3107">PEP 3107</a> (function
annotations) <a class="footnote-reference" href="#pep-3102" id="id3">[5]</a> <a class="footnote-reference" href="#pep-3107" id="id4">[6]</a>.  Both PEPs have been accepted and
introduce new functionality within a function's signature.  And yet
for both PEPs the new feature cannot be applied to tuple parameters as
a whole.  <a class="reference external" href="/dev/peps/pep-3102">PEP 3102</a> has no support for tuple parameters at all (which
makes sense as there is no way to reference a tuple parameter by
name).  <a class="reference external" href="/dev/peps/pep-3107">PEP 3107</a> allows annotations for each item within the tuple
(e.g., <tt class="docutils literal">(x:int, y:int)</tt>), but not the whole tuple (e.g.,
<tt class="docutils literal">(x, <span class="pre">y):int</span></tt>).</p>
<p>The existence of tuple parameters also places sequence objects
separately from mapping objects in a function signature.  There is no
way to pass in a mapping object (e.g., a dict) as a parameter and have
it unpack in the same fashion as a sequence does into a tuple
parameter.</p>
</div>
<div class="section" id="uninformative-error-messages">
<h2><a class="toc-backref" href="#id12">Uninformative Error Messages</a></h2>
<p>Consider the following function:</p>
<pre class="literal-block">
def fxn((a, b), (c, d)):
    pass
</pre>
<p>If called as <tt class="docutils literal">fxn(1, (2, 3))</tt> one is given the error message
<tt class="docutils literal">TypeError: unpack <span class="pre">non-sequence</span></tt>.  This error message in no way
tells you which tuple was not unpacked properly.  There is also no
indication that this was a result that occurred because of the
arguments.  Other error messages regarding arguments to functions
explicitly state its relation to the signature:
<tt class="docutils literal">TypeError: fxn() takes exactly 2 arguments (0 given)</tt>, etc.</p>
</div>
<div class="section" id="little-usage">
<h2><a class="toc-backref" href="#id13">Little Usage</a></h2>
<p>While an informal poll of the handful of Python programmers I know
personally and from the PyCon 2007 sprint indicates a huge majority of
people do not know of this feature and the rest just do not use it,
some hard numbers is needed to back up the claim that the feature is
not heavily used.</p>
<p>Iterating over every line in Python's code repository in the <tt class="docutils literal">Lib/</tt>
directory using the regular expression <tt class="docutils literal"><span class="pre">^\s*def\s*\w+\s*\(</span></tt> to
detect function and method definitions there were 22,252 matches in
the trunk.</p>
<p>Tacking on <tt class="docutils literal"><span class="pre">.*,\s*\(</span></tt> to find <tt class="docutils literal">def</tt> statements that contained a
tuple parameter, only 41 matches were found.  This means that for
<tt class="docutils literal">def</tt> statements, only 0.18% of them seem to use a tuple parameter.</p>
</div>
</div>
<div class="section" id="why-they-should-supposedly-stay">
<h1><a class="toc-backref" href="#id14">Why They Should (Supposedly) Stay</a></h1>
<div class="section" id="practical-use">
<h2><a class="toc-backref" href="#id15">Practical Use</a></h2>
<p>In certain instances tuple parameters can be useful.  A common example
is code that expects a two-item tuple that represents a Cartesian
point.  While true it is nice to be able to have the unpacking of the
x and y coordinates for you, the argument is that this small amount of
practical usefulness is heavily outweighed by other issues pertaining
to tuple parameters.  And as shown in
<a class="reference internal" href="#no-loss-of-abilities-if-removed">No Loss Of Abilities If Removed</a>, their use is purely practical and
in no way provide a unique ability that cannot be handled in other
ways very easily.</p>
</div>
<div class="section" id="self-documentation-for-parameters">
<h2><a class="toc-backref" href="#id16">Self-Documentation For Parameters</a></h2>
<p>It has been argued that tuple parameters provide a way of
self-documentation for parameters that are expected to be of a certain
sequence format.  Using our Cartesian point example from
<a class="reference internal" href="#practical-use">Practical Use</a>, seeing <tt class="docutils literal">(x, y)</tt> as a parameter in a function makes
it obvious that a tuple of length two is expected as an argument for
that parameter.</p>
<p>But Python provides several other ways to document what parameters are
for.  Documentation strings are meant to provide enough information
needed to explain what arguments are expected.  Tuple parameters might
tell you the expected length of a sequence argument, it does not tell
you what that data will be used for.  One must also read the docstring
to know what other arguments are expected if not all parameters are
tuple parameters.</p>
<p>Function annotations (which do not work with tuple parameters) can
also supply documentation.  Because annotations can be of any form,
what was once a tuple parameter can be a single argument parameter
with an annotation of <tt class="docutils literal">tuple</tt>, <tt class="docutils literal">tuple(2)</tt>, <tt class="docutils literal">Cartesian point</tt>,
<tt class="docutils literal">(x, y)</tt>, etc.  Annotations provide great flexibility for
documenting what an argument is expected to be for a parameter,
including being a sequence of a certain length.</p>
</div>
</div>
<div class="section" id="transition-plan">
<h1><a class="toc-backref" href="#id17">Transition Plan</a></h1>
<p>To transition Python 2.x code to 3.x where tuple parameters are
removed, two steps are suggested.  First, the proper warning is to be
emitted when Python's compiler comes across a tuple parameter in
Python 2.6.  This will be treated like any other syntactic change that
is to occur in Python 3.0 compared to Python 2.6.</p>
<p>Second, the 2to3 refactoring tool <a class="footnote-reference" href="#to3" id="id5">[1]</a> will gain a fixer
<a class="footnote-reference" href="#fixer" id="id6">[2]</a> for translating tuple parameters to being a single parameter
that is unpacked as the first statement in the function.  The name of
the new parameter will be changed.  The new parameter will then be
unpacked into the names originally used in the tuple parameter.  This
means that the following function:</p>
<pre class="literal-block">
def fxn((a, (b, c))):
    pass
</pre>
<p>will be translated into:</p>
<pre class="literal-block">
def fxn(a_b_c):
    (a, (b, c)) = a_b_c
    pass
</pre>
<p>As tuple parameters are used by lambdas because of the single
expression limitation, they must also be supported.  This is done by
having the expected sequence argument bound to a single parameter and
then indexing on that parameter:</p>
<pre class="literal-block">
lambda (x, y): x + y
</pre>
<p>will be translated into:</p>
<pre class="literal-block">
lambda x_y: x_y[0] + x_y[1]
</pre>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id18">References</a></h1>
<table class="docutils footnote" frame="void" id="to3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[1]</a></td><td>2to3 refactoring tool
(<a class="reference external" href="http://svn.python.org/view/sandbox/trunk/2to3/">http://svn.python.org/view/sandbox/trunk/2to3/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="fixer" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[2]</a></td><td>2to3 fixer
(<a class="reference external" href="http://svn.python.org/view/sandbox/trunk/2to3/fixes/fix_tuple_params.py">http://svn.python.org/view/sandbox/trunk/2to3/fixes/fix_tuple_params.py</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="ironpython" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[3]</a></td><td>IronPython
(<a class="reference external" href="http://www.codeplex.com/Wiki/View.aspx?ProjectName=IronPython">http://www.codeplex.com/Wiki/View.aspx?ProjectName=IronPython</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="msil" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[4]</a></td><td>Microsoft Intermediate Language
(<a class="reference external" href="http://msdn.microsoft.com/library/en-us/cpguide/html/cpconmicrosoftintermediatelanguagemsil.asp?frame=true">http://msdn.microsoft.com/library/en-us/cpguide/html/cpconmicrosoftintermediatelanguagemsil.asp?frame=true</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="pep-3102" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[5]</a></td><td><a class="reference external" href="/dev/peps/pep-3102">PEP 3102</a> (Keyword-Only Arguments)
(<a class="reference external" href="http://www.python.org/dev/peps/pep-3102/">http://www.python.org/dev/peps/pep-3102/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="pep-3107" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[6]</a></td><td><a class="reference external" href="/dev/peps/pep-3107">PEP 3107</a> (Function Annotations)
(<a class="reference external" href="http://www.python.org/dev/peps/pep-3107/">http://www.python.org/dev/peps/pep-3107/</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id19">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

