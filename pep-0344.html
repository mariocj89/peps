<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">344</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Exception Chaining and Embedded Tracebacks</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0344.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Ka-Ping Yee</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Superseded</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">12-May-2005</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.5</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#numbering-note" id="id29">Numbering Note</a></li>
<li><a class="reference internal" href="#abstract" id="id30">Abstract</a></li>
<li><a class="reference internal" href="#motivation" id="id31">Motivation</a></li>
<li><a class="reference internal" href="#history" id="id32">History</a></li>
<li><a class="reference internal" href="#rationale" id="id33">Rationale</a></li>
<li><a class="reference internal" href="#implicit-exception-chaining" id="id34">Implicit Exception Chaining</a></li>
<li><a class="reference internal" href="#explicit-exception-chaining" id="id35">Explicit Exception Chaining</a></li>
<li><a class="reference internal" href="#traceback-attribute" id="id36">Traceback Attribute</a></li>
<li><a class="reference internal" href="#enhanced-reporting" id="id37">Enhanced Reporting</a></li>
<li><a class="reference internal" href="#c-api" id="id38">C API</a></li>
<li><a class="reference internal" href="#compatibility" id="id39">Compatibility</a></li>
<li><a class="reference internal" href="#open-issue-extra-information" id="id40">Open Issue:  Extra Information</a></li>
<li><a class="reference internal" href="#open-issue-suppressing-context" id="id41">Open Issue:  Suppressing Context</a></li>
<li><a class="reference internal" href="#open-issue-limiting-exception-types" id="id42">Open Issue:  Limiting Exception Types</a></li>
<li><a class="reference internal" href="#open-issue-yield" id="id43">Open Issue:  yield</a></li>
<li><a class="reference internal" href="#open-issue-garbage-collection" id="id44">Open Issue:  Garbage Collection</a></li>
<li><a class="reference internal" href="#possible-future-compatible-changes" id="id45">Possible Future Compatible Changes</a></li>
<li><a class="reference internal" href="#possible-future-incompatible-changes" id="id46">Possible Future Incompatible Changes</a></li>
<li><a class="reference internal" href="#acknowledgements" id="id47">Acknowledgements</a></li>
<li><a class="reference internal" href="#references" id="id48">References</a></li>
<li><a class="reference internal" href="#copyright" id="id49">Copyright</a></li>
</ul>
</div>
<div class="section" id="numbering-note">
<h1><a class="toc-backref" href="#id29">Numbering Note</a></h1>
<p>This PEP has been renumbered to <a class="reference external" href="/dev/peps/pep-3134">PEP 3134</a>.  The text below is the last version
submitted under the old number.</p>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id30">Abstract</a></h1>
<p>This PEP proposes three standard attributes on exception instances: the
<tt class="docutils literal">__context__</tt> attribute for implicitly chained exceptions, the
<tt class="docutils literal">__cause__</tt> attribute for explicitly chained exceptions, and the
<tt class="docutils literal">__traceback__</tt> attribute for the traceback.  A new <tt class="docutils literal">raise ... from</tt>
statement sets the <tt class="docutils literal">__cause__</tt> attribute.</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id31">Motivation</a></h1>
<p>During the handling of one exception (exception A), it is possible that another
exception (exception B) may occur.  In today's Python (version 2.4), if this
happens, exception B is propagated outward and exception A is lost.  In order
to debug the problem, it is useful to know about both exceptions.  The
<tt class="docutils literal">__context__</tt> attribute retains this information automatically.</p>
<p>Sometimes it can be useful for an exception handler to intentionally re-raise
an exception, either to provide extra information or to translate an exception
to another type.  The <tt class="docutils literal">__cause__</tt> attribute provides an explicit way to
record the direct cause of an exception.</p>
<p>In today's Python implementation, exceptions are composed of three parts: the
type, the value, and the traceback.  The <tt class="docutils literal">sys</tt> module, exposes the current
exception in three parallel variables, <tt class="docutils literal">exc_type</tt>, <tt class="docutils literal">exc_value</tt>, and
<tt class="docutils literal">exc_traceback</tt>, the <tt class="docutils literal">sys.exc_info()</tt> function returns a tuple of these
three parts, and the <tt class="docutils literal">raise</tt> statement has a three-argument form accepting
these three parts.  Manipulating exceptions often requires passing these three
things in parallel, which can be tedious and error-prone.  Additionally, the
<tt class="docutils literal">except</tt> statement can only provide access to the value, not the traceback.
Adding the <tt class="docutils literal">__traceback__</tt> attribute to exception values makes all the
exception information accessible from a single place.</p>
</div>
<div class="section" id="history">
<h1><a class="toc-backref" href="#id32">History</a></h1>
<p>Raymond Hettinger <a class="footnote-reference" href="#id16" id="id1">[1]</a> raised the issue of masked exceptions on Python-Dev in
January 2003 and proposed a <tt class="docutils literal">PyErr_FormatAppend()</tt> function that C modules
could use to augment the currently active exception with more information.
Brett Cannon <a class="footnote-reference" href="#id17" id="id2">[2]</a> brought up chained exceptions again in June 2003, prompting
a long discussion.</p>
<p>Greg Ewing <a class="footnote-reference" href="#id18" id="id3">[3]</a> identified the case of an exception occurring in a <tt class="docutils literal">finally</tt>
block during unwinding triggered by an original exception, as distinct from
the case of an exception occurring in an <tt class="docutils literal">except</tt> block that is handling the
original exception.</p>
<p>Greg Ewing <a class="footnote-reference" href="#id19" id="id4">[4]</a> and Guido van Rossum <a class="footnote-reference" href="#id20" id="id5">[5]</a>, and probably others, have
previously mentioned adding a traceback attribute to <tt class="docutils literal">Exception</tt> instances.
This is noted in <a class="reference external" href="/dev/peps/pep-3000">PEP 3000</a>.</p>
<p>This PEP was motivated by yet another recent Python-Dev reposting of the same
ideas <a class="footnote-reference" href="#id21" id="id6">[6]</a> <a class="footnote-reference" href="#id22" id="id7">[7]</a>.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id33">Rationale</a></h1>
<p>The Python-Dev discussions revealed interest in exception chaining for two
quite different purposes.  To handle the unexpected raising of a secondary
exception, the exception must be retained implicitly. To support intentional
translation of an exception, there must be a way to chain exceptions
explicitly.  This PEP addresses both.</p>
<p>Several attribute names for chained exceptions have been suggested on Python-
Dev <a class="footnote-reference" href="#id17" id="id8">[2]</a>, including <tt class="docutils literal">cause</tt>, <tt class="docutils literal">antecedent</tt>, <tt class="docutils literal">reason</tt>, <tt class="docutils literal">original</tt>,
<tt class="docutils literal">chain</tt>, <tt class="docutils literal">chainedexc</tt>, <tt class="docutils literal">xc_chain</tt>, <tt class="docutils literal">excprev</tt>, <tt class="docutils literal">previous</tt> and
<tt class="docutils literal">precursor</tt>.  For an explicitly chained exception, this PEP suggests
<tt class="docutils literal">__cause__</tt> because of its specific meaning.  For an implicitly chained
exception, this PEP proposes the name <tt class="docutils literal">__context__</tt> because the intended
meaning is more specific than temporal precedence but less specific than
causation: an exception occurs in the context of handling another exception.</p>
<p>This PEP suggests names with leading and trailing double-underscores for these
three attributes because they are set by the Python VM. Only in very special
cases should they be set by normal assignment.</p>
<p>This PEP handles exceptions that occur during <tt class="docutils literal">except</tt> blocks and
<tt class="docutils literal">finally</tt> blocks in the same way.  Reading the traceback makes it clear
where the exceptions occurred, so additional mechanisms for distinguishing
the two cases would only add unnecessary complexity.</p>
<p>This PEP proposes that the outermost exception object (the one exposed for
matching by <tt class="docutils literal">except</tt> clauses) be the most recently raised exception for
compatibility with current behaviour.</p>
<p>This PEP proposes that tracebacks display the outermost exception last,
because this would be consistent with the chronological order of tracebacks
(from oldest to most recent frame) and because the actual thrown exception is
easier to find on the last line.</p>
<p>To keep things simpler, the C API calls for setting an exception will not
automatically set the exception's <tt class="docutils literal">__context__</tt>.  Guido van Rossum has
expressed concerns with making such changes <a class="footnote-reference" href="#id23" id="id9">[8]</a>.</p>
<p>As for other languages, Java and Ruby both discard the original exception when
another exception occurs in a <tt class="docutils literal">catch/rescue</tt> or <tt class="docutils literal">finally/ensure</tt> clause.
Perl 5 lacks built-in structured exception handling.  For Perl 6, RFC number
88 <a class="footnote-reference" href="#id24" id="id10">[9]</a> proposes an exception mechanism that implicitly retains chained
exceptions in an array named <tt class="docutils literal">&#64;&#64;</tt>.  In that RFC, the most recently raised
exception is exposed for matching, as in this PEP; also, arbitrary expressions
(possibly involving <tt class="docutils literal">&#64;&#64;</tt>) can be evaluated for exception matching.</p>
<p>Exceptions in C# contain a read-only <tt class="docutils literal">InnerException</tt> property that may
point to another exception.  Its documentation <a class="footnote-reference" href="#id25" id="id11">[10]</a> says that &quot;When an
exception X is thrown as a direct result of a previous exception Y, the
<tt class="docutils literal">InnerException</tt> property of X should contain a reference to Y.&quot;  This
property is not set by the VM automatically; rather, all exception
constructors take an optional <tt class="docutils literal">innerException</tt> argument to set it
explicitly.  The <tt class="docutils literal">__cause__</tt> attribute fulfills the same purpose as
<tt class="docutils literal">InnerException</tt>, but this PEP proposes a new form of <tt class="docutils literal">raise</tt> rather than
extending the constructors of all exceptions. C# also provides a
<tt class="docutils literal">GetBaseException</tt> method that jumps directly to the end of the
<tt class="docutils literal">InnerException</tt> chain; this PEP proposes no analog.</p>
<p>The reason all three of these attributes are presented together in one proposal
is that the <tt class="docutils literal">__traceback__</tt> attribute provides convenient access to the
traceback on chained exceptions.</p>
</div>
<div class="section" id="implicit-exception-chaining">
<h1><a class="toc-backref" href="#id34">Implicit Exception Chaining</a></h1>
<p>Here is an example to illustrate the <tt class="docutils literal">__context__</tt> attribute:</p>
<pre class="literal-block">
def compute(a, b):
    try:
        a/b
    except Exception, exc:
        log(exc)

def log(exc):
    file = open('logfile.txt')  # oops, forgot the 'w'
    print &gt;&gt;file, exc
    file.close()
</pre>
<p>Calling <tt class="docutils literal">compute(0, 0)</tt> causes a <tt class="docutils literal">ZeroDivisionError</tt>.  The <tt class="docutils literal">compute()</tt>
function catches this exception and calls <tt class="docutils literal">log(exc)</tt>, but the <tt class="docutils literal">log()</tt>
function also raises an exception when it tries to write to a file that wasn't
opened for writing.</p>
<p>In today's Python, the caller of <tt class="docutils literal">compute()</tt> gets thrown an <tt class="docutils literal">IOError</tt>. The
<tt class="docutils literal">ZeroDivisionError</tt> is lost.  With the proposed change, the instance of
<tt class="docutils literal">IOError</tt> has an additional <tt class="docutils literal">__context__</tt> attribute that retains the
<tt class="docutils literal">ZeroDivisionError</tt>.</p>
<p>The following more elaborate example demonstrates the handling of a mixture of
<tt class="docutils literal">finally</tt> and <tt class="docutils literal">except</tt> clauses:</p>
<pre class="literal-block">
def main(filename):
    file = open(filename)       # oops, forgot the 'w'
    try:
        try:
            compute()
        except Exception, exc:
            log(file, exc)
        finally:
            file.clos()         # oops, misspelled 'close'

def compute():
    1/0

def log(file, exc):
    try:
        print &gt;&gt;file, exc       # oops, file is not writable
    except:
        display(exc)

def display(exc):
    print ex                    # oops, misspelled 'exc'
</pre>
<p>Calling <tt class="docutils literal">main()</tt> with the name of an existing file will trigger four
exceptions.  The ultimate result will be an <tt class="docutils literal">AttributeError</tt> due to the
misspelling of <tt class="docutils literal">clos</tt>, whose <tt class="docutils literal">__context__</tt> points to a <tt class="docutils literal">NameError</tt> due
to the misspelling of <tt class="docutils literal">ex</tt>, whose <tt class="docutils literal">__context__</tt> points to an <tt class="docutils literal">IOError</tt>
due to the file being read-only, whose <tt class="docutils literal">__context__</tt> points to a
<tt class="docutils literal">ZeroDivisionError</tt>, whose <tt class="docutils literal">__context__</tt> attribute is <tt class="docutils literal">None</tt>.</p>
<p>The proposed semantics are as follows:</p>
<ol class="arabic simple">
<li>Each thread has an exception context initially set to <tt class="docutils literal">None</tt>.</li>
<li>Whenever an exception is raised, if the exception instance does not
already have a <tt class="docutils literal">__context__</tt> attribute, the interpreter sets it equal to
the thread's exception context.</li>
<li>Immediately after an exception is raised, the thread's exception context is
set to the exception.</li>
<li>Whenever the interpreter exits an <tt class="docutils literal">except</tt> block by reaching the end or
executing a <tt class="docutils literal">return</tt>, <tt class="docutils literal">yield</tt>, <tt class="docutils literal">continue</tt>, or <tt class="docutils literal">break</tt> statement,
the thread's exception context is set to <tt class="docutils literal">None</tt>.</li>
</ol>
</div>
<div class="section" id="explicit-exception-chaining">
<h1><a class="toc-backref" href="#id35">Explicit Exception Chaining</a></h1>
<p>The <tt class="docutils literal">__cause__</tt> attribute on exception objects is always initialized to
<tt class="docutils literal">None</tt>.  It is set by a new form of the <tt class="docutils literal">raise</tt> statement:</p>
<pre class="literal-block">
raise EXCEPTION from CAUSE
</pre>
<p>which is equivalent to:</p>
<pre class="literal-block">
exc = EXCEPTION
exc.__cause__ = CAUSE
raise exc
</pre>
<p>In the following example, a database provides implementations for a few
different kinds of storage, with file storage as one kind.  The database
designer wants errors to propagate as <tt class="docutils literal">DatabaseError</tt> objects so that the
client doesn't have to be aware of the storage-specific details, but doesn't
want to lose the underlying error information:</p>
<pre class="literal-block">
class DatabaseError(StandardError):
    pass

class FileDatabase(Database):
    def __init__(self, filename):
        try:
            self.file = open(filename)
        except IOError, exc:
            raise DatabaseError('failed to open') from exc
</pre>
<p>If the call to <tt class="docutils literal">open()</tt> raises an exception, the problem will be reported as
a <tt class="docutils literal">DatabaseError</tt>, with a <tt class="docutils literal">__cause__</tt> attribute that reveals the
<tt class="docutils literal">IOError</tt> as the original cause.</p>
</div>
<div class="section" id="traceback-attribute">
<h1><a class="toc-backref" href="#id36">Traceback Attribute</a></h1>
<p>The following example illustrates the <tt class="docutils literal">__traceback__</tt> attribute:</p>
<pre class="literal-block">
def do_logged(file, work):
    try:
        work()
    except Exception, exc:
        write_exception(file, exc)
        raise exc

from traceback import format_tb

def write_exception(file, exc):
    ...
    type = exc.__class__
    message = str(exc)
    lines = format_tb(exc.__traceback__)
    file.write(... type ... message ... lines ...)
    ...
</pre>
<p>In today's Python, the <tt class="docutils literal">do_logged()</tt> function would have to extract the
traceback from <tt class="docutils literal">sys.exc_traceback</tt> or <tt class="docutils literal">sys.exc_info()</tt> <a class="footnote-reference" href="#id17" id="id12">[2]</a> and pass both
the value and the traceback to <tt class="docutils literal">write_exception()</tt>.  With the proposed
change, <tt class="docutils literal">write_exception()</tt> simply gets one argument and obtains the
exception using the <tt class="docutils literal">__traceback__</tt> attribute.</p>
<p>The proposed semantics are as follows:</p>
<ol class="arabic simple">
<li>Whenever an exception is caught, if the exception instance does not already
have a <tt class="docutils literal">__traceback__</tt> attribute, the interpreter sets it to the newly
caught traceback.</li>
</ol>
</div>
<div class="section" id="enhanced-reporting">
<h1><a class="toc-backref" href="#id37">Enhanced Reporting</a></h1>
<p>The default exception handler will be modified to report chained exceptions.
The chain of exceptions is traversed by following the <tt class="docutils literal">__cause__</tt> and
<tt class="docutils literal">__context__</tt> attributes, with <tt class="docutils literal">__cause__</tt> taking priority.  In keeping
with the chronological order of tracebacks, the most recently raised exception
is displayed last; that is, the display begins with the description of the
innermost exception and backs up the chain to the outermost exception.  The
tracebacks are formatted as usual, with one of the lines:</p>
<pre class="literal-block">
The above exception was the direct cause of the following exception:
</pre>
<p>or</p>
<pre class="literal-block">
During handling of the above exception, another exception occurred:
</pre>
<p>between tracebacks, depending whether they are linked by <tt class="docutils literal">__cause__</tt> or
<tt class="docutils literal">__context__</tt> respectively.  Here is a sketch of the procedure:</p>
<pre class="literal-block">
def print_chain(exc):
    if exc.__cause__:
        print_chain(exc.__cause__)
        print '\nThe above exception was the direct cause...'
    elif exc.__context__:
        print_chain(exc.__context__)
        print '\nDuring handling of the above exception, ...'
    print_exc(exc)
</pre>
<p>In the <tt class="docutils literal">traceback</tt> module, the <tt class="docutils literal">format_exception</tt>, <tt class="docutils literal">print_exception</tt>,
<tt class="docutils literal">print_exc</tt>, and <tt class="docutils literal">print_last functions</tt> will be updated to accept an
optional <tt class="docutils literal">chain</tt> argument, <tt class="docutils literal">True</tt> by default.  When this argument is
<tt class="docutils literal">True</tt>, these functions will format or display the entire chain of
exceptions as just described.  When it is <tt class="docutils literal">False</tt>, these functions will
format or display only the outermost exception.</p>
<p>The <tt class="docutils literal">cgitb</tt> module should also be updated to display the entire chain of
exceptions.</p>
</div>
<div class="section" id="c-api">
<h1><a class="toc-backref" href="#id38">C API</a></h1>
<p>The <tt class="docutils literal">PyErr_Set*</tt> calls for setting exceptions will not set the
<tt class="docutils literal">__context__</tt> attribute on exceptions.  <tt class="docutils literal">PyErr_NormalizeException</tt> will
always set the <tt class="docutils literal">traceback</tt> attribute to its <tt class="docutils literal">tb</tt> argument and the
<tt class="docutils literal">__context__</tt> and <tt class="docutils literal">__cause__</tt> attributes to <tt class="docutils literal">None</tt>.</p>
<p>A new API function, <tt class="docutils literal">PyErr_SetContext(context)</tt>, will help C programmers
provide chained exception information.  This function will first normalize the
current exception so it is an instance, then set its <tt class="docutils literal">__context__</tt>
attribute.  A similar API function, <tt class="docutils literal">PyErr_SetCause(cause)</tt>, will set the
<tt class="docutils literal">__cause__</tt> attribute.</p>
</div>
<div class="section" id="compatibility">
<h1><a class="toc-backref" href="#id39">Compatibility</a></h1>
<p>Chained exceptions expose the type of the most recent exception, so they will
still match the same <tt class="docutils literal">except</tt> clauses as they do now.</p>
<p>The proposed changes should not break any code unless it sets or uses
attributes named <tt class="docutils literal">__context__</tt>, <tt class="docutils literal">__cause__</tt>, or <tt class="docutils literal">__traceback__</tt> on
exception instances.  As of 2005-05-12, the Python standard library contains
no mention of such attributes.</p>
</div>
<div class="section" id="open-issue-extra-information">
<h1><a class="toc-backref" href="#id40">Open Issue:  Extra Information</a></h1>
<p>Walter Dörwald <a class="footnote-reference" href="#id26" id="id13">[11]</a> expressed a desire to attach extra information to an
exception during its upward propagation without changing its type.  This could
be a useful feature, but it is not addressed by this PEP.  It could
conceivably be addressed by a separate PEP establishing conventions for other
informational attributes on exceptions.</p>
</div>
<div class="section" id="open-issue-suppressing-context">
<h1><a class="toc-backref" href="#id41">Open Issue:  Suppressing Context</a></h1>
<p>As written, this PEP makes it impossible to suppress <tt class="docutils literal">__context__</tt>, since
setting <tt class="docutils literal">exc.__context__</tt> to <tt class="docutils literal">None</tt> in an <tt class="docutils literal">except</tt> or <tt class="docutils literal">finally</tt> clause
will only result in it being set again when <tt class="docutils literal">exc</tt> is raised.</p>
</div>
<div class="section" id="open-issue-limiting-exception-types">
<h1><a class="toc-backref" href="#id42">Open Issue:  Limiting Exception Types</a></h1>
<p>To improve encapsulation, library implementors may want to wrap all
implementation-level exceptions with an application-level exception. One could
try to wrap exceptions by writing this:</p>
<pre class="literal-block">
try:
    ... implementation may raise an exception ...
except:
    import sys
    raise ApplicationError from sys.exc_value
</pre>
<p>or this</p>
<pre class="literal-block">
try:
    ... implementation may raise an exception ...
except Exception, exc:
    raise ApplicationError from exc
</pre>
<p>but both are somewhat flawed.  It would be nice to be able to name the current
exception in a catch-all <tt class="docutils literal">except</tt> clause, but that isn't addressed here.
Such a feature would allow something like this:</p>
<pre class="literal-block">
try:
    ... implementation may raise an exception ...
except *, exc:
    raise ApplicationError from exc
</pre>
</div>
<div class="section" id="open-issue-yield">
<h1><a class="toc-backref" href="#id43">Open Issue:  yield</a></h1>
<p>The exception context is lost when a <tt class="docutils literal">yield</tt> statement is executed; resuming
the frame after the <tt class="docutils literal">yield</tt> does not restore the context. Addressing this
problem is out of the scope of this PEP; it is not a new problem, as
demonstrated by the following example:</p>
<pre class="literal-block">
&gt;&gt;&gt; def gen():
...     try:
...         1/0
...     except:
...         yield 3
...         raise
...
&gt;&gt;&gt; g = gen()
&gt;&gt;&gt; g.next()
3
&gt;&gt;&gt; g.next()
TypeError: exceptions must be classes, instances, or strings
(deprecated), not NoneType
</pre>
</div>
<div class="section" id="open-issue-garbage-collection">
<h1><a class="toc-backref" href="#id44">Open Issue:  Garbage Collection</a></h1>
<p>The strongest objection to this proposal has been that it creates cycles
between exceptions and stack frames <a class="footnote-reference" href="#id27" id="id14">[12]</a>.  Collection of cyclic garbage (and
therefore resource release) can be greatly delayed:</p>
<pre class="literal-block">
&gt;&gt;&gt; try:
&gt;&gt;&gt;     1/0
&gt;&gt;&gt; except Exception, err:
&gt;&gt;&gt;     pass
</pre>
<p>will introduce a cycle from err -&gt; traceback -&gt; stack frame -&gt; err, keeping
all locals in the same scope alive until the next GC happens.</p>
<p>Today, these locals would go out of scope.  There is lots of code which
assumes that &quot;local&quot; resources -- particularly open files -- will be closed
quickly.  If closure has to wait for the next GC, a program (which runs fine
today) may run out of file handles.</p>
<p>Making the <tt class="docutils literal">__traceback__</tt> attribute a weak reference would avoid the
problems with cyclic garbage.  Unfortunately, it would make saving the
<tt class="docutils literal">Exception</tt> for later (as <tt class="docutils literal">unittest</tt> does) more awkward, and it would not
allow as much cleanup of the <tt class="docutils literal">sys</tt> module.</p>
<p>A possible alternate solution, suggested by Adam Olsen, would be to instead
turn the reference from the stack frame to the <tt class="docutils literal">err</tt> variable into a weak
reference when the variable goes out of scope <a class="footnote-reference" href="#id28" id="id15">[13]</a>.</p>
</div>
<div class="section" id="possible-future-compatible-changes">
<h1><a class="toc-backref" href="#id45">Possible Future Compatible Changes</a></h1>
<p>These changes are consistent with the appearance of exceptions as a single
object rather than a triple at the interpreter level.</p>
<ul class="simple">
<li>If <a class="reference external" href="/dev/peps/pep-0340">PEP 340</a> or <a class="reference external" href="/dev/peps/pep-0343">PEP 343</a> is accepted, replace the three (<tt class="docutils literal">type</tt>, <tt class="docutils literal">value</tt>,
<tt class="docutils literal">traceback</tt>) arguments to <tt class="docutils literal">__exit__</tt> with a single exception argument.</li>
<li>Deprecate <tt class="docutils literal">sys.exc_type</tt>, <tt class="docutils literal">sys.exc_value</tt>, <tt class="docutils literal">sys.exc_traceback</tt>, and
<tt class="docutils literal">sys.exc_info()</tt> in favour of a single member, <tt class="docutils literal">sys.exception</tt>.</li>
<li>Deprecate <tt class="docutils literal">sys.last_type</tt>, <tt class="docutils literal">sys.last_value</tt>, and <tt class="docutils literal">sys.last_traceback</tt>
in favour of a single member, <tt class="docutils literal">sys.last_exception</tt>.</li>
<li>Deprecate the three-argument form of the <tt class="docutils literal">raise</tt> statement in favour of
the one-argument form.</li>
<li>Upgrade <tt class="docutils literal">cgitb.html()</tt> to accept a single value as its first argument as
an alternative to a <tt class="docutils literal">(type, value, traceback)</tt> tuple.</li>
</ul>
</div>
<div class="section" id="possible-future-incompatible-changes">
<h1><a class="toc-backref" href="#id46">Possible Future Incompatible Changes</a></h1>
<p>These changes might be worth considering for Python 3000.</p>
<ul class="simple">
<li>Remove <tt class="docutils literal">sys.exc_type</tt>, <tt class="docutils literal">sys.exc_value</tt>, <tt class="docutils literal">sys.exc_traceback</tt>, and
<tt class="docutils literal">sys.exc_info()</tt>.</li>
<li>Remove <tt class="docutils literal">sys.last_type</tt>, <tt class="docutils literal">sys.last_value</tt>, and <tt class="docutils literal">sys.last_traceback</tt>.</li>
<li>Replace the three-argument <tt class="docutils literal">sys.excepthook</tt> with a one-argument API, and
changing the <tt class="docutils literal">cgitb</tt> module to match.</li>
<li>Remove the three-argument form of the <tt class="docutils literal">raise</tt> statement.</li>
<li>Upgrade <tt class="docutils literal">traceback.print_exception</tt> to accept an <tt class="docutils literal">exception</tt> argument
instead of the <tt class="docutils literal">type</tt>, <tt class="docutils literal">value</tt>, and <tt class="docutils literal">traceback</tt> arguments.</li>
</ul>
</div>
<div class="section" id="acknowledgements">
<h1><a class="toc-backref" href="#id47">Acknowledgements</a></h1>
<p>Brett Cannon, Greg Ewing, Guido van Rossum, Jeremy Hylton, Phillip J. Eby,
Raymond Hettinger, Walter Dörwald, and others.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id48">References</a></h1>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Raymond Hettinger, &quot;Idea for avoiding exception masking&quot;
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2003-January/032492.html">https://mail.python.org/pipermail/python-dev/2003-January/032492.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id8">2</a>, <a class="fn-backref" href="#id12">3</a>)</em> Brett Cannon explains chained exceptions
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2003-June/036063.html">https://mail.python.org/pipermail/python-dev/2003-June/036063.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>Greg Ewing points out masking caused by exceptions during finally
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2003-June/036290.html">https://mail.python.org/pipermail/python-dev/2003-June/036290.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>Greg Ewing suggests storing the traceback in the exception object
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2003-June/036092.html">https://mail.python.org/pipermail/python-dev/2003-June/036092.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>Guido van Rossum mentions exceptions having a traceback attribute
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2005-April/053060.html">https://mail.python.org/pipermail/python-dev/2005-April/053060.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td>Ka-Ping Yee, &quot;Tidier Exceptions&quot;
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2005-May/053671.html">https://mail.python.org/pipermail/python-dev/2005-May/053671.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[7]</a></td><td>Ka-Ping Yee, &quot;Chained Exceptions&quot;
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2005-May/053672.html">https://mail.python.org/pipermail/python-dev/2005-May/053672.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id23" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[8]</a></td><td>Guido van Rossum discusses automatic chaining in <tt class="docutils literal">PyErr_Set*</tt>
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2003-June/036180.html">https://mail.python.org/pipermail/python-dev/2003-June/036180.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id24" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[9]</a></td><td>Tony Olensky, &quot;Omnibus Structured Exception/Error Handling Mechanism&quot;
<a class="reference external" href="http://dev.perl.org/perl6/rfc/88.html">http://dev.perl.org/perl6/rfc/88.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id25" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[10]</a></td><td>MSDN .NET Framework Library, &quot;Exception.InnerException Property&quot;
<a class="reference external" href="http://msdn.microsoft.com/library/en-us/cpref/html/frlrfsystemexceptionclassinnerexceptiontopic.asp">http://msdn.microsoft.com/library/en-us/cpref/html/frlrfsystemexceptionclassinnerexceptiontopic.asp</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id26" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[11]</a></td><td>Walter Dörwald suggests wrapping exceptions to add details
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2003-June/036148.html">https://mail.python.org/pipermail/python-dev/2003-June/036148.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id27" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[12]</a></td><td>Guido van Rossum restates the objection to cyclic trash
<a class="reference external" href="https://mail.python.org/pipermail/python-3000/2007-January/005322.html">https://mail.python.org/pipermail/python-3000/2007-January/005322.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id28" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[13]</a></td><td>Adam Olsen suggests using a weakref from stack frame to exception
<a class="reference external" href="https://mail.python.org/pipermail/python-3000/2007-January/005363.html">https://mail.python.org/pipermail/python-3000/2007-January/005363.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id49">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

