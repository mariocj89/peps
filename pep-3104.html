<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">3104</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Access to Names in Outer Scopes</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-3104.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Ka-Ping Yee &lt;ping&#32;&#97;t&#32;zesty.ca&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">12-Oct-2006</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.0</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id74">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id75">Rationale</a></li>
<li><a class="reference internal" href="#other-languages" id="id76">Other Languages</a><ul>
<li><a class="reference internal" href="#javascript-perl-scheme-smalltalk-gnu-c-c-2-0" id="id77">JavaScript, Perl, Scheme, Smalltalk, GNU C, C# 2.0</a></li>
<li><a class="reference internal" href="#ruby-as-of-1-8" id="id78">Ruby (as of 1.8)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#overview-of-proposals" id="id79">Overview of Proposals</a><ul>
<li><a class="reference internal" href="#new-syntax-in-the-binding-outer-scope" id="id80">New Syntax in the Binding (Outer) Scope</a><ul>
<li><a class="reference internal" href="#scope-override-declaration" id="id81">Scope Override Declaration</a></li>
<li><a class="reference internal" href="#required-variable-declaration" id="id82">Required Variable Declaration</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-syntax-in-the-referring-inner-scope" id="id83">New Syntax in the Referring (Inner) Scope</a><ul>
<li><a class="reference internal" href="#outer-reference-expression" id="id84">Outer Reference Expression</a></li>
<li><a class="reference internal" href="#rebinding-operator" id="id85">Rebinding Operator</a></li>
<li><a class="reference internal" href="#id14" id="id86">Scope Override Declaration</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#proposed-solution" id="id87">Proposed Solution</a></li>
<li><a class="reference internal" href="#backward-compatibility" id="id88">Backward Compatibility</a></li>
<li><a class="reference internal" href="#references" id="id89">References</a></li>
<li><a class="reference internal" href="#acknowledgements" id="id90">Acknowledgements</a></li>
<li><a class="reference internal" href="#copyright" id="id91">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id74">Abstract</a></h1>
<p>In most languages that support nested scopes, code can refer to or
rebind (assign to) any name in the nearest enclosing scope.
Currently, Python code can refer to a name in any enclosing scope,
but it can only rebind names in two scopes: the local scope (by
simple assignment) or the module-global scope (using a <tt class="docutils literal">global</tt>
declaration).</p>
<p>This limitation has been raised many times on the Python-Dev mailing
list and elsewhere, and has led to extended discussion and many
proposals for ways to remove this limitation.  This PEP summarizes
the various alternatives that have been suggested, together with
advantages and disadvantages that have been mentioned for each.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id75">Rationale</a></h1>
<p>Before version 2.1, Python's treatment of scopes resembled that of
standard C: within a file there were only two levels of scope, global
and local.  In C, this is a natural consequence of the fact that
function definitions cannot be nested.  But in Python, though
functions are usually defined at the top level, a function definition
can be executed anywhere.  This gave Python the syntactic appearance
of nested scoping without the semantics, and yielded inconsistencies
that were surprising to some programmers -- for example, a recursive
function that worked at the top level would cease to work when moved
inside another function, because the recursive function's own name
would no longer be visible in its body's scope.  This violates the
intuition that a function should behave consistently when placed in
different contexts.  Here's an example:</p>
<pre class="literal-block">
def enclosing_function():
    def factorial(n):
        if n &lt; 2:
            return 1
        return n * factorial(n - 1)  # fails with NameError
    print factorial(5)
</pre>
<p>Python 2.1 moved closer to static nested scoping by making visible
the names bound in all enclosing scopes (see <a class="reference external" href="/dev/peps/pep-0227">PEP 227</a>).  This change
makes the above code example work as expected.  However, because any
assignment to a name implicitly declares that name to be local, it is
impossible to rebind a name in an outer scope (except when a
<tt class="docutils literal">global</tt> declaration forces the name to be global).  Thus, the
following code, intended to display a number that can be incremented
and decremented by clicking buttons, doesn't work as someone familiar
with lexical scoping might expect:</p>
<pre class="literal-block">
def make_scoreboard(frame, score=0):
    label = Label(frame)
    label.pack()
    for i in [-10, -1, 1, 10]:
        def increment(step=i):
            score = score + step  # fails with UnboundLocalError
            label['text'] = score
        button = Button(frame, text='%+d' % i, command=increment)
        button.pack()
    return label
</pre>
<p>Python syntax doesn't provide a way to indicate that the name
<tt class="docutils literal">score</tt> mentioned in <tt class="docutils literal">increment</tt> refers to the variable <tt class="docutils literal">score</tt>
bound in <tt class="docutils literal">make_scoreboard</tt>, not a local variable in <tt class="docutils literal">increment</tt>.
Users and developers of Python have expressed an interest in removing
this limitation so that Python can have the full flexibility of the
Algol-style scoping model that is now standard in many programming
languages, including JavaScript, Perl, Ruby, Scheme, Smalltalk,
C with GNU extensions, and C# 2.0.</p>
<p>It has been argued that such a feature isn't necessary, because
a rebindable outer variable can be simulated by wrapping it in a
mutable object:</p>
<pre class="literal-block">
class Namespace:
    pass

def make_scoreboard(frame, score=0):
    ns = Namespace()
    ns.score = 0
    label = Label(frame)
    label.pack()
    for i in [-10, -1, 1, 10]:
        def increment(step=i):
            ns.score = ns.score + step
            label['text'] = ns.score
        button = Button(frame, text='%+d' % i, command=increment)
        button.pack()
    return label
</pre>
<p>However, this workaround only highlights the shortcomings of existing
scopes: the purpose of a function is to encapsulate code in its own
namespace, so it seems unfortunate that the programmer should have to
create additional namespaces to make up for missing functionality in
the existing local scopes, and then have to decide whether each name
should reside in the real scope or the simulated scope.</p>
<p>Another common objection is that the desired functionality can be
written as a class instead, albeit somewhat more verbosely.  One
rebuttal to this objection is that the existence of a different
implementation style is not a reason to leave a supported programming
construct (nested scopes) functionally incomplete.  Python is
sometimes called a &quot;multi-paradigm language&quot; because it derives so
much strength, practical flexibility, and pedagogical power from its
support and graceful integration of multiple programming paradigms.</p>
<p>A proposal for scoping syntax appeared on Python-Dev as far back as
1994 <a class="footnote-reference" href="#id44" id="id1">[1]</a>, long before <a class="reference external" href="/dev/peps/pep-0227">PEP 227</a>'s support for nested scopes was
adopted.  At the time, Guido's response was:</p>
<blockquote>
This is dangerously close to introducing CSNS [classic static
nested scopes]. <em>If</em> you were to do so, your proposed semantics
of scoped seem allright. I still think there is not enough need
for CSNS to warrant this kind of construct ...</blockquote>
<p>After <a class="reference external" href="/dev/peps/pep-0227">PEP 227</a>, the &quot;outer name rebinding discussion&quot; has reappeared
on Python-Dev enough times that it has become a familiar event,
having recurred in its present form since at least 2003 <a class="footnote-reference" href="#id45" id="id2">[2]</a>.
Although none of the language changes proposed in these discussions
have yet been adopted, Guido has acknowledged that a language change
is worth considering <a class="footnote-reference" href="#id55" id="id3">[12]</a>.</p>
</div>
<div class="section" id="other-languages">
<h1><a class="toc-backref" href="#id76">Other Languages</a></h1>
<p>To provide some background, this section describes how some other
languages handle nested scopes and rebinding.</p>
<div class="section" id="javascript-perl-scheme-smalltalk-gnu-c-c-2-0">
<h2><a class="toc-backref" href="#id77">JavaScript, Perl, Scheme, Smalltalk, GNU C, C# 2.0</a></h2>
<p>These languages use variable declarations to indicate scope.  In
JavaScript, a lexically scoped variable is declared with the <tt class="docutils literal">var</tt>
keyword; undeclared variable names are assumed to be global.  In
Perl, a lexically scoped variable is declared with the <tt class="docutils literal">my</tt>
keyword; undeclared variable names are assumed to be global.  In
Scheme, all variables must be declared (with <tt class="docutils literal">define</tt> or <tt class="docutils literal">let</tt>,
or as formal parameters).  In Smalltalk, any block can begin by
declaring a list of local variable names between vertical bars.
C and C# require type declarations for all variables.  For all these
cases, the variable belongs to the scope containing the declaration.</p>
</div>
<div class="section" id="ruby-as-of-1-8">
<h2><a class="toc-backref" href="#id78">Ruby (as of 1.8)</a></h2>
<p>Ruby is an instructive example because it appears to be the only
other currently popular language that, like Python, tries to support
statically nested scopes without requiring variable declarations, and
thus has to come up with an unusual solution.  Functions in Ruby can
contain other function definitions, and they can also contain code
blocks enclosed in curly braces.  Blocks have access to outer
variables, but nested functions do not.  Within a block, an
assignment to a name implies a declaration of a local variable only
if it would not shadow a name already bound in an outer scope;
otherwise assignment is interpreted as rebinding of the outer name.
Ruby's scoping syntax and rules have also been debated at great
length, and changes seem likely in Ruby 2.0 <a class="footnote-reference" href="#id71" id="id4">[28]</a>.</p>
</div>
</div>
<div class="section" id="overview-of-proposals">
<h1><a class="toc-backref" href="#id79">Overview of Proposals</a></h1>
<p>There have been many different proposals on Python-Dev for ways to
rebind names in outer scopes.  They all fall into two categories:
new syntax in the scope where the name is bound, or new syntax in
the scope where the name is used.</p>
<div class="section" id="new-syntax-in-the-binding-outer-scope">
<h2><a class="toc-backref" href="#id80">New Syntax in the Binding (Outer) Scope</a></h2>
<div class="section" id="scope-override-declaration">
<h3><a class="toc-backref" href="#id81">Scope Override Declaration</a></h3>
<p>The proposals in this category all suggest a new kind of declaration
statement similar to JavaScript's <tt class="docutils literal">var</tt>.  A few possible keywords
have been proposed for this purpose:</p>
<ul class="simple">
<li><tt class="docutils literal">scope x</tt> <a class="footnote-reference" href="#id47" id="id5">[4]</a></li>
<li><tt class="docutils literal">var x</tt> <a class="footnote-reference" href="#id47" id="id6">[4]</a> <a class="footnote-reference" href="#id52" id="id7">[9]</a></li>
<li><tt class="docutils literal">my x</tt> <a class="footnote-reference" href="#id56" id="id8">[13]</a></li>
</ul>
<p>In all these proposals, a declaration such as <tt class="docutils literal">var x</tt> in a
particular scope S would cause all references to <tt class="docutils literal">x</tt> in scopes
nested within S to refer to the <tt class="docutils literal">x</tt> bound in S.</p>
<p>The primary objection to this category of proposals is that the
meaning of a function definition would become context-sensitive.
Moving a function definition inside some other block could cause any
of the local name references in the function to become nonlocal, due
to declarations in the enclosing block.  For blocks in Ruby 1.8,
this is actually the case; in the following example, the two setters
have different effects even though they look identical:</p>
<pre class="literal-block">
setter1 = proc { | x | y = x }      # y is local here
y = 13
setter2 = proc { | x | y = x }      # y is nonlocal here
setter1.call(99)
puts y                              # prints 13
setter2.call(77)
puts y                              # prints 77
</pre>
<p>Note that although this proposal resembles declarations in JavaScript
and Perl, the effect on the language is different because in those
languages undeclared variables are global by default, whereas in
Python undeclared variables are local by default.  Thus, moving
a function inside some other block in JavaScript or Perl can only
reduce the scope of a previously global name reference, whereas in
Python with this proposal, it could expand the scope of a previously
local name reference.</p>
</div>
<div class="section" id="required-variable-declaration">
<h3><a class="toc-backref" href="#id82">Required Variable Declaration</a></h3>
<p>A more radical proposal <a class="footnote-reference" href="#id64" id="id9">[21]</a> suggests removing Python's scope-guessing
convention altogether and requiring that all names be declared in the
scope where they are to be bound, much like Scheme.  With this
proposal, <tt class="docutils literal">var x = 3</tt> would both declare <tt class="docutils literal">x</tt> to belong to the
local scope and bind it, where as <tt class="docutils literal">x = 3</tt> would rebind the existing
visible <tt class="docutils literal">x</tt>.  In a context without an enclosing scope containing a
<tt class="docutils literal">var x</tt> declaration, the statement <tt class="docutils literal">x = 3</tt> would be statically
determined to be illegal.</p>
<p>This proposal yields a simple and consistent model, but it would be
incompatible with all existing Python code.</p>
</div>
</div>
<div class="section" id="new-syntax-in-the-referring-inner-scope">
<h2><a class="toc-backref" href="#id83">New Syntax in the Referring (Inner) Scope</a></h2>
<p>There are three kinds of proposals in this category.</p>
<div class="section" id="outer-reference-expression">
<h3><a class="toc-backref" href="#id84">Outer Reference Expression</a></h3>
<p>This type of proposal suggests a new way of referring to a variable
in an outer scope when using the variable in an expression.  One
syntax that has been suggested for this is <tt class="docutils literal">.x</tt> <a class="footnote-reference" href="#id50" id="id10">[7]</a>, which would
refer to <tt class="docutils literal">x</tt> without creating a local binding for it.  A concern
with this proposal is that in many contexts <tt class="docutils literal">x</tt> and <tt class="docutils literal">.x</tt> could
be used interchangeably, which would confuse the reader.  A closely
related idea is to use multiple dots to specify the number of scope
levels to ascend <a class="footnote-reference" href="#id51" id="id11">[8]</a>, but most consider this too error-prone <a class="footnote-reference" href="#id60" id="id12">[17]</a>.</p>
</div>
<div class="section" id="rebinding-operator">
<h3><a class="toc-backref" href="#id85">Rebinding Operator</a></h3>
<p>This proposal suggests a new assignment-like operator that rebinds
a name without declaring the name to be local <a class="footnote-reference" href="#id45" id="id13">[2]</a>.  Whereas the
statement <tt class="docutils literal">x = 3</tt> both declares <tt class="docutils literal">x</tt> a local variable and binds
it to 3, the statement <tt class="docutils literal">x := 3</tt> would change the existing binding
of <tt class="docutils literal">x</tt> without declaring it local.</p>
<p>This is a simple solution, but according to <a class="reference external" href="/dev/peps/pep-3099">PEP 3099</a> it has been
rejected (perhaps because it would be too easy to miss or to confuse
with <tt class="docutils literal">=</tt>).</p>
</div>
<div class="section" id="id14">
<h3><a class="toc-backref" href="#id86">Scope Override Declaration</a></h3>
<p>The proposals in this category suggest a new kind of declaration
statement in the inner scope that prevents a name from becoming
local.  This statement would be similar in nature to the <tt class="docutils literal">global</tt>
statement, but instead of making the name refer to a binding in the
top module-level scope, it would make the name refer to the binding
in the nearest enclosing scope.</p>
<p>This approach is attractive due to its parallel with a familiar
Python construct, and because it retains context-independence for
function definitions.</p>
<p>This approach also has advantages from a security and debugging
perspective.  The resulting Python would not only match the
functionality of other nested-scope languages but would do so with a
syntax that is arguably even better for defensive programming.  In
most other languages, a declaration contracts the scope of an
existing name, so inadvertently omitting the declaration could yield
farther-reaching (i.e. more dangerous) effects than expected.  In
Python with this proposal, the extra effort of adding the declaration
is aligned with the increased risk of non-local effects (i.e. the
path of least resistance is the safer path).</p>
<p>Many spellings have been suggested for such a declaration:</p>
<ul class="simple">
<li><tt class="docutils literal">scoped x</tt> <a class="footnote-reference" href="#id44" id="id15">[1]</a></li>
<li><tt class="docutils literal">global x in f</tt> <a class="footnote-reference" href="#id46" id="id16">[3]</a> (explicitly specify which scope)</li>
<li><tt class="docutils literal">free x</tt> <a class="footnote-reference" href="#id48" id="id17">[5]</a></li>
<li><tt class="docutils literal">outer x</tt> <a class="footnote-reference" href="#id49" id="id18">[6]</a></li>
<li><tt class="docutils literal">use x</tt> <a class="footnote-reference" href="#id52" id="id19">[9]</a></li>
<li><tt class="docutils literal">global x</tt> <a class="footnote-reference" href="#id53" id="id20">[10]</a> (change the meaning of <tt class="docutils literal">global</tt>)</li>
<li><tt class="docutils literal">nonlocal x</tt> <a class="footnote-reference" href="#id54" id="id21">[11]</a></li>
<li><tt class="docutils literal">global x outer</tt> <a class="footnote-reference" href="#id61" id="id22">[18]</a></li>
<li><tt class="docutils literal">global in x</tt> <a class="footnote-reference" href="#id61" id="id23">[18]</a></li>
<li><tt class="docutils literal">not global x</tt> <a class="footnote-reference" href="#id61" id="id24">[18]</a></li>
<li><tt class="docutils literal">extern x</tt> <a class="footnote-reference" href="#id63" id="id25">[20]</a></li>
<li><tt class="docutils literal">ref x</tt> <a class="footnote-reference" href="#id65" id="id26">[22]</a></li>
<li><tt class="docutils literal">refer x</tt> <a class="footnote-reference" href="#id65" id="id27">[22]</a></li>
<li><tt class="docutils literal">share x</tt> <a class="footnote-reference" href="#id65" id="id28">[22]</a></li>
<li><tt class="docutils literal">sharing x</tt> <a class="footnote-reference" href="#id65" id="id29">[22]</a></li>
<li><tt class="docutils literal">common x</tt> <a class="footnote-reference" href="#id65" id="id30">[22]</a></li>
<li><tt class="docutils literal">using x</tt> <a class="footnote-reference" href="#id65" id="id31">[22]</a></li>
<li><tt class="docutils literal">borrow x</tt> <a class="footnote-reference" href="#id65" id="id32">[22]</a></li>
<li><tt class="docutils literal">reuse x</tt> <a class="footnote-reference" href="#id66" id="id33">[23]</a></li>
<li><tt class="docutils literal">scope f x</tt> <a class="footnote-reference" href="#id68" id="id34">[25]</a> (explicitly specify which scope)</li>
</ul>
<p>The most commonly discussed choices appear to be <tt class="docutils literal">outer</tt>,
<tt class="docutils literal">global</tt>, and <tt class="docutils literal">nonlocal</tt>.  <tt class="docutils literal">outer</tt> is already used as both a
variable name and an attribute name in the standard library.  The
word <tt class="docutils literal">global</tt> has a conflicting meaning, because &quot;global variable&quot;
is generally understood to mean a variable with top-level scope <a class="footnote-reference" href="#id70" id="id35">[27]</a>.
In C, the keyword <tt class="docutils literal">extern</tt> means that a name refers to a variable
in a different compilation unit.  While <tt class="docutils literal">nonlocal</tt> is a bit long
and less pleasant-sounding than some of the other options, it does
have precisely the correct meaning: it declares a name not local.</p>
</div>
</div>
</div>
<div class="section" id="proposed-solution">
<h1><a class="toc-backref" href="#id87">Proposed Solution</a></h1>
<p>The solution proposed by this PEP is to add a scope override
declaration in the referring (inner) scope.  Guido has expressed a
preference for this category of solution on Python-Dev <a class="footnote-reference" href="#id57" id="id36">[14]</a> and has
shown approval for <tt class="docutils literal">nonlocal</tt> as the keyword <a class="footnote-reference" href="#id62" id="id37">[19]</a>.</p>
<p>The proposed declaration:</p>
<pre class="literal-block">
nonlocal x
</pre>
<p>prevents <tt class="docutils literal">x</tt> from becoming a local name in the current scope.  All
occurrences of <tt class="docutils literal">x</tt> in the current scope will refer to the <tt class="docutils literal">x</tt>
bound in an outer enclosing scope.  As with <tt class="docutils literal">global</tt>, multiple
names are permitted:</p>
<pre class="literal-block">
nonlocal x, y, z
</pre>
<p>If there is no pre-existing binding in an enclosing scope, the
compiler raises a SyntaxError.  (It may be a bit of a stretch to
call this a syntax error, but so far SyntaxError is used for all
compile-time errors, including, for example, __future__ import
with an unknown feature name.)  Guido has said that this kind of
declaration in the absence of an outer binding should be considered
an error <a class="footnote-reference" href="#id59" id="id38">[16]</a>.</p>
<p>If a <tt class="docutils literal">nonlocal</tt> declaration collides with the name of a formal
parameter in the local scope, the compiler raises a SyntaxError.</p>
<p>A shorthand form is also permitted, in which <tt class="docutils literal">nonlocal</tt> is
prepended to an assignment or augmented assignment:</p>
<pre class="literal-block">
nonlocal x = 3
</pre>
<p>The above has exactly the same meaning as <tt class="docutils literal">nonlocal x; x = 3</tt>.
(Guido supports a similar form of the <tt class="docutils literal">global</tt> statement <a class="footnote-reference" href="#id67" id="id39">[24]</a>.)</p>
<p>On the left side of the shorthand form, only identifiers are allowed,
not target expressions like <tt class="docutils literal">x[0]</tt>.  Otherwise, all forms of
assignment are allowed.  The proposed grammar of the <tt class="docutils literal">nonlocal</tt>
statement is:</p>
<pre class="literal-block">
nonlocal_stmt ::=
    &quot;nonlocal&quot; identifier (&quot;,&quot; identifier)*
               [&quot;=&quot; (target_list &quot;=&quot;)+ expression_list]
  | &quot;nonlocal&quot; identifier augop expression_list
</pre>
<p>The rationale for allowing all these forms of assignment is that it
simplifies understanding of the <tt class="docutils literal">nonlocal</tt> statement.  Separating
the shorthand form into a declaration and an assignment is sufficient
to understand what it means and whether it is valid.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The shorthand syntax was not added in the original implementation
of the PEP. Later discussions <a class="footnote-reference" href="#id72" id="id40">[29]</a> <a class="footnote-reference" href="#id73" id="id41">[30]</a> concluded this syntax
should not be implemented.</p>
</div>
</div>
<div class="section" id="backward-compatibility">
<h1><a class="toc-backref" href="#id88">Backward Compatibility</a></h1>
<p>This PEP targets Python 3000, as suggested by Guido <a class="footnote-reference" href="#id62" id="id42">[19]</a>.  However,
others have noted that some options considered in this PEP may be
small enough changes to be feasible in Python 2.x <a class="footnote-reference" href="#id69" id="id43">[26]</a>, in which
case this PEP could possibly be moved to be a 2.x series PEP.</p>
<p>As a (very rough) measure of the impact of introducing a new keyword,
here is the number of times that some of the proposed keywords appear
as identifiers in the standard library, according to a scan of the
Python SVN repository on November 5, 2006:</p>
<pre class="literal-block">
nonlocal    0
use         2
using       3
reuse       4
free        8
outer     147
</pre>
<p><tt class="docutils literal">global</tt> appears 214 times as an existing keyword.  As a measure
of the impact of using <tt class="docutils literal">global</tt> as the outer-scope keyword, there
are 18 files in the standard library that would break as a result
of such a change (because a function declares a variable <tt class="docutils literal">global</tt>
before that variable has been introduced in the global scope):</p>
<pre class="literal-block">
cgi.py
dummy_thread.py
mhlib.py
mimetypes.py
idlelib/PyShell.py
idlelib/run.py
msilib/__init__.py
test/inspect_fodder.py
test/test_compiler.py
test/test_decimal.py
test/test_descr.py
test/test_dummy_threading.py
test/test_fileinput.py
test/test_global.py (not counted: this tests the keyword itself)
test/test_grammar.py (not counted: this tests the keyword itself)
test/test_itertools.py
test/test_multifile.py
test/test_scope.py (not counted: this tests the keyword itself)
test/test_threaded_import.py
test/test_threadsignals.py
test/test_warnings.py
</pre>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id89">References</a></h1>
<table class="docutils footnote" frame="void" id="id44" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id15">2</a>)</em> Scoping (was Re: Lambda binding solved?) (Rafael Bracho)
<a class="reference external" href="http://www.python.org/search/hypermail/python-1994q1/0301.html">http://www.python.org/search/hypermail/python-1994q1/0301.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id45" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id13">2</a>)</em> Extended Function syntax (Just van Rossum)
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2003-February/032764.html">https://mail.python.org/pipermail/python-dev/2003-February/032764.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id46" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[3]</a></td><td>Closure semantics (Guido van Rossum)
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2003-October/039214.html">https://mail.python.org/pipermail/python-dev/2003-October/039214.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id47" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td><em>(<a class="fn-backref" href="#id5">1</a>, <a class="fn-backref" href="#id6">2</a>)</em> Better Control of Nested Lexical Scopes (Almann T. Goo)
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2006-February/061568.html">https://mail.python.org/pipermail/python-dev/2006-February/061568.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id48" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[5]</a></td><td>PEP for Better Control of Nested Lexical Scopes (Jeremy Hylton)
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2006-February/061602.html">https://mail.python.org/pipermail/python-dev/2006-February/061602.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id49" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[6]</a></td><td>PEP for Better Control of Nested Lexical Scopes (Almann T. Goo)
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2006-February/061603.html">https://mail.python.org/pipermail/python-dev/2006-February/061603.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id50" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[7]</a></td><td>Using and binding relative names (Phillip J. Eby)
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2006-February/061636.html">https://mail.python.org/pipermail/python-dev/2006-February/061636.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id51" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[8]</a></td><td>Using and binding relative names (Steven Bethard)
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2006-February/061749.html">https://mail.python.org/pipermail/python-dev/2006-February/061749.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id52" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[9]</td><td><em>(<a class="fn-backref" href="#id7">1</a>, <a class="fn-backref" href="#id19">2</a>)</em> Lexical scoping in Python 3k (Ka-Ping Yee)
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2006-July/066862.html">https://mail.python.org/pipermail/python-dev/2006-July/066862.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id53" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id20">[10]</a></td><td>Lexical scoping in Python 3k (Greg Ewing)
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2006-July/066889.html">https://mail.python.org/pipermail/python-dev/2006-July/066889.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id54" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id21">[11]</a></td><td>Lexical scoping in Python 3k (Ka-Ping Yee)
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2006-July/066942.html">https://mail.python.org/pipermail/python-dev/2006-July/066942.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id55" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[12]</a></td><td>Lexical scoping in Python 3k (Guido van Rossum)
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2006-July/066950.html">https://mail.python.org/pipermail/python-dev/2006-July/066950.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id56" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[13]</a></td><td>Explicit Lexical Scoping (pre-PEP?) (Talin)
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2006-July/066978.html">https://mail.python.org/pipermail/python-dev/2006-July/066978.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id57" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id36">[14]</a></td><td>Explicit Lexical Scoping (pre-PEP?) (Guido van Rossum)
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2006-July/066991.html">https://mail.python.org/pipermail/python-dev/2006-July/066991.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id58" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[15]</td><td>Explicit Lexical Scoping (pre-PEP?) (Guido van Rossum)
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2006-July/066995.html">https://mail.python.org/pipermail/python-dev/2006-July/066995.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id59" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id38">[16]</a></td><td>Lexical scoping in Python 3k (Guido van Rossum)
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2006-July/066968.html">https://mail.python.org/pipermail/python-dev/2006-July/066968.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id60" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[17]</a></td><td>Explicit Lexical Scoping (pre-PEP?) (Guido van Rossum)
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2006-July/067004.html">https://mail.python.org/pipermail/python-dev/2006-July/067004.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id61" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[18]</td><td><em>(<a class="fn-backref" href="#id22">1</a>, <a class="fn-backref" href="#id23">2</a>, <a class="fn-backref" href="#id24">3</a>)</em> Explicit Lexical Scoping (pre-PEP?) (Andrew Clover)
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2006-July/067007.html">https://mail.python.org/pipermail/python-dev/2006-July/067007.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id62" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[19]</td><td><em>(<a class="fn-backref" href="#id37">1</a>, <a class="fn-backref" href="#id42">2</a>)</em> Explicit Lexical Scoping (pre-PEP?) (Guido van Rossum)
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2006-July/067067.html">https://mail.python.org/pipermail/python-dev/2006-July/067067.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id63" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id25">[20]</a></td><td>Explicit Lexical Scoping (pre-PEP?) (Matthew Barnes)
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2006-July/067221.html">https://mail.python.org/pipermail/python-dev/2006-July/067221.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id64" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[21]</a></td><td>Sky pie: a &quot;var&quot; keyword (a thread started by Neil Toronto)
<a class="reference external" href="https://mail.python.org/pipermail/python-3000/2006-October/003968.html">https://mail.python.org/pipermail/python-3000/2006-October/003968.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id65" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[22]</td><td><em>(<a class="fn-backref" href="#id26">1</a>, <a class="fn-backref" href="#id27">2</a>, <a class="fn-backref" href="#id28">3</a>, <a class="fn-backref" href="#id29">4</a>, <a class="fn-backref" href="#id30">5</a>, <a class="fn-backref" href="#id31">6</a>, <a class="fn-backref" href="#id32">7</a>)</em> Alternatives to 'outer' (Talin)
<a class="reference external" href="https://mail.python.org/pipermail/python-3000/2006-October/004021.html">https://mail.python.org/pipermail/python-3000/2006-October/004021.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id66" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id33">[23]</a></td><td>Alternatives to 'outer' (Jim Jewett)
<a class="reference external" href="https://mail.python.org/pipermail/python-3000/2006-November/004153.html">https://mail.python.org/pipermail/python-3000/2006-November/004153.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id67" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id39">[24]</a></td><td>Draft PEP for outer scopes (Guido van Rossum)
<a class="reference external" href="https://mail.python.org/pipermail/python-3000/2006-November/004166.html">https://mail.python.org/pipermail/python-3000/2006-November/004166.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id68" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id34">[25]</a></td><td>Draft PEP for outer scopes (Talin)
<a class="reference external" href="https://mail.python.org/pipermail/python-3000/2006-November/004190.html">https://mail.python.org/pipermail/python-3000/2006-November/004190.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id69" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id43">[26]</a></td><td>Draft PEP for outer scopes (Nick Coghlan)
<a class="reference external" href="https://mail.python.org/pipermail/python-3000/2006-November/004237.html">https://mail.python.org/pipermail/python-3000/2006-November/004237.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id70" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id35">[27]</a></td><td>Global variable (version 2006-11-01T01:23:16)
<a class="reference external" href="http://en.wikipedia.org/wiki/Global_variable">http://en.wikipedia.org/wiki/Global_variable</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id71" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[28]</a></td><td>Ruby 2.0 block local variable
<a class="reference external" href="http://redhanded.hobix.com/inspect/ruby20BlockLocalVariable.html">http://redhanded.hobix.com/inspect/ruby20BlockLocalVariable.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id72" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id40">[29]</a></td><td>Issue 4199: combining assignment with global &amp; nonlocal (Guido van Rossum)
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2013-June/127142.html">https://mail.python.org/pipermail/python-dev/2013-June/127142.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id73" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id41">[30]</a></td><td>Whatever happened to 'nonlocal x = y'? (Guido van Rossum)
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2018-January/151627.html">https://mail.python.org/pipermail/python-dev/2018-January/151627.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="acknowledgements">
<h1><a class="toc-backref" href="#id90">Acknowledgements</a></h1>
<p>The ideas and proposals mentioned in this PEP are gleaned from
countless Python-Dev postings.  Thanks to Jim Jewett, Mike Orr,
Jason Orendorff, and Christian Tanzer for suggesting specific
edits to this PEP.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id91">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

