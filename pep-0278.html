<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">278</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Universal Newline Support</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0278.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">jack&#32;&#97;t&#32;cwi.nl (Jack Jansen)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">14-Jan-2002</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.3</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id1">Abstract</a></li>
<li><a class="reference internal" href="#specification" id="id2">Specification</a></li>
<li><a class="reference internal" href="#rationale" id="id3">Rationale</a></li>
<li><a class="reference internal" href="#reference-implementation" id="id4">Reference Implementation</a></li>
<li><a class="reference internal" href="#references" id="id5">References</a></li>
<li><a class="reference internal" href="#copyright" id="id6">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id1">Abstract</a></h1>
<p>This PEP discusses a way in which Python can support I/O on files
which have a newline format that is not the native format on the
platform, so that Python on each platform can read and import
files with CR (Macintosh), LF (Unix) or CR LF (Windows) line
endings.</p>
<p>It is more and more common to come across files that have an end
of line that does not match the standard on the current platform:
files downloaded over the net, remotely mounted filesystems on a
different platform, Mac OS X with its double standard of Mac and
Unix line endings, etc.</p>
<p>Many tools such as editors and compilers already handle this
gracefully, it would be good if Python did so too.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id2">Specification</a></h1>
<p>Universal newline support is enabled by default,
but can be disabled during the configure of Python.</p>
<p>In a Python with universal newline support the feature is
automatically enabled for all import statements and <tt class="docutils literal">execfile()</tt>
calls. There is no special support for <tt class="docutils literal">eval()</tt> or exec.</p>
<p>In a Python with universal newline support <tt class="docutils literal">open()</tt> the mode
parameter can also be &quot;U&quot;, meaning &quot;open for input as a text file
with universal newline interpretation&quot;.  Mode &quot;rU&quot; is also allowed,
for symmetry with &quot;rb&quot;. Mode &quot;U&quot; cannot be
combined with other mode flags such as &quot;+&quot;. Any line ending in the
input file will be seen as a <tt class="docutils literal">'\n'</tt> in Python, so little other code has
to change to handle universal newlines.</p>
<p>Conversion of newlines happens in all calls that read data: <tt class="docutils literal">read()</tt>,
<tt class="docutils literal">readline()</tt>, <tt class="docutils literal">readlines()</tt>, etc.</p>
<p>There is no special support for output to file with a different
newline convention, and so mode &quot;wU&quot; is also illegal.</p>
<p>A file object that has been opened in universal newline mode gets
a new attribute &quot;newlines&quot; which reflects the newline convention
used in the file.  The value for this attribute is one of None (no
newline read yet), <tt class="docutils literal">&quot;\r&quot;</tt>, <tt class="docutils literal">&quot;\n&quot;</tt>, <tt class="docutils literal">&quot;\r\n&quot;</tt> or a tuple containing all the
newline types seen.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id3">Rationale</a></h1>
<p>Universal newline support is implemented in C, not in Python.
This is done because we want files with a foreign newline
convention to be import-able, so a Python Lib directory can be
shared over a remote file system connection, or between MacPython
and Unix-Python on Mac OS X.  For this to be feasible the
universal newline convention needs to have a reasonably small
impact on performance, which means a Python implementation is not
an option as it would bog down all imports. And because of files
with multiple newline conventions, which Visual C++ and other
Windows tools will happily produce, doing a quick check for the
newlines used in a file (handing off the import to C code if a
platform-local newline is seen) will not work.  Finally, a C
implementation also allows tracebacks and such (which open the
Python source module) to be handled easily.</p>
<p>There is no output implementation of universal newlines, Python
programs are expected to handle this by themselves or write files
with platform-local convention otherwise.  The reason for this is
that input is the difficult case, outputting different newlines to
a file is already easy enough in Python.</p>
<p>Also, an output implementation would be much more difficult than an
input implementation, surprisingly: a lot of output is done through
<tt class="docutils literal">PyXXX_Print()</tt> methods, and at this point the file object is not
available anymore, only a <tt class="docutils literal">FILE *</tt>. So, an output implementation would
need to somehow go from the <tt class="docutils literal">FILE*</tt> to the file object, because that
is where the current newline delimiter is stored.</p>
<p>The input implementation has no such problem: there are no cases in
the Python source tree where files are partially read from C,
partially from Python, and such cases are expected to be rare in
extension modules. If such cases exist the only problem is that the
newlines attribute of the file object is not updated during the
<tt class="docutils literal">fread()</tt> or <tt class="docutils literal">fgets()</tt> calls that are done direct from C.</p>
<p>A partial output implementation, where strings passed to <tt class="docutils literal">fp.write()</tt>
would be converted to use <tt class="docutils literal">fp.newlines</tt> as their line terminator but
all other output would not is far too surprising, in my view.</p>
<p>Because there is no output support for universal newlines there is
also no support for a mode &quot;rU+&quot;: the surprise factor of the
previous paragraph would hold to an even stronger degree.</p>
<p>There is no support for universal newlines in strings passed to
<tt class="docutils literal">eval()</tt> or <tt class="docutils literal">exec</tt>. It is envisioned that such strings always have the
standard <tt class="docutils literal">\n</tt> line feed, if the strings come from a file that file can
be read with universal newlines.</p>
<p>I think there are no special issues with unicode. utf-16 shouldn't
pose any new problems, as such files need to be opened in binary
mode anyway. Interaction with utf-8 is fine too: values 0x0a and 0x0d
cannot occur as part of a multibyte sequence.</p>
<p>Universal newline files should work fine with iterators and
<tt class="docutils literal">xreadlines()</tt> as these eventually call the normal file
readline/readlines methods.</p>
<p>While universal newlines are automatically enabled for import they
are not for opening, where you have to specifically say <tt class="docutils literal"><span class="pre">open(...,</span>
&quot;U&quot;)</tt>. This is open to debate, but here are a few reasons for this
design:</p>
<ul class="simple">
<li>Compatibility.  Programs which already do their own
interpretation of <tt class="docutils literal">\r\n</tt> in text files would break. Examples of such
programs would be editors which warn you when you open a file with
a different newline convention. If universal newlines was made the
default such an editor would silently convert your line endings to
the local convention on save. Programs which open binary files as
text files on Unix would also break (but it could be argued they
deserve it :-).</li>
<li>Interface clarity.  Universal newlines are only supported for
input files, not for input/output files, as the semantics would
become muddy.  Would you write Mac newlines if all reads so far
had encountered Mac newlines?  But what if you then later read a
Unix newline?</li>
</ul>
<p>The <tt class="docutils literal">newlines</tt> attribute is included so that programs that really
care about the newline convention, such as text editors, can
examine what was in a file.  They can then save (a copy of) the
file with the same newline convention (or, in case of a file with
mixed newlines, ask the user what to do, or output in platform
convention).</p>
<p>Feedback is explicitly solicited on one item in the reference
implementation: whether or not the universal newlines routines
should grab the global interpreter lock.  Currently they do not,
but this could be considered living dangerously, as they may
modify fields in a <tt class="docutils literal">FileObject</tt>.  But as these routines are
replacements for <tt class="docutils literal">fgets()</tt> and <tt class="docutils literal">fread()</tt> as well it may be difficult
to decide whether or not the lock is held when the routine is
called.  Moreover, the only danger is that if two threads read the
same <tt class="docutils literal">FileObject</tt> at the same time an extraneous newline may be seen
or the <tt class="docutils literal">newlines</tt> attribute may inadvertently be set to mixed.  I
would argue that if you read the same <tt class="docutils literal">FileObject</tt> in two threads
simultaneously you are asking for trouble anyway.</p>
<p>Note that no globally accessible pointers are manipulated in the
<tt class="docutils literal">fgets()</tt> or <tt class="docutils literal">fread()</tt> replacement routines, just some integer-valued
flags, so the chances of core dumps are zero (he said:-).</p>
<p>Universal newline support can be disabled during configure because it does
have a small performance penalty, and moreover the implementation has
not been tested on all conceivable platforms yet. It might also be silly
on some platforms (WinCE or Palm devices, for instance). If universal
newline support is not enabled then file objects do not have the <tt class="docutils literal">newlines</tt>
attribute, so testing whether the current Python has it can be done with a
simple:</p>
<pre class="literal-block">
if hasattr(open, 'newlines'):
   print 'We have universal newline support'
</pre>
<p>Note that this test uses the <tt class="docutils literal">open()</tt> function rather than the <tt class="docutils literal">file</tt>
type so that it won't fail for versions of Python where the <tt class="docutils literal">file</tt>
type was not available (the <tt class="docutils literal">file</tt> type was added to the built-in
namespace in the same release as the universal newline feature was
added).</p>
<p>Additionally, note that this test fails again on Python versions
&gt;= 2.5, when <tt class="docutils literal">open()</tt> was made a function again and is not synonymous
with the <tt class="docutils literal">file</tt> type anymore.</p>
</div>
<div class="section" id="reference-implementation">
<h1><a class="toc-backref" href="#id4">Reference Implementation</a></h1>
<p>A reference implementation is available in SourceForge patch
#476814: <a class="reference external" href="http://www.python.org/sf/476814">http://www.python.org/sf/476814</a></p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id5">References</a></h1>
<p>None.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id6">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
fill-column: 70
End: -->
</div>

