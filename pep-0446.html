<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">446</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Make newly created file descriptors non-inheritable</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0446.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Victor Stinner &lt;victor.stinner&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">5-August-2013</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.4</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id3">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id4">Rationale</a><ul>
<li><a class="reference internal" href="#inheritance-of-file-descriptors" id="id5">Inheritance of File Descriptors</a></li>
<li><a class="reference internal" href="#inheritance-of-file-descriptors-on-windows" id="id6">Inheritance of File Descriptors on Windows</a></li>
<li><a class="reference internal" href="#only-inherit-some-handles-on-windows" id="id7">Only Inherit Some Handles on Windows</a></li>
<li><a class="reference internal" href="#inheritance-of-file-descriptors-on-unix" id="id8">Inheritance of File Descriptors on UNIX</a></li>
<li><a class="reference internal" href="#issues-with-inheritable-file-descriptors" id="id9">Issues with Inheritable File Descriptors</a></li>
<li><a class="reference internal" href="#security-vulnerability" id="id10">Security Vulnerability</a></li>
<li><a class="reference internal" href="#issues-fixed-in-the-subprocess-module" id="id11">Issues fixed in the subprocess module</a></li>
<li><a class="reference internal" href="#atomic-creation-of-non-inheritable-file-descriptors" id="id12">Atomic Creation of non-inheritable File Descriptors</a></li>
<li><a class="reference internal" href="#status-of-python-3-3" id="id13">Status of Python 3.3</a></li>
<li><a class="reference internal" href="#closing-all-open-file-descriptors" id="id14">Closing All Open File Descriptors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#proposal" id="id15">Proposal</a><ul>
<li><a class="reference internal" href="#non-inheritable-file-descriptors" id="id16">Non-inheritable File Descriptors</a></li>
<li><a class="reference internal" href="#new-functions-and-methods" id="id17">New Functions And Methods</a></li>
<li><a class="reference internal" href="#other-changes" id="id18">Other Changes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backward-compatibility" id="id19">Backward Compatibility</a></li>
<li><a class="reference internal" href="#related-work" id="id20">Related Work</a></li>
<li><a class="reference internal" href="#rejected-alternatives" id="id21">Rejected Alternatives</a><ul>
<li><a class="reference internal" href="#add-a-new-open-noinherit-function" id="id22">Add a new open_noinherit() function</a></li>
<li><a class="reference internal" href="#pep-433" id="id23">PEP 433</a></li>
</ul>
</li>
<li><a class="reference internal" href="#python-issues" id="id24">Python Issues</a></li>
<li><a class="reference internal" href="#copyright" id="id25">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id3">Abstract</a></h1>
<p>Leaking file descriptors in child processes causes various annoying
issues and is a known major security vulnerability. Using the
<tt class="docutils literal">subprocess</tt> module with the <em>close_fds</em> parameter set to <tt class="docutils literal">True</tt> is
not possible in all cases.</p>
<p>This PEP proposes to make all file descriptors created by Python
non-inheritable by default to reduce the risk of these issues. This PEP
fixes also a race condition in multi-threaded applications on operating
systems supporting atomic flags to create non-inheritable file
descriptors.</p>
<p>We are aware of the code breakage this is likely to cause, and doing it
anyway for the good of mankind. (Details in the section &quot;Backward
Compatibility&quot; below.)</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id4">Rationale</a></h1>
<div class="section" id="inheritance-of-file-descriptors">
<h2><a class="toc-backref" href="#id5">Inheritance of File Descriptors</a></h2>
<p>Each operating system handles the inheritance of file descriptors
differently. Windows creates non-inheritable handles by default, whereas
UNIX and the POSIX API on Windows create inheritable file descriptors by
default. Python prefers the POSIX API over the native Windows API, to
have a single code base and to use the same type for file descriptors,
and so it creates inheritable file descriptors.</p>
<p>There is one exception: <tt class="docutils literal">os.pipe()</tt> creates non-inheritable pipes on
Windows, whereas it creates inheritable pipes on UNIX. The reason is an
implementation artifact: <tt class="docutils literal">os.pipe()</tt> calls <tt class="docutils literal">CreatePipe()</tt> on Windows
(native API), whereas it calls <tt class="docutils literal">pipe()</tt> on UNIX (POSIX API). The call
to <tt class="docutils literal">CreatePipe()</tt> was added in Python in 1994, before the introduction
of <tt class="docutils literal">pipe()</tt> in the POSIX API in Windows 98. The <a class="reference external" href="http://bugs.python.org/issue4708">issue #4708</a> proposes to change <tt class="docutils literal">os.pipe()</tt> on
Windows to create inheritable pipes.</p>
</div>
<div class="section" id="inheritance-of-file-descriptors-on-windows">
<h2><a class="toc-backref" href="#id6">Inheritance of File Descriptors on Windows</a></h2>
<p>On Windows, the native type of file objects is handles (C type
<tt class="docutils literal">HANDLE</tt>). These handles have a <tt class="docutils literal">HANDLE_FLAG_INHERIT</tt> flag which
defines if a handle can be inherited in a child process or not. For the
POSIX API, the C runtime (CRT) also provides file descriptors (C type
<tt class="docutils literal">int</tt>). The handle of a file descriptor can be retrieve using the
function <tt class="docutils literal">_get_osfhandle(fd)</tt>. A file descriptor can be created from a
handle using the function <tt class="docutils literal">_open_osfhandle(handle)</tt>.</p>
<p>Using <a class="reference external" href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms682425%28v=vs.85%29.aspx">CreateProcess()</a>,
handles are only inherited if their inheritable flag
(<tt class="docutils literal">HANDLE_FLAG_INHERIT</tt>) is set <strong>and</strong> the <tt class="docutils literal">bInheritHandles</tt>
parameter of <tt class="docutils literal">CreateProcess()</tt> is <tt class="docutils literal">TRUE</tt>; all file descriptors
except standard streams (0, 1, 2) are closed in the child process, even
if <tt class="docutils literal">bInheritHandles</tt> is <tt class="docutils literal">TRUE</tt>. Using the <tt class="docutils literal">spawnv()</tt> function, all
inheritable handles and all inheritable file descriptors are inherited
in the child process. This function uses the undocumented fields
<em>cbReserved2</em> and <em>lpReserved2</em> of the <a class="reference external" href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms686331%28v=vs.85%29.aspx">STARTUPINFO</a>
structure to pass an array of file descriptors.</p>
<p>To replace standard streams (stdin, stdout, stderr) using
<tt class="docutils literal">CreateProcess()</tt>, the <tt class="docutils literal">STARTF_USESTDHANDLES</tt> flag must be set in
the <em>dwFlags</em> field of the <tt class="docutils literal">STARTUPINFO</tt> structure and the
<em>bInheritHandles</em> parameter of <tt class="docutils literal">CreateProcess()</tt> must be set to
<tt class="docutils literal">TRUE</tt>. So when at least one standard stream is replaced, all
inheritable handles are inherited by the child process.</p>
<p>The default value of the <em>close_fds</em> parameter of <tt class="docutils literal">subprocess</tt> process
is <tt class="docutils literal">True</tt> (<tt class="docutils literal">bInheritHandles=FALSE</tt>) if <em>stdin</em>, <em>stdout</em> and
<em>stderr</em> parameters are <tt class="docutils literal">None</tt>, <tt class="docutils literal">False</tt> (<tt class="docutils literal">bInheritHandles=TRUE</tt>)
otherwise.</p>
<p>See also:</p>
<ul class="simple">
<li><a class="reference external" href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms724466%28v=vs.85%29.aspx">Handle Inheritance</a></li>
<li><a class="reference external" href="http://stackoverflow.com/questions/12058911/can-tcp-socket-handles-be-set-not-inheritable">Stackoverflow: Can TCP SOCKET handles be set not inheritable?</a></li>
</ul>
</div>
<div class="section" id="only-inherit-some-handles-on-windows">
<h2><a class="toc-backref" href="#id7">Only Inherit Some Handles on Windows</a></h2>
<p>Since Windows Vista, <tt class="docutils literal">CreateProcess()</tt> supports an extension of the
STARTUPINFO structure: the <a class="reference external" href="http://msdn.microsoft.com/en-us/library/ms686329%28v=vs.85%29.aspx">STARTUPINFOEX structure</a>.
Using this new structure, it is possible to specify a list of handles to
inherit: <tt class="docutils literal">PROC_THREAD_ATTRIBUTE_HANDLE_LIST</tt>. Read <a class="reference external" href="http://blogs.msdn.com/b/oldnewthing/archive/2011/12/16/10248328.aspx">Programmatically
controlling which handles are inherited by new processes in Win32</a>
(Raymond Chen, Dec 2011) for more information.</p>
<p>Before Windows Vista, it is possible to make handles inheritable and
call <tt class="docutils literal">CreateProcess()</tt> with <tt class="docutils literal">bInheritHandles=TRUE</tt>. This option
works if all other handles are non-inheritable. There is a race
condition: if another thread calls <tt class="docutils literal">CreateProcess()</tt> with
<tt class="docutils literal">bInheritHandles=TRUE</tt>, handles will also be inherited in the second
process.</p>
<p>Microsoft suggests to use a lock to avoid the race condition: read
<a class="reference external" href="http://support.microsoft.com/kb/315939/en-us">Q315939: PRB: Child Inherits Unintended Handles During CreateProcess
Call</a> (last review:
November 2006). The <a class="reference external" href="http://bugs.python.org/issue16500">Python issue #16500 &quot;Add an atfork module&quot;</a> proposes to add such lock, it can
be used to make handles non-inheritable without the race condition. Such
lock only protects against a race condition between Python threads; C
threads are not protected.</p>
<p>Another option is to duplicate handles that must be inherited, passing the
values of the duplicated handles to the child process, so the child
process can steal duplicated handles using <a class="reference external" href="http://msdn.microsoft.com/en-us/library/windows/apps/ms724251%28v=vs.85%29.aspx">DuplicateHandle()</a>
with <tt class="docutils literal">DUPLICATE_CLOSE_SOURCE</tt>. Handle values change between the
parent and the child process because the handles are duplicated (twice);
the parent and/or the child process must be adapted to handle this
change. If the child program cannot be modified, an intermediate program
can be used to steal handles from the parent process before spawning the
final child program. The intermediate program has to pass the handle from the
child process to the parent process. The parent may have to close
duplicated handles if all handles were not stolen, for example if the
intermediate process fails. If the command line is used to pass the
handle values, the command line must be modified when handles are
duplicated, because their values are modified.</p>
<p>This PEP does not include a solution to this problem because there is no
perfect solution working on all Windows versions. This point is deferred
until use cases relying on handle or file descriptor inheritance on
Windows are well known, so we can choose the best solution and carefully
test its implementation.</p>
</div>
<div class="section" id="inheritance-of-file-descriptors-on-unix">
<h2><a class="toc-backref" href="#id8">Inheritance of File Descriptors on UNIX</a></h2>
<p>POSIX provides a <em>close-on-exec</em> flag on file descriptors to automatically
close a file descriptor when the C function <tt class="docutils literal">execv()</tt> is
called. File descriptors with the <em>close-on-exec</em> flag cleared are
inherited in the child process, file descriptors with the flag set are
closed in the child process.</p>
<p>The flag can be set in two syscalls (one to get current flags, a second
to set new flags) using <tt class="docutils literal">fcntl()</tt>:</p>
<pre class="literal-block">
int flags, res;
flags = fcntl(fd, F_GETFD);
if (flags == -1) { /* handle the error */ }
flags |= FD_CLOEXEC;
/* or &quot;flags &amp;= ~FD_CLOEXEC;&quot; to clear the flag */
res = fcntl(fd, F_SETFD, flags);
if (res == -1) { /* handle the error */ }
</pre>
<p>FreeBSD, Linux, Mac OS X, NetBSD, OpenBSD and QNX also support setting
the flag in a single syscall using ioctl():</p>
<pre class="literal-block">
int res;
res = ioctl(fd, FIOCLEX, 0);
if (!res) { /* handle the error */ }
</pre>
<p>NOTE: The <em>close-on-exec</em> flag has no effect on <tt class="docutils literal">fork()</tt>: all file
descriptors are inherited by the child process. The <a class="reference external" href="http://bugs.python.org/issue16500">Python issue #16500
&quot;Add an atfork module&quot;</a> proposes to
add a new <tt class="docutils literal">atfork</tt> module to execute code at fork, which may be used to
automatically close file descriptors.</p>
</div>
<div class="section" id="issues-with-inheritable-file-descriptors">
<h2><a class="toc-backref" href="#id9">Issues with Inheritable File Descriptors</a></h2>
<p>Most of the time, inheritable file descriptors &quot;leaked&quot; to child
processes are not noticed, because they don't cause major bugs. It does
not mean that these bugs must not be fixed.</p>
<p>Two common issues with inherited file descriptors:</p>
<ul class="simple">
<li>On Windows, a directory cannot be removed before all file handles open
in the directory are closed. The same issue can be seen with files,
except if the file was created with the <tt class="docutils literal">FILE_SHARE_DELETE</tt> flag
(<tt class="docutils literal">O_TEMPORARY</tt> mode for <tt class="docutils literal">open()</tt>).</li>
<li>If a listening socket is leaked to a child process, the socket address
cannot be reused before the parent and child processes terminated. For
example, if a web server spawns a new program to handle a process, and
the server restarts while the program is not done, the server cannot
start because the TCP port is still in use.</li>
</ul>
<p>Example of issues in open source projects:</p>
<ul class="simple">
<li><a class="reference external" href="https://bugzilla.mozilla.org/show_bug.cgi?id=147659">Mozilla (Firefox)</a>:
open since 2002-05</li>
<li><a class="reference external" href="https://bugs.freedesktop.org/show_bug.cgi?id=15947">dbus library</a>:
fixed in 2008-05 (<a class="reference external" href="http://cgit.freedesktop.org/dbus/dbus/commit/?id=e2bc7232069b14b7299cb8b2eab436f60a232007">dbus commit</a>),
close file descriptors in the child process</li>
<li><a class="reference external" href="https://bugzilla.redhat.com/show_bug.cgi?id=390591">autofs</a>:
fixed in 2009-02, set the CLOEXEC flag</li>
<li><a class="reference external" href="https://bugzilla.redhat.com/show_bug.cgi?id=528134">qemu</a>:
fixed in 2009-12 (<a class="reference external" href="http://git.qemu.org/?p=qemu.git;a=commit;h=40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4">qemu commit</a>),
set CLOEXEC flag</li>
<li><a class="reference external" href="https://trac.torproject.org/projects/tor/ticket/2029">Tor</a>:
fixed in 2010-12, set CLOEXEC flag</li>
<li><a class="reference external" href="http://caml.inria.fr/mantis/view.php?id=5256">OCaml</a>: open since
2011-04, &quot;PR#5256: Processes opened using Unix.open_process* inherit
all opened file descriptors (including sockets)&quot;</li>
<li><a class="reference external" href="https://zeromq.jira.com/browse/LIBZMQ-408">ØMQ</a>:
open since 2012-08</li>
<li><a class="reference external" href="https://bugzilla.redhat.com/show_bug.cgi?id=837033">Squid</a>:
open since 2012-07</li>
</ul>
<p>See also: <a class="reference external" href="http://danwalsh.livejournal.com/53603.html">Excuse me son, but your code is leaking !!!</a> (Dan Walsh, March 2012)
for SELinux issues with leaked file descriptors.</p>
</div>
<div class="section" id="security-vulnerability">
<h2><a class="toc-backref" href="#id10">Security Vulnerability</a></h2>
<p>Leaking sensitive file handles and file descriptors can lead to security
vulnerabilities. An untrusted child process might read sensitive data like
passwords or take control of the parent process though a leaked file
descriptor. With a leaked listening socket, a child process can accept
new connections to read sensitive data.</p>
<p>Example of vulnerabilities:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.securityfocus.com/archive/1/348368">Hijacking Apache https by mod_php</a> (2003)<ul>
<li>Apache: <a class="reference external" href="https://issues.apache.org/bugzilla/show_bug.cgi?id=46425">Apr should set FD_CLOEXEC if APR_FOPEN_NOCLEANUP is not set</a>:
fixed in 2009</li>
<li>PHP: <a class="reference external" href="https://bugs.php.net/bug.php?id=38915">system() (and similar) don't cleanup opened handles of Apache</a>: open since 2006</li>
</ul>
</li>
<li><a class="reference external" href="http://cwe.mitre.org/data/definitions/403.html">CWE-403: Exposure of File Descriptor to Unintended Control Sphere</a> (2008)</li>
<li><a class="reference external" href="http://www.openssh.com/txt/portable-keysign-rand-helper.adv">OpenSSH Security Advisory: portable-keysign-rand-helper.adv</a>
(2011)</li>
</ul>
<p>Read also the CERT Secure Coding Standards:
<a class="reference external" href="https://www.securecoding.cert.org/confluence/display/seccode/FIO42-C.+Ensure+files+are+properly+closed+when+they+are+no+longer+needed">FIO42-C. Ensure files are properly closed when they are no longer
needed</a>.</p>
</div>
<div class="section" id="issues-fixed-in-the-subprocess-module">
<h2><a class="toc-backref" href="#id11">Issues fixed in the subprocess module</a></h2>
<p>Inherited file descriptors caused 4 issues in the <tt class="docutils literal">subprocess</tt>
module:</p>
<ul class="simple">
<li><a class="reference external" href="http://bugs.python.org/issue2320">Issue #2320: Race condition in subprocess using stdin</a> (opened in 2008)</li>
<li><a class="reference external" href="http://bugs.python.org/issue3006">Issue #3006: subprocess.Popen causes socket to remain open after
close</a> (opened in 2008)</li>
<li><a class="reference external" href="http://bugs.python.org/issue7213">Issue #7213: subprocess leaks open file descriptors between Popen
instances causing hangs</a>
(opened in 2009)</li>
<li><a class="reference external" href="http://bugs.python.org/issue12786">Issue #12786: subprocess wait() hangs when stdin is closed</a> (opened in 2011)</li>
</ul>
<p>These issues were fixed in Python 3.2 by 4 different changes in the
<tt class="docutils literal">subprocess</tt> module:</p>
<ul class="simple">
<li>Pipes are now non-inheritable;</li>
<li>The default value of the <em>close_fds</em> parameter is now <tt class="docutils literal">True</tt>,
with one exception on Windows: the default value is <tt class="docutils literal">False</tt> if
at least one standard stream is replaced;</li>
<li>A new <em>pass_fds</em> parameter has been added;</li>
<li>Creation of a <tt class="docutils literal">_posixsubprocess</tt> module implemented in C.</li>
</ul>
</div>
<div class="section" id="atomic-creation-of-non-inheritable-file-descriptors">
<h2><a class="toc-backref" href="#id12">Atomic Creation of non-inheritable File Descriptors</a></h2>
<p>In a multi-threaded application, an inheritable file descriptor may be
created just before a new program is spawned, before the file descriptor
is made non-inheritable. In this case, the file descriptor is leaked to
the child process. This race condition could be avoided if the file
descriptor is created directly non-inheritable.</p>
<p>FreeBSD, Linux, Mac OS X, Windows and many other operating systems
support creating non-inheritable file descriptors with the inheritable
flag cleared atomically at the creation of the file descriptor.</p>
<p>A new <tt class="docutils literal">WSA_FLAG_NO_HANDLE_INHERIT</tt> flag for <tt class="docutils literal">WSASocket()</tt> was added
in Windows 7 SP1 and Windows Server 2008 R2 SP1 to create
non-inheritable sockets. If this flag is used on an older Windows
version (ex: Windows XP SP3), <tt class="docutils literal">WSASocket()</tt> fails with
<tt class="docutils literal">WSAEPROTOTYPE</tt>.</p>
<p>On UNIX, new flags were added for files and sockets:</p>
<ul class="simple">
<li><tt class="docutils literal">O_CLOEXEC</tt>: available on Linux (2.6.23), FreeBSD (8.3),
Mac OS 10.8, OpenBSD 5.0, Solaris 11, QNX, BeOS, next NetBSD release
(6.1?). This flag is part of POSIX.1-2008.</li>
<li><tt class="docutils literal">SOCK_CLOEXEC</tt> flag for <tt class="docutils literal">socket()</tt> and <tt class="docutils literal">socketpair()</tt>,
available on Linux 2.6.27, OpenBSD 5.2, NetBSD 6.0.</li>
<li><tt class="docutils literal">fcntl()</tt>: <tt class="docutils literal">F_DUPFD_CLOEXEC</tt> flag, available on Linux 2.6.24,
OpenBSD 5.0, FreeBSD 9.1, NetBSD 6.0, Solaris 11. This flag is part
of POSIX.1-2008.</li>
<li><tt class="docutils literal">fcntl()</tt>: <tt class="docutils literal">F_DUP2FD_CLOEXEC</tt> flag, available on FreeBSD 9.1
and Solaris 11.</li>
<li><tt class="docutils literal">recvmsg()</tt>: <tt class="docutils literal">MSG_CMSG_CLOEXEC</tt>, available on Linux 2.6.23,
NetBSD 6.0.</li>
</ul>
<p>On Linux older than 2.6.23, <tt class="docutils literal">O_CLOEXEC</tt> flag is simply ignored. So
<tt class="docutils literal">fcntl()</tt> must be called to check if the file descriptor is
non-inheritable: <tt class="docutils literal">O_CLOEXEC</tt> is not supported if the <tt class="docutils literal">FD_CLOEXEC</tt>
flag is missing. On Linux older than 2.6.27, <tt class="docutils literal">socket()</tt> or
<tt class="docutils literal">socketpair()</tt> fail with <tt class="docutils literal">errno</tt> set to <tt class="docutils literal">EINVAL</tt> if the
<tt class="docutils literal">SOCK_CLOEXEC</tt> flag is set in the socket type.</p>
<p>New functions:</p>
<ul class="simple">
<li><tt class="docutils literal">dup3()</tt>: available on Linux 2.6.27 (and glibc 2.9)</li>
<li><tt class="docutils literal">pipe2()</tt>: available on Linux 2.6.27 (and glibc 2.9)</li>
<li><tt class="docutils literal">accept4()</tt>: available on Linux 2.6.28 (and glibc 2.10)</li>
</ul>
<p>On Linux older than 2.6.28, <tt class="docutils literal">accept4()</tt> fails with <tt class="docutils literal">errno</tt> set to
<tt class="docutils literal">ENOSYS</tt>.</p>
<p>Summary:</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="20%" />
<col width="48%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Operating System</th>
<th class="head">Atomic File</th>
<th class="head">Atomic Socket</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>FreeBSD</td>
<td>8.3 (2012)</td>
<td>X</td>
</tr>
<tr><td>Linux</td>
<td>2.6.23 (2007)</td>
<td>2.6.27 (2008)</td>
</tr>
<tr><td>Mac OS X</td>
<td>10.8 (2012)</td>
<td>X</td>
</tr>
<tr><td>NetBSD</td>
<td>6.1 (?)</td>
<td>6.0 (2012)</td>
</tr>
<tr><td>OpenBSD</td>
<td>5.0 (2011)</td>
<td>5.2 (2012)</td>
</tr>
<tr><td>Solaris</td>
<td>11 (2011)</td>
<td>X</td>
</tr>
<tr><td>Windows</td>
<td>XP (2001)</td>
<td>Seven SP1 (2011), 2008 R2 SP1 (2011)</td>
</tr>
</tbody>
</table>
<p>Legend:</p>
<ul class="simple">
<li>&quot;Atomic File&quot;: first version of the operating system supporting
creating atomically a non-inheritable file descriptor using
<tt class="docutils literal">open()</tt></li>
<li>&quot;Atomic Socket&quot;: first version of the operating system supporting
creating atomically a non-inheritable socket</li>
<li>&quot;X&quot;: not supported yet</li>
</ul>
<p>See also:</p>
<ul class="simple">
<li><a class="reference external" href="http://udrepper.livejournal.com/20407.html">Secure File Descriptor Handling</a> (Ulrich Drepper,
2008)</li>
<li><a class="reference external" href="http://lwn.net/Articles/412131/">Ghosts of Unix past, part 2: Conflated designs</a> (Neil Brown, 2010) explains the
history of <tt class="docutils literal">O_CLOEXEC</tt> and <tt class="docutils literal">O_NONBLOCK</tt> flags</li>
<li><a class="reference external" href="http://lwn.net/Articles/292843/">File descriptor handling changes in 2.6.27</a></li>
<li><a class="reference external" href="https://wiki.freebsd.org/AtomicCloseOnExec">FreeBSD: atomic close on exec</a></li>
</ul>
</div>
<div class="section" id="status-of-python-3-3">
<h2><a class="toc-backref" href="#id13">Status of Python 3.3</a></h2>
<p>Python 3.3 creates inheritable file descriptors on all platforms, except
<tt class="docutils literal">os.pipe()</tt> which creates non-inheritable file descriptors on Windows.</p>
<p>New constants and functions related to the atomic creation of
non-inheritable file descriptors were added to Python 3.3:
<tt class="docutils literal">os.O_CLOEXEC</tt>, <tt class="docutils literal">os.pipe2()</tt> and <tt class="docutils literal">socket.SOCK_CLOEXEC</tt>.</p>
<p>On UNIX, the <tt class="docutils literal">subprocess</tt> module closes all file descriptors in the
child process by default, except standard streams (0, 1, 2) and file
descriptors of the <em>pass_fds</em> parameter. If the <em>close_fds</em> parameter is
set to <tt class="docutils literal">False</tt>, all inheritable file descriptors are inherited in the
child process.</p>
<p>On Windows, the <tt class="docutils literal">subprocess</tt> closes all handles and file descriptors
in the child process by default. If at least one standard stream (stdin,
stdout or stderr) is replaced (ex: redirected into a pipe), all
inheritable handles and file descriptors 0, 1 and 2 are inherited in the
child process.</p>
<p>Using the functions of the <tt class="docutils literal"><span class="pre">os.execv*()</span></tt> and <tt class="docutils literal"><span class="pre">os.spawn*()</span></tt> families,
all inheritable handles and all inheritable file descriptors are
inherited by the child process.</p>
<p>On UNIX, the <tt class="docutils literal">multiprocessing</tt> module uses <tt class="docutils literal">os.fork()</tt> and so all
file descriptors are inherited by child processes.</p>
<p>On Windows, all inheritable handles and file descriptors 0, 1 and 2 are
inherited by the child process using the <tt class="docutils literal">multiprocessing</tt> module, all
file descriptors except standard streams are closed.</p>
<p>Summary:</p>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="21%" />
<col width="25%" />
<col width="18%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Module</th>
<th class="head">FD on UNIX</th>
<th class="head">Handles on Windows</th>
<th class="head">FD on Windows</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>subprocess, default</td>
<td>STD, pass_fds</td>
<td>none</td>
<td>STD</td>
</tr>
<tr><td>subprocess, replace stdout</td>
<td>STD, pass_fds</td>
<td>all</td>
<td>STD</td>
</tr>
<tr><td>subprocess, close_fds=False</td>
<td>all</td>
<td>all</td>
<td>STD</td>
</tr>
<tr><td>multiprocessing</td>
<td>not applicable</td>
<td>all</td>
<td>STD</td>
</tr>
<tr><td>os.execv(), os.spawn()</td>
<td>all</td>
<td>all</td>
<td>all</td>
</tr>
</tbody>
</table>
<p>Legend:</p>
<ul class="simple">
<li>&quot;all&quot;: all <em>inheritable</em> file descriptors or handles are inherited in
the child process</li>
<li>&quot;none&quot;: all handles are closed in the child process</li>
<li>&quot;STD&quot;: only file descriptors 0 (stdin), 1 (stdout) and 2 (stderr) are
inherited in the child process</li>
<li>&quot;pass_fds&quot;: file descriptors of the <em>pass_fds</em> parameter of the
subprocess are inherited</li>
<li>&quot;not applicable&quot;: on UNIX, the multiprocessing uses <tt class="docutils literal">fork()</tt>,
so this case is not affected by this PEP.</li>
</ul>
</div>
<div class="section" id="closing-all-open-file-descriptors">
<h2><a class="toc-backref" href="#id14">Closing All Open File Descriptors</a></h2>
<p>On UNIX, the <tt class="docutils literal">subprocess</tt> module closes almost all file descriptors in
the child process. This operation requires MAXFD system calls, where
MAXFD is the maximum number of file descriptors, even if there are only
few open file descriptors. This maximum can be read using:
<tt class="docutils literal"><span class="pre">os.sysconf(&quot;SC_OPEN_MAX&quot;)</span></tt>.</p>
<p>The operation can be slow if MAXFD is large. For example, on a FreeBSD
buildbot with <tt class="docutils literal">MAXFD=655,000</tt>, the operation took 300 ms: see
<a class="reference external" href="http://bugs.python.org/issue11284#msg132668">issue #11284: slow close file descriptors</a>.</p>
<p>On Linux, Python 3.3 gets the list of all open file descriptors from
<tt class="docutils literal"><span class="pre">/proc/&lt;PID&gt;/fd/</span></tt>, and so performances depends on the number of open
file descriptors, not on MAXFD.</p>
<p>See also:</p>
<ul class="simple">
<li><a class="reference external" href="http://bugs.python.org/issue1663329">Python issue #1663329</a>:
subprocess close_fds perform poor if <tt class="docutils literal">SC_OPEN_MAX</tt> is high</li>
<li><a class="reference external" href="https://bugzilla.redhat.com/show_bug.cgi?id=837033">Squid Bug #837033</a>:
Squid should set CLOEXEC on opened FDs. &quot;32k+ close() calls in each
child process take a long time ([12-56] seconds) in Xen PV guests.&quot;</li>
</ul>
</div>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id15">Proposal</a></h1>
<div class="section" id="non-inheritable-file-descriptors">
<h2><a class="toc-backref" href="#id16">Non-inheritable File Descriptors</a></h2>
<p>The following functions are modified to make newly created file
descriptors non-inheritable by default:</p>
<ul class="simple">
<li><tt class="docutils literal">asyncore.dispatcher.create_socket()</tt></li>
<li><tt class="docutils literal">io.FileIO</tt></li>
<li><tt class="docutils literal">io.open()</tt></li>
<li><tt class="docutils literal">open()</tt></li>
<li><tt class="docutils literal">os.dup()</tt></li>
<li><tt class="docutils literal">os.fdopen()</tt></li>
<li><tt class="docutils literal">os.open()</tt></li>
<li><tt class="docutils literal">os.openpty()</tt></li>
<li><tt class="docutils literal">os.pipe()</tt></li>
<li><tt class="docutils literal">select.devpoll()</tt></li>
<li><tt class="docutils literal">select.epoll()</tt></li>
<li><tt class="docutils literal">select.kqueue()</tt></li>
<li><tt class="docutils literal">socket.socket()</tt></li>
<li><tt class="docutils literal">socket.socket.accept()</tt></li>
<li><tt class="docutils literal">socket.socket.dup()</tt></li>
<li><tt class="docutils literal">socket.socket.fromfd()</tt></li>
<li><tt class="docutils literal">socket.socketpair()</tt></li>
</ul>
<p><tt class="docutils literal">os.dup2()</tt> still creates inheritable by default, see below.</p>
<p>When available, atomic flags are used to make file descriptors
non-inheritable. The atomicity is not guaranteed because a fallback is
required when atomic flags are not available.</p>
</div>
<div class="section" id="new-functions-and-methods">
<h2><a class="toc-backref" href="#id17">New Functions And Methods</a></h2>
<p>New functions available on all platforms:</p>
<ul class="simple">
<li><tt class="docutils literal">os.get_inheritable(fd: int)</tt>: return <tt class="docutils literal">True</tt> if the file
descriptor can be inherited by child processes, <tt class="docutils literal">False</tt> otherwise.</li>
<li><tt class="docutils literal">os.set_inheritable(fd: int, inheritable: bool)</tt>: set the
inheritable flag of the specified file descriptor.</li>
</ul>
<p>New functions only available on Windows:</p>
<ul class="simple">
<li><tt class="docutils literal">os.get_handle_inheritable(handle: int)</tt>: return <tt class="docutils literal">True</tt> if the
handle can be inherited by child processes, <tt class="docutils literal">False</tt> otherwise.</li>
<li><tt class="docutils literal">os.set_handle_inheritable(handle: int, inheritable: bool)</tt>:
set the inheritable flag of the specified handle.</li>
</ul>
<p>New methods:</p>
<ul class="simple">
<li><tt class="docutils literal">socket.socket.get_inheritable()</tt>: return <tt class="docutils literal">True</tt> if the
socket can be inherited by child processes, <tt class="docutils literal">False</tt> otherwise.</li>
<li><tt class="docutils literal">socket.socket.set_inheritable(inheritable: bool)</tt>:
set the inheritable flag of the specified socket.</li>
</ul>
</div>
<div class="section" id="other-changes">
<h2><a class="toc-backref" href="#id18">Other Changes</a></h2>
<p>On UNIX, subprocess makes file descriptors of the <em>pass_fds</em> parameter
inheritable. The file descriptor is made inheritable in the child
process after the <tt class="docutils literal">fork()</tt> and before <tt class="docutils literal">execv()</tt>, so the inheritable
flag of file descriptors is unchanged in the parent process.</p>
<p><tt class="docutils literal">os.dup2()</tt> has a new optional <em>inheritable</em> parameter: <tt class="docutils literal">os.dup2(fd,
fd2, inheritable=True)</tt>. <em>fd2</em> is created inheritable by default, but
non-inheritable if <em>inheritable</em> is <tt class="docutils literal">False</tt>.</p>
<p><tt class="docutils literal">os.dup2()</tt> behaves differently than <tt class="docutils literal">os.dup()</tt> because the most
common use case of <tt class="docutils literal">os.dup2()</tt> is to replace the file descriptors of
the standard streams: <tt class="docutils literal">stdin</tt> (<tt class="docutils literal">0</tt>), <tt class="docutils literal">stdout</tt> (<tt class="docutils literal">1</tt>) and
<tt class="docutils literal">stderr</tt> (<tt class="docutils literal">2</tt>). Standard streams are expected to be inherited by
child processes.</p>
</div>
</div>
<div class="section" id="backward-compatibility">
<h1><a class="toc-backref" href="#id19">Backward Compatibility</a></h1>
<p>This PEP break applications relying on inheritance of file descriptors.
Developers are encouraged to reuse the high-level Python module
<tt class="docutils literal">subprocess</tt> which handles the inheritance of file descriptors in a
portable way.</p>
<p>Applications using the <tt class="docutils literal">subprocess</tt> module with the <em>pass_fds</em>
parameter or using only <tt class="docutils literal">os.dup2()</tt> to redirect standard streams should
not be affected.</p>
<p>Python no longer conform to POSIX, since file descriptors are now
made non-inheritable by default. Python was not designed to conform to
POSIX, but was designed to develop portable applications.</p>
</div>
<div class="section" id="related-work">
<h1><a class="toc-backref" href="#id20">Related Work</a></h1>
<p>The programming languages Go, Perl and Ruby make newly created file
descriptors non-inheritable by default: since Go 1.0 (2009), Perl 1.0
(1987) and Ruby 2.0 (2013).</p>
<p>The SCons project, written in Python, overrides builtin functions
<tt class="docutils literal">file()</tt> and <tt class="docutils literal">open()</tt> to make files non-inheritable on Windows:
see <a class="reference external" href="https://bitbucket.org/scons/scons/src/c8dbbaa4598e7119ae80f72068386be105b5ad98/src/engine/SCons/Platform/win32.py?at=default#cl-68">win32.py</a>.</p>
</div>
<div class="section" id="rejected-alternatives">
<h1><a class="toc-backref" href="#id21">Rejected Alternatives</a></h1>
<div class="section" id="add-a-new-open-noinherit-function">
<h2><a class="toc-backref" href="#id22">Add a new open_noinherit() function</a></h2>
<p>In June 2007, Henning von Bargen proposed on the python-dev mailing list
to add a new open_noinherit() function to fix issues of inherited file
descriptors in child processes. At this time, the default value of the
<em>close_fds</em> parameter of the subprocess module was <tt class="docutils literal">False</tt>.</p>
<p>Read the mail thread: <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2007-June/073688.html">[Python-Dev] Proposal for a new function
&quot;open_noinherit&quot; to avoid problems with subprocesses and security risks</a>.</p>
</div>
<div class="section" id="pep-433">
<h2><a class="reference external" href="/dev/peps/pep-0433">PEP 433</a></h2>
<p><a class="reference external" href="/dev/peps/pep-0433">PEP 433</a>, &quot;Easier suppression of file descriptor inheritance&quot;,
was a previous attempt proposing various other alternatives, but no
consensus could be reached.</p>
</div>
</div>
<div class="section" id="python-issues">
<h1><a class="toc-backref" href="#id24">Python Issues</a></h1>
<ul class="simple">
<li><a class="reference external" href="http://bugs.python.org/issue10115">#10115: Support accept4() for atomic setting of flags at socket
creation</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue12105">#12105: open() does not able to set flags, such as O_CLOEXEC</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue12107">#12107: TCP listening sockets created without FD_CLOEXEC flag</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue16850">#16850: Add &quot;e&quot; mode to open(): close-and-exec
(O_CLOEXEC) / O_NOINHERIT</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue16860">#16860: Use O_CLOEXEC in the tempfile module</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue16946">#16946: subprocess: _close_open_fd_range_safe() does not set
close-on-exec flag on Linux &lt; 2.6.23 if O_CLOEXEC is defined</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue17070">#17070: Use the new cloexec to improve security and avoid bugs</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue18571">#18571: Implementation of the PEP 446: non-inheritable file
descriptors</a></li>
</ul>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id25">Copyright</a></h1>
<p>This document has been placed into the public domain.</p>
</div>

