<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">329</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Treating Builtins as Constants in the Standard Library</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0329.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Raymond Hettinger &lt;python&#32;&#97;t&#32;rcn.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">18-Apr-2004</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.4</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">18-Apr-2004</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id6">Abstract</a></li>
<li><a class="reference internal" href="#status" id="id7">Status</a></li>
<li><a class="reference internal" href="#motivation" id="id8">Motivation</a></li>
<li><a class="reference internal" href="#proposal" id="id9">Proposal</a></li>
<li><a class="reference internal" href="#questions-and-answers" id="id10">Questions and Answers</a></li>
<li><a class="reference internal" href="#sample-implementation" id="id11">Sample Implementation</a></li>
<li><a class="reference internal" href="#references" id="id12">References</a></li>
<li><a class="reference internal" href="#copyright" id="id13">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id6">Abstract</a></h1>
<p>The proposal is to add a function for treating builtin references as
constants and to apply that function throughout the standard library.</p>
</div>
<div class="section" id="status">
<h1><a class="toc-backref" href="#id7">Status</a></h1>
<p>The PEP is self rejected by the author.  Though the ASPN recipe was
well received, there was less willingness to consider this for
inclusion in the core distribution.</p>
<p>The Jython implementation does not use byte codes, so its performance
would suffer if the current <tt class="docutils literal">_len=len</tt> optimizations were removed.</p>
<p>Also, altering byte codes is one of the least clean ways to improve
performance and enable cleaner coding.  A more robust solution would
likely involve compiler pragma directives or metavariables indicating
what can be optimized (similar to const/volatile declarations).</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id8">Motivation</a></h1>
<p>The library contains code such as <tt class="docutils literal">_len=len</tt> which is intended to
create fast local references instead of slower global lookups.  Though
necessary for performance, these constructs clutter the code and are
usually incomplete (missing many opportunities).</p>
<p>If the proposal is adopted, those constructs could be eliminated from
the code base and at the same time improve upon their results in terms
of performance.</p>
<p>There are currently over a hundred instances of <tt class="docutils literal">while 1</tt> in the
library.  They were not replaced with the more readable <tt class="docutils literal">while True</tt>
because of performance reasons (the compiler cannot eliminate the test
because <cite>True</cite> is not known to always be a constant).  Conversion of
True to a constant will clarify the code while retaining performance.</p>
<p>Many other basic Python operations run much slower because of global
lookups.  In try/except statements, the trapped exceptions are
dynamically looked up before testing whether they match.
Similarly, simple identity tests such as <tt class="docutils literal">while x is not None</tt>
require the <cite>None</cite> variable to be re-looked up on every pass.
Builtin lookups are especially egregious because the enclosing global
scope must be checked first.  These lookup chains devour cache space
that is best used elsewhere.</p>
<p>In short, if the proposal is adopted, the code will become cleaner
and performance will improve across the board.</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id9">Proposal</a></h1>
<p>Add a module called codetweaks.py which contains two functions,
<cite>bind_constants()</cite> and <cite>bind_all()</cite>.  The first function performs
constant binding and the second recursively applies it to every
function and class in a target module.</p>
<p>For most modules in the standard library, add a pair of lines near
the end of the script:</p>
<pre class="literal-block">
import codetweaks, sys
codetweaks.bind_all(sys.modules[__name__])
</pre>
<p>In addition to binding builtins, there are some modules (like
<cite>sre_compile</cite>) where it also makes sense to bind module variables
as well as builtins into constants.</p>
</div>
<div class="section" id="questions-and-answers">
<h1><a class="toc-backref" href="#id10">Questions and Answers</a></h1>
<ol class="arabic">
<li><p class="first">Will this make everyone divert their attention to optimization
issues?</p>
<p>Because it is done automatically, it reduces the need to think
about optimizations.</p>
</li>
<li><p class="first">In a nutshell, how does it work?</p>
<p>Every function has attributes with its bytecodes (the language of
the Python virtual machine) and a table of constants.  The bind
function scans the bytecodes for a <cite>LOAD_GLOBAL</cite> instruction and
checks to see whether the value is already known.  If so, it adds
that value to the constants table and replaces the opcode with
<cite>LOAD_CONSTANT</cite>.</p>
</li>
<li><p class="first">When does it work?</p>
<p>When a module is imported for the first time, python compiles the
bytecode and runs the binding optimization.  Subsequent imports
just re-use the previous work.  Each session repeats this process
(the results are not saved in <cite>pyc</cite> files).</p>
</li>
<li><p class="first">How do you know this works?</p>
<p>I implemented it, applied it to every module in library, and the test
suite ran without exception.</p>
</li>
<li><p class="first">What if the module defines a variable shadowing a builtin?</p>
<p>This does happen.  For instance, True can be redefined at the module
level as <cite>True = (1==1)</cite>.  The sample implementation below detects the
shadowing and leaves the global lookup unchanged.</p>
</li>
<li><p class="first">Are you the first person to recognize that most global lookups are for
values that never change?</p>
<p>No, this has long been known.  Skip Montanaro provides an eloquent
explanation in <a class="footnote-reference" href="#id3" id="id1">[1]</a>.</p>
</li>
<li><p class="first">What if I want to replace the builtins module and supply my own
implementations?</p>
<p>Either do this before importing a module, or just reload the
module, or disable <cite>codetweaks.py</cite> (it will have a disable flag).</p>
</li>
<li><p class="first">How susceptible is this module to changes in Python's byte coding?</p>
<p>It imports <cite>opcode.py</cite> to protect against renumbering.  Also, it
uses <cite>LOAD_CONST</cite> and <cite>LOAD_GLOBAL</cite> which are fundamental and have
been around forever.  That notwithstanding, the coding scheme could
change and this implementation would have to change along with
modules like <cite>dis</cite> which also rely on the current coding scheme.</p>
</li>
<li><p class="first">What is the effect on startup time?</p>
<p>I could not measure a difference.  None of the startup modules are
bound except for warnings.py.  Also, the binding function is very
fast, making just a single pass over the code string in search of
the <cite>LOAD_GLOBAL</cite> opcode.</p>
</li>
</ol>
</div>
<div class="section" id="sample-implementation">
<h1><a class="toc-backref" href="#id11">Sample Implementation</a></h1>
<p>Here is a sample implementation for codetweaks.py:</p>
<pre class="literal-block">
from types import ClassType, FunctionType
from opcode import opmap, HAVE_ARGUMENT, EXTENDED_ARG
LOAD_GLOBAL, LOAD_CONST = opmap['LOAD_GLOBAL'], opmap['LOAD_CONST']
ABORT_CODES = (EXTENDED_ARG, opmap['STORE_GLOBAL'])

def bind_constants(f, builtin_only=False, stoplist=[], verbose=False):
    &quot;&quot;&quot; Return a new function with optimized global references.

    Replaces global references with their currently defined values.
    If not defined, the dynamic (runtime) global lookup is left undisturbed.
    If builtin_only is True, then only builtins are optimized.
    Variable names in the stoplist are also left undisturbed.
    If verbose is True, prints each substitution as is occurs.

    &quot;&quot;&quot;
    import __builtin__
    env = vars(__builtin__).copy()
    stoplist = dict.fromkeys(stoplist)
    if builtin_only:
        stoplist.update(f.func_globals)
    else:
        env.update(f.func_globals)

    co = f.func_code
    newcode = map(ord, co.co_code)
    newconsts = list(co.co_consts)
    codelen = len(newcode)

    i = 0
    while i &lt; codelen:
        opcode = newcode[i]
        if opcode in ABORT_CODES:
            return f    # for simplicity, only optimize common cases
        if opcode == LOAD_GLOBAL:
            oparg = newcode[i+1] + (newcode[i+2] &lt;&lt; 8)
            name = co.co_names[oparg]
            if name in env and name not in stoplist:
                value = env[name]
                try:
                    pos = newconsts.index(value)
                except ValueError:
                    pos = len(newconsts)
                    newconsts.append(value)
                newcode[i] = LOAD_CONST
                newcode[i+1] = pos &amp; 0xFF
                newcode[i+2] = pos &gt;&gt; 8
                if verbose:
                    print name, '--&gt;', value
        i += 1
        if opcode &gt;= HAVE_ARGUMENT:
            i += 2

    codestr = ''.join(map(chr, newcode))
    codeobj = type(co)(co.co_argcount, co.co_nlocals, co.co_stacksize,
                    co.co_flags, codestr, tuple(newconsts), co.co_names,
                    co.co_varnames, co.co_filename, co.co_name,
                    co.co_firstlineno, co.co_lnotab, co.co_freevars,
                    co.co_cellvars)
    return type(f)(codeobj, f.func_globals, f.func_name, f.func_defaults,
                    f.func_closure)


def bind_all(mc, builtin_only=False, stoplist=[], verbose=False):
    &quot;&quot;&quot;Recursively apply bind_constants() to functions in a module or class.

    Use as the last line of the module (after everything is defined, but
    before test code).

    In modules that need modifiable globals, set builtin_only to True.

    &quot;&quot;&quot;
    for k, v in vars(mc).items():
        if type(v) is FunctionType:
            newv = bind_constants(v, builtin_only, stoplist, verbose)
            setattr(mc, k, newv)
        elif type(v) in (type, ClassType):
            bind_all(v, builtin_only, stoplist, verbose)


def f(): pass
try:
    f.func_code.code
except AttributeError:                  # detect non-CPython environments
    bind_all = lambda *args, **kwds: 0
del f

import sys
bind_all(sys.modules[__name__])         # Optimizer, optimize thyself!
</pre>
<p>Note the automatic detection of a non-CPython environment that does not
have bytecodes <a class="footnote-reference" href="#id5" id="id2">[3]</a>.  In that situation, the bind functions would simply
return the original function unchanged.  This assures that the two
line additions to library modules do not impact other implementations.</p>
<p>The final code should add a flag to make it easy to disable binding.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id12">References</a></h1>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Optimizing Global Variable/Attribute Access
<a class="reference external" href="http://www.python.org/dev/peps/pep-0266/">http://www.python.org/dev/peps/pep-0266/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>ASPN Recipe for a non-private implementation
<a class="reference external" href="http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/277940">http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/277940</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[3]</a></td><td>Differences between CPython and Jython
<a class="reference external" href="http://www.jython.org/cgi-bin/faqw.py?req=show&amp;file=faq01.003.htp">http://www.jython.org/cgi-bin/faqw.py?req=show&amp;file=faq01.003.htp</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id13">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>

