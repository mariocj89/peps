<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">234</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Iterators</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0234.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">ping&#32;&#97;t&#32;zesty.ca (Ka-Ping Yee), guido&#32;&#97;t&#32;python.org (Guido van Rossum)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">30-Jan-2001</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.1</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">30-Apr-2001</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id2">Abstract</a></li>
<li><a class="reference internal" href="#c-api-specification" id="id3">C API Specification</a></li>
<li><a class="reference internal" href="#python-api-specification" id="id4">Python API Specification</a></li>
<li><a class="reference internal" href="#dictionary-iterators" id="id5">Dictionary Iterators</a></li>
<li><a class="reference internal" href="#file-iterators" id="id6">File Iterators</a></li>
<li><a class="reference internal" href="#rationale" id="id7">Rationale</a></li>
<li><a class="reference internal" href="#resolved-issues" id="id8">Resolved Issues</a></li>
<li><a class="reference internal" href="#mailing-lists" id="id9">Mailing Lists</a></li>
<li><a class="reference internal" href="#copyright" id="id10">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id2">Abstract</a></h1>
<p>This document proposes an iteration interface that objects can provide to
control the behaviour of <tt class="docutils literal">for</tt> loops.  Looping is customized by providing a
method that produces an iterator object.  The iterator provides a <em>get next
value</em> operation that produces the next item in the sequence each time it is
called, raising an exception when no more items are available.</p>
<p>In addition, specific iterators over the keys of a dictionary and over the
lines of a file are proposed, and a proposal is made to allow spelling
<tt class="docutils literal">dict.has_key(key)</tt> as <tt class="docutils literal">key in dict</tt>.</p>
<p>Note: this is an almost complete rewrite of this PEP by the second author,
describing the actual implementation checked into the trunk of the Python 2.2
CVS tree.  It is still open for discussion.  Some of the more esoteric
proposals in the original version of this PEP have been withdrawn for now;
these may be the subject of a separate PEP in the future.</p>
</div>
<div class="section" id="c-api-specification">
<h1><a class="toc-backref" href="#id3">C API Specification</a></h1>
<p>A new exception is defined, <tt class="docutils literal">StopIteration</tt>, which can be used to signal the
end of an iteration.</p>
<p>A new slot named <tt class="docutils literal">tp_iter</tt> for requesting an iterator is added to the type
object structure.  This should be a function of one <tt class="docutils literal">PyObject *</tt> argument
returning a <tt class="docutils literal">PyObject *</tt>, or <tt class="docutils literal">NULL</tt>.  To use this slot, a new C API
function <tt class="docutils literal">PyObject_GetIter()</tt> is added, with the same signature as the
<tt class="docutils literal">tp_iter</tt> slot function.</p>
<p>Another new slot, named <tt class="docutils literal">tp_iternext</tt>, is added to the type structure, for
obtaining the next value in the iteration.  To use this slot, a new C API
function <tt class="docutils literal">PyIter_Next()</tt> is added.  The signature for both the slot and the
API function is as follows, although the <tt class="docutils literal">NULL</tt> return conditions differ:
the argument is a <tt class="docutils literal">PyObject *</tt> and so is the return value.  When the return
value is non-<tt class="docutils literal">NULL</tt>, it is the next value in the iteration.  When it is
<tt class="docutils literal">NULL</tt>, then for the <tt class="docutils literal">tp_iternext slot</tt> there are three possibilities:</p>
<ul class="simple">
<li>No exception is set; this implies the end of the iteration.</li>
<li>The <tt class="docutils literal">StopIteration</tt> exception (or a derived exception class) is set; this
implies the end of the iteration.</li>
<li>Some other exception is set; this means that an error occurred that should be
propagated normally.</li>
</ul>
<p>The higher-level <tt class="docutils literal">PyIter_Next()</tt> function clears the <tt class="docutils literal">StopIteration</tt>
exception (or derived exception) when it occurs, so its <tt class="docutils literal">NULL</tt> return
conditions are simpler:</p>
<ul class="simple">
<li>No exception is set; this means iteration has ended.</li>
<li>Some exception is set; this means an error occurred, and should be propagated
normally.</li>
</ul>
<p>Iterators implemented in C should <em>not</em> implement a <tt class="docutils literal">next()</tt> method with
similar semantics as the <tt class="docutils literal">tp_iternext</tt> slot!  When the type's dictionary is
initialized (by <tt class="docutils literal">PyType_Ready()</tt>), the presence of a <tt class="docutils literal">tp_iternext</tt> slot
causes a method <tt class="docutils literal">next()</tt> wrapping that slot to be added to the type's
<tt class="docutils literal">tp_dict</tt>.  (Exception: if the type doesn't use <tt class="docutils literal">PyObject_GenericGetAttr()</tt>
to access instance attributes, the <tt class="docutils literal">next()</tt> method in the type's <tt class="docutils literal">tp_dict</tt>
may not be seen.)  (Due to a misunderstanding in the original text of this PEP,
in Python 2.2, all iterator types implemented a <tt class="docutils literal">next()</tt> method that was
overridden by the wrapper; this has been fixed in Python 2.3.)</p>
<p>To ensure binary backwards compatibility, a new flag <tt class="docutils literal">Py_TPFLAGS_HAVE_ITER</tt>
is added to the set of flags in the <tt class="docutils literal">tp_flags</tt> field, and to the default
flags macro.  This flag must be tested before accessing the <tt class="docutils literal">tp_iter</tt> or
<tt class="docutils literal">tp_iternext</tt> slots.  The macro <tt class="docutils literal">PyIter_Check()</tt> tests whether an object
has the appropriate flag set and has a non-<tt class="docutils literal">NULL</tt> <tt class="docutils literal">tp_iternext</tt> slot.
There is no such macro for the <tt class="docutils literal">tp_iter</tt> slot (since the only place where
this slot is referenced should be <tt class="docutils literal">PyObject_GetIter()</tt>, and this can check
for the <tt class="docutils literal">Py_TPFLAGS_HAVE_ITER</tt> flag directly).</p>
<p>(Note: the <tt class="docutils literal">tp_iter</tt> slot can be present on any object; the <tt class="docutils literal">tp_iternext</tt>
slot should only be present on objects that act as iterators.)</p>
<p>For backwards compatibility, the <tt class="docutils literal">PyObject_GetIter()</tt> function implements
fallback semantics when its argument is a sequence that does not implement a
<tt class="docutils literal">tp_iter</tt> function: a lightweight sequence iterator object is constructed in
that case which iterates over the items of the sequence in the natural order.</p>
<p>The Python bytecode generated for <tt class="docutils literal">for</tt> loops is changed to use new opcodes,
<tt class="docutils literal">GET_ITER</tt> and <tt class="docutils literal">FOR_ITER</tt>, that use the iterator protocol rather than the
sequence protocol to get the next value for the loop variable.  This makes it
possible to use a <tt class="docutils literal">for</tt> loop to loop over non-sequence objects that support
the <tt class="docutils literal">tp_iter</tt> slot.  Other places where the interpreter loops over the values
of a sequence should also be changed to use iterators.</p>
<p>Iterators ought to implement the <tt class="docutils literal">tp_iter</tt> slot as returning a reference to
themselves; this is needed to make it possible to use an iterator (as opposed
to a sequence) in a <tt class="docutils literal">for</tt> loop.</p>
<p>Iterator implementations (in C or in Python) should guarantee that once the
iterator has signalled its exhaustion, subsequent calls to <tt class="docutils literal">tp_iternext</tt> or
to the <tt class="docutils literal">next()</tt> method will continue to do so.  It is not specified whether
an iterator should enter the exhausted state when an exception (other than
<tt class="docutils literal">StopIteration</tt>) is raised. Note that Python cannot guarantee that
user-defined or 3rd party iterators implement this requirement correctly.</p>
</div>
<div class="section" id="python-api-specification">
<h1><a class="toc-backref" href="#id4">Python API Specification</a></h1>
<p>The <tt class="docutils literal">StopIteration</tt> exception is made visible as one of the standard
exceptions.  It is derived from <tt class="docutils literal">Exception</tt>.</p>
<p>A new built-in function is defined, <tt class="docutils literal">iter()</tt>, which can be called in two
ways:</p>
<ul class="simple">
<li><tt class="docutils literal">iter(obj)</tt> calls <tt class="docutils literal">PyObject_GetIter(obj)</tt>.</li>
<li><tt class="docutils literal">iter(callable, sentinel)</tt> returns a special kind of iterator that calls
the callable to produce a new value, and compares the return value to the
sentinel value.  If the return value equals the sentinel, this signals the
end of the iteration and <tt class="docutils literal">StopIteration</tt> is raised rather than returning
normal; if the return value does not equal the sentinel, it is returned as
the next value from the iterator.  If the callable raises an exception, this
is propagated normally; in particular, the function is allowed to raise
<tt class="docutils literal">StopIteration</tt> as an alternative way to end the iteration.  (This
functionality is available from the C API as
<tt class="docutils literal">PyCallIter_New(callable, sentinel)</tt>.)</li>
</ul>
<p>Iterator objects returned by either form of <tt class="docutils literal">iter()</tt> have a <tt class="docutils literal">next()</tt>
method.  This method either returns the next value in the iteration, or raises
<tt class="docutils literal">StopIteration</tt> (or a derived exception class) to signal the end of the
iteration.  Any other exception should be considered to signify an error and
should be propagated normally, not taken to mean the end of the iteration.</p>
<p>Classes can define how they are iterated over by defining an <tt class="docutils literal">__iter__()</tt>
method; this should take no additional arguments and return a valid iterator
object.  A class that wants to be an iterator should implement two methods: a
<tt class="docutils literal">next()</tt> method that behaves as described above, and an <tt class="docutils literal">__iter__()</tt> method
that returns <tt class="docutils literal">self</tt>.</p>
<p>The two methods correspond to two distinct protocols:</p>
<ol class="arabic simple">
<li>An object can be iterated over with <tt class="docutils literal">for</tt> if it implements <tt class="docutils literal">__iter__()</tt>
or <tt class="docutils literal">__getitem__()</tt>.</li>
<li>An object can function as an iterator if it implements <tt class="docutils literal">next()</tt>.</li>
</ol>
<p>Container-like objects usually support protocol 1.  Iterators are currently
required to support both protocols.  The semantics of iteration come only from
protocol 2; protocol 1 is present to make iterators behave like sequences; in
particular so that code receiving an iterator can use a for-loop over the
iterator.</p>
</div>
<div class="section" id="dictionary-iterators">
<h1><a class="toc-backref" href="#id5">Dictionary Iterators</a></h1>
<ul>
<li><p class="first">Dictionaries implement a <tt class="docutils literal">sq_contains</tt> slot that implements the same test
as the <tt class="docutils literal">has_key()</tt> method.  This means that we can write</p>
<pre class="literal-block">
if k in dict: ...
</pre>
<p>which is equivalent to</p>
<pre class="literal-block">
if dict.has_key(k): ...
</pre>
</li>
<li><p class="first">Dictionaries implement a <tt class="docutils literal">tp_iter</tt> slot that returns an efficient iterator
that iterates over the keys of the dictionary.  During such an iteration, the
dictionary should not be modified, except that setting the value for an
existing key is allowed (deletions or additions are not, nor is the
<tt class="docutils literal">update()</tt> method).  This means that we can write</p>
<pre class="literal-block">
for k in dict: ...
</pre>
<p>which is equivalent to, but much faster than</p>
<pre class="literal-block">
for k in dict.keys(): ...
</pre>
<p>as long as the restriction on modifications to the dictionary (either by the
loop or by another thread) are not violated.</p>
</li>
<li><p class="first">Add methods to dictionaries that return different kinds of iterators
explicitly:</p>
<pre class="literal-block">
for key in dict.iterkeys(): ...

for value in dict.itervalues(): ...

for key, value in dict.iteritems(): ...
</pre>
<p>This means that <tt class="docutils literal">for x in dict</tt> is shorthand for
<tt class="docutils literal">for x in dict.iterkeys()</tt>.</p>
</li>
</ul>
<p>Other mappings, if they support iterators at all, should also iterate over the
keys.  However, this should not be taken as an absolute rule; specific
applications may have different requirements.</p>
</div>
<div class="section" id="file-iterators">
<h1><a class="toc-backref" href="#id6">File Iterators</a></h1>
<p>The following proposal is useful because it provides us with a good answer to
the complaint that the common idiom to iterate over the lines of a file is ugly
and slow.</p>
<ul>
<li><p class="first">Files implement a <tt class="docutils literal">tp_iter</tt> slot that is equivalent to
<tt class="docutils literal">iter(f.readline, &quot;&quot;)</tt>.  This means that we can write</p>
<pre class="literal-block">
for line in file:
    ...
</pre>
<p>as a shorthand for</p>
<pre class="literal-block">
for line in iter(file.readline, &quot;&quot;):
    ...
</pre>
<p>which is equivalent to, but faster than</p>
<pre class="literal-block">
while 1:
    line = file.readline()
    if not line:
        break
    ...
</pre>
</li>
</ul>
<p>This also shows that some iterators are destructive: they consume all the
values and a second iterator cannot easily be created that iterates
independently over the same values.  You could open the file for a second time,
or <tt class="docutils literal">seek()</tt> to the beginning, but these solutions don't work for all file
types, e.g. they don't work when the open file object really represents a pipe
or a stream socket.</p>
<p>Because the file iterator uses an internal buffer, mixing this with other file
operations (e.g. <tt class="docutils literal">file.readline()</tt>) doesn't work right.  Also, the following
code:</p>
<pre class="literal-block">
for line in file:
    if line == &quot;\n&quot;:
        break
for line in file:
   print line,
</pre>
<p>doesn't work as you might expect, because the iterator created by the second
for-loop doesn't take the buffer read-ahead by the first for-loop into account.
A correct way to write this is:</p>
<pre class="literal-block">
it = iter(file)
for line in it:
    if line == &quot;\n&quot;:
        break
for line in it:
    print line,
</pre>
<p>(The rationale for these restrictions are that <tt class="docutils literal">for line in file</tt> ought to
become the recommended, standard way to iterate over the lines of a file, and
this should be as fast as can be.  The iterator version is considerable faster
than calling <tt class="docutils literal">readline()</tt>, due to the internal buffer in the iterator.)</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id7">Rationale</a></h1>
<p>If all the parts of the proposal are included, this addresses many concerns in
a consistent and flexible fashion.  Among its chief virtues are the following
four -- no, five -- no, six -- points:</p>
<ol class="arabic simple">
<li>It provides an extensible iterator interface.</li>
<li>It allows performance enhancements to list iteration.</li>
<li>It allows big performance enhancements to dictionary iteration.</li>
<li>It allows one to provide an interface for just iteration without pretending
to provide random access to elements.</li>
<li>It is backward-compatible with all existing user-defined classes and
extension objects that emulate sequences and mappings, even mappings that
only implement a subset of {<tt class="docutils literal">__getitem__</tt>, <tt class="docutils literal">keys</tt>, <tt class="docutils literal">values</tt>,
<tt class="docutils literal">items</tt>}.</li>
<li>It makes code iterating over non-sequence collections more concise and
readable.</li>
</ol>
</div>
<div class="section" id="resolved-issues">
<h1><a class="toc-backref" href="#id8">Resolved Issues</a></h1>
<p>The following topics have been decided by consensus or BDFL pronouncement.</p>
<ul>
<li><p class="first">Two alternative spellings for <tt class="docutils literal">next()</tt> have been proposed but rejected:
<tt class="docutils literal">__next__()</tt>, because it corresponds to a type object slot
(<tt class="docutils literal">tp_iternext</tt>); and <tt class="docutils literal">__call__()</tt>, because this is the only operation.</p>
<p>Arguments against <tt class="docutils literal">__next__()</tt>: while many iterators are used in for loops,
it is expected that user code will also call <tt class="docutils literal">next()</tt> directly, so having
to write <tt class="docutils literal">__next__()</tt> is ugly; also, a possible extension of the protocol
would be to allow for <tt class="docutils literal">prev()</tt>, <tt class="docutils literal">current()</tt> and <tt class="docutils literal">reset()</tt> operations;
surely we don't want to use <tt class="docutils literal">__prev__()</tt>, <tt class="docutils literal">__current__()</tt>,
<tt class="docutils literal">__reset__()</tt>.</p>
<p>Arguments against <tt class="docutils literal">__call__()</tt> (the original proposal): taken out of
context, <tt class="docutils literal">x()</tt> is not very readable, while <tt class="docutils literal">x.next()</tt> is clear; there's a
danger that every special-purpose object wants to use <tt class="docutils literal">__call__()</tt> for its
most common operation, causing more confusion than clarity.</p>
<p>(In retrospect, it might have been better to go for <tt class="docutils literal">__next__()</tt> and have a
new built-in, <tt class="docutils literal">next(it)</tt>, which calls <tt class="docutils literal">it.__next__()</tt>. But alas, it's too
late; this has been deployed in Python 2.2 since December 2001.)</p>
</li>
<li><p class="first">Some folks have requested the ability to restart an iterator. This should be
dealt with by calling <tt class="docutils literal">iter()</tt> on a sequence repeatedly, not by the
iterator protocol itself.  (See also requested extensions below.)</p>
</li>
<li><p class="first">It has been questioned whether an exception to signal the end of the
iteration isn't too expensive.  Several alternatives for the
<tt class="docutils literal">StopIteration</tt> exception have been proposed: a special value <tt class="docutils literal">End</tt> to
signal the end, a function <tt class="docutils literal">end()</tt> to test whether the iterator is
finished, even reusing the <tt class="docutils literal">IndexError</tt> exception.</p>
<ul class="simple">
<li>A special value has the problem that if a sequence ever contains that
special value, a loop over that sequence will end prematurely without any
warning.  If the experience with null-terminated C strings hasn't taught us
the problems this can cause, imagine the trouble a Python introspection
tool would have iterating over a list of all built-in names, assuming that
the special <tt class="docutils literal">End</tt> value was a built-in name!</li>
<li>Calling an <tt class="docutils literal">end()</tt> function would require two calls per iteration.  Two
calls is much more expensive than one call plus a test for an exception.
Especially the time-critical for loop can test very cheaply for an
exception.</li>
<li>Reusing <tt class="docutils literal">IndexError</tt> can cause confusion because it can be a genuine
error, which would be masked by ending the loop prematurely.</li>
</ul>
</li>
<li><p class="first">Some have asked for a standard iterator type.  Presumably all iterators would
have to be derived from this type.  But this is not the Python way:
dictionaries are mappings because they support <tt class="docutils literal">__getitem__()</tt> and a
handful other operations, not because they are derived from an abstract
mapping type.</p>
</li>
<li><p class="first">Regarding <tt class="docutils literal">if key in dict</tt>: there is no doubt that the <tt class="docutils literal">dict.has_key(x)</tt>
interpretation of <tt class="docutils literal">x in dict</tt> is by far the most useful interpretation,
probably the only useful one.  There has been resistance against this because
<tt class="docutils literal">x in list</tt> checks whether <em>x</em> is present among the values, while the
proposal makes <tt class="docutils literal">x in dict</tt> check whether <em>x</em> is present among the keys.
Given that the symmetry between lists and dictionaries is very weak, this
argument does not have much weight.</p>
</li>
<li><p class="first">The name <tt class="docutils literal">iter()</tt> is an abbreviation.  Alternatives proposed include
<tt class="docutils literal">iterate()</tt>, <tt class="docutils literal">traverse()</tt>, but these appear too long. Python has a
history of using abbrs for common builtins, e.g. <tt class="docutils literal">repr()</tt>, <tt class="docutils literal">str()</tt>,
<tt class="docutils literal">len()</tt>.</p>
<p>Resolution: <tt class="docutils literal">iter()</tt> it is.</p>
</li>
<li><p class="first">Using the same name for two different operations (getting an iterator from an
object and making an iterator for a function with a sentinel value) is
somewhat ugly.  I haven't seen a better name for the second operation though,
and since they both return an iterator, it's easy to remember.</p>
<p>Resolution: the builtin <tt class="docutils literal">iter()</tt> takes an optional argument, which is the
sentinel to look for.</p>
</li>
<li><p class="first">Once a particular iterator object has raised <tt class="docutils literal">StopIteration</tt>, will it also
raise <tt class="docutils literal">StopIteration</tt> on all subsequent <tt class="docutils literal">next()</tt> calls? Some say that it
would be useful to require this, others say that it is useful to leave this
open to individual iterators.  Note that this may require an additional state
bit for some iterator implementations (e.g. function-wrapping iterators).</p>
<p>Resolution: once <tt class="docutils literal">StopIteration</tt> is raised, calling <tt class="docutils literal">it.next()</tt> continues
to raise <tt class="docutils literal">StopIteration</tt>.</p>
<p>Note: this was in fact not implemented in Python 2.2; there are many cases
where an iterator's <tt class="docutils literal">next()</tt> method can raise <tt class="docutils literal">StopIteration</tt> on one call
but not on the next.  This has been remedied in Python 2.3.</p>
</li>
<li><p class="first">It has been proposed that a file object should be its own iterator, with a
<tt class="docutils literal">next()</tt> method returning the next line.  This has certain advantages, and
makes it even clearer that this iterator is destructive.  The disadvantage is
that this would make it even more painful to implement the &quot;sticky
StopIteration&quot; feature proposed in the previous bullet.</p>
<p>Resolution: tentatively rejected (though there are still people arguing for
this).</p>
</li>
<li><p class="first">Some folks have requested extensions of the iterator protocol, e.g.
<tt class="docutils literal">prev()</tt> to get the previous item, <tt class="docutils literal">current()</tt> to get the current item
again, <tt class="docutils literal">finished()</tt> to test whether the iterator is finished, and maybe
even others, like <tt class="docutils literal">rewind()</tt>, <tt class="docutils literal">__len__()</tt>, <tt class="docutils literal">position()</tt>.</p>
<p>While some of these are useful, many of these cannot easily be implemented
for all iterator types without adding arbitrary buffering, and sometimes they
can't be implemented at all (or not reasonably).  E.g. anything to do with
reversing directions can't be done when iterating over a file or function.
Maybe a separate PEP can be drafted to standardize the names for such
operations when they are implementable.</p>
<p>Resolution: rejected.</p>
</li>
<li><p class="first">There has been a long discussion about whether</p>
<pre class="literal-block">
for x in dict: ...
</pre>
<p>should assign <em>x</em> the successive keys, values, or items of the dictionary.
The symmetry between <tt class="docutils literal">if x in y</tt> and <tt class="docutils literal">for x in y</tt> suggests that it should
iterate over keys.  This symmetry has been observed by many independently and
has even been used to &quot;explain&quot; one using the other.  This is because for
sequences, <tt class="docutils literal">if x in y</tt> iterates over <em>y</em> comparing the iterated values to
<em>x</em>.  If we adopt both of the above proposals, this will also hold for
dictionaries.</p>
<p>The argument against making <tt class="docutils literal">for x in dict</tt> iterate over the keys comes
mostly from a practicality point of view: scans of the standard library show
that there are about as many uses of <tt class="docutils literal">for x in dict.items()</tt> as there are
of <tt class="docutils literal">for x in dict.keys()</tt>, with the <tt class="docutils literal">items()</tt> version having a small
majority.  Presumably many of the loops using <tt class="docutils literal">keys()</tt> use the
corresponding value anyway, by writing <tt class="docutils literal">dict[x]</tt>, so (the argument goes) by
making both the key and value available, we could support the largest number
of cases.  While this is true, I (Guido) find the correspondence between
<tt class="docutils literal">for x in dict</tt> and <tt class="docutils literal">if x in dict</tt> too compelling to break, and there's
not much overhead in having to write <tt class="docutils literal">dict[x]</tt> to explicitly get the value.</p>
<p>For fast iteration over items, use <tt class="docutils literal">for key, value in dict.iteritems()</tt>.
I've timed the difference between</p>
<pre class="literal-block">
for key in dict: dict[key]
</pre>
<p>and</p>
<pre class="literal-block">
for key, value in dict.iteritems(): pass
</pre>
<p>and found that the latter is only about 7% faster.</p>
<p>Resolution: By BDFL pronouncement, <tt class="docutils literal">for x in dict</tt> iterates over the keys,
and dictionaries have <tt class="docutils literal">iteritems()</tt>, <tt class="docutils literal">iterkeys()</tt>, and <tt class="docutils literal">itervalues()</tt>
to return the different flavors of dictionary iterators.</p>
</li>
</ul>
</div>
<div class="section" id="mailing-lists">
<h1><a class="toc-backref" href="#id9">Mailing Lists</a></h1>
<p>The iterator protocol has been discussed extensively in a mailing list on
SourceForge:</p>
<blockquote>
<a class="reference external" href="http://lists.sourceforge.net/lists/listinfo/python-iterators">http://lists.sourceforge.net/lists/listinfo/python-iterators</a></blockquote>
<p>Initially, some of the discussion was carried out at Yahoo; archives are still
accessible:</p>
<blockquote>
<a class="reference external" href="http://groups.yahoo.com/group/python-iter">http://groups.yahoo.com/group/python-iter</a></blockquote>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id10">Copyright</a></h1>
<p>This document is in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

