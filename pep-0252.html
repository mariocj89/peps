<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">252</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Making Types Look More Like Classes</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0252.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">guido&#32;&#97;t&#32;python.org (Guido van Rossum)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">19-Apr-2001</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.2</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id1">Abstract</a></li>
<li><a class="reference internal" href="#introduction" id="id2">Introduction</a></li>
<li><a class="reference internal" href="#introspection-apis" id="id3">Introspection APIs</a></li>
<li><a class="reference internal" href="#specification-of-the-class-based-introspection-api" id="id4">Specification of the class-based introspection API</a></li>
<li><a class="reference internal" href="#specification-of-the-attribute-descriptor-api" id="id5">Specification of the attribute descriptor API</a></li>
<li><a class="reference internal" href="#static-methods-and-class-methods" id="id6">Static methods and class methods</a></li>
<li><a class="reference internal" href="#c-api" id="id7">C API</a></li>
<li><a class="reference internal" href="#discussion" id="id8">Discussion</a></li>
<li><a class="reference internal" href="#examples" id="id9">Examples</a></li>
<li><a class="reference internal" href="#backwards-compatibility" id="id10">Backwards compatibility</a></li>
<li><a class="reference internal" href="#warnings-and-errors" id="id11">Warnings and Errors</a></li>
<li><a class="reference internal" href="#implementation" id="id12">Implementation</a></li>
<li><a class="reference internal" href="#references" id="id13">References</a></li>
<li><a class="reference internal" href="#copyright" id="id14">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id1">Abstract</a></h1>
<p>This PEP proposes changes to the introspection API for types that
makes them look more like classes, and their instances more like
class instances.  For example, <tt class="docutils literal">type(x)</tt> will be equivalent to
<tt class="docutils literal">x.__class__</tt> for most built-in types.  When C is <tt class="docutils literal">x.__class__</tt>,
<tt class="docutils literal">x.meth(a)</tt> will generally be equivalent to <tt class="docutils literal">C.meth(x, a)</tt>, and
<tt class="docutils literal">C.__dict__</tt> contains x's methods and other attributes.</p>
<p>This PEP also introduces a new approach to specifying attributes,
using attribute descriptors, or descriptors for short.
Descriptors unify and generalize several different common
mechanisms used for describing attributes: a descriptor can
describe a method, a typed field in the object structure, or a
generalized attribute represented by getter and setter functions.</p>
<p>Based on the generalized descriptor API, this PEP also introduces
a way to declare class methods and static methods.</p>
<p>[Editor's note: the ideas described in this PEP have been incorporated
into Python.  The PEP no longer accurately describes the implementation.]</p>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id2">Introduction</a></h1>
<p>One of Python's oldest language warts is the difference between
classes and types.  For example, you can't directly subclass the
dictionary type, and the introspection interface for finding out
what methods and instance variables an object has is different for
types and for classes.</p>
<p>Healing the class/type split is a big effort, because it affects
many aspects of how Python is implemented.  This PEP concerns
itself with making the introspection API for types look the same
as that for classes.  Other PEPs will propose making classes look
more like types, and subclassing from built-in types; these topics
are not on the table for this PEP.</p>
</div>
<div class="section" id="introspection-apis">
<h1><a class="toc-backref" href="#id3">Introspection APIs</a></h1>
<p>Introspection concerns itself with finding out what attributes an
object has.  Python's very general getattr/setattr API makes it
impossible to guarantee that there always is a way to get a list
of all attributes supported by a specific object, but in practice
two conventions have appeared that together work for almost all
objects.  I'll call them the class-based introspection API and the
type-based introspection API; class API and type API for short.</p>
<p>The class-based introspection API is used primarily for class
instances; it is also used by Jim Fulton's ExtensionClasses.  It
assumes that all data attributes of an object x are stored in the
dictionary <tt class="docutils literal">x.__dict__</tt>, and that all methods and class variables
can be found by inspection of x's class, written as <tt class="docutils literal">x.__class__</tt>.
Classes have a <tt class="docutils literal">__dict__</tt> attribute, which yields a dictionary
containing methods and class variables defined by the class
itself, and a <tt class="docutils literal">__bases__</tt> attribute, which is a tuple of base
classes that must be inspected recursively.  Some assumptions here
are:</p>
<ul class="simple">
<li>attributes defined in the instance dict override attributes
defined by the object's class;</li>
<li>attributes defined in a derived class override attributes
defined in a base class;</li>
<li>attributes in an earlier base class (meaning occurring earlier
in <tt class="docutils literal">__bases__</tt>) override attributes in a later base class.</li>
</ul>
<p>(The last two rules together are often summarized as the
left-to-right, depth-first rule for attribute search.  This is the
classic Python attribute lookup rule.  Note that <a class="reference external" href="/dev/peps/pep-0253">PEP 253</a> will
propose to change the attribute lookup order, and if accepted,
this PEP will follow suit.)</p>
<p>The type-based introspection API is supported in one form or
another by most built-in objects.  It uses two special attributes,
<tt class="docutils literal">__members__</tt> and <tt class="docutils literal">__methods__</tt>.  The <tt class="docutils literal">__methods__</tt> attribute, if
present, is a list of method names supported by the object.  The
<tt class="docutils literal">__members__</tt> attribute, if present, is a list of data attribute
names supported by the object.</p>
<p>The type API is sometimes combined with a <tt class="docutils literal">__dict__</tt> that works the
same as for instances (for example for function objects in
Python 2.1, <tt class="docutils literal">f.__dict__</tt> contains f's dynamic attributes, while
<tt class="docutils literal">f.__members__</tt> lists the names of f's statically defined
attributes).</p>
<p>Some caution must be exercised: some objects don't list their
&quot;intrinsic&quot; attributes (like <tt class="docutils literal">__dict__</tt> and <tt class="docutils literal">__doc__</tt>) in <tt class="docutils literal">__members__</tt>,
while others do; sometimes attribute names occur both in
<tt class="docutils literal">__members__</tt> or <tt class="docutils literal">__methods__</tt> and as keys in <tt class="docutils literal">__dict__</tt>, in which case
it's anybody's guess whether the value found in <tt class="docutils literal">__dict__</tt> is used
or not.</p>
<p>The type API has never been carefully specified.  It is part of
Python folklore, and most third party extensions support it
because they follow examples that support it.  Also, any type that
uses <tt class="docutils literal">Py_FindMethod()</tt> and/or <tt class="docutils literal">PyMember_Get()</tt> in its tp_getattr
handler supports it, because these two functions special-case the
attribute names <tt class="docutils literal">__methods__</tt> and <tt class="docutils literal">__members__</tt>, respectively.</p>
<p>Jim Fulton's ExtensionClasses ignore the type API, and instead
emulate the class API, which is more powerful.  In this PEP, I
propose to phase out the type API in favor of supporting the class
API for all types.</p>
<p>One argument in favor of the class API is that it doesn't require
you to create an instance in order to find out which attributes a
type supports; this in turn is useful for documentation
processors.  For example, the socket module exports the SocketType
object, but this currently doesn't tell us what methods are
defined on socket objects.  Using the class API, SocketType would
show exactly what the methods for socket objects are, and we can
even extract their docstrings, without creating a socket.  (Since
this is a C extension module, the source-scanning approach to
docstring extraction isn't feasible in this case.)</p>
</div>
<div class="section" id="specification-of-the-class-based-introspection-api">
<h1><a class="toc-backref" href="#id4">Specification of the class-based introspection API</a></h1>
<p>Objects may have two kinds of attributes: static and dynamic.  The
names and sometimes other properties of static attributes are
knowable by inspection of the object's type or class, which is
accessible through <tt class="docutils literal">obj.__class__</tt> or <tt class="docutils literal">type(obj)</tt>.  (I'm using type
and class interchangeably; a clumsy but descriptive term that fits
both is &quot;meta-object&quot;.)</p>
<p>(XXX static and dynamic are not great terms to use here, because
&quot;static&quot; attributes may actually behave quite dynamically, and
because they have nothing to do with static class members in C++
or Java.  Barry suggests to use immutable and mutable instead, but
those words already have precise and different meanings in
slightly different contexts, so I think that would still be
confusing.)</p>
<p>Examples of dynamic attributes are instance variables of class
instances, module attributes, etc.  Examples of static attributes
are the methods of built-in objects like lists and dictionaries,
and the attributes of frame and code objects (<tt class="docutils literal">f.f_code</tt>,
<tt class="docutils literal">c.co_filename</tt>, etc.).  When an object with dynamic attributes
exposes these through its <tt class="docutils literal">__dict__</tt> attribute, <tt class="docutils literal">__dict__</tt> is a static
attribute.</p>
<p>The names and values of dynamic properties are typically stored in
a dictionary, and this dictionary is typically accessible as
<tt class="docutils literal">obj.__dict__</tt>.  The rest of this specification is more concerned
with discovering the names and properties of static attributes
than with dynamic attributes; the latter are easily discovered by
inspection of <tt class="docutils literal">obj.__dict__</tt>.</p>
<p>In the discussion below, I distinguish two kinds of objects:
regular objects (like lists, ints, functions) and meta-objects.
Types and classes are meta-objects.  Meta-objects are also regular
objects, but we're mostly interested in them because they are
referenced by the <tt class="docutils literal">__class__</tt> attribute of regular objects (or by
the <tt class="docutils literal">__bases__</tt> attribute of other meta-objects).</p>
<p>The class introspection API consists of the following elements:</p>
<ul class="simple">
<li>the <tt class="docutils literal">__class__</tt> and <tt class="docutils literal">__dict__</tt> attributes on regular objects;</li>
<li>the <tt class="docutils literal">__bases__</tt> and <tt class="docutils literal">__dict__</tt> attributes on meta-objects;</li>
<li>precedence rules;</li>
<li>attribute descriptors.</li>
</ul>
<p>Together, these not only tell us about <strong>all</strong> attributes defined by
a meta-object, but they also help us calculate the value of a
specific attribute of a given object.</p>
<ol class="arabic">
<li><p class="first">The <tt class="docutils literal">__dict__</tt> attribute on regular objects</p>
<p>A regular object may have a <tt class="docutils literal">__dict__</tt> attribute.  If it does,
this should be a mapping (not necessarily a dictionary)
supporting at least <tt class="docutils literal">__getitem__()</tt>, <tt class="docutils literal">keys()</tt>, and <tt class="docutils literal">has_key()</tt>.  This
gives the dynamic attributes of the object.  The keys in the
mapping give attribute names, and the corresponding values give
their values.</p>
<p>Typically, the value of an attribute with a given name is the
same object as the value corresponding to that name as a key in
the <tt class="docutils literal">__dict__</tt>.  In other words, <tt class="docutils literal"><span class="pre">obj.__dict__['spam']</span></tt> is <tt class="docutils literal">obj.spam</tt>.
(But see the precedence rules below; a static attribute with
the same name <strong>may</strong> override the dictionary item.)</p>
</li>
<li><p class="first">The <tt class="docutils literal">__class__</tt> attribute on regular objects</p>
<p>A regular object usually has a <tt class="docutils literal">__class__</tt> attribute.  If it
does, this references a meta-object.  A meta-object can define
static attributes for the regular object whose <tt class="docutils literal">__class__</tt> it
is.  This is normally done through the following mechanism:</p>
</li>
<li><p class="first">The <tt class="docutils literal">__dict__</tt> attribute on meta-objects</p>
<p>A meta-object may have a <tt class="docutils literal">__dict__</tt> attribute, of the same form
as the <tt class="docutils literal">__dict__</tt> attribute for regular objects (a mapping but
not necessarily a dictionary).  If it does, the keys of the
meta-object's <tt class="docutils literal">__dict__</tt> are names of static attributes for the
corresponding regular object.  The values are attribute
descriptors; we'll explain these later.  An unbound method is a
special case of an attribute descriptor.</p>
<p>Because a meta-object is also a regular object, the items in a
meta-object's <tt class="docutils literal">__dict__</tt> correspond to attributes of the
meta-object; however, some transformation may be applied, and
bases (see below) may define additional dynamic attributes.  In
other words, <tt class="docutils literal">mobj.spam</tt> is not always <tt class="docutils literal"><span class="pre">mobj.__dict__['spam']</span></tt>.
(This rule contains a loophole because for classes, if
<tt class="docutils literal"><span class="pre">C.__dict__['spam']</span></tt> is a function, <tt class="docutils literal">C.spam</tt> is an unbound method
object.)</p>
</li>
<li><p class="first">The <tt class="docutils literal">__bases__</tt> attribute on meta-objects</p>
<p>A meta-object may have a <tt class="docutils literal">__bases__</tt> attribute.  If it does, this
should be a sequence (not necessarily a tuple) of other
meta-objects, the bases.  An absent <tt class="docutils literal">__bases__</tt> is equivalent to
an empty sequence of bases.  There must never be a cycle in the
relationship between meta-objects defined by <tt class="docutils literal">__bases__</tt>
attributes; in other words, the <tt class="docutils literal">__bases__</tt> attributes define a
directed acyclic graph, with arcs pointing from derived
meta-objects to their base meta-objects.  (It is not
necessarily a tree, since multiple classes can have the same
base class.)  The <tt class="docutils literal">__dict__</tt> attributes of a meta-object in the
inheritance graph supply attribute descriptors for the regular
object whose <tt class="docutils literal">__class__</tt> attribute points to the root of the
inheritance tree (which is not the same as the root of the
inheritance hierarchy -- rather more the opposite, at the
bottom given how inheritance trees are typically drawn).
Descriptors are first searched in the dictionary of the root
meta-object, then in its bases, according to a precedence rule
(see the next paragraph).</p>
</li>
<li><p class="first">Precedence rules</p>
<p>When two meta-objects in the inheritance graph for a given
regular object both define an attribute descriptor with the
same name, the search order is up to the meta-object.  This
allows different meta-objects to define different search
orders.  In particular, classic classes use the old
left-to-right depth-first rule, while new-style classes use a
more advanced rule (see the section on method resolution order
in <a class="reference external" href="/dev/peps/pep-0253">PEP 253</a>).</p>
<p>When a dynamic attribute (one defined in a regular object's
<tt class="docutils literal">__dict__</tt>) has the same name as a static attribute (one defined
by a meta-object in the inheritance graph rooted at the regular
object's <tt class="docutils literal">__class__</tt>), the static attribute has precedence if it
is a descriptor that defines a <tt class="docutils literal">__set__</tt> method (see below);
otherwise (if there is no <tt class="docutils literal">__set__</tt> method) the dynamic attribute
has precedence.  In other words, for data attributes (those
with a <tt class="docutils literal">__set__</tt> method), the static definition overrides the
dynamic definition, but for other attributes, dynamic overrides
static.</p>
<p>Rationale: we can't have a simple rule like &quot;static overrides
dynamic&quot; or &quot;dynamic overrides static&quot;, because some static
attributes indeed override dynamic attributes; for example, a
key '__class__' in an instance's <tt class="docutils literal">__dict__</tt> is ignored in favor
of the statically defined <tt class="docutils literal">__class__</tt> pointer, but on the other
hand most keys in <tt class="docutils literal">inst.__dict__</tt> override attributes defined in
<tt class="docutils literal">inst.__class__</tt>.  Presence of a <tt class="docutils literal">__set__</tt> method on a descriptor
indicates that this is a data descriptor.  (Even read-only data
descriptors have a <tt class="docutils literal">__set__</tt> method: it always raises an
exception.)  Absence of a <tt class="docutils literal">__set__</tt> method on a descriptor
indicates that the descriptor isn't interested in intercepting
assignment, and then the classic rule applies: an instance
variable with the same name as a method hides the method until
it is deleted.</p>
</li>
<li><p class="first">Attribute descriptors</p>
<p>This is where it gets interesting -- and messy.  Attribute
descriptors (descriptors for short) are stored in the
meta-object's <tt class="docutils literal">__dict__</tt> (or in the <tt class="docutils literal">__dict__</tt> of one of its
ancestors), and have two uses: a descriptor can be used to get
or set the corresponding attribute value on the (regular,
non-meta) object, and it has an additional interface that
describes the attribute for documentation and introspection
purposes.</p>
<p>There is little prior art in Python for designing the
descriptor's interface, neither for getting/setting the value
nor for describing the attribute otherwise, except some trivial
properties (it's reasonable to assume that <tt class="docutils literal">__name__</tt> and <tt class="docutils literal">__doc__</tt>
should be the attribute's name and docstring).  I will propose
such an API below.</p>
<p>If an object found in the meta-object's <tt class="docutils literal">__dict__</tt> is not an
attribute descriptor, backward compatibility dictates certain
minimal semantics.  This basically means that if it is a Python
function or an unbound method, the attribute is a method;
otherwise, it is the default value for a dynamic data
attribute.  Backwards compatibility also dictates that (in the
absence of a <tt class="docutils literal">__setattr__</tt> method) it is legal to assign to an
attribute corresponding to a method, and that this creates a
data attribute shadowing the method for this particular
instance.  However, these semantics are only required for
backwards compatibility with regular classes.</p>
</li>
</ol>
<p>The introspection API is a read-only API.  We don't define the
effect of assignment to any of the special attributes (<tt class="docutils literal">__dict__</tt>,
<tt class="docutils literal">__class__</tt> and <tt class="docutils literal">__bases__</tt>), nor the effect of assignment to the
items of a <tt class="docutils literal">__dict__</tt>.  Generally, such assignments should be
considered off-limits.  A future PEP may define some semantics for
some such assignments.  (Especially because currently instances
support assignment to <tt class="docutils literal">__class__</tt> and <tt class="docutils literal">__dict__</tt>, and classes support
assignment to <tt class="docutils literal">__bases__</tt> and <tt class="docutils literal">__dict__</tt>.)</p>
</div>
<div class="section" id="specification-of-the-attribute-descriptor-api">
<h1><a class="toc-backref" href="#id5">Specification of the attribute descriptor API</a></h1>
<p>Attribute descriptors may have the following attributes.  In the
examples, x is an object, C is <tt class="docutils literal">x.__class__</tt>, <tt class="docutils literal">x.meth()</tt> is a method,
and <tt class="docutils literal">x.ivar</tt> is a data attribute or instance variable.  All
attributes are optional -- a specific attribute may or may not be
present on a given descriptor.  An absent attribute means that the
corresponding information is not available or the corresponding
functionality is not implemented.</p>
<ul class="simple">
<li><tt class="docutils literal">__name__</tt>: the attribute name.  Because of aliasing and renaming,
the attribute may (additionally or exclusively) be known under a
different name, but this is the name under which it was born.
Example: <tt class="docutils literal">C.meth.__name__ == 'meth'</tt>.</li>
<li><tt class="docutils literal">__doc__</tt>: the attribute's documentation string.  This may be
None.</li>
<li><tt class="docutils literal">__objclass__</tt>: the class that declared this attribute.  The
descriptor only applies to objects that are instances of this
class (this includes instances of its subclasses).  Example:
<tt class="docutils literal">C.meth.__objclass__ is C</tt>.</li>
<li><tt class="docutils literal">__get__()</tt>: a function callable with one or two arguments that
retrieves the attribute value from an object.  This is also
referred to as a &quot;binding&quot; operation, because it may return a
&quot;bound method&quot; object in the case of method descriptors.  The
first argument, X, is the object from which the attribute must
be retrieved or to which it must be bound.  When X is None, the
optional second argument, T, should be meta-object and the
binding operation may return an <strong>unbound</strong> method restricted to
instances of T.  When both X and T are specified, X should be an
instance of T.  Exactly what is returned by the binding
operation depends on the semantics of the descriptor; for
example, static methods and class methods (see below) ignore the
instance and bind to the type instead.</li>
<li><tt class="docutils literal">__set__()</tt>: a function of two arguments that sets the attribute
value on the object.  If the attribute is read-only, this method
may raise a TypeError or <tt class="docutils literal">AttributeError</tt> exception (both are
allowed, because both are historically found for undefined or
unsettable attributes).  Example:
<tt class="docutils literal">C.ivar.set(x, y) ~~ x.ivar = y</tt>.</li>
</ul>
</div>
<div class="section" id="static-methods-and-class-methods">
<h1><a class="toc-backref" href="#id6">Static methods and class methods</a></h1>
<p>The descriptor API makes it possible to add static methods and
class methods.  Static methods are easy to describe: they behave
pretty much like static methods in C++ or Java.  Here's an
example:</p>
<pre class="literal-block">
class C:

    def foo(x, y):
        print &quot;staticmethod&quot;, x, y
    foo = staticmethod(foo)

C.foo(1, 2)
c = C()
c.foo(1, 2)
</pre>
<p>Both the call <tt class="docutils literal">C.foo(1, 2)</tt> and the call <tt class="docutils literal">c.foo(1, 2)</tt> call <tt class="docutils literal">foo()</tt> with
two arguments, and print &quot;staticmethod 1 2&quot;.  No &quot;self&quot; is declared in
the definition of <tt class="docutils literal">foo()</tt>, and no instance is required in the call.</p>
<p>The line &quot;foo = staticmethod(foo)&quot; in the class statement is the
crucial element: this makes <tt class="docutils literal">foo()</tt> a static method.  The built-in
<tt class="docutils literal">staticmethod()</tt> wraps its function argument in a special kind of
descriptor whose <tt class="docutils literal">__get__()</tt> method returns the original function
unchanged.  Without this, the <tt class="docutils literal">__get__()</tt> method of standard
function objects would have created a bound method object for
'c.foo' and an unbound method object for 'C.foo'.</p>
<p>(XXX Barry suggests to use &quot;sharedmethod&quot; instead of
&quot;staticmethod&quot;, because the word static is being overloaded in so
many ways already.  But I'm not sure if shared conveys the right
meaning.)</p>
<p>Class methods use a similar pattern to declare methods that
receive an implicit first argument that is the <em>class</em> for which
they are invoked.  This has no C++ or Java equivalent, and is not
quite the same as what class methods are in Smalltalk, but may
serve a similar purpose.  According to Armin Rigo, they are
similar to &quot;virtual class methods&quot; in Borland Pascal dialect
Delphi.  (Python also has real metaclasses, and perhaps methods
defined in a metaclass have more right to the name &quot;class method&quot;;
but I expect that most programmers won't be using metaclasses.)
Here's an example:</p>
<pre class="literal-block">
class C:

    def foo(cls, y):
        print &quot;classmethod&quot;, cls, y
    foo = classmethod(foo)

C.foo(1)
c = C()
c.foo(1)
</pre>
<p>Both the call <tt class="docutils literal">C.foo(1)</tt> and the call <tt class="docutils literal">c.foo(1)</tt> end up calling <tt class="docutils literal">foo()</tt>
with <strong>two</strong> arguments, and print &quot;classmethod __main__.C 1&quot;.  The
first argument of <tt class="docutils literal">foo()</tt> is implied, and it is the class, even if
the method was invoked via an instance.  Now let's continue the
example:</p>
<pre class="literal-block">
class D(C):
    pass

D.foo(1)
d = D()
d.foo(1)
</pre>
<p>This prints &quot;classmethod __main__.D 1&quot; both times; in other words,
the class passed as the first argument of <tt class="docutils literal">foo()</tt> is the class
involved in the call, not the class involved in the definition of
<tt class="docutils literal">foo()</tt>.</p>
<p>But notice this:</p>
<pre class="literal-block">
class E(C):
    def foo(cls, y): # override C.foo
        print &quot;E.foo() called&quot;
        C.foo(y)
    foo = classmethod(foo)

E.foo(1)
e = E()
e.foo(1)
</pre>
<p>In this example, the call to <tt class="docutils literal">C.foo()</tt> from <tt class="docutils literal">E.foo()</tt> will see class C
as its first argument, not class E.  This is to be expected, since
the call specifies the class C.  But it stresses the difference
between these class methods and methods defined in metaclasses,
where an upcall to a metamethod would pass the target class as an
explicit first argument.  (If you don't understand this, don't
worry, you're not alone.)  Note that calling <tt class="docutils literal">cls.foo(y)</tt> would be a
mistake -- it would cause infinite recursion.  Also note that you
can't specify an explicit 'cls' argument to a class method.  If
you want this (e.g. the <tt class="docutils literal">__new__</tt> method in <a class="reference external" href="/dev/peps/pep-0253">PEP 253</a> requires this),
use a static method with a class as its explicit first argument
instead.</p>
</div>
<div class="section" id="c-api">
<h1><a class="toc-backref" href="#id7">C API</a></h1>
<p>XXX The following is VERY rough text that I wrote with a different
audience in mind; I'll have to go through this to edit it more.
XXX It also doesn't go into enough detail for the C API.</p>
<p>A built-in type can declare special data attributes in two ways:
using a struct memberlist (defined in structmember.h) or a struct
getsetlist (defined in descrobject.h).  The struct memberlist is
an old mechanism put to new use: each attribute has a descriptor
record including its name, an enum giving its type (various C
types are supported as well as <tt class="docutils literal">PyObject *</tt>), an offset from the
start of the instance, and a read-only flag.</p>
<p>The struct getsetlist mechanism is new, and intended for cases
that don't fit in that mold, because they either require
additional checking, or are plain calculated attributes.  Each
attribute here has a name, a getter C function pointer, a setter C
function pointer, and a context pointer.  The function pointers
are optional, so that for example setting the setter function
pointer to <tt class="docutils literal">NULL</tt> makes a read-only attribute.  The context pointer
is intended to pass auxiliary information to generic getter/setter
functions, but I haven't found a need for this yet.</p>
<p>Note that there is also a similar mechanism to declare built-in
methods: these are <tt class="docutils literal">PyMethodDef</tt> structures, which contain a name
and a C function pointer (and some flags for the calling
convention).</p>
<p>Traditionally, built-in types have had to define their own
<tt class="docutils literal">tp_getattro</tt> and <tt class="docutils literal">tp_setattro</tt> slot functions to make these attribute
definitions work (<tt class="docutils literal">PyMethodDef</tt> and struct memberlist are quite
old).  There are convenience functions that take an array of
<tt class="docutils literal">PyMethodDef</tt> or memberlist structures, an object, and an attribute
name, and return or set the attribute if found in the list, or
raise an exception if not found.  But these convenience functions
had to be explicitly called by the <tt class="docutils literal">tp_getattro</tt> or <tt class="docutils literal">tp_setattro</tt>
method of the specific type, and they did a linear search of the
array using <tt class="docutils literal">strcmp()</tt> to find the array element describing the
requested attribute.</p>
<p>I now have a brand spanking new generic mechanism that improves
this situation substantially.</p>
<ul>
<li><p class="first">Pointers to arrays of <tt class="docutils literal">PyMethodDef</tt>, memberlist, getsetlist
structures are part of the new type object (<tt class="docutils literal">tp_methods</tt>,
<tt class="docutils literal">tp_members</tt>, <tt class="docutils literal">tp_getset</tt>).</p>
</li>
<li><p class="first">At type initialization time (in <tt class="docutils literal">PyType_InitDict()</tt>), for each
entry in those three arrays, a descriptor object is created and
placed in a dictionary that belongs to the type (<tt class="docutils literal">tp_dict</tt>).</p>
</li>
<li><p class="first">Descriptors are very lean objects that mostly point to the
corresponding structure.  An implementation detail is that all
descriptors share the same object type, and a discriminator
field tells what kind of descriptor it is (method, member, or
getset).</p>
</li>
<li><p class="first">As explained in <a class="reference external" href="/dev/peps/pep-0252">PEP 252</a>, descriptors have a <tt class="docutils literal">get()</tt> method that
takes an object argument and returns that object's attribute;
descriptors for writable attributes also have a <tt class="docutils literal">set()</tt> method
that takes an object and a value and set that object's
attribute.  Note that the <tt class="docutils literal">get()</tt> object also serves as a <tt class="docutils literal">bind()</tt>
operation for methods, binding the unbound method implementation
to the object.</p>
</li>
<li><p class="first">Instead of providing their own tp_getattro and tp_setattro
implementation, almost all built-in objects now place
<tt class="docutils literal">PyObject_GenericGetAttr</tt> and (if they have any writable
attributes) <tt class="docutils literal">PyObject_GenericSetAttr</tt> in their <tt class="docutils literal">tp_getattro</tt> and
<tt class="docutils literal">tp_setattro</tt> slots.  (Or, they can leave these <tt class="docutils literal">NULL</tt>, and inherit
them from the default base object, if they arrange for an
explicit call to <tt class="docutils literal">PyType_InitDict()</tt> for the type before the first
instance is created.)</p>
</li>
<li><p class="first">In the simplest case, <tt class="docutils literal">PyObject_GenericGetAttr()</tt> does exactly one
dictionary lookup: it looks up the attribute name in the type's
dictionary (obj-&gt;ob_type-&gt;tp_dict).  Upon success, there are two
possibilities: the descriptor has a get method, or it doesn't.
For speed, the get and set methods are type slots: <tt class="docutils literal">tp_descr_get</tt>
and <tt class="docutils literal">tp_descr_set</tt>.  If the <tt class="docutils literal">tp_descr_get</tt> slot is non-NULL, it is
called, passing the object as its only argument, and the return
value from this call is the result of the getattr operation.  If
the <tt class="docutils literal">tp_descr_get</tt> slot is <tt class="docutils literal">NULL</tt>, as a fallback the descriptor
itself is returned (compare class attributes that are not
methods but simple values).</p>
</li>
<li><p class="first"><tt class="docutils literal">PyObject_GenericSetAttr()</tt> works very similar but uses the
<tt class="docutils literal">tp_descr_set</tt> slot and calls it with the object and the new
attribute value; if the <tt class="docutils literal">tp_descr_set</tt> slot is <tt class="docutils literal">NULL</tt>, an
<tt class="docutils literal">AttributeError</tt> is raised.</p>
</li>
<li><p class="first">But now for a more complicated case.  The approach described
above is suitable for most built-in objects such as lists,
strings, numbers.  However, some object types have a dictionary
in each instance that can store arbitrary attributes.  In fact,
when you use a class statement to subtype an existing built-in
type, you automatically get such a dictionary (unless you
explicitly turn it off, using another advanced feature,
<tt class="docutils literal">__slots__</tt>).  Let's call this the instance dict, to distinguish
it from the type dict.</p>
</li>
<li><p class="first">In the more complicated case, there's a conflict between names
stored in the instance dict and names stored in the type dict.
If both dicts have an entry with the same key, which one should
we return?  Looking at classic Python for guidance, I find
conflicting rules: for class instances, the instance dict
overrides the class dict, <strong>except</strong> for the special attributes
(like <tt class="docutils literal">__dict__</tt> and <tt class="docutils literal">__class__</tt>), which have priority over the
instance dict.</p>
</li>
<li><p class="first">I resolved this with the following set of rules, implemented in
<tt class="docutils literal">PyObject_GenericGetAttr()</tt>:</p>
<ol class="arabic simple">
<li>Look in the type dict.  If you find a <strong>data</strong> descriptor, use
its <tt class="docutils literal">get()</tt> method to produce the result.  This takes care of
special attributes like <tt class="docutils literal">__dict__</tt> and <tt class="docutils literal">__class__</tt>.</li>
<li>Look in the instance dict.  If you find anything, that's it.
(This takes care of the requirement that normally the
instance dict overrides the class dict.)</li>
<li>Look in the type dict again (in reality this uses the saved
result from step 1, of course).  If you find a descriptor,
use its <tt class="docutils literal">get()</tt> method; if you find something else, that's it;
if it's not there, raise <tt class="docutils literal">AttributeError</tt>.</li>
</ol>
<p>This requires a classification of descriptors as data and
nondata descriptors.  The current implementation quite sensibly
classifies member and getset descriptors as data (even if they
are read-only!)  and method descriptors as nondata.
Non-descriptors (like function pointers or plain values) are
also classified as non-data (!).</p>
</li>
<li><p class="first">This scheme has one drawback: in what I assume to be the most
common case, referencing an instance variable stored in the
instance dict, it does <strong>two</strong> dictionary lookups, whereas the
classic scheme did a quick test for attributes starting with two
underscores plus a single dictionary lookup.  (Although the
implementation is sadly structured as <tt class="docutils literal">instance_getattr()</tt> calling
<tt class="docutils literal">instance_getattr1()</tt> calling <tt class="docutils literal">instance_getattr2()</tt> which finally
calls <tt class="docutils literal">PyDict_GetItem()</tt>, and the underscore test calls
<tt class="docutils literal">PyString_AsString()</tt> rather than inlining this.  I wonder if
optimizing the snot out of this might not be a good idea to
speed up Python 2.2, if we weren't going to rip it all out. :-)</p>
</li>
<li><p class="first">A benchmark verifies that in fact this is as fast as classic
instance variable lookup, so I'm no longer worried.</p>
</li>
<li><p class="first">Modification for dynamic types: step 1 and 3 look in the
dictionary of the type and all its base classes (in MRO
sequence, or couse).</p>
</li>
</ul>
</div>
<div class="section" id="discussion">
<h1><a class="toc-backref" href="#id8">Discussion</a></h1>
<p>XXX</p>
</div>
<div class="section" id="examples">
<h1><a class="toc-backref" href="#id9">Examples</a></h1>
<p>Let's look at lists.  In classic Python, the method names of
lists were available as the __methods__ attribute of list objects:</p>
<pre class="literal-block">
&gt;&gt;&gt; [].__methods__
['append', 'count', 'extend', 'index', 'insert', 'pop',
'remove', 'reverse', 'sort']
&gt;&gt;&gt;
</pre>
<p>Under the new proposal, the __methods__ attribute no longer exists:</p>
<pre class="literal-block">
&gt;&gt;&gt; [].__methods__
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
AttributeError: 'list' object has no attribute '__methods__'
&gt;&gt;&gt;
</pre>
<p>Instead, you can get the same information from the list type:</p>
<pre class="literal-block">
&gt;&gt;&gt; T = [].__class__
&gt;&gt;&gt; T
&lt;type 'list'&gt;
&gt;&gt;&gt; dir(T)                # like T.__dict__.keys(), but sorted
['__add__', '__class__', '__contains__', '__eq__', '__ge__',
'__getattr__', '__getitem__', '__getslice__', '__gt__',
'__iadd__', '__imul__', '__init__', '__le__', '__len__',
'__lt__', '__mul__', '__ne__', '__new__', '__radd__',
'__repr__', '__rmul__', '__setitem__', '__setslice__', 'append',
'count', 'extend', 'index', 'insert', 'pop', 'remove',
'reverse', 'sort']
&gt;&gt;&gt;
</pre>
<p>The new introspection API gives more information than the old one:
in addition to the regular methods, it also shows the methods that
are normally invoked through special notations, e.g.  <tt class="docutils literal">__iadd__</tt>
(<tt class="docutils literal">+=</tt>), <tt class="docutils literal">__len__</tt> (<tt class="docutils literal">len</tt>), <tt class="docutils literal">__ne__</tt> (<tt class="docutils literal">!=</tt>).
You can invoke any method from this list directly:</p>
<pre class="literal-block">
&gt;&gt;&gt; a = ['tic', 'tac']
&gt;&gt;&gt; T.__len__(a)          # same as len(a)
2
&gt;&gt;&gt; T.append(a, 'toe')    # same as a.append('toe')
&gt;&gt;&gt; a
['tic', 'tac', 'toe']
&gt;&gt;&gt;
</pre>
<p>This is just like it is for user-defined classes.</p>
<p>Notice a familiar yet surprising name in the list: <tt class="docutils literal">__init__</tt>.  This
is the domain of <a class="reference external" href="/dev/peps/pep-0253">PEP 253</a>.</p>
</div>
<div class="section" id="backwards-compatibility">
<h1><a class="toc-backref" href="#id10">Backwards compatibility</a></h1>
<p>XXX</p>
</div>
<div class="section" id="warnings-and-errors">
<h1><a class="toc-backref" href="#id11">Warnings and Errors</a></h1>
<p>XXX</p>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id12">Implementation</a></h1>
<p>A partial implementation of this PEP is available from CVS as a
branch named &quot;descr-branch&quot;.  To experiment with this
implementation, proceed to check out Python from CVS according to
the instructions at <a class="reference external" href="http://sourceforge.net/cvs/?group_id=5470">http://sourceforge.net/cvs/?group_id=5470</a> but
add the arguments &quot;-r descr-branch&quot; to the cvs checkout command.
(You can also start with an existing checkout and do &quot;cvs update
-r descr-branch&quot;.)  For some examples of the features described
here, see the file Lib/test/test_descr.py.</p>
<p>Note: the code in this branch goes way beyond this PEP; it is also
the experimentation area for <a class="reference external" href="/dev/peps/pep-0253">PEP 253</a> (Subtyping Built-in Types).</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id13">References</a></h1>
<p>XXX</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id14">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

