<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">222</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Web Library Enhancements</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0222.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">A.M. Kuchling &lt;amk&#32;&#97;t&#32;amk.ca&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Deferred</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">18-Aug-2000</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.1</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">22-Dec-2000</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id2">Abstract</a></li>
<li><a class="reference internal" href="#open-issues" id="id3">Open Issues</a></li>
<li><a class="reference internal" href="#new-modules" id="id4">New Modules</a></li>
<li><a class="reference internal" href="#major-changes-to-existing-modules" id="id5">Major Changes to Existing Modules</a></li>
<li><a class="reference internal" href="#minor-changes-to-existing-modules" id="id6">Minor Changes to Existing Modules</a></li>
<li><a class="reference internal" href="#rejected-changes" id="id7">Rejected Changes</a></li>
<li><a class="reference internal" href="#proposed-interface" id="id8">Proposed Interface</a></li>
<li><a class="reference internal" href="#copyright" id="id9">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id2">Abstract</a></h1>
<p>This PEP proposes a set of enhancements to the CGI development
facilities in the Python standard library.  Enhancements might be
new features, new modules for tasks such as cookie support, or
removal of obsolete code.</p>
<p>The original intent was to make improvements to Python 2.1.
However, there seemed little interest from the Python community,
and time was lacking, so this PEP has been deferred to some future
Python release.</p>
</div>
<div class="section" id="open-issues">
<h1><a class="toc-backref" href="#id3">Open Issues</a></h1>
<p>This section lists changes that have been suggested, but about
which no firm decision has yet been made.  In the final version of
this PEP, this section should be empty, as all the changes should
be classified as accepted or rejected.</p>
<p>cgi.py: We should not be told to create our own subclass just so
we can handle file uploads. As a practical matter, I have yet to
find the time to do this right, so I end up reading cgi.py's temp
file into, at best, another file. Some of our legacy code actually
reads it into a second temp file, then into a final destination!
And even if we did, that would mean creating yet another object
with its <tt class="docutils literal">__init__</tt> call and associated overhead.</p>
<p>cgi.py: Currently, query data with no <tt class="docutils literal">=</tt> are ignored.  Even if
<tt class="docutils literal">keep_blank_values</tt> is set, queries like <tt class="docutils literal"><span class="pre">...?value=&amp;...</span></tt> are
returned with blank values but queries like <tt class="docutils literal"><span class="pre">...?value&amp;...</span></tt> are
completely lost.  It would be great if such data were made
available through the <tt class="docutils literal">FieldStorage</tt> interface, either as entries
with <tt class="docutils literal">None</tt> as values, or in a separate list.</p>
<p>Utility function: build a query string from a list of 2-tuples</p>
<p>Dictionary-related utility classes: <tt class="docutils literal">NoKeyErrors</tt> (returns an empty
string, never a <tt class="docutils literal">KeyError</tt>), <tt class="docutils literal">PartialStringSubstitution</tt> (returns
the original key string, never a <tt class="docutils literal">KeyError</tt>)</p>
</div>
<div class="section" id="new-modules">
<h1><a class="toc-backref" href="#id4">New Modules</a></h1>
<p>This section lists details about entire new packages or modules
that should be added to the Python standard library.</p>
<ul class="simple">
<li>fcgi.py : A new module adding support for the FastCGI protocol.
Robin Dunn's code needs to be ported to Windows, though.</li>
</ul>
</div>
<div class="section" id="major-changes-to-existing-modules">
<h1><a class="toc-backref" href="#id5">Major Changes to Existing Modules</a></h1>
<p>This section lists details of major changes to existing modules,
whether in implementation or in interface.  The changes in this
section therefore carry greater degrees of risk, either in
introducing bugs or a backward incompatibility.</p>
<p>The cgi.py module would be deprecated.  (XXX A new module or
package name hasn't been chosen yet: 'web'?  'cgilib'?)</p>
</div>
<div class="section" id="minor-changes-to-existing-modules">
<h1><a class="toc-backref" href="#id6">Minor Changes to Existing Modules</a></h1>
<p>This section lists details of minor changes to existing modules.
These changes should have relatively small implementations, and
have little risk of introducing incompatibilities with previous
versions.</p>
</div>
<div class="section" id="rejected-changes">
<h1><a class="toc-backref" href="#id7">Rejected Changes</a></h1>
<p>The changes listed in this section were proposed for Python 2.1,
but were rejected as unsuitable.  For each rejected change, a
rationale is given describing why the change was deemed
inappropriate.</p>
<ul class="simple">
<li>An HTML generation module is not part of this PEP.  Several such
modules exist, ranging from HTMLgen's purely programming
interface to ASP-inspired simple templating to DTML's complex
templating.  There's no indication of which templating module to
enshrine in the standard library, and that probably means that
no module should be so chosen.</li>
<li>cgi.py: Allowing a combination of query data and POST data.
This doesn't seem to be standard at all, and therefore is
dubious practice.</li>
</ul>
</div>
<div class="section" id="proposed-interface">
<h1><a class="toc-backref" href="#id8">Proposed Interface</a></h1>
<p>XXX open issues: naming convention (studlycaps or
underline-separated?); need to look at the <tt class="docutils literal"><span class="pre">cgi.parse*()</span></tt> functions
and see if they can be simplified, too.</p>
<p>Parsing functions: carry over most of the <tt class="docutils literal">parse*</tt> functions from
cgi.py</p>
<pre class="literal-block">
# The Response class borrows most of its methods from Zope's
# HTTPResponse class.

class Response:
    &quot;&quot;&quot;
    Attributes:
    status: HTTP status code to return
    headers: dictionary of response headers
    body: string containing the body of the HTTP response
    &quot;&quot;&quot;

    def __init__(self, status=200, headers={}, body=&quot;&quot;):
        pass

    def setStatus(self, status, reason=None):
        &quot;Set the numeric HTTP response code&quot;
        pass

    def setHeader(self, name, value):
        &quot;Set an HTTP header&quot;
        pass

    def setBody(self, body):
        &quot;Set the body of the response&quot;
        pass

    def setCookie(self, name, value,
                  path = '/',
                  comment = None,
                  domain = None,
                  max-age = None,
                  expires = None,
                  secure = 0
                  ):
        &quot;Set a cookie&quot;
        pass

    def expireCookie(self, name):
        &quot;Remove a cookie from the user&quot;
        pass

    def redirect(self, url):
        &quot;Redirect the browser to another URL&quot;
        pass

    def __str__(self):
        &quot;Convert entire response to a string&quot;
        pass

    def dump(self):
        &quot;Return a string representation useful for debugging&quot;
        pass

    # XXX methods for specific classes of error:serverError,
    # badRequest, etc.?


class Request:

    &quot;&quot;&quot;
    Attributes:

    XXX should these be dictionaries, or dictionary-like objects?
    .headers : dictionary containing HTTP headers
    .cookies : dictionary of cookies
    .fields  : data from the form
    .env     : environment dictionary
    &quot;&quot;&quot;

    def __init__(self, environ=os.environ, stdin=sys.stdin,
                 keep_blank_values=1, strict_parsing=0):
        &quot;&quot;&quot;Initialize the request object, using the provided environment
        and standard input.&quot;&quot;&quot;
        pass

    # Should people just use the dictionaries directly?
    def getHeader(self, name, default=None):
        pass

    def getCookie(self, name, default=None):
        pass

    def getField(self, name, default=None):
        &quot;Return field's value as a string (even if it's an uploaded file)&quot;
        pass

    def getUploadedFile(self, name):
        &quot;&quot;&quot;Returns a file object that can be read to obtain the contents
        of an uploaded file.  XXX should this report an error if the
        field isn't actually an uploaded file?  Or should it wrap
        a StringIO around simple fields for consistency?
        &quot;&quot;&quot;

    def getURL(self, n=0, query_string=0):
        &quot;&quot;&quot;Return the URL of the current request, chopping off 'n' path
        components from the right.  Eg. if the URL is
        &quot;http://foo.com/bar/baz/quux&quot;, n=2 would return
        &quot;http://foo.com/bar&quot;.  Does not include the query string (if
        any)
        &quot;&quot;&quot;

    def getBaseURL(self, n=0):
        &quot;&quot;&quot;Return the base URL of the current request, adding 'n' path
        components to the end to recreate more of the whole URL.

        Eg. if the request URL is
        &quot;http://foo.com/q/bar/baz/qux&quot;, n=0 would return
        &quot;http://foo.com/&quot;, and n=2 &quot;http://foo.com/q/bar&quot;.

        Returned URL does not include the query string, if any.
        &quot;&quot;&quot;

    def dump(self):
        &quot;String representation suitable for debugging output&quot;
        pass

    # Possibilities?  I don't know if these are worth doing in the
    # basic objects.
    def getBrowser(self):
        &quot;Returns Mozilla/IE/Lynx/Opera/whatever&quot;

    def isSecure(self):
        &quot;Return true if this is an SSLified request&quot;


# Module-level function
def wrapper(func, logfile=sys.stderr):
    &quot;&quot;&quot;
    Calls the function 'func', passing it the arguments
    (request, response, logfile).  Exceptions are trapped and
    sent to the file 'logfile'.
    &quot;&quot;&quot;
    # This wrapper will detect if it's being called from the command-line,
    # and if so, it will run in a debugging mode; name=value pairs
    # can be entered on standard input to set field values.
    # (XXX how to do file uploads in this syntax?)
</pre>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id9">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

