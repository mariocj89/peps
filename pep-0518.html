<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">518</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Specifying Minimum Build System Requirements for Python Projects</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0518.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Brett Cannon &lt;brett&#32;&#97;t&#32;python.org&gt;,
Nathaniel Smith &lt;njs&#32;&#97;t&#32;pobox.com&gt;,
Donald Stufft &lt;donald&#32;&#97;t&#32;stufft.io&gt;</td>
</tr>
<tr class="field"><th class="field-name">BDFL-Delegate:</th><td class="field-body">Nick Coghlan</td>
</tr>
<tr class="field"><th class="field-name">Discussions-To:</th><td class="field-body">distutils-sig &lt;distutils-sig at python.org&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Accepted</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Informational</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">10-May-2016</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">10-May-2016,
11-May-2016,
13-May-2016</td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/distutils-sig/2016-May/028969.html">https://mail.python.org/pipermail/distutils-sig/2016-May/028969.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id22">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id23">Rationale</a></li>
<li><a class="reference internal" href="#specification" id="id24">Specification</a></li>
<li><a class="reference internal" href="#rejected-ideas" id="id25">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#a-semantic-version-key" id="id26">A semantic version key</a></li>
<li><a class="reference internal" href="#a-more-nested-namespace" id="id27">A more nested namespace</a></li>
<li><a class="reference internal" href="#other-table-names" id="id28">Other table names</a></li>
<li><a class="reference internal" href="#other-file-formats" id="id29">Other file formats</a><ul>
<li><a class="reference internal" href="#json" id="id30">JSON</a></li>
<li><a class="reference internal" href="#yaml" id="id31">YAML</a></li>
<li><a class="reference internal" href="#configparser" id="id32">configparser</a></li>
<li><a class="reference internal" href="#python-literals" id="id33">Python literals</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-file-names" id="id34">Other file names</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references" id="id35">References</a></li>
<li><a class="reference internal" href="#copyright" id="id36">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id22">Abstract</a></h1>
<p>This PEP specifies how Python software packages should specify what
dependencies they have in order to execute their chosen build system.
As part of this specification, a new configuration file is introduced
for software packages to use to specify their build dependencies (with
the expectation that the same configuration file will be used for
future configuration details).</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id23">Rationale</a></h1>
<p>When Python first developed its tooling for building distributions of
software for projects, distutils <a class="footnote-reference" href="#distutils" id="id1">[1]</a> was the chosen
solution. As time went on, setuptools <a class="footnote-reference" href="#setuptools" id="id2">[2]</a> gained popularity
to add some features on top of distutils. Both used the concept of a
<tt class="docutils literal">setup.py</tt> file that project maintainers executed to build
distributions of their software (as well as users to install said
distribution).</p>
<p>Using an executable file to specify build requirements under distutils
isn't an issue as distutils is part of Python's standard library.
Having the build tool as part of Python means that a <tt class="docutils literal">setup.py</tt> has
no external dependency that a project maintainer needs to worry about
to build a distribution of their project. There was no need to specify
any dependency information as the only dependency is Python.</p>
<p>But when a project chooses to use setuptools, the use of an executable
file like <tt class="docutils literal">setup.py</tt> becomes an issue. You can't execute a
<tt class="docutils literal">setup.py</tt> file without knowing its dependencies, but currently
there is no standard way to know what those dependencies are in an
automated fashion without executing the <tt class="docutils literal">setup.py</tt> file where that
information is stored. It's a catch-22 of a file not being runnable
without knowing its own contents which can't be known programmatically
unless you run the file.</p>
<p>Setuptools tried to solve this with a <tt class="docutils literal">setup_requires</tt> argument to
its <tt class="docutils literal">setup()</tt> function <a class="footnote-reference" href="#setup-args" id="id3">[3]</a>. This solution has a number
of issues, such as:</p>
<ul class="simple">
<li>No tooling (besides setuptools itself) can access this information
without executing the <tt class="docutils literal">setup.py</tt>, but <tt class="docutils literal">setup.py</tt> can't be
executed without having these items installed.</li>
<li>While setuptools itself will install anything listed in this, they
won't be installed until <em>during</em> the execution of the <tt class="docutils literal">setup()</tt>
function, which means that the only way to actually use anything
added here is through increasingly complex machinations that delay
the import and usage of these modules until later on in the
execution of the <tt class="docutils literal">setup()</tt> function.</li>
<li>This cannot include <tt class="docutils literal">setuptools</tt> itself nor can it include a
replacement to <tt class="docutils literal">setuptools</tt>, which means that projects such as
<tt class="docutils literal">numpy.distutils</tt> are largely incapable of utilizing it and
projects cannot take advantage of newer setuptools features until
their users naturally upgrade the version of setuptools to a newer
one.</li>
<li>The items listed in <tt class="docutils literal">setup_requires</tt> get implicily installed
whenever you execute the <tt class="docutils literal">setup.py</tt> but one of the common ways
that the <tt class="docutils literal">setup.py</tt> is executed is via another tool, such as
<tt class="docutils literal">pip</tt>, who is already managing dependencies. This means that
a command like <tt class="docutils literal">pip install spam</tt> might end up having both
pip and setuptools downloading and installing packages and end
users needing to configure <em>both</em> tools (and for <tt class="docutils literal">setuptools</tt>
without being in control of the invocation) to change settings
like which repository it installs from. It also means that users
need to be aware of the discovery rules for both tools, as one
may support different package formats or determine the latest
version differently.</li>
</ul>
<p>This has cumulated in a situation where use of <tt class="docutils literal">setup_requires</tt>
is rare, where projects tend to either simply copy and paste snippets
between <tt class="docutils literal">setup.py</tt> files or they eschew it all together in favor
of simply documenting elsewhere what they expect the user to have
manually installed prior to attempting to build or install their
project.</p>
<p>All of this has led pip <a class="footnote-reference" href="#pip" id="id4">[4]</a> to simply assume that setuptools is
necessary when executing a <tt class="docutils literal">setup.py</tt> file. The problem with this,
though, is it doesn't scale if another project began to gain traction
in the community as setuptools has. It also prevents other projects
from gaining traction due to the friction required to use it with a
project when pip can't infer the fact that something other than
setuptools is required.</p>
<p>This PEP attempts to rectify the situation by specifying a way to list
the minimal dependencies of the build system of a project in a
declarative fashion in a specific file. This allows a project to list
what build dependencies it has to go from e.g. source checkout to
wheel, while not falling into the catch-22 trap that a <tt class="docutils literal">setup.py</tt>
has where tooling can't infer what a project needs to build itself.
Implementing this PEP will allow projects to specify what build system
they depend on upfront so that tools like pip can make sure that they
are installed in order to run the build system to build the project.</p>
<p>To provide more context and motivation for this PEP, think of the
(rough) steps required to produce a built artifact for a project:</p>
<ol class="arabic simple">
<li>The source checkout of the project.</li>
<li>Installation of the build system.</li>
<li>Execute the build system.</li>
</ol>
<p>This PEP covers step #2. It is fully expected that a future PEP will
cover step #3, including how to have the build system dynamically
specify more dependencies that the build system requires to perform
its job. The purpose of this PEP though, is to specify the minimal set
of requirements for the build system to simply begin execution.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id24">Specification</a></h1>
<p>The build system dependencies will be stored in a file named
<tt class="docutils literal">pyproject.toml</tt> that is written in the TOML format <a class="footnote-reference" href="#toml" id="id5">[6]</a>. This
format was chosen as it is human-usable (unlike JSON <a class="footnote-reference" href="#id19" id="id6">[7]</a>), it is
flexible enough (unlike configparser <a class="footnote-reference" href="#id21" id="id7">[9]</a>), stems from a
standard (also unlike configparser <a class="footnote-reference" href="#id21" id="id8">[9]</a>), and it is not
overly complex (unlike YAML <a class="footnote-reference" href="#id20" id="id9">[8]</a>). The TOML format is already in
use by the Rust community as part of their
Cargo package manager <a class="footnote-reference" href="#cargo" id="id10">[14]</a> and in private email stated they have
been quite happy with their choice of TOML. A more thorough
discussion as to why various alternatives were not chosen can be read
in the <a class="reference internal" href="#other-file-formats">Other file formats</a> section.</p>
<p>There will be a <tt class="docutils literal"><span class="pre">[build-system]</span></tt> table in the
configuration file to store build-related data. Initially only one key
of the table will be valid and mandatory: <tt class="docutils literal">requires</tt>. That key will
have a value of a list of strings representing the <a class="reference external" href="/dev/peps/pep-0508">PEP 508</a>
dependencies required to execute the build system (currently that
means what dependencies are required to execute a <tt class="docutils literal">setup.py</tt> file).</p>
<p>To provide a type-specific representation of the resulting data from
the TOML file for illustrative purposes only, the following JSON
Schema <a class="footnote-reference" href="#jsonschema" id="id11">[15]</a> would match the data format:</p>
<pre class="literal-block">
{
    &quot;$schema&quot;: &quot;http://json-schema.org/schema#&quot;,

    &quot;type&quot;: &quot;object&quot;,
    &quot;additionalProperties&quot;: false,

    &quot;properties&quot;: {
        &quot;build-system&quot;: {
            &quot;type&quot;: &quot;object&quot;,
            &quot;additionalProperties&quot;: false,

            &quot;properties&quot;: {
                &quot;requires&quot;: {
                    &quot;type&quot;: &quot;array&quot;,
                    &quot;items&quot;: {
                        &quot;type&quot;: &quot;string&quot;
                    }
                }
            },
            &quot;required&quot;: [&quot;requires&quot;]
        },

        &quot;tool&quot;: {
            &quot;type&quot;: &quot;object&quot;
        }
    }
}
</pre>
<p>For the vast majority of Python projects that rely upon setuptools,
the <tt class="docutils literal">pyproject.toml</tt> file will be:</p>
<pre class="literal-block">
[build-system]
# Minimum requirements for the build system to execute.
requires = [&quot;setuptools&quot;, &quot;wheel&quot;]  # PEP 508 specifications.
</pre>
<p>Because the use of setuptools and wheel are so expansive in the
community at the moment, build tools are expected to use the example
configuration file above as their default semantics when a
<tt class="docutils literal">pyproject.toml</tt> file is not present.</p>
<p>All other top-level keys and tables are reserved for future use by
other PEPs except for the <tt class="docutils literal">[tool]</tt> table. Within that table, tools
can have users specify configuration data as long as they use a
sub-table within <tt class="docutils literal">[tool]</tt>, e.g. the
<a class="reference external" href="https://pypi.python.org/pypi/flit">flit</a> tool would store its
configuration in <tt class="docutils literal">[tool.flit]</tt>.</p>
<p>We need some mechanism to allocate names within the <tt class="docutils literal">tool.*</tt>
namespace, to make sure that different projects don't attempt to use
the same sub-table and collide. Our rule is that a project can use
the subtable <tt class="docutils literal"><span class="pre">tool.$NAME</span></tt> if, and only if, they own the entry for
<tt class="docutils literal">$NAME</tt> in the Cheeseshop/PyPI.</p>
</div>
<div class="section" id="rejected-ideas">
<h1><a class="toc-backref" href="#id25">Rejected Ideas</a></h1>
<div class="section" id="a-semantic-version-key">
<h2><a class="toc-backref" href="#id26">A semantic version key</a></h2>
<p>For future-proofing the structure of the configuration file, a
<tt class="docutils literal"><span class="pre">semantics-version</span></tt> key was initially proposed. Defaulting to <tt class="docutils literal">1</tt>,
the idea was that if any semantics changes to previously defined keys
or tables occurred which were not backwards-compatible, then the
<tt class="docutils literal"><span class="pre">semantics-version</span></tt> would be incremented to a new number.</p>
<p>In the end, though, it was decided that this was a premature
optimization. The expectation is that changes to what is pre-defined
semantically in the configuration file will be rather conservative.
And in the instances where a backwards-incompatible change would have
occurred, different names can be used for the new semantics to avoid
breaking older tools.</p>
</div>
<div class="section" id="a-more-nested-namespace">
<h2><a class="toc-backref" href="#id27">A more nested namespace</a></h2>
<p>An earlier draft of this PEP had a top-level <tt class="docutils literal">[package]</tt> table. The
idea was to impose some scoping for a semantics versioning scheme
(see <a class="reference internal" href="#a-semantic-version-key">A semantic version key</a> for why that idea was rejected).
With the need for scoping removed, the point of having a top-level
table became superfluous.</p>
</div>
<div class="section" id="other-table-names">
<h2><a class="toc-backref" href="#id28">Other table names</a></h2>
<p>Another name proposed for the <tt class="docutils literal"><span class="pre">[build-system]</span></tt> table was
<tt class="docutils literal">[build]</tt>. The alternative name is shorter, but doesn't convey as
much of the intention of what information is store in the table. After
a vote on the distutils-sig mailing list, the current name won out.</p>
</div>
<div class="section" id="other-file-formats">
<h2><a class="toc-backref" href="#id29">Other file formats</a></h2>
<p>Several other file formats were put forward for consideration, all
rejected for various reasons. Key requirements were that the format
be editable by human beings and have an implementation that can be
vendored easily by projects. This outright excluded certain formats
like XML which are not friendly towards human beings and were never
seriously discussed.</p>
<div class="section" id="json">
<h3><a class="toc-backref" href="#id30">JSON</a></h3>
<p>The JSON format <a class="footnote-reference" href="#id19" id="id12">[7]</a> was initially considered but quickly
rejected. While great as a human-readable, string-based data exchange
format, the syntax does not lend itself to easy editing by a human
being (e.g. the syntax is more verbose than necessary while not
allowing for comments).</p>
<p>An example JSON file for the proposed data would be:</p>
<pre class="literal-block">
{
    &quot;build&quot;: {
        &quot;requires&quot;: [
            &quot;setuptools&quot;,
            &quot;wheel&gt;=0.27&quot;
        ]
    }
}
</pre>
</div>
<div class="section" id="yaml">
<h3><a class="toc-backref" href="#id31">YAML</a></h3>
<p>The YAML format <a class="footnote-reference" href="#id20" id="id13">[8]</a> was designed to be a superset of JSON
<a class="footnote-reference" href="#id19" id="id14">[7]</a> while being easier to work with by hand. There are three main
issues with YAML.</p>
<p>One is that the specification is large: 86 pages if printed on
letter-sized paper. That leaves the possibility that someone may use a
feature of YAML that works with one parser but not another. It has
been suggested to standardize on a subset, but that basically means
creating a new standard specific to this file which is not tractable
long-term.</p>
<p>Two is that YAML itself is not safe by default. The specification
allows for the arbitrary execution of code which is best avoided when
dealing with configuration data.  It is of course possible to avoid
this behavior -- for example, PyYAML provides a <tt class="docutils literal">safe_load</tt> operation
-- but if any tool carelessly uses <tt class="docutils literal">load</tt> instead then they open
themselves up to arbitrary code execution. While this PEP is focused on
the building of projects which inherently involves code execution,
other configuration data such as project name and version number may
end up in the same file someday where arbitrary code execution is not
desired.</p>
<p>And finally, the most popular Python implemenation of YAML is
PyYAML <a class="footnote-reference" href="#pyyaml" id="id15">[10]</a> which is a large project of a few thousand lines of
code and an optional C extension module. While in and of itself this
isn't necessarily an issue, this becomes more of a problem for
projects like pip where they would most likely need to vendor PyYAML
as a dependency so as to be fully self-contained (otherwise you end
up with your install tool needing an install tool to work). A
proof-of-concept re-working of PyYAML has been done to see how easy
it would be to potentially vendor a simpler version of the library
which shows it is a possibility.</p>
<p>An example YAML file is:</p>
<pre class="literal-block">
build:
    requires:
        - setuptools
        - wheel&gt;=0.27
</pre>
</div>
<div class="section" id="configparser">
<h3><a class="toc-backref" href="#id32">configparser</a></h3>
<p>An INI-style configuration file based on what
configparser <a class="footnote-reference" href="#id21" id="id16">[9]</a> accepts was considered. Unfortunately
there is no specification of what configparser accepts, leading to
support skew between versions. For instance, what ConfigParser in
Python 2.7 accepts is not the same as what configparser in Python 3
accepts. While one could standardize on what Python 3 accepts and
simply vendor the backport of the configparser module, that does mean
this PEP would have to codify that the backport of configparser must
be used by all project wishes to consume the metadata specified by
this PEP. This is overly restrictive and could lead to confusion if
someone is not aware of that a specific version of configparser is
expected.</p>
<p>An example INI file is:</p>
<pre class="literal-block">
[build]
requires =
    setuptools
    wheel&gt;=0.27
</pre>
</div>
<div class="section" id="python-literals">
<h3><a class="toc-backref" href="#id33">Python literals</a></h3>
<p>Someone proposed using Python literals as the configuration format.
The file would contain one dict at the top level, with the data all
inside that dict, with sections defined by the keys. All Python
programmers would be used to the format, there would implicitly be no
third-party dependency to read the configuration data, and it can be
safe if parsed by <tt class="docutils literal">ast.literal_eval()</tt> <a class="footnote-reference" href="#ast-literal-eval" id="id17">[13]</a>.
Python literals can be identical to JSON, with the added benefit of
supporting trailing commas and comments. In addition, Python's richer
data model may be useful for some future configuration needs (e.g. non-string
dict keys, floating point vs. integer values).</p>
<p>On the other hand, python literals are a Python-specific format, and
it is anticipated that these data may need to be read by packaging
tools, etc. that are not written in Python.</p>
<p>An example Python literal file for the proposed data would be:</p>
<pre class="literal-block">
# The build configuration
{&quot;build&quot;: {&quot;requires&quot;: [&quot;setuptools&quot;,
                        &quot;wheel&gt;=0.27&quot;, # note the trailing comma
                        # &quot;numpy&gt;=1.10&quot; # a commented out data line
                        ]
# and here is an arbitrary comment.
           }
 }
</pre>
</div>
</div>
<div class="section" id="other-file-names">
<h2><a class="toc-backref" href="#id34">Other file names</a></h2>
<p>Several other file names were considered and rejected (although this
is very much a bikeshedding topic, and so the decision comes down to
mostly taste).</p>
<dl class="docutils">
<dt>pysettings.toml</dt>
<dd>Most reasonable alternative.</dd>
<dt>pypa.toml</dt>
<dd>While it makes sense to reference the PyPA <a class="footnote-reference" href="#pypa" id="id18">[11]</a>, it is a
somewhat niche term. It's better to have the file name make sense
without having domain-specific knowledge.</dd>
<dt>pybuild.toml</dt>
<dd>From the restrictive perspective of this PEP this filename makes
sense, but if any non-build metadata ever gets added to the file
then the name ceases to make sense.</dd>
<dt>pip.toml</dt>
<dd>Too tool-specific.</dd>
<dt>meta.toml</dt>
<dd>Too generic; project may want to have its own metadata file.</dd>
<dt>setup.toml</dt>
<dd>While keeping with traditional thanks to <tt class="docutils literal">setup.py</tt>, it does not
necessarily match what the file may contain in the future (.e.g is
knowing the name of a project inerhently part of its setup?).</dd>
<dt>pymeta.toml</dt>
<dd>Not obvious to newcomers to programming and/or Python.</dd>
<dt>pypackage.toml &amp; pypackaging.toml</dt>
<dd>Name conflation of what a &quot;package&quot; is (project versus namespace).</dd>
<dt>pydevelop.toml</dt>
<dd>The file may contain details not specific to development.</dd>
<dt>pysource.toml</dt>
<dd>Not directly related to source code.</dd>
<dt>pytools.toml</dt>
<dd>Misleading as the file is (currently) aimed at project management.</dd>
<dt>dstufft.toml</dt>
<dd>Too person-specific. ;)</dd>
</dl>
</div>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id35">References</a></h1>
<table class="docutils footnote" frame="void" id="distutils" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>distutils
(<a class="reference external" href="https://docs.python.org/3/library/distutils.html#module-distutils">https://docs.python.org/3/library/distutils.html#module-distutils</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="setuptools" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>setuptools
(<a class="reference external" href="https://pypi.python.org/pypi/setuptools">https://pypi.python.org/pypi/setuptools</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="setup-args" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>setuptools: New and Changed setup() Keywords
(<a class="reference external" href="http://pythonhosted.org/setuptools/setuptools.html#new-and-changed-setup-keywords">http://pythonhosted.org/setuptools/setuptools.html#new-and-changed-setup-keywords</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="pip" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>pip
(<a class="reference external" href="https://pypi.python.org/pypi/pip">https://pypi.python.org/pypi/pip</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="wheel" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td>wheel
(<a class="reference external" href="https://pypi.python.org/pypi/wheel">https://pypi.python.org/pypi/wheel</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="toml" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[6]</a></td><td>TOML
(<a class="reference external" href="https://github.com/toml-lang/toml">https://github.com/toml-lang/toml</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[7]</td><td><em>(<a class="fn-backref" href="#id6">1</a>, <a class="fn-backref" href="#id12">2</a>, <a class="fn-backref" href="#id14">3</a>)</em> JSON
(<a class="reference external" href="http://json.org/">http://json.org/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[8]</td><td><em>(<a class="fn-backref" href="#id9">1</a>, <a class="fn-backref" href="#id13">2</a>)</em> YAML
(<a class="reference external" href="http://yaml.org/">http://yaml.org/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[9]</td><td><em>(<a class="fn-backref" href="#id7">1</a>, <a class="fn-backref" href="#id8">2</a>, <a class="fn-backref" href="#id16">3</a>)</em> configparser
(<a class="reference external" href="https://docs.python.org/3/library/configparser.html#module-configparser">https://docs.python.org/3/library/configparser.html#module-configparser</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="pyyaml" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[10]</a></td><td>PyYAML
(<a class="reference external" href="https://pypi.python.org/pypi/PyYAML">https://pypi.python.org/pypi/PyYAML</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="pypa" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[11]</a></td><td>PyPA
(<a class="reference external" href="https://www.pypa.io">https://www.pypa.io</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="bazel" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[12]</td><td>Bazel
(<a class="reference external" href="http://bazel.io/">http://bazel.io/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="ast-literal-eval" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[13]</a></td><td><tt class="docutils literal">ast.literal_eval()</tt>
(<a class="reference external" href="https://docs.python.org/3/library/ast.html#ast.literal_eval">https://docs.python.org/3/library/ast.html#ast.literal_eval</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="cargo" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[14]</a></td><td>Cargo, Rust's package manager
(<a class="reference external" href="http://doc.crates.io/">http://doc.crates.io/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="jsonschema" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[15]</a></td><td>JSON Schema
(<a class="reference external" href="http://json-schema.org/">http://json-schema.org/</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id36">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

