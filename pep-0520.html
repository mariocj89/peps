<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">520</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Preserving Class Attribute Definition Order</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0520.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Eric Snow &lt;ericsnowcurrently&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">7-Jun-2016</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.6</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">7-Jun-2016, 11-Jun-2016, 20-Jun-2016, 24-Jun-2016</td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2016-June/145442.html">https://mail.python.org/pipermail/python-dev/2016-June/145442.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id1">Abstract</a></li>
<li><a class="reference internal" href="#motivation" id="id2">Motivation</a></li>
<li><a class="reference internal" href="#background" id="id3">Background</a></li>
<li><a class="reference internal" href="#specification" id="id4">Specification</a><ul>
<li><a class="reference internal" href="#why-a-tuple" id="id5">Why a tuple?</a></li>
<li><a class="reference internal" href="#why-not-a-read-only-attribute" id="id6">Why not a read-only attribute?</a></li>
<li><a class="reference internal" href="#why-not-attribute-order" id="id7">Why not &quot;__attribute_order__&quot;?</a></li>
<li><a class="reference internal" href="#why-not-ignore-dunder-names" id="id8">Why not ignore &quot;dunder&quot; names?</a></li>
<li><a class="reference internal" href="#why-none-instead-of-an-empty-tuple" id="id9">Why None instead of an empty tuple?</a></li>
<li><a class="reference internal" href="#why-none-instead-of-not-setting-the-attribute" id="id10">Why None instead of not setting the attribute?</a></li>
<li><a class="reference internal" href="#why-constrain-manually-set-values" id="id11">Why constrain manually set values?</a></li>
<li><a class="reference internal" href="#why-not-hide-definition-order-on-non-type-objects" id="id12">Why not hide __definition_order__ on non-type objects?</a></li>
<li><a class="reference internal" href="#what-about-slots" id="id13">What about __slots__?</a></li>
<li><a class="reference internal" href="#why-is-definition-order-even-necessary" id="id14">Why is __definition_order__ even necessary?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#support-for-c-api-types" id="id15">Support for C-API Types</a></li>
<li><a class="reference internal" href="#compatibility" id="id16">Compatibility</a></li>
<li><a class="reference internal" href="#changes" id="id17">Changes</a></li>
<li><a class="reference internal" href="#other-python-implementations" id="id18">Other Python Implementations</a></li>
<li><a class="reference internal" href="#implementation" id="id19">Implementation</a></li>
<li><a class="reference internal" href="#alternatives" id="id20">Alternatives</a><ul>
<li><a class="reference internal" href="#an-order-preserving-cls-dict" id="id21">An Order-preserving cls.__dict__</a></li>
<li><a class="reference internal" href="#a-namespace-keyword-arg-for-class-definition" id="id22">A &quot;namespace&quot; Keyword Arg for Class Definition</a></li>
<li><a class="reference internal" href="#a-stdlib-metaclass-that-implements-prepare-with-ordereddict" id="id23">A stdlib Metaclass that Implements __prepare__() with OrderedDict</a></li>
<li><a class="reference internal" href="#set-definition-order-at-compile-time" id="id24">Set __definition_order__ at Compile-time</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references" id="id25">References</a></li>
<li><a class="reference internal" href="#copyright" id="id26">Copyright</a></li>
</ul>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Since compact dict has landed in 3.6, __definition_order__
has been removed.  <tt class="docutils literal">cls.__dict__</tt> now mostly accomplishes the same
thing instead.</p>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id1">Abstract</a></h1>
<p>The class definition syntax is ordered by its very nature. Class
attributes defined there are thus ordered.  Aside from helping with
readability, that ordering is sometimes significant.  If it were
automatically available outside the class definition then the
attribute order could be used without the need for extra boilerplate
(such as metaclasses or manually enumerating the attribute order).
Given that this information already exists, access to the definition
order of attributes is a reasonable expectation.  However, currently
Python does not preserve the attribute order from the class
definition.</p>
<p>This PEP changes that by preserving the order in which attributes
are introduced in the class definition body.  That order will now be
preserved in the <tt class="docutils literal">__definition_order__</tt> attribute of the class.
This allows introspection of the original definition order, e.g. by
class decorators.</p>
<p>Additionally, this PEP requires that the default class definition
namespace be ordered (e.g. <tt class="docutils literal">OrderedDict</tt>) by default.  The long-
lived class namespace (<tt class="docutils literal">__dict__</tt>) will remain a <tt class="docutils literal">dict</tt>.</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id2">Motivation</a></h1>
<p>The attribute order from a class definition may be useful to tools
that rely on name order.  However, without the automatic availability
of the definition order, those tools must impose extra requirements on
users.  For example, use of such a tool may require that your class use
a particular metaclass.  Such requirements are often enough to
discourage use of the tool.</p>
<p>Some tools that could make use of this PEP include:</p>
<ul class="simple">
<li>documentation generators</li>
<li>testing frameworks</li>
<li>CLI frameworks</li>
<li>web frameworks</li>
<li>config generators</li>
<li>data serializers</li>
<li>enum factories (my original motivation)</li>
</ul>
</div>
<div class="section" id="background">
<h1><a class="toc-backref" href="#id3">Background</a></h1>
<p>When a class is defined using a <tt class="docutils literal">class</tt> statement, the class body
is executed within a namespace.  Currently that namespace defaults to
<tt class="docutils literal">dict</tt>.  If the metaclass defines <tt class="docutils literal">__prepare__()</tt> then the result
of calling it is used for the class definition namespace.</p>
<p>After the execution completes, the definition namespace is
copied into a new <tt class="docutils literal">dict</tt>.  Then the original definition namespace is
discarded.  The new copy is stored away as the class's namespace and
is exposed as <tt class="docutils literal">__dict__</tt> through a read-only proxy.</p>
<p>The class attribute definition order is represented by the insertion
order of names in the <em>definition</em> namespace.  Thus, we can have
access to the definition order by switching the definition namespace
to an ordered mapping, such as <tt class="docutils literal">collections.OrderedDict</tt>.  This is
feasible using a metaclass and <tt class="docutils literal">__prepare__</tt>, as described above.
In fact, exactly this is by far the most common use case for using
<tt class="docutils literal">__prepare__</tt>.</p>
<p>At that point, the only missing thing for later access to the
definition order is storing it on the class before the definition
namespace is thrown away.  Again, this may be done using a metaclass.
However, this means that the definition order is preserved only for
classes that use such a metaclass.  There are two practical problems
with that:</p>
<p>First, it requires the use of a metaclass.  Metaclasses introduce an
extra level of complexity to code and in some cases (e.g. conflicts)
are a problem.  So reducing the need for them is worth doing when the
opportunity presents itself.  <a class="reference external" href="/dev/peps/pep-0422">PEP 422</a> and <a class="reference external" href="/dev/peps/pep-0487">PEP 487</a> discuss this at
length.  We have such an opportunity by using an ordered mapping (e.g.
<tt class="docutils literal">OrderedDict</tt> for CPython at least) for the default class definition
namespace, virtually eliminating the need for <tt class="docutils literal">__prepare__()</tt>.</p>
<p>Second, only classes that opt in to using the <tt class="docutils literal">OrderedDict</tt>-based
metaclass will have access to the definition order. This is problematic
for cases where universal access to the definition order is important.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id4">Specification</a></h1>
<p>Part 1:</p>
<ul class="simple">
<li>all classes have a <tt class="docutils literal">__definition_order__</tt> attribute</li>
<li><tt class="docutils literal">__definition_order__</tt> is a <tt class="docutils literal">tuple</tt> of identifiers (or <tt class="docutils literal">None</tt>)</li>
<li><tt class="docutils literal">__definition_order__</tt> is always set:<ol class="arabic">
<li>during execution of the class body, the insertion order of names
into the class <em>definition</em> namespace is stored in a tuple</li>
<li>if <tt class="docutils literal">__definition_order__</tt> is defined in the class body then it
must be a <tt class="docutils literal">tuple</tt> of identifiers or <tt class="docutils literal">None</tt>; any other value
will result in <tt class="docutils literal">TypeError</tt></li>
<li>classes that do not have a class definition (e.g. builtins) have
their <tt class="docutils literal">__definition_order__</tt> set to <tt class="docutils literal">None</tt></li>
<li>classes for which <tt class="docutils literal">__prepare__()</tt> returned something other than
<tt class="docutils literal">OrderedDict</tt> (or a subclass) have their <tt class="docutils literal">__definition_order__</tt>
set to <tt class="docutils literal">None</tt> (except where #2 applies)</li>
</ol>
</li>
</ul>
<p>Not changing:</p>
<ul class="simple">
<li><tt class="docutils literal">dir()</tt> will not depend on <tt class="docutils literal">__definition_order__</tt></li>
<li>descriptors and custom <tt class="docutils literal">__getattribute__</tt> methods are unconstrained
regarding <tt class="docutils literal">__definition_order__</tt></li>
</ul>
<p>Part 2:</p>
<ul class="simple">
<li>the default class <em>definition</em> namespace is now an ordered mapping
(e.g. <tt class="docutils literal">OrderdDict</tt>)</li>
<li><tt class="docutils literal">cls.__dict__</tt> does not change, remaining a read-only proxy around
<tt class="docutils literal">dict</tt></li>
</ul>
<p>Note that Python implementations which have an ordered <tt class="docutils literal">dict</tt> won't
need to change anything.</p>
<p>The following code demonstrates roughly equivalent semantics for both
parts 1 and 2:</p>
<pre class="literal-block">
class Meta(type):
    &#64;classmethod
    def __prepare__(cls, *args, **kwargs):
        return OrderedDict()

class Spam(metaclass=Meta):
    ham = None
    eggs = 5
    __definition_order__ = tuple(locals())
</pre>
<div class="section" id="why-a-tuple">
<h2><a class="toc-backref" href="#id5">Why a tuple?</a></h2>
<p>Use of a tuple reflects the fact that we are exposing the order in
which attributes on the class were <em>defined</em>.  Since the definition
is already complete by the time <tt class="docutils literal">__definition_order__</tt> is set, the
content and order of the value won't be changing.  Thus we use a type
that communicates that state of immutability.</p>
</div>
<div class="section" id="why-not-a-read-only-attribute">
<h2><a class="toc-backref" href="#id6">Why not a read-only attribute?</a></h2>
<p>There are some valid arguments for making <tt class="docutils literal">__definition_order__</tt>
a read-only attribute (like <tt class="docutils literal">cls.__dict__</tt> is).  Most notably, a
read-only attribute conveys the nature of the attribute as &quot;complete&quot;,
which is exactly correct for <tt class="docutils literal">__definition_order__</tt>.  Since it
represents the state of a particular one-time event (execution of
the class definition body), allowing the value to be replaced would
reduce confidence that the attribute corresponds to the original class
body.  Furthermore, often an immuntable-by-default approach helps to
make data easier to reason about.</p>
<p>However, in this case there still isn't a <em>strong</em> reason to counter
the well-worn precedent found in Python.  Per Guido:</p>
<pre class="literal-block">
I don't see why it needs to be a read-only attribute. There are
very few of those -- in general we let users play around with
things unless we have a hard reason to restrict assignment (e.g.
the interpreter's internal state could be compromised). I don't
see such a hard reason here.
</pre>
<p>Also, note that a writeable <tt class="docutils literal">__definition_order__</tt> allows dynamically
created classes (e.g. by Cython) to still have <tt class="docutils literal">__definition_order__</tt>
properly set.  That could certainly be handled through specific class-
creation tools, such as <tt class="docutils literal">type()</tt> or the C-API, without the need to
lose the semantics of a read-only attribute.  However, with a writeable
attribute it's a moot point.</p>
</div>
<div class="section" id="why-not-attribute-order">
<h2><a class="toc-backref" href="#id7">Why not &quot;__attribute_order__&quot;?</a></h2>
<p><tt class="docutils literal">__definition_order__</tt> is centered on the class definition
body.  The use cases for dealing with the class namespace (<tt class="docutils literal">__dict__</tt>)
post-definition are a separate matter.  <tt class="docutils literal">__definition_order__</tt> would
be a significantly misleading name for a feature focused on more than
class definition.</p>
</div>
<div class="section" id="why-not-ignore-dunder-names">
<h2><a class="toc-backref" href="#id8">Why not ignore &quot;dunder&quot; names?</a></h2>
<p>Names starting and ending with &quot;__&quot; are reserved for use by the
interpreter.  In practice they should not be relevant to the users of
<tt class="docutils literal">__definition_order__</tt>.  Instead, for nearly everyone they would only
be clutter, causing the same extra work (filtering out the dunder
names) for the majority.  In cases where a dunder name is significant,
the class definition <em>could</em> manually set <tt class="docutils literal">__definition_order__</tt>,
making the common case simpler.</p>
<p>However, leaving dunder names out of <tt class="docutils literal">__definition_order__</tt> means
that their place in the definition order would be unrecoverably lost.
Dropping dunder names by default may inadvertently cause problems for
classes that use dunder names unconventionally.  In this case it's
better to play it safe and preserve <em>all</em> the names from the class
definition.  This isn't a big problem since it is easy to filter out
dunder names:</p>
<pre class="literal-block">
(name for name in cls.__definition_order__
      if not (name.startswith('__') and name.endswith('__')))
</pre>
<p>In fact, in some application contexts there may be other criteria on
which similar filtering would be applied, such as ignoring any name
starting with &quot;_&quot;, leaving out all methods, or including only
descriptors.  Ultimately dunder names aren't a special enough case to
be treated exceptionally.</p>
<p>Note that a couple of dunder names (<tt class="docutils literal">__name__</tt> and <tt class="docutils literal">__qualname__</tt>)
are injected by default by the compiler.  So they will be included even
though they are not strictly part of the class definition body.</p>
</div>
<div class="section" id="why-none-instead-of-an-empty-tuple">
<h2><a class="toc-backref" href="#id9">Why None instead of an empty tuple?</a></h2>
<p>A key objective of adding <tt class="docutils literal">__definition_order__</tt> is to preserve
information in class definitions which was lost prior to this PEP.
One consequence is that <tt class="docutils literal">__definition_order__</tt> implies an original
class definition.  Using <tt class="docutils literal">None</tt> allows us to clearly distinguish
classes that do not have a definition order.  An empty tuple clearly
indicates a class that came from a definition statement but did not
define any attributes there.</p>
</div>
<div class="section" id="why-none-instead-of-not-setting-the-attribute">
<h2><a class="toc-backref" href="#id10">Why None instead of not setting the attribute?</a></h2>
<p>The absence of an attribute requires more complex handling than <tt class="docutils literal">None</tt>
does for consumers of <tt class="docutils literal">__definition_order__</tt>.</p>
</div>
<div class="section" id="why-constrain-manually-set-values">
<h2><a class="toc-backref" href="#id11">Why constrain manually set values?</a></h2>
<p>If <tt class="docutils literal">__definition_order__</tt> is manually set in the class body then it
will be used.  We require it to be a tuple of identifiers (or <tt class="docutils literal">None</tt>)
so that consumers of <tt class="docutils literal">__definition_order__</tt> may have a consistent
expectation for the value.  That helps maximize the feature's
usefulness.</p>
<p>We could also also allow an arbitrary iterable for a manually set
<tt class="docutils literal">__definition_order__</tt> and convert it into a tuple.  However, not
all iterables infer a definition order (e.g. <tt class="docutils literal">set</tt>).  So we opt in
favor of requiring a tuple.</p>
</div>
<div class="section" id="why-not-hide-definition-order-on-non-type-objects">
<h2><a class="toc-backref" href="#id12">Why not hide __definition_order__ on non-type objects?</a></h2>
<p>Python doesn't make much effort to hide class-specific attributes
during lookup on instances of classes.  While it may make sense
to consider <tt class="docutils literal">__definition_order__</tt> a class-only attribute, hidden
during lookup on objects, setting precedent in that regard is
beyond the goals of this PEP.</p>
</div>
<div class="section" id="what-about-slots">
<h2><a class="toc-backref" href="#id13">What about __slots__?</a></h2>
<p><tt class="docutils literal">__slots__</tt> will be added to <tt class="docutils literal">__definition_order__</tt> like any
other name in the class definition body.  The actual slot names
will not be added to <tt class="docutils literal">__definition_order__</tt> since they aren't
set as names in the definition namespace.</p>
</div>
<div class="section" id="why-is-definition-order-even-necessary">
<h2><a class="toc-backref" href="#id14">Why is __definition_order__ even necessary?</a></h2>
<p>Since the definition order is not preserved in <tt class="docutils literal">__dict__</tt>, it is
lost once class definition execution completes.  Classes <em>could</em>
explicitly set the attribute as the last thing in the body.  However,
then independent decorators could only make use of classes that had done
so.  Instead, <tt class="docutils literal">__definition_order__</tt> preserves this one bit of info
from the class body so that it is universally available.</p>
</div>
</div>
<div class="section" id="support-for-c-api-types">
<h1><a class="toc-backref" href="#id15">Support for C-API Types</a></h1>
<p>Arguably, most C-defined Python types (e.g. built-in, extension modules)
have a roughly equivalent concept of a definition order. So conceivably
<tt class="docutils literal">__definition_order__</tt> could be set for such types automatically. This
PEP does not introduce any such support. However, it does not prohibit
it either.  However, since <tt class="docutils literal">__definition_order__</tt> can be set at any
time through normal attribute assignment, it does not need any special
treatment in the C-API.</p>
<p>The specific cases:</p>
<ul class="simple">
<li>builtin types</li>
<li>PyType_Ready</li>
<li>PyType_FromSpec</li>
</ul>
</div>
<div class="section" id="compatibility">
<h1><a class="toc-backref" href="#id16">Compatibility</a></h1>
<p>This PEP does not break backward compatibility, except in the case that
someone relies <em>strictly</em> on <tt class="docutils literal">dict</tt> as the class definition namespace.
This shouldn't be a problem since <tt class="docutils literal">issubclass(OrderedDict, dict)</tt> is
true.</p>
</div>
<div class="section" id="changes">
<h1><a class="toc-backref" href="#id17">Changes</a></h1>
<p>In addition to the class syntax, the following expose the new behavior:</p>
<ul class="simple">
<li>builtins.__build_class__</li>
<li>types.prepare_class</li>
<li>types.new_class</li>
</ul>
<p>Also, the 3-argument form of <tt class="docutils literal">builtins.type()</tt> will allow inclusion
of <tt class="docutils literal">__definition_order__</tt> in the namespace that gets passed in.  It
will be subject to the same constraints as when <tt class="docutils literal">__definition_order__</tt>
is explicitly defined in the class body.</p>
</div>
<div class="section" id="other-python-implementations">
<h1><a class="toc-backref" href="#id18">Other Python Implementations</a></h1>
<p>Pending feedback, the impact on Python implementations is expected to
be minimal.  All conforming implementations are expected to set
<tt class="docutils literal">__definition_order__</tt> as described in this PEP.</p>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id19">Implementation</a></h1>
<p>The implementation is found in the tracker. [<a class="reference internal" href="#impl">impl</a>]</p>
</div>
<div class="section" id="alternatives">
<h1><a class="toc-backref" href="#id20">Alternatives</a></h1>
<div class="section" id="an-order-preserving-cls-dict">
<h2><a class="toc-backref" href="#id21">An Order-preserving cls.__dict__</a></h2>
<p>Instead of storing the definition order in <tt class="docutils literal">__definition_order__</tt>,
the now-ordered definition namespace could be copied into a new
<tt class="docutils literal">OrderedDict</tt>.  This would then be used as the mapping proxied as
<tt class="docutils literal">__dict__</tt>.  Doing so would mostly provide the same semantics.</p>
<p>However, using <tt class="docutils literal">OrderedDict</tt> for <tt class="docutils literal">__dict__</tt> would obscure the
relationship with the definition namespace, making it less useful.</p>
<p>Additionally, (in the case of <tt class="docutils literal">OrderedDict</tt> specifically) doing
this would require significant changes to the semantics of the
concrete <tt class="docutils literal">dict</tt> C-API.</p>
<p>There has been some discussion about moving to a compact dict
implementation which would (mostly) preserve insertion order.  However
the lack of an explicit <tt class="docutils literal">__definition_order__</tt> would still remain
as a pain point.</p>
</div>
<div class="section" id="a-namespace-keyword-arg-for-class-definition">
<h2><a class="toc-backref" href="#id22">A &quot;namespace&quot; Keyword Arg for Class Definition</a></h2>
<p><a class="reference external" href="/dev/peps/pep-0422">PEP 422</a> introduced a new &quot;namespace&quot; keyword arg to class definitions
that effectively replaces the need to <tt class="docutils literal">__prepare__()</tt>. [<a class="reference internal" href="#pep422">pep422</a>]
However, the proposal was withdrawn in favor of the simpler <a class="reference external" href="/dev/peps/pep-0487">PEP 487</a>.</p>
</div>
<div class="section" id="a-stdlib-metaclass-that-implements-prepare-with-ordereddict">
<h2><a class="toc-backref" href="#id23">A stdlib Metaclass that Implements __prepare__() with OrderedDict</a></h2>
<p>This has all the same problems as writing your own metaclass.  The
only advantage is that you don't have to actually write this
metaclass.  So it doesn't offer any benefit in the context of this
PEP.</p>
</div>
<div class="section" id="set-definition-order-at-compile-time">
<h2><a class="toc-backref" href="#id24">Set __definition_order__ at Compile-time</a></h2>
<p>Each class's <tt class="docutils literal">__qualname__</tt> is determined at compile-time.
This same concept could be applied to <tt class="docutils literal">__definition_order__</tt>.
The result of composing <tt class="docutils literal">__definition_order__</tt> at compile-time
would be nearly the same as doing so at run-time.</p>
<p>Comparative implementation difficulty aside, the key difference
would be that at compile-time it would not be practical to
preserve definition order for attributes that are set dynamically
in the class body (e.g. <tt class="docutils literal"><span class="pre">locals()[name]</span> = value</tt>).  However,
they should still be reflected in the definition order.  One
possible resolution would be to require class authors to manually
set <tt class="docutils literal">__definition_order__</tt> if they define any class attributes
dynamically.</p>
<p>Ultimately, the use of <tt class="docutils literal">OrderedDict</tt> at run-time or compile-time
discovery is almost entirely an implementation detail.</p>
</div>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id25">References</a></h1>
<table class="docutils citation" frame="void" id="impl" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[impl]</td><td>issue #24254
(<a class="reference external" href="https://bugs.python.org/issue24254">https://bugs.python.org/issue24254</a>)</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="nick-concern" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[nick_concern]</td><td>Nick's concerns about mutability
(<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2016-June/144883.html">https://mail.python.org/pipermail/python-dev/2016-June/144883.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="pep422" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[pep422]</td><td><a class="reference external" href="/dev/peps/pep-0422">PEP 422</a>
(<a class="reference external" href="https://www.python.org/dev/peps/pep-0422/#order-preserving-classes">https://www.python.org/dev/peps/pep-0422/#order-preserving-classes</a>)</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="pep487" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[pep487]</td><td><a class="reference external" href="/dev/peps/pep-0487">PEP 487</a>
(<a class="reference external" href="https://www.python.org/dev/peps/pep-0487/#defining-arbitrary-namespaces">https://www.python.org/dev/peps/pep-0487/#defining-arbitrary-namespaces</a>)</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="orig" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[orig]</td><td>original discussion
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2013-February/019690.html">https://mail.python.org/pipermail/python-ideas/2013-February/019690.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="followup1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[followup1]</td><td>follow-up 1
(<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2013-June/127103.html">https://mail.python.org/pipermail/python-dev/2013-June/127103.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="followup2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[followup2]</td><td>follow-up 2
(<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2015-May/140137.html">https://mail.python.org/pipermail/python-dev/2015-May/140137.html</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id26">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

