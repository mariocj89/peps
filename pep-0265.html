<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">265</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Sorting Dictionaries by Value</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0265.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">g2&#32;&#97;t&#32;iowegian.com (Grant Griffin)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">8-Aug-2001</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.2</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id1">Abstract</a></li>
<li><a class="reference internal" href="#bdfl-pronouncement" id="id2">BDFL Pronouncement</a></li>
<li><a class="reference internal" href="#motivation" id="id3">Motivation</a></li>
<li><a class="reference internal" href="#rationale" id="id4">Rationale</a></li>
<li><a class="reference internal" href="#implementation" id="id5">Implementation</a></li>
<li><a class="reference internal" href="#concerns" id="id6">Concerns</a></li>
<li><a class="reference internal" href="#references" id="id7">References</a></li>
<li><a class="reference internal" href="#copyright" id="id8">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id1">Abstract</a></h1>
<p>This PEP suggests a &quot;sort by value&quot; operation for dictionaries.
The primary benefit would be in terms of &quot;batteries included&quot;
support for a common Python idiom which, in its current form, is
both difficult for beginners to understand and cumbersome for all
to implement.</p>
</div>
<div class="section" id="bdfl-pronouncement">
<h1><a class="toc-backref" href="#id2">BDFL Pronouncement</a></h1>
<p>This PEP is rejected because the need for it has been largely
fulfilled by Py2.4's <tt class="docutils literal">sorted()</tt> builtin function:</p>
<pre class="literal-block">
&gt;&gt;&gt; sorted(d.iteritems(), key=itemgetter(1), reverse=True)
[('b', 23), ('d', 17), ('c', 5), ('a', 2), ('e', 1)]
</pre>
<p>or for just the keys:</p>
<pre class="literal-block">
sorted(d, key=d.__getitem__, reverse=True)
['b', 'd', 'c', 'a', 'e']
</pre>
<p>Also, Python 2.5's <tt class="docutils literal">heapq.nlargest()</tt> function addresses the common use
case of finding only a few of the highest valued items:</p>
<pre class="literal-block">
&gt;&gt;&gt; nlargest(2, d.iteritems(), itemgetter(1))
[('b', 23), ('d', 17)]
</pre>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id3">Motivation</a></h1>
<p>A common use of dictionaries is to count occurrences by setting
the value of <tt class="docutils literal">d[key]</tt> to 1 on its first occurrence, then increment
the value on each subsequent occurrence.  This can be done several
different ways, but the <tt class="docutils literal">get()</tt> method is the most succinct:</p>
<pre class="literal-block">
d[key] = d.get(key, 0) + 1
</pre>
<p>Once all occurrences have been counted, a common use of the
resulting dictionary is to print the occurrences in
occurrence-sorted order, often with the largest value first.</p>
<p>This leads to a need to sort a dictionary's items by value.  The
canonical method of doing so in Python is to first use <tt class="docutils literal">d.items()</tt>
to get a list of the dictionary's items, then invert the ordering
of each item's tuple from (key, value) into (value, key), then
sort the list; since Python sorts the list based on the first item
of the tuple, the list of (inverted) items is therefore sorted by
value.  If desired, the list can then be reversed, and the tuples
can be re-inverted back to (key, value).  (However, in my
experience, the inverted tuple ordering is fine for most purposes,
e.g. printing out the list.)</p>
<p>For example, given an occurrence count of:</p>
<pre class="literal-block">
&gt;&gt;&gt; d = {'a':2, 'b':23, 'c':5, 'd':17, 'e':1}
</pre>
<p>we might do:</p>
<pre class="literal-block">
&gt;&gt;&gt; items = [(v, k) for k, v in d.items()]
&gt;&gt;&gt; items.sort()
&gt;&gt;&gt; items.reverse()             # so largest is first
&gt;&gt;&gt; items = [(k, v) for v, k in items]
</pre>
<p>resulting in:</p>
<pre class="literal-block">
&gt;&gt;&gt; items
[('b', 23), ('d', 17), ('c', 5), ('a', 2), ('e', 1)]
</pre>
<p>which shows the list in by-value order, largest first.  (In this
case, <tt class="docutils literal">'b'</tt> was found to have the most occurrences.)</p>
<p>This works fine, but is &quot;hard to use&quot; in two aspects.  First,
although this idiom is known to veteran Pythoneers, it is not at
all obvious to newbies -- either in terms of its algorithm
(inverting the ordering of item tuples) or its implementation
(using list comprehensions -- which are an advanced Python
feature.)  Second, it requires having to repeatedly type a lot of
&quot;grunge&quot;, resulting in both tedium and mistakes.</p>
<p>We therefore would rather Python provide a method of sorting
dictionaries by value which would be both easy for newbies to
understand (or, better yet, not to <em>have to</em> understand) and
easier for all to use.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id4">Rationale</a></h1>
<p>As Tim Peters has pointed out, this sort of thing brings on the
problem of trying to be all things to all people.  Therefore, we
will limit its scope to try to hit &quot;the sweet spot&quot;.  Unusual
cases (e.g. sorting via a custom comparison function) can, of
course, be handled &quot;manually&quot; using present methods.</p>
<p>Here are some simple possibilities:</p>
<p>The <tt class="docutils literal">items()</tt> method of dictionaries can be augmented with new
parameters having default values that provide for full
backwards-compatibility:</p>
<pre class="literal-block">
(1) items(sort_by_values=0, reversed=0)
</pre>
<p>or maybe just:</p>
<pre class="literal-block">
(2) items(sort_by_values=0)
</pre>
<p>since reversing a list is easy enough.</p>
<p>Alternatively, <tt class="docutils literal">items()</tt> could simply let us control the (key, value)
order:</p>
<pre class="literal-block">
(3) items(values_first=0)
</pre>
<p>Again, this is fully backwards-compatible.  It does less work than
the others, but it at least eases the most complicated/tricky part
of the sort-by-value problem: inverting the order of item tuples.
Using this is very simple:</p>
<pre class="literal-block">
items = d.items(1)
items.sort()
items.reverse()         # (if desired)
</pre>
<p>The primary drawback of the preceding three approaches is the
additional overhead for the parameter-less <tt class="docutils literal">items()</tt> case, due to
having to process default parameters.  (However, if one assumes
that <tt class="docutils literal">items()</tt> gets used primarily for creating sort-by-value lists,
this is not really a drawback in practice.)</p>
<p>Alternatively, we might add a new dictionary method which somehow
embodies &quot;sorting&quot;.  This approach offers two advantages.  First,
it avoids adding overhead to the <tt class="docutils literal">items()</tt> method.  Second, it is
perhaps more accessible to newbies: when they go looking for a
method for sorting dictionaries, they hopefully run into this one,
and they will not have to understand the finer points of tuple
inversion and list sorting to achieve sort-by-value.</p>
<p>To allow the four basic possibilities of sorting by key/value and in
forward/reverse order, we could add this method:</p>
<pre class="literal-block">
(4) sorted_items(by_value=0, reversed=0)
</pre>
<p>I believe the most common case would actually be <tt class="docutils literal">by_value=1,
reversed=1</tt>, but the defaults values given here might lead to
fewer surprises by users: <tt class="docutils literal">sorted_items()</tt> would be the same as
<tt class="docutils literal">items()</tt> followed by <tt class="docutils literal">sort()</tt>.</p>
<p>Finally (as a last resort), we could use:</p>
<pre class="literal-block">
(5) items_sorted_by_value(reversed=0)
</pre>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id5">Implementation</a></h1>
<p>The proposed dictionary methods would necessarily be implemented
in C.  Presumably, the implementation would be fairly simple since
it involves just adding a few calls to Python's existing
machinery.</p>
</div>
<div class="section" id="concerns">
<h1><a class="toc-backref" href="#id6">Concerns</a></h1>
<p>Aside from the run-time overhead already addressed in
possibilities 1 through 3, concerns with this proposal probably
will fall into the categories of &quot;feature bloat&quot; and/or &quot;code
bloat&quot;.  However, I believe that several of the suggestions made
here will result in quite minimal bloat, resulting in a good
tradeoff between bloat and &quot;value added&quot;.</p>
<p>Tim Peters has noted that implementing this in C might not be
significantly faster than implementing it in Python today.
However, the major benefits intended here are &quot;accessibility&quot; and
&quot;ease of use&quot;, not &quot;speed&quot;.  Therefore, as long as it is not
noticeably slower (in the case of plain <tt class="docutils literal">items()</tt>, speed need not be
a consideration.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id7">References</a></h1>
<p>A related thread called &quot;counting occurrences&quot; appeared on
comp.lang.python in August, 2001.  This included examples of
approaches to systematizing the sort-by-value problem by
implementing it as reusable Python functions and classes.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id8">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

