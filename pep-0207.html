<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">207</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Rich Comparisons</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0207.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">guido&#32;&#97;t&#32;python.org (Guido van Rossum), DavidA&#32;&#97;t&#32;ActiveState.com (David Ascher)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.1</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id4">Abstract</a></li>
<li><a class="reference internal" href="#motivation" id="id5">Motivation</a></li>
<li><a class="reference internal" href="#previous-work" id="id6">Previous Work</a></li>
<li><a class="reference internal" href="#concerns" id="id7">Concerns</a></li>
<li><a class="reference internal" href="#proposed-resolutions" id="id8">Proposed Resolutions</a></li>
<li><a class="reference internal" href="#implementation-proposal" id="id9">Implementation Proposal</a><ul>
<li><a class="reference internal" href="#c-api" id="id10">C API</a></li>
<li><a class="reference internal" href="#changes-to-the-interpreter" id="id11">Changes to the interpreter</a></li>
<li><a class="reference internal" href="#classes" id="id12">Classes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#copyright" id="id13">Copyright</a></li>
<li><a class="reference internal" href="#appendix" id="id14">Appendix</a></li>
<li><a class="reference internal" href="#id1" id="id15">Abstract</a></li>
<li><a class="reference internal" href="#id2" id="id16">Motivation</a></li>
<li><a class="reference internal" href="#current-state-of-affairs" id="id17">Current State of Affairs</a><ul>
<li><a class="reference internal" href="#proposed-mechanism" id="id18">Proposed Mechanism</a></li>
<li><a class="reference internal" href="#chained-comparisons" id="id19">Chained Comparisons</a><ul>
<li><a class="reference internal" href="#problem" id="id20">Problem</a></li>
<li><a class="reference internal" href="#solution" id="id21">Solution</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id4">Abstract</a></h1>
<p>This PEP proposes several new features for comparisons:</p>
<ul class="simple">
<li>Allow separately overloading of &lt;, &gt;, &lt;=, &gt;=, ==, !=, both in
classes and in C extensions.</li>
<li>Allow any of those overloaded operators to return something else
besides a Boolean result.</li>
</ul>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id5">Motivation</a></h1>
<p>The main motivation comes from NumPy, whose users agree that A&lt;B
should return an array of elementwise comparison outcomes; they
currently have to spell this as less(A,B) because A&lt;B can only
return a Boolean result or raise an exception.</p>
<p>An additional motivation is that frequently, types don't have a
natural ordering, but still need to be compared for equality.
Currently such a type <strong>must</strong> implement comparison and thus define
an arbitrary ordering, just so that equality can be tested.</p>
<p>Also, for some object types an equality test can be implemented
much more efficiently than an ordering test; for example, lists
and dictionaries that differ in length are unequal, but the
ordering requires inspecting some (potentially all) items.</p>
</div>
<div class="section" id="previous-work">
<h1><a class="toc-backref" href="#id6">Previous Work</a></h1>
<p>Rich Comparisons have been proposed before; in particular by David
Ascher, after experience with Numerical Python:</p>
<blockquote>
<a class="reference external" href="http://starship.python.net/crew/da/proposals/richcmp.html">http://starship.python.net/crew/da/proposals/richcmp.html</a></blockquote>
<p>It is also included below as an Appendix.  Most of the material in
this PEP is derived from David's proposal.</p>
</div>
<div class="section" id="concerns">
<h1><a class="toc-backref" href="#id7">Concerns</a></h1>
<ol class="arabic simple">
<li>Backwards compatibility, both at the Python level (classes using
<tt class="docutils literal">__cmp__</tt> need not be changed) and at the C level (extensions
defining <tt class="docutils literal">tp_comparea</tt> need not be changed, code using
<tt class="docutils literal">PyObject_Compare()</tt> must work even if the compared objects use
the new rich comparison scheme).</li>
<li>When A&lt;B returns a matrix of elementwise comparisons, an easy
mistake to make is to use this expression in a Boolean context.
Without special precautions, it would always be true.  This use
should raise an exception instead.</li>
<li>If a class overrides x==y but nothing else, should x!=y be
computed as not(x==y), or fail?  What about the similar
relationship between &lt; and &gt;=, or between &gt; and &lt;=?</li>
<li>Similarly, should we allow x&lt;y to be calculated from y&gt;x?  And
x&lt;=y from not(x&gt;y)?  And x==y from y==x, or x!=y from y!=x?</li>
<li>When comparison operators return elementwise comparisons, what
to do about shortcut operators like A&lt;B&lt;C, <tt class="docutils literal">A&lt;B and C&lt;D</tt>,
<tt class="docutils literal">A&lt;B or C&lt;D</tt>?</li>
<li>What to do about <tt class="docutils literal">min()</tt> and <tt class="docutils literal">max()</tt>, the 'in' and 'not in'
operators, <tt class="docutils literal">list.sort()</tt>, dictionary key comparison, and other
uses of comparisons by built-in operations?</li>
</ol>
</div>
<div class="section" id="proposed-resolutions">
<h1><a class="toc-backref" href="#id8">Proposed Resolutions</a></h1>
<ol class="arabic">
<li><p class="first">Full backwards compatibility can be achieved as follows.  When
an object defines <tt class="docutils literal">tp_compare()</tt> but not <tt class="docutils literal">tp_richcompare()</tt>, and a
rich comparison is requested, the outcome of <tt class="docutils literal">tp_compare()</tt> is
used in the ovious way.  E.g. if &quot;&lt;&quot; is requested, an exception if
<tt class="docutils literal">tp_compare()</tt> raises an exception, the outcome is 1 if
<tt class="docutils literal">tp_compare()</tt> is negative, and 0 if it is zero or positive.  Etc.</p>
<p>Full forward compatibility can be achieved as follows.  When a
classic comparison is requested on an object that implements
<tt class="docutils literal">tp_richcompare()</tt>, up to three comparisons are used: first == is
tried, and if it returns true, 0 is returned; next, &lt; is tried
and if it returns true, -1 is returned; next, &gt; is tried and if
it returns true, +1 is returned.  If any operator tried returns
a non-Boolean value (see below), the exception raised by
conversion to Boolean is passed through.  If none of the
operators tried returns true, the classic comparison fallbacks
are tried next.</p>
<p>(I thought long and hard about the order in which the three
comparisons should be tried.  At one point I had a convincing
argument for doing it in this order, based on the behavior of
comparisons for cyclical data structures.  But since that code
has changed again, I'm not so sure that it makes a difference
any more.)</p>
</li>
<li><p class="first">Any type that returns a collection of Booleans instead of a
single boolean should define <tt class="docutils literal">nb_nonzero()</tt> to raise an exception.
Such a type is considered a non-Boolean.</p>
</li>
<li><p class="first">The == and != operators are not assumed to be each other's
complement (e.g. IEEE 754 floating point numbers do not satisfy
this).  It is up to the type to implement this if desired.
Similar for &lt; and &gt;=, or &gt; and &lt;=; there are lots of examples
where these assumptions aren't true (e.g. tabnanny).</p>
</li>
<li><p class="first">The reflexivity rules <strong>are</strong> assumed by Python.  Thus, the
interpreter may swap y&gt;x with x&lt;y, y&gt;=x with x&lt;=y, and may swap
the arguments of x==y and x!=y.  (Note: Python currently assumes
that x==x is always true and x!=x is never true; this should not
be assumed.)</p>
</li>
<li><p class="first">In the current proposal, when A&lt;B returns an array of
elementwise comparisons, this outcome is considered non-Boolean,
and its interpretation as Boolean by the shortcut operators
raises an exception.  David Ascher's proposal tries to deal
with this; I don't think this is worth the additional complexity
in the code generator.  Instead of A&lt;B&lt;C, you can write
(A&lt;B)&amp;(B&lt;C).</p>
</li>
<li><p class="first">The <tt class="docutils literal">min()</tt> and <tt class="docutils literal">list.sort()</tt> operations will only use the
&lt; operator; max() will only use the &gt; operator.  The 'in' and
'not in' operators and dictionary lookup will only use the ==
operator.</p>
</li>
</ol>
</div>
<div class="section" id="implementation-proposal">
<h1><a class="toc-backref" href="#id9">Implementation Proposal</a></h1>
<p>This closely follows David Ascher's proposal.</p>
<div class="section" id="c-api">
<h2><a class="toc-backref" href="#id10">C API</a></h2>
<ul>
<li><p class="first">New functions:</p>
<pre class="literal-block">
PyObject *PyObject_RichCompare(PyObject *, PyObject *, int)
</pre>
<p>This performs the requested rich comparison, returning a Python
object or raising an exception.  The 3rd argument must be one of
Py_LT, Py_LE, Py_EQ, Py_NE, Py_GT or Py_GE.</p>
<pre class="literal-block">
int PyObject_RichCompareBool(PyObject *, PyObject *, int)
</pre>
<p>This performs the requested rich comparison, returning a
Boolean: -1 for exception, 0 for false, 1 for true.  The 3rd
argument must be one of Py_LT, Py_LE, Py_EQ, Py_NE, Py_GT or
Py_GE.  Note that when <tt class="docutils literal">PyObject_RichCompare()</tt> returns a
non-Boolean object, <tt class="docutils literal">PyObject_RichCompareBool()</tt> will raise an
exception.</p>
</li>
<li><p class="first">New typedef:</p>
<pre class="literal-block">
typedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);
</pre>
</li>
<li><p class="first">New slot in type object, replacing spare tp_xxx7:</p>
<pre class="literal-block">
richcmpfunc tp_richcompare;
</pre>
<p>This should be a function with the same signature as
<tt class="docutils literal">PyObject_RichCompare()</tt>, and performing the same comparison.
At least one of the arguments is of the type whose
tp_richcompare slot is being used, but the other may have a
different type.  If the function cannot compare the particular
combination of objects, it should return a new reference to
<tt class="docutils literal">Py_NotImplemented</tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal">PyObject_Compare()</tt> is changed to try rich comparisons if they
are defined (but only if classic comparisons aren't defined).</p>
</li>
</ul>
</div>
<div class="section" id="changes-to-the-interpreter">
<h2><a class="toc-backref" href="#id11">Changes to the interpreter</a></h2>
<ul class="simple">
<li>Whenever <tt class="docutils literal">PyObject_Compare()</tt> is called with the intent of getting
the outcome of a particular comparison (e.g. in <tt class="docutils literal">list.sort()</tt>, and
of course for the comparison operators in ceval.c), the code is
changed to call <tt class="docutils literal">PyObject_RichCompare()</tt> or
<tt class="docutils literal">PyObject_RichCompareBool()</tt> instead; if the C code needs to know
the outcome of the comparison, <tt class="docutils literal">PyObject_IsTrue()</tt> is called on
the result (which may raise an exception).</li>
<li>Most built-in types that currently define a comparison will be
modified to define a rich comparison instead.  (This is
optional; I've converted lists, tuples, complex numbers, and
arrays so far, and am not sure whether I will convert others.)</li>
</ul>
</div>
<div class="section" id="classes">
<h2><a class="toc-backref" href="#id12">Classes</a></h2>
<ul class="simple">
<li>Classes can define new special methods <tt class="docutils literal">__lt__</tt>, <tt class="docutils literal">__le__</tt>, <tt class="docutils literal">__eq__</tt>,
<tt class="docutils literal">__ne__</tt>, <tt class="docutils literal">__gt__</tt>, <tt class="docutils literal">__ge__</tt> to override the corresponding operators.
(I.e., &lt;, &lt;=, ==, !=, &gt;, &gt;=. You gotta love the Fortran
heritage.)  If a class defines <tt class="docutils literal">__cmp__</tt> as well, it is only used
when <tt class="docutils literal">__lt__</tt> etc. have been tried and return <tt class="docutils literal">NotImplemented</tt>.</li>
</ul>
</div>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id13">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
</div>
<div class="section" id="appendix">
<h1><a class="toc-backref" href="#id14">Appendix</a></h1>
<p>Here is most of David Ascher's original proposal (version 0.2.1,
dated Wed Jul 22 16:49:28 1998; I've left the Contents, History
and Patches sections out).  It addresses almost all concerns
above.</p>
</div>
<div class="section" id="id1">
<h1><a class="toc-backref" href="#id15">Abstract</a></h1>
<p>A new mechanism allowing comparisons of Python objects to return
values other than -1, 0, or 1 (or raise exceptions) is
proposed. This mechanism is entirely backwards compatible, and can
be controlled at the level of the C <tt class="docutils literal">PyObject</tt> type or of the Python
class definition. There are three cooperating parts to the
proposed mechanism:</p>
<ul class="simple">
<li>the use of the last slot in the type object structure to store a
pointer to a rich comparison function</li>
<li>the addition of special methods for classes</li>
<li>the addition of an optional argument to the builtin <tt class="docutils literal">cmp()</tt>
function.</li>
</ul>
</div>
<div class="section" id="id2">
<h1><a class="toc-backref" href="#id16">Motivation</a></h1>
<p>The current comparison protocol for Python objects assumes that
any two Python objects can be compared (as of Python 1.5, object
comparisons can raise exceptions), and that the return value for
any comparison should be -1, 0 or 1. -1 indicates that the first
argument to the comparison function is less than the right one, +1
indicating the contrapositive, and 0 indicating that the two
objects are equal. While this mechanism allows the establishment
of an order relationship (e.g. for use by the <tt class="docutils literal">sort()</tt> method of list
objects), it has proven to be limited in the context of Numeric
Python (NumPy).</p>
<p>Specifically, NumPy allows the creation of multidimensional
arrays, which support most of the numeric operators. Thus:</p>
<pre class="literal-block">
x = array((1,2,3,4))        y = array((2,2,4,4))
</pre>
<p>are two NumPy arrays. While they can be added elementwise,:</p>
<pre class="literal-block">
z = x + y   # z == array((3,4,7,8))
</pre>
<p>they cannot be compared in the current framework - the released
version of NumPy compares the pointers, (thus yielding junk
information) which was the only solution before the recent
addition of the ability (in 1.5) to raise exceptions in comparison
functions.</p>
<p>Even with the ability to raise exceptions, the current protocol
makes array comparisons useless. To deal with this fact, NumPy
includes several functions which perform the comparisons: <tt class="docutils literal">less()</tt>,
<tt class="docutils literal">less_equal()</tt>, <tt class="docutils literal">greater()</tt>, <tt class="docutils literal">greater_equal()</tt>, <tt class="docutils literal">equal()</tt>,
<tt class="docutils literal">not_equal()</tt>. These functions return arrays with the same shape as
their arguments (modulo broadcasting), filled with 0's and 1's
depending on whether the comparison is true or not for each
element pair. Thus, for example, using the arrays x and y defined
above:</p>
<pre class="literal-block">
less(x,y)
</pre>
<p>would be an array containing the numbers (1,0,0,0).</p>
<p>The current proposal is to modify the Python object interface to
allow the NumPy package to make it so that x &lt; y returns the same
thing as less(x,y). The exact return value is up to the NumPy
package -- what this proposal really asks for is changing the
Python core so that extension objects have the ability to return
something other than -1, 0, 1, should their authors choose to do
so.</p>
</div>
<div class="section" id="current-state-of-affairs">
<h1><a class="toc-backref" href="#id17">Current State of Affairs</a></h1>
<p>The current protocol is, at the C level, that each object type
defines a <tt class="docutils literal">tp_compare</tt> slot, which is a pointer to a function which
takes two <tt class="docutils literal">PyObject*</tt> references and returns -1, 0, or 1. This
function is called by the <tt class="docutils literal">PyObject_Compare()</tt> function defined in
the C API. <tt class="docutils literal">PyObject_Compare()</tt> is also called by the builtin
function <tt class="docutils literal">cmp()</tt> which takes two arguments.</p>
<div class="section" id="proposed-mechanism">
<h2><a class="toc-backref" href="#id18">Proposed Mechanism</a></h2>
<ol class="arabic">
<li><p class="first">Changes to the C structure for type objects</p>
<p>The last available slot in the <tt class="docutils literal">PyTypeObject</tt>, reserved up to now
for future expansion, is used to optionally store a pointer to a
new comparison function, of type richcmpfunc defined by:</p>
<pre class="literal-block">
typedef PyObject *(*richcmpfunc)
     Py_PROTO((PyObject *, PyObject *, int));
</pre>
<p>This function takes three arguments. The first two are the objects
to be compared, and the third is an integer corresponding to an
opcode (one of LT, LE, EQ, NE, GT, GE). If this slot is left NULL,
then rich comparison for that object type is not supported (except
for class instances whose class provide the special methods
described below).</p>
<p>The above opcodes need to be added to the published Python/C API
(probably under the names Py_LT, Py_LE, etc.)</p>
</li>
<li><p class="first">Additions of special methods for classes</p>
<p>Classes wishing to support the rich comparison mechanisms must add
one or more of the following new special methods:</p>
<pre class="literal-block">
def __lt__(self, other):
   ...
def __le__(self, other):
   ...
def __gt__(self, other):
   ...
def __ge__(self, other):
   ...
def __eq__(self, other):
   ...
def __ne__(self, other):
   ...
</pre>
<p>Each of these is called when the class instance is the on the
left-hand-side of the corresponding operators (&lt;, &lt;=, &gt;, &gt;=, ==,
and != or &lt;&gt;). The argument other is set to the object on the
right side of the operator. The return value of these methods is
up to the class implementor (after all, that's the entire point of
the proposal).</p>
<p>If the object on the left side of the operator does not define an
appropriate rich comparison operator (either at the C level or
with one of the special methods, then the comparison is reversed,
and the right hand operator is called with the opposite operator,
and the two objects are swapped. This assumes that a &lt; b and b &gt; a
are equivalent, as are a &lt;= b and b &gt;= a, and that == and != are
commutative (e.g. a == b if and only if b == a).</p>
<p>For example, if obj1 is an object which supports the rich
comparison protocol and x and y are objects which do not support
the rich comparison protocol, then obj1 &lt; x will call the <tt class="docutils literal">__lt__</tt>
method of obj1 with x as the second argument. x &lt; obj1 will call
obj1's <tt class="docutils literal">__gt__</tt> method with x as a second argument, and x &lt; y will
just use the existing (non-rich) comparison mechanism.</p>
<p>The above mechanism is such that classes can get away with not
implementing either <tt class="docutils literal">__lt__</tt> and <tt class="docutils literal">__le__</tt> or <tt class="docutils literal">__gt__</tt> and
<tt class="docutils literal">__ge__</tt>. Further smarts could have been added to the comparison
mechanism, but this limited set of allowed &quot;swaps&quot; was chosen
because it doesn't require the infrastructure to do any processing
(negation) of return values. The choice of six special methods was
made over a single (e.g. <tt class="docutils literal">__richcmp__</tt>) method to allow the
dispatching on the opcode to be performed at the level of the C
implementation rather than the user-defined method.</p>
</li>
<li><p class="first">Addition of an optional argument to the builtin <tt class="docutils literal">cmp()</tt></p>
<p>The builtin <tt class="docutils literal">cmp()</tt> is still used for simple comparisons. For rich
comparisons, it is called with a third argument, one of &quot;&lt;&quot;, &quot;&lt;=&quot;,
&quot;&gt;&quot;, &quot;&gt;=&quot;, &quot;==&quot;, &quot;!=&quot;, &quot;&lt;&gt;&quot; (the last two have the same
meaning). When called with one of these strings as the third
argument, <tt class="docutils literal">cmp()</tt> can return any Python object. Otherwise, it can
only return -1, 0 or 1 as before.</p>
</li>
</ol>
</div>
<div class="section" id="chained-comparisons">
<h2><a class="toc-backref" href="#id19">Chained Comparisons</a></h2>
<div class="section" id="problem">
<h3><a class="toc-backref" href="#id20">Problem</a></h3>
<p>It would be nice to allow objects for which the comparison returns
something other than -1, 0, or 1 to be used in chained
comparisons, such as:</p>
<pre class="literal-block">
x &lt; y &lt; z
</pre>
<p>Currently, this is interpreted by Python as:</p>
<pre class="literal-block">
temp1 = x &lt; y
if temp1:
  return y &lt; z
else:
  return temp1
</pre>
<p>Note that this requires testing the truth value of the result of
comparisons, with potential &quot;shortcutting&quot; of the right-side
comparison testings. In other words, the truth-value of the result
of the result of the comparison determines the result of a chained
operation. This is problematic in the case of arrays, since if x,
y and z are three arrays, then the user expects:</p>
<pre class="literal-block">
x &lt; y &lt; z
</pre>
<p>to be an array of 0's and 1's where 1's are in the locations
corresponding to the elements of y which are between the
corresponding elements in x and z. In other words, the right-hand
side must be evaluated regardless of the result of x &lt; y, which is
incompatible with the mechanism currently in use by the parser.</p>
</div>
<div class="section" id="solution">
<h3><a class="toc-backref" href="#id21">Solution</a></h3>
<p>Guido mentioned that one possible way out would be to change the
code generated by chained comparisons to allow arrays to be
chained-compared intelligently. What follows is a mixture of his
idea and my suggestions. The code generated for x &lt; y &lt; z would be
equivalent to:</p>
<pre class="literal-block">
temp1 = x &lt; y
if temp1:
  temp2 = y &lt; z
  return boolean_combine(temp1, temp2)
else:
  return temp1
</pre>
<p>where boolean_combine is a new function which does something like
the following:</p>
<pre class="literal-block">
def boolean_combine(a, b):
    if hasattr(a, '__boolean_and__') or \
       hasattr(b, '__boolean_and__'):
        try:
            return a.__boolean_and__(b)
        except:
            return b.__boolean_and__(a)
    else: # standard behavior
        if a:
            return b
        else:
            return 0
</pre>
<p>where the <tt class="docutils literal">__boolean_and__</tt> special method is implemented for
C-level types by another value of the third argument to the
richcmp function. This method would perform a boolean comparison
of the arrays (currently implemented in the umath module as the
logical_and ufunc).</p>
<p>Thus, objects returned by rich comparisons should always test
true, but should define another special method which creates
boolean combinations of them and their argument.</p>
<p>This solution has the advantage of allowing chained comparisons to
work for arrays, but the disadvantage that it requires comparison
arrays to always return true (in an ideal world, I'd have them
always raise an exception on truth testing, since the meaning of
testing &quot;if a&gt;b:&quot; is massively ambiguous.</p>
<p>The inlining already present which deals with integer comparisons
would still apply, resulting in no performance cost for the most
common cases.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>
</div>
</div>

