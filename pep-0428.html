<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">428</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">The pathlib module -- object-oriented filesystem paths</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0428.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Antoine Pitrou &lt;solipsis&#32;&#97;t&#32;pitrou.net&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">30-July-2012</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.4</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2012-October/016338.html">https://mail.python.org/pipermail/python-ideas/2012-October/016338.html</a></td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2013-November/130424.html">https://mail.python.org/pipermail/python-dev/2013-November/130424.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id25">Abstract</a></li>
<li><a class="reference internal" href="#related-work" id="id26">Related work</a></li>
<li><a class="reference internal" href="#implementation" id="id27">Implementation</a></li>
<li><a class="reference internal" href="#why-an-object-oriented-api" id="id28">Why an object-oriented API</a></li>
<li><a class="reference internal" href="#proposal" id="id29">Proposal</a><ul>
<li><a class="reference internal" href="#class-hierarchy" id="id30">Class hierarchy</a></li>
<li><a class="reference internal" href="#no-confusion-with-builtins" id="id31">No confusion with builtins</a></li>
<li><a class="reference internal" href="#immutability" id="id32">Immutability</a></li>
<li><a class="reference internal" href="#sane-behaviour" id="id33">Sane behaviour</a></li>
<li><a class="reference internal" href="#comparisons" id="id34">Comparisons</a></li>
<li><a class="reference internal" href="#useful-notations" id="id35">Useful notations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pure-paths-api" id="id36">Pure paths API</a><ul>
<li><a class="reference internal" href="#definitions" id="id37">Definitions</a></li>
<li><a class="reference internal" href="#construction" id="id38">Construction</a></li>
<li><a class="reference internal" href="#representing" id="id39">Representing</a></li>
<li><a class="reference internal" href="#properties" id="id40">Properties</a></li>
<li><a class="reference internal" href="#deriving-new-paths" id="id41">Deriving new paths</a><ul>
<li><a class="reference internal" href="#joining" id="id42">Joining</a></li>
<li><a class="reference internal" href="#changing-the-path-s-final-component" id="id43">Changing the path's final component</a></li>
<li><a class="reference internal" href="#making-the-path-relative" id="id44">Making the path relative</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sequence-like-access" id="id45">Sequence-like access</a></li>
<li><a class="reference internal" href="#querying" id="id46">Querying</a></li>
</ul>
</li>
<li><a class="reference internal" href="#concrete-paths-api" id="id47">Concrete paths API</a><ul>
<li><a class="reference internal" href="#constructing" id="id48">Constructing</a></li>
<li><a class="reference internal" href="#file-metadata" id="id49">File metadata</a></li>
<li><a class="reference internal" href="#path-resolution" id="id50">Path resolution</a></li>
<li><a class="reference internal" href="#directory-walking" id="id51">Directory walking</a></li>
<li><a class="reference internal" href="#file-opening" id="id52">File opening</a></li>
<li><a class="reference internal" href="#filesystem-modification" id="id53">Filesystem modification</a></li>
</ul>
</li>
<li><a class="reference internal" href="#discussion" id="id54">Discussion</a><ul>
<li><a class="reference internal" href="#division-operator" id="id55">Division operator</a></li>
<li><a class="reference internal" href="#joinpath" id="id56">joinpath()</a></li>
<li><a class="reference internal" href="#case-sensitivity" id="id57">Case-sensitivity</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id1" id="id58">References</a></li>
<li><a class="reference internal" href="#copyright" id="id59">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id25">Abstract</a></h1>
<p>This PEP proposes the inclusion of a third-party module, <a class="reference external" href="http://pypi.python.org/pypi/pathlib/">pathlib</a> <a class="footnote-reference" href="#id2" id="id3">[1]</a>, in
the standard library.  The inclusion is proposed under the provisional
label, as described in <a class="reference external" href="/dev/peps/pep-0411">PEP 411</a>.  Therefore, API changes can be done,
either as part of the PEP process, or after acceptance in the standard
library (and until the provisional label is removed).</p>
<p>The aim of this library is to provide a simple hierarchy of classes to
handle filesystem paths and the common operations users do over them.</p>
</div>
<div class="section" id="related-work">
<h1><a class="toc-backref" href="#id26">Related work</a></h1>
<p>An object-oriented API for filesystem paths has already been proposed
and rejected in <a class="reference external" href="/dev/peps/pep-0355">PEP 355</a>.  Several third-party implementations of the
idea of object-oriented filesystem paths exist in the wild:</p>
<ul class="simple">
<li>The historical <a class="reference external" href="https://github.com/jaraco/path.py">path.py module</a> <a class="footnote-reference" href="#id7" id="id8">[2]</a> by Jason Orendorff, Jason R. Coombs
and others, which provides a <tt class="docutils literal">str</tt>-subclassing <tt class="docutils literal">Path</tt> class;</li>
<li>Twisted's slightly specialized <a class="reference external" href="http://twistedmatrix.com/documents/current/api/twisted.python.filepath.FilePath.html">FilePath class</a> <a class="footnote-reference" href="#id9" id="id10">[3]</a>;</li>
<li>An <a class="reference external" href="http://wiki.python.org/moin/AlternativePathClass">AlternativePathClass proposal</a> <a class="footnote-reference" href="#id11" id="id12">[4]</a>, subclassing <tt class="docutils literal">tuple</tt> rather than
<tt class="docutils literal">str</tt>;</li>
<li><a class="reference external" href="https://bitbucket.org/sluggo/unipath/overview">Unipath</a> <a class="footnote-reference" href="#id13" id="id14">[5]</a>, a variation on the str-subclassing approach with two public
classes, an <tt class="docutils literal">AbstractPath</tt> class for operations which don't do I/O and a
<tt class="docutils literal">Path</tt> class for all common operations.</li>
</ul>
<p>This proposal attempts to learn from these previous attempts and the
rejection of <a class="reference external" href="/dev/peps/pep-0355">PEP 355</a>.</p>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id27">Implementation</a></h1>
<p>The implementation of this proposal is tracked in the <tt class="docutils literal">pep428</tt> branch
of pathlib's <a class="reference external" href="https://bitbucket.org/pitrou/pathlib/">Mercurial repository</a> <a class="footnote-reference" href="#id15" id="id16">[6]</a>.</p>
</div>
<div class="section" id="why-an-object-oriented-api">
<h1><a class="toc-backref" href="#id28">Why an object-oriented API</a></h1>
<p>The rationale to represent filesystem paths using dedicated classes is the
same as for other kinds of stateless objects, such as dates, times or IP
addresses.  Python has been slowly moving away from strictly replicating
the C language's APIs to providing better, more helpful abstractions around
all kinds of common functionality.  Even if this PEP isn't accepted, it is
likely that another form of filesystem handling abstraction will be adopted
one day into the standard library.</p>
<p>Indeed, many people will prefer handling dates and times using the high-level
objects provided by the <tt class="docutils literal">datetime</tt> module, rather than using numeric
timestamps and the <tt class="docutils literal">time</tt> module API.  Moreover, using a dedicated class
allows to enable desirable behaviours by default, for example the case
insensitivity of Windows paths.</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id29">Proposal</a></h1>
<div class="section" id="class-hierarchy">
<h2><a class="toc-backref" href="#id30">Class hierarchy</a></h2>
<p>The <a class="reference external" href="http://pypi.python.org/pypi/pathlib/">pathlib</a> <a class="footnote-reference" href="#id2" id="id4">[1]</a> module implements a simple hierarchy of classes:</p>
<pre class="literal-block">
                +----------+
                |          |
       ---------| PurePath |--------
       |        |          |       |
       |        +----------+       |
       |             |             |
       |             |             |
       v             |             v
+---------------+    |    +-----------------+
|               |    |    |                 |
| PurePosixPath |    |    | PureWindowsPath |
|               |    |    |                 |
+---------------+    |    +-----------------+
       |             v             |
       |          +------+         |
       |          |      |         |
       |   -------| Path |------   |
       |   |      |      |     |   |
       |   |      +------+     |   |
       |   |                   |   |
       |   |                   |   |
       v   v                   v   v
  +-----------+           +-------------+
  |           |           |             |
  | PosixPath |           | WindowsPath |
  |           |           |             |
  +-----------+           +-------------+
</pre>
<p>This hierarchy divides path classes along two dimensions:</p>
<ul class="simple">
<li>a path class can be either pure or concrete: pure classes support only
operations that don't need to do any actual I/O, which are most path
manipulation operations; concrete classes support all the operations
of pure classes, plus operations that do I/O.</li>
<li>a path class is of a given flavour according to the kind of operating
system paths it represents.  <a class="reference external" href="http://pypi.python.org/pypi/pathlib/">pathlib</a> <a class="footnote-reference" href="#id2" id="id5">[1]</a> implements two flavours: Windows
paths for the filesystem semantics embodied in Windows systems, POSIX
paths for other systems.</li>
</ul>
<p>Any pure class can be instantiated on any system: for example, you can
manipulate <tt class="docutils literal">PurePosixPath</tt> objects under Windows, <tt class="docutils literal">PureWindowsPath</tt>
objects under Unix, and so on.  However, concrete classes can only be
instantiated on a matching system: indeed, it would be error-prone to start
doing I/O with <tt class="docutils literal">WindowsPath</tt> objects under Unix, or vice-versa.</p>
<p>Furthermore, there are two base classes which also act as system-dependent
factories: <tt class="docutils literal">PurePath</tt> will instantiate either a <tt class="docutils literal">PurePosixPath</tt> or a
<tt class="docutils literal">PureWindowsPath</tt> depending on the operating system.  Similarly, <tt class="docutils literal">Path</tt>
will instantiate either a <tt class="docutils literal">PosixPath</tt> or a <tt class="docutils literal">WindowsPath</tt>.</p>
<p>It is expected that, in most uses, using the <tt class="docutils literal">Path</tt> class is adequate,
which is why it has the shortest name of all.</p>
</div>
<div class="section" id="no-confusion-with-builtins">
<h2><a class="toc-backref" href="#id31">No confusion with builtins</a></h2>
<p>In this proposal, the path classes do not derive from a builtin type.  This
contrasts with some other Path class proposals which were derived from
<tt class="docutils literal">str</tt>.  They also do not pretend to implement the sequence protocol:
if you want a path to act as a sequence, you have to lookup a dedicated
attribute (the <tt class="docutils literal">parts</tt> attribute).</p>
<p>The key reasoning behind not inheriting from <tt class="docutils literal">str</tt> is to prevent accidentally
performing operations with a string representing a path and a string that
doesn't, e.g. <tt class="docutils literal">path + an_accident</tt>. Since operations with a string will not
necessarily lead to a valid or expected file system path, &quot;explicit is better
than implicit&quot; by avoiding accidental operations with strings by not
subclassing it. A <a class="reference external" href="http://www.snarky.ca/why-pathlib-path-doesn-t-inherit-from-str">blog post</a> <a class="footnote-reference" href="#id17" id="id18">[7]</a> by a Python core developer goes into more detail
on the reasons behind this specific design decision.</p>
</div>
<div class="section" id="immutability">
<h2><a class="toc-backref" href="#id32">Immutability</a></h2>
<p>Path objects are immutable, which makes them hashable and also prevents a
class of programming errors.</p>
</div>
<div class="section" id="sane-behaviour">
<h2><a class="toc-backref" href="#id33">Sane behaviour</a></h2>
<p>Little of the functionality from os.path is reused.  Many os.path functions
are tied by backwards compatibility to confusing or plain wrong behaviour
(for example, the fact that <tt class="docutils literal">os.path.abspath()</tt> simplifies &quot;..&quot; path
components without resolving symlinks first).</p>
</div>
<div class="section" id="comparisons">
<h2><a class="toc-backref" href="#id34">Comparisons</a></h2>
<p>Paths of the same flavour are comparable and orderable, whether pure or not:</p>
<pre class="literal-block">
&gt;&gt;&gt; PurePosixPath('a') == PurePosixPath('b')
False
&gt;&gt;&gt; PurePosixPath('a') &lt; PurePosixPath('b')
True
&gt;&gt;&gt; PurePosixPath('a') == PosixPath('a')
True
</pre>
<p>Comparing and ordering Windows path objects is case-insensitive:</p>
<pre class="literal-block">
&gt;&gt;&gt; PureWindowsPath('a') == PureWindowsPath('A')
True
</pre>
<p>Paths of different flavours always compare unequal, and cannot be ordered:</p>
<pre class="literal-block">
&gt;&gt;&gt; PurePosixPath('a') == PureWindowsPath('a')
False
&gt;&gt;&gt; PurePosixPath('a') &lt; PureWindowsPath('a')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unorderable types: PurePosixPath() &lt; PureWindowsPath()
</pre>
<p>Paths compare unequal to, and are not orderable with instances of builtin
types (such as <tt class="docutils literal">str</tt>) and any other types.</p>
</div>
<div class="section" id="useful-notations">
<h2><a class="toc-backref" href="#id35">Useful notations</a></h2>
<p>The API tries to provide useful notations all the while avoiding magic.
Some examples:</p>
<pre class="literal-block">
&gt;&gt;&gt; p = Path('/home/antoine/pathlib/setup.py')
&gt;&gt;&gt; p.name
'setup.py'
&gt;&gt;&gt; p.suffix
'.py'
&gt;&gt;&gt; p.root
'/'
&gt;&gt;&gt; p.parts
('/', 'home', 'antoine', 'pathlib', 'setup.py')
&gt;&gt;&gt; p.relative_to('/home/antoine')
PosixPath('pathlib/setup.py')
&gt;&gt;&gt; p.exists()
True
</pre>
</div>
</div>
<div class="section" id="pure-paths-api">
<h1><a class="toc-backref" href="#id36">Pure paths API</a></h1>
<p>The philosophy of the <tt class="docutils literal">PurePath</tt> API is to provide a consistent array of
useful path manipulation operations, without exposing a hodge-podge of
functions like <tt class="docutils literal">os.path</tt> does.</p>
<div class="section" id="definitions">
<h2><a class="toc-backref" href="#id37">Definitions</a></h2>
<p>First a couple of conventions:</p>
<ul class="simple">
<li>All paths can have a drive and a root.  For POSIX paths, the drive is
always empty.</li>
<li>A relative path has neither drive nor root.</li>
<li>A POSIX path is absolute if it has a root.  A Windows path is absolute if
it has both a drive <em>and</em> a root.  A Windows UNC path (e.g.
<tt class="docutils literal">\\host\share\myfile.txt</tt>) always has a drive and a root
(here, <tt class="docutils literal">\\host\share</tt> and <tt class="docutils literal">\</tt>, respectively).</li>
<li>A path which has either a drive <em>or</em> a root is said to be anchored.
Its anchor is the concatenation of the drive and root.  Under POSIX,
&quot;anchored&quot; is the same as &quot;absolute&quot;.</li>
</ul>
</div>
<div class="section" id="construction">
<h2><a class="toc-backref" href="#id38">Construction</a></h2>
<p>We will present construction and joining together since they expose
similar semantics.</p>
<p>The simplest way to construct a path is to pass it its string representation:</p>
<pre class="literal-block">
&gt;&gt;&gt; PurePath('setup.py')
PurePosixPath('setup.py')
</pre>
<p>Extraneous path separators and <tt class="docutils literal">&quot;.&quot;</tt> components are eliminated:</p>
<pre class="literal-block">
&gt;&gt;&gt; PurePath('a///b/c/./d/')
PurePosixPath('a/b/c/d')
</pre>
<p>If you pass several arguments, they will be automatically joined:</p>
<pre class="literal-block">
&gt;&gt;&gt; PurePath('docs', 'Makefile')
PurePosixPath('docs/Makefile')
</pre>
<p>Joining semantics are similar to os.path.join, in that anchored paths ignore
the information from the previously joined components:</p>
<pre class="literal-block">
&gt;&gt;&gt; PurePath('/etc', '/usr', 'bin')
PurePosixPath('/usr/bin')
</pre>
<p>However, with Windows paths, the drive is retained as necessary:</p>
<pre class="literal-block">
&gt;&gt;&gt; PureWindowsPath('c:/foo', '/Windows')
PureWindowsPath('c:/Windows')
&gt;&gt;&gt; PureWindowsPath('c:/foo', 'd:')
PureWindowsPath('d:')
</pre>
<p>Also, path separators are normalized to the platform default:</p>
<pre class="literal-block">
&gt;&gt;&gt; PureWindowsPath('a/b') == PureWindowsPath('a\\b')
True
</pre>
<p>Extraneous path separators and <tt class="docutils literal">&quot;.&quot;</tt> components are eliminated, but not
<tt class="docutils literal"><span class="pre">&quot;..&quot;</span></tt> components:</p>
<pre class="literal-block">
&gt;&gt;&gt; PurePosixPath('a//b/./c/')
PurePosixPath('a/b/c')
&gt;&gt;&gt; PurePosixPath('a/../b')
PurePosixPath('a/../b')
</pre>
<p>Multiple leading slashes are treated differently depending on the path
flavour.  They are always retained on Windows paths (because of the UNC
notation):</p>
<pre class="literal-block">
&gt;&gt;&gt; PureWindowsPath('//some/path')
PureWindowsPath('//some/path/')
</pre>
<p>On POSIX, they are collapsed except if there are exactly two leading slashes,
which is a special case in the POSIX specification on <a class="reference external" href="http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap04.html#tag_04_11">pathname resolution</a> <a class="footnote-reference" href="#id19" id="id20">[8]</a>
(this is also necessary for Cygwin compatibility):</p>
<pre class="literal-block">
&gt;&gt;&gt; PurePosixPath('///some/path')
PurePosixPath('/some/path')
&gt;&gt;&gt; PurePosixPath('//some/path')
PurePosixPath('//some/path')
</pre>
<p>Calling the constructor without any argument creates a path object pointing
to the logical &quot;current directory&quot; (without looking up its absolute path,
which is the job of the <tt class="docutils literal">cwd()</tt> classmethod on concrete paths):</p>
<pre class="literal-block">
&gt;&gt;&gt; PurePosixPath()
PurePosixPath('.')
</pre>
</div>
<div class="section" id="representing">
<h2><a class="toc-backref" href="#id39">Representing</a></h2>
<p>To represent a path (e.g. to pass it to third-party libraries), just call
<tt class="docutils literal">str()</tt> on it:</p>
<pre class="literal-block">
&gt;&gt;&gt; p = PurePath('/home/antoine/pathlib/setup.py')
&gt;&gt;&gt; str(p)
'/home/antoine/pathlib/setup.py'
&gt;&gt;&gt; p = PureWindowsPath('c:/windows')
&gt;&gt;&gt; str(p)
'c:\\windows'
</pre>
<p>To force the string representation with forward slashes, use the <tt class="docutils literal">as_posix()</tt>
method:</p>
<pre class="literal-block">
&gt;&gt;&gt; p.as_posix()
'c:/windows'
</pre>
<p>To get the bytes representation (which might be useful under Unix systems),
call <tt class="docutils literal">bytes()</tt> on it, which internally uses <tt class="docutils literal">os.fsencode()</tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; bytes(p)
b'/home/antoine/pathlib/setup.py'
</pre>
<p>To represent the path as a <tt class="docutils literal">file:</tt> URI, call the <tt class="docutils literal">as_uri()</tt> method:</p>
<pre class="literal-block">
&gt;&gt;&gt; p = PurePosixPath('/etc/passwd')
&gt;&gt;&gt; p.as_uri()
'file:///etc/passwd'
&gt;&gt;&gt; p = PureWindowsPath('c:/Windows')
&gt;&gt;&gt; p.as_uri()
'file:///c:/Windows'
</pre>
<p>The repr() of a path always uses forward slashes, even under Windows, for
readability and to remind users that forward slashes are ok:</p>
<pre class="literal-block">
&gt;&gt;&gt; p = PureWindowsPath('c:/Windows')
&gt;&gt;&gt; p
PureWindowsPath('c:/Windows')
</pre>
</div>
<div class="section" id="properties">
<h2><a class="toc-backref" href="#id40">Properties</a></h2>
<p>Several simple properties are provided on every path (each can be empty):</p>
<pre class="literal-block">
&gt;&gt;&gt; p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')
&gt;&gt;&gt; p.drive
'c:'
&gt;&gt;&gt; p.root
'\\'
&gt;&gt;&gt; p.anchor
'c:\\'
&gt;&gt;&gt; p.name
'pathlib.tar.gz'
&gt;&gt;&gt; p.stem
'pathlib.tar'
&gt;&gt;&gt; p.suffix
'.gz'
&gt;&gt;&gt; p.suffixes
['.tar', '.gz']
</pre>
</div>
<div class="section" id="deriving-new-paths">
<h2><a class="toc-backref" href="#id41">Deriving new paths</a></h2>
<div class="section" id="joining">
<h3><a class="toc-backref" href="#id42">Joining</a></h3>
<p>A path can be joined with another using the <tt class="docutils literal">/</tt> operator:</p>
<pre class="literal-block">
&gt;&gt;&gt; p = PurePosixPath('foo')
&gt;&gt;&gt; p / 'bar'
PurePosixPath('foo/bar')
&gt;&gt;&gt; p / PurePosixPath('bar')
PurePosixPath('foo/bar')
&gt;&gt;&gt; 'bar' / p
PurePosixPath('bar/foo')
</pre>
<p>As with the constructor, multiple path components can be specified, either
collapsed or separately:</p>
<pre class="literal-block">
&gt;&gt;&gt; p / 'bar/xyzzy'
PurePosixPath('foo/bar/xyzzy')
&gt;&gt;&gt; p / 'bar' / 'xyzzy'
PurePosixPath('foo/bar/xyzzy')
</pre>
<p>A joinpath() method is also provided, with the same behaviour:</p>
<pre class="literal-block">
&gt;&gt;&gt; p.joinpath('Python')
PurePosixPath('foo/Python')
</pre>
</div>
<div class="section" id="changing-the-path-s-final-component">
<h3><a class="toc-backref" href="#id43">Changing the path's final component</a></h3>
<p>The <tt class="docutils literal">with_name()</tt> method returns a new path, with the name changed:</p>
<pre class="literal-block">
&gt;&gt;&gt; p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')
&gt;&gt;&gt; p.with_name('setup.py')
PureWindowsPath('c:/Downloads/setup.py')
</pre>
<p>It fails with a <tt class="docutils literal">ValueError</tt> if the path doesn't have an actual name:</p>
<pre class="literal-block">
&gt;&gt;&gt; p = PureWindowsPath('c:/')
&gt;&gt;&gt; p.with_name('setup.py')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;pathlib.py&quot;, line 875, in with_name
    raise ValueError(&quot;%r has an empty name&quot; % (self,))
ValueError: PureWindowsPath('c:/') has an empty name
&gt;&gt;&gt; p.name
''
</pre>
<p>The <tt class="docutils literal">with_suffix()</tt> method returns a new path with the suffix changed.
However, if the path has no suffix, the new suffix is added:</p>
<pre class="literal-block">
&gt;&gt;&gt; p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')
&gt;&gt;&gt; p.with_suffix('.bz2')
PureWindowsPath('c:/Downloads/pathlib.tar.bz2')
&gt;&gt;&gt; p = PureWindowsPath('README')
&gt;&gt;&gt; p.with_suffix('.bz2')
PureWindowsPath('README.bz2')
</pre>
</div>
<div class="section" id="making-the-path-relative">
<h3><a class="toc-backref" href="#id44">Making the path relative</a></h3>
<p>The <tt class="docutils literal">relative_to()</tt> method computes the relative difference of a path to
another:</p>
<pre class="literal-block">
&gt;&gt;&gt; PurePosixPath('/usr/bin/python').relative_to('/usr')
PurePosixPath('bin/python')
</pre>
<p>ValueError is raised if the method cannot return a meaningful value:</p>
<pre class="literal-block">
&gt;&gt;&gt; PurePosixPath('/usr/bin/python').relative_to('/etc')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;pathlib.py&quot;, line 926, in relative_to
    .format(str(self), str(formatted)))
ValueError: '/usr/bin/python' does not start with '/etc'
</pre>
</div>
</div>
<div class="section" id="sequence-like-access">
<h2><a class="toc-backref" href="#id45">Sequence-like access</a></h2>
<p>The <tt class="docutils literal">parts</tt> property returns a tuple providing read-only sequence access
to a path's components:</p>
<pre class="literal-block">
&gt;&gt;&gt; p = PurePosixPath('/etc/init.d')
&gt;&gt;&gt; p.parts
('/', 'etc', 'init.d')
</pre>
<p>Windows paths handle the drive and the root as a single path component:</p>
<pre class="literal-block">
&gt;&gt;&gt; p = PureWindowsPath('c:/setup.py')
&gt;&gt;&gt; p.parts
('c:\\', 'setup.py')
</pre>
<p>(separating them would be wrong, since <tt class="docutils literal">C:</tt> is not the parent of <tt class="docutils literal"><span class="pre">C:\\</span></tt>).</p>
<p>The <tt class="docutils literal">parent</tt> property returns the logical parent of the path:</p>
<pre class="literal-block">
&gt;&gt;&gt; p = PureWindowsPath('c:/python33/bin/python.exe')
&gt;&gt;&gt; p.parent
PureWindowsPath('c:/python33/bin')
</pre>
<p>The <tt class="docutils literal">parents</tt> property returns an immutable sequence of the path's
logical ancestors:</p>
<pre class="literal-block">
&gt;&gt;&gt; p = PureWindowsPath('c:/python33/bin/python.exe')
&gt;&gt;&gt; len(p.parents)
3
&gt;&gt;&gt; p.parents[0]
PureWindowsPath('c:/python33/bin')
&gt;&gt;&gt; p.parents[1]
PureWindowsPath('c:/python33')
&gt;&gt;&gt; p.parents[2]
PureWindowsPath('c:/')
</pre>
</div>
<div class="section" id="querying">
<h2><a class="toc-backref" href="#id46">Querying</a></h2>
<p><tt class="docutils literal">is_relative()</tt> returns True if the path is relative (see definition
above), False otherwise.</p>
<p><tt class="docutils literal">is_reserved()</tt> returns True if a Windows path is a reserved path such
as <tt class="docutils literal">CON</tt> or <tt class="docutils literal">NUL</tt>.  It always returns False for POSIX paths.</p>
<p><tt class="docutils literal">match()</tt> matches the path against a glob pattern. It operates on
individual parts and matches from the right:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; p = PurePosixPath('/usr/bin')
&gt;&gt;&gt; p.match('/usr/b*')
True
&gt;&gt;&gt; p.match('usr/b*')
True
&gt;&gt;&gt; p.match('b*')
True
&gt;&gt;&gt; p.match('/u*')
False
</pre>
</blockquote>
<p>This behaviour respects the following expectations:</p>
<ul class="simple">
<li>A simple pattern such as &quot;*.py&quot; matches arbitrarily long paths as long
as the last part matches, e.g. &quot;/usr/foo/bar.py&quot;.</li>
<li>Longer patterns can be used as well for more complex matching, e.g.
&quot;/usr/foo/*.py&quot; matches &quot;/usr/foo/bar.py&quot;.</li>
</ul>
</div>
</div>
<div class="section" id="concrete-paths-api">
<h1><a class="toc-backref" href="#id47">Concrete paths API</a></h1>
<p>In addition to the operations of the pure API, concrete paths provide
additional methods which actually access the filesystem to query or mutate
information.</p>
<div class="section" id="constructing">
<h2><a class="toc-backref" href="#id48">Constructing</a></h2>
<p>The classmethod <tt class="docutils literal">cwd()</tt> creates a path object pointing to the current
working directory in absolute form:</p>
<pre class="literal-block">
&gt;&gt;&gt; Path.cwd()
PosixPath('/home/antoine/pathlib')
</pre>
</div>
<div class="section" id="file-metadata">
<h2><a class="toc-backref" href="#id49">File metadata</a></h2>
<p>The <tt class="docutils literal">stat()</tt> returns the file's stat() result; similarly, <tt class="docutils literal">lstat()</tt>
returns the file's lstat() result (which is different iff the file is a
symbolic link):</p>
<pre class="literal-block">
&gt;&gt;&gt; p.stat()
posix.stat_result(st_mode=33277, st_ino=7483155, st_dev=2053, st_nlink=1, st_uid=500, st_gid=500, st_size=928, st_atime=1343597970, st_mtime=1328287308, st_ctime=1343597964)
</pre>
<p>Higher-level methods help examine the kind of the file:</p>
<pre class="literal-block">
&gt;&gt;&gt; p.exists()
True
&gt;&gt;&gt; p.is_file()
True
&gt;&gt;&gt; p.is_dir()
False
&gt;&gt;&gt; p.is_symlink()
False
&gt;&gt;&gt; p.is_socket()
False
&gt;&gt;&gt; p.is_fifo()
False
&gt;&gt;&gt; p.is_block_device()
False
&gt;&gt;&gt; p.is_char_device()
False
</pre>
<p>The file owner and group names (rather than numeric ids) are queried
through corresponding methods:</p>
<pre class="literal-block">
&gt;&gt;&gt; p = Path('/etc/shadow')
&gt;&gt;&gt; p.owner()
'root'
&gt;&gt;&gt; p.group()
'shadow'
</pre>
</div>
<div class="section" id="path-resolution">
<h2><a class="toc-backref" href="#id50">Path resolution</a></h2>
<p>The <tt class="docutils literal">resolve()</tt> method makes a path absolute, resolving any symlink on
the way (like the POSIX realpath() call).  It is the only operation which
will remove &quot;<tt class="docutils literal">..</tt>&quot; path components.  On Windows, this method will also
take care to return the canonical path (with the right casing).</p>
</div>
<div class="section" id="directory-walking">
<h2><a class="toc-backref" href="#id51">Directory walking</a></h2>
<p>Simple (non-recursive) directory access is done by calling the iterdir()
method, which returns an iterator over the child paths:</p>
<pre class="literal-block">
&gt;&gt;&gt; p = Path('docs')
&gt;&gt;&gt; for child in p.iterdir(): child
...
PosixPath('docs/conf.py')
PosixPath('docs/_templates')
PosixPath('docs/make.bat')
PosixPath('docs/index.rst')
PosixPath('docs/_build')
PosixPath('docs/_static')
PosixPath('docs/Makefile')
</pre>
<p>This allows simple filtering through list comprehensions:</p>
<pre class="literal-block">
&gt;&gt;&gt; p = Path('.')
&gt;&gt;&gt; [child for child in p.iterdir() if child.is_dir()]
[PosixPath('.hg'), PosixPath('docs'), PosixPath('dist'), PosixPath('__pycache__'), PosixPath('build')]
</pre>
<p>Simple and recursive globbing is also provided:</p>
<pre class="literal-block">
&gt;&gt;&gt; for child in p.glob('**/*.py'): child
...
PosixPath('test_pathlib.py')
PosixPath('setup.py')
PosixPath('pathlib.py')
PosixPath('docs/conf.py')
PosixPath('build/lib/pathlib.py')
</pre>
</div>
<div class="section" id="file-opening">
<h2><a class="toc-backref" href="#id52">File opening</a></h2>
<p>The <tt class="docutils literal">open()</tt> method provides a file opening API similar to the builtin
<tt class="docutils literal">open()</tt> method:</p>
<pre class="literal-block">
&gt;&gt;&gt; p = Path('setup.py')
&gt;&gt;&gt; with p.open() as f: f.readline()
...
'#!/usr/bin/env python3\n'
</pre>
</div>
<div class="section" id="filesystem-modification">
<h2><a class="toc-backref" href="#id53">Filesystem modification</a></h2>
<p>Several common filesystem operations are provided as methods: <tt class="docutils literal">touch()</tt>,
<tt class="docutils literal">mkdir()</tt>, <tt class="docutils literal">rename()</tt>, <tt class="docutils literal">replace()</tt>, <tt class="docutils literal">unlink()</tt>, <tt class="docutils literal">rmdir()</tt>,
<tt class="docutils literal">chmod()</tt>, <tt class="docutils literal">lchmod()</tt>, <tt class="docutils literal">symlink_to()</tt>.  More operations could be
provided, for example some of the functionality of the shutil module.</p>
<p>Detailed documentation of the proposed API can be found at the <a class="reference external" href="https://pathlib.readthedocs.org/en/pep428/">pathlib
docs</a> <a class="footnote-reference" href="#id21" id="id22">[9]</a>.</p>
</div>
</div>
<div class="section" id="discussion">
<h1><a class="toc-backref" href="#id54">Discussion</a></h1>
<div class="section" id="division-operator">
<h2><a class="toc-backref" href="#id55">Division operator</a></h2>
<p>The division operator came out first in a <a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2012-October/016544.html">poll</a> <a class="footnote-reference" href="#id23" id="id24">[10]</a> about the path joining
operator.  Initial versions of <a class="reference external" href="http://pypi.python.org/pypi/pathlib/">pathlib</a> <a class="footnote-reference" href="#id2" id="id6">[1]</a> used square brackets
(i.e. <tt class="docutils literal">__getitem__</tt>) instead.</p>
</div>
<div class="section" id="joinpath">
<h2><a class="toc-backref" href="#id56">joinpath()</a></h2>
<p>The joinpath() method was initially called join(), but several people
objected that it could be confused with str.join() which has different
semantics.  Therefore, it was renamed to joinpath().</p>
</div>
<div class="section" id="case-sensitivity">
<h2><a class="toc-backref" href="#id57">Case-sensitivity</a></h2>
<p>Windows users consider filesystem paths to be case-insensitive and expect
path objects to observe that characteristic, even though in some rare
situations some foreign filesystem mounts may be case-sensitive under
Windows.</p>
<p>In the words of one commenter,</p>
<blockquote>
<p>&quot;If glob(&quot;*.py&quot;) failed to find SETUP.PY on Windows, that would be a
usability disaster&quot;.</p>
<p class="attribution">&mdash;Paul Moore in
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2013-April/125254.html">https://mail.python.org/pipermail/python-dev/2013-April/125254.html</a></p>
</blockquote>
</div>
</div>
<div class="section" id="id1">
<h1><a class="toc-backref" href="#id58">References</a></h1>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id4">2</a>, <a class="fn-backref" href="#id5">3</a>, <a class="fn-backref" href="#id6">4</a>)</em> <a class="reference external" href="http://pypi.python.org/pypi/pathlib/">http://pypi.python.org/pypi/pathlib/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[2]</a></td><td><a class="reference external" href="https://github.com/jaraco/path.py">https://github.com/jaraco/path.py</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[3]</a></td><td><a class="reference external" href="http://twistedmatrix.com/documents/current/api/twisted.python.filepath.FilePath.html">http://twistedmatrix.com/documents/current/api/twisted.python.filepath.FilePath.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[4]</a></td><td><a class="reference external" href="http://wiki.python.org/moin/AlternativePathClass">http://wiki.python.org/moin/AlternativePathClass</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[5]</a></td><td><a class="reference external" href="https://bitbucket.org/sluggo/unipath/overview">https://bitbucket.org/sluggo/unipath/overview</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[6]</a></td><td><a class="reference external" href="https://bitbucket.org/pitrou/pathlib/">https://bitbucket.org/pitrou/pathlib/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[7]</a></td><td><a class="reference external" href="http://www.snarky.ca/why-pathlib-path-doesn-t-inherit-from-str">http://www.snarky.ca/why-pathlib-path-doesn-t-inherit-from-str</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id20">[8]</a></td><td><a class="reference external" href="http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap04.html#tag_04_11">http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap04.html#tag_04_11</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id22">[9]</a></td><td><a class="reference external" href="https://pathlib.readthedocs.org/en/pep428/">https://pathlib.readthedocs.org/en/pep428/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id23" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id24">[10]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2012-October/016544.html">https://mail.python.org/pipermail/python-ideas/2012-October/016544.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id59">Copyright</a></h1>
<p>This document has been placed into the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8 -->
</div>

