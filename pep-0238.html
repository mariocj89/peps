<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">238</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Changing the Division Operator</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0238.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">moshez&#32;&#97;t&#32;zadka.site.co.il (Moshe Zadka),
guido&#32;&#97;t&#32;python.org (Guido van Rossum)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">11-Mar-2001</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.2</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">16-Mar-2001, 26-Jul-2001, 27-Jul-2001</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id16">Abstract</a></li>
<li><a class="reference internal" href="#motivation" id="id17">Motivation</a></li>
<li><a class="reference internal" href="#variations" id="id18">Variations</a></li>
<li><a class="reference internal" href="#alternatives" id="id19">Alternatives</a></li>
<li><a class="reference internal" href="#api-changes" id="id20">API Changes</a></li>
<li><a class="reference internal" href="#command-line-option" id="id21">Command Line Option</a></li>
<li><a class="reference internal" href="#semantics-of-floor-division" id="id22">Semantics of Floor Division</a></li>
<li><a class="reference internal" href="#semantics-of-true-division" id="id23">Semantics of True Division</a></li>
<li><a class="reference internal" href="#the-future-division-statement" id="id24">The Future Division Statement</a></li>
<li><a class="reference internal" href="#open-issues" id="id25">Open Issues</a></li>
<li><a class="reference internal" href="#resolved-issues" id="id26">Resolved Issues</a></li>
<li><a class="reference internal" href="#faq" id="id27">FAQ</a><ul>
<li><a class="reference internal" href="#when-will-python-3-0-be-released" id="id28">When will Python 3.0 be released?</a></li>
<li><a class="reference internal" href="#why-isn-t-true-division-called-float-division" id="id29">Why isn't true division called float division?</a></li>
<li><a class="reference internal" href="#why-is-there-a-need-for-truediv-and-itruediv" id="id30">Why is there a need for <tt class="docutils literal">__truediv__</tt> and <tt class="docutils literal">__itruediv__</tt>?</a></li>
<li><a class="reference internal" href="#how-do-i-write-code-that-works-under-the-classic-rules-as-well-as-under-the-new-rules-without-using-or-a-future-division-statement" id="id31">How do I write code that works under the classic rules as well as under the new rules without using <tt class="docutils literal">//</tt> or a future division statement?</a></li>
<li><a class="reference internal" href="#how-do-i-specify-the-division-semantics-for-input-compile-execfile-eval-and-exec" id="id32">How do I specify the division semantics for <tt class="docutils literal">input()</tt>, <tt class="docutils literal">compile()</tt>, <tt class="docutils literal">execfile()</tt>, <tt class="docutils literal">eval()</tt> and <tt class="docutils literal">exec</tt>?</a></li>
<li><a class="reference internal" href="#what-about-code-compiled-by-the-codeop-module" id="id33">What about code compiled by the codeop module?</a></li>
<li><a class="reference internal" href="#will-there-be-conversion-tools-or-aids" id="id34">Will there be conversion tools or aids?</a></li>
<li><a class="reference internal" href="#why-is-my-question-not-answered-here" id="id35">Why is my question not answered here?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation" id="id36">Implementation</a></li>
<li><a class="reference internal" href="#references" id="id37">References</a></li>
<li><a class="reference internal" href="#copyright" id="id38">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id16">Abstract</a></h1>
<p>The current division (<tt class="docutils literal">/</tt>) operator has an ambiguous meaning for numerical
arguments: it returns the floor of the mathematical result of division if the
arguments are ints or longs, but it returns a reasonable approximation of the
division result if the arguments are floats or complex.  This makes
expressions expecting float or complex results error-prone when integers are
not expected but possible as inputs.</p>
<p>We propose to fix this by introducing different operators for different
operations: <tt class="docutils literal">x/y</tt> to return a reasonable approximation of the mathematical
result of the division (&quot;true division&quot;), <tt class="docutils literal"><span class="pre">x//y</span></tt> to return the floor
(&quot;floor division&quot;).  We call the current, mixed meaning of x/y
&quot;classic division&quot;.</p>
<p>Because of severe backwards compatibility issues, not to mention a major
flamewar on c.l.py, we propose the following transitional measures (starting
with Python 2.2):</p>
<ul class="simple">
<li>Classic division will remain the default in the Python 2.x series; true
division will be standard in Python 3.0.</li>
<li>The <tt class="docutils literal">//</tt> operator will be available to request floor division
unambiguously.</li>
<li>The future division statement, spelled <tt class="docutils literal">from __future__ import division</tt>,
will change the <tt class="docutils literal">/</tt> operator to mean true division throughout the module.</li>
<li>A command line option will enable run-time warnings for classic division
applied to int or long arguments; another command line option will make true
division the default.</li>
<li>The standard library will use the future division statement and the <tt class="docutils literal">//</tt>
operator when appropriate, so as to completely avoid classic division.</li>
</ul>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id17">Motivation</a></h1>
<p>The classic division operator makes it hard to write numerical expressions
that are supposed to give correct results from arbitrary numerical inputs.
For all other operators, one can write down a formula such as <tt class="docutils literal"><span class="pre">x*y**2</span> + z</tt>,
and the calculated result will be close to the mathematical result (within the
limits of numerical accuracy, of course) for any numerical input type (int,
long, float, or complex).  But division poses a problem: if the expressions
for both arguments happen to have an integral type, it implements floor
division rather than true division.</p>
<p>The problem is unique to dynamically typed languages: in a statically typed
language like C, the inputs, typically function arguments, would be declared
as double or float, and when a call passes an integer argument, it is
converted to double or float at the time of the call.  Python doesn't have
argument type declarations, so integer arguments can easily find their way
into an expression.</p>
<p>The problem is particularly pernicious since ints are perfect substitutes for
floats in all other circumstances: <tt class="docutils literal">math.sqrt(2)</tt> returns the same value as
<tt class="docutils literal">math.sqrt(2.0)</tt>, <tt class="docutils literal">3.14*100</tt> and <tt class="docutils literal">3.14*100.0</tt> return the same value, and
so on.  Thus, the author of a numerical routine may only use floating point
numbers to test his code, and believe that it works correctly, and a user may
accidentally pass in an integer input value and get incorrect results.</p>
<p>Another way to look at this is that classic division makes it difficult to
write polymorphic functions that work well with either float or int arguments;
all other operators already do the right thing.  No algorithm that works for
both ints and floats has a need for truncating division in one case and true
division in the other.</p>
<p>The correct work-around is subtle: casting an argument to float() is wrong if
it could be a complex number; adding 0.0 to an argument doesn't preserve the
sign of the argument if it was minus zero.  The only solution without either
downside is multiplying an argument (typically the first) by 1.0.  This leaves
the value and sign unchanged for float and complex, and turns int and long
into a float with the corresponding value.</p>
<p>It is the opinion of the authors that this is a real design bug in Python, and
that it should be fixed sooner rather than later. Assuming Python usage will
continue to grow, the cost of leaving this bug in the language will eventually
outweigh the cost of fixing old code -- there is an upper bound to the amount
of code to be fixed, but the amount of code that might be affected by the bug
in the future is unbounded.</p>
<p>Another reason for this change is the desire to ultimately unify Python's
numeric model.  This is the subject of <a class="reference external" href="/dev/peps/pep-0228">PEP 228</a> <a class="footnote-reference" href="#id10" id="id1">[0]</a> (which is currently
incomplete).  A unified numeric model removes most of the user's need to be
aware of different numerical types.  This is good for beginners, but also
takes away concerns about different numeric behavior for advanced programmers.
(Of course, it won't remove concerns about numerical stability and accuracy.)</p>
<p>In a unified numeric model, the different types (int, long, float, complex,
and possibly others, such as a new rational type) serve mostly as storage
optimizations, and to some extent to indicate orthogonal properties such as
inexactness or complexity.  In a unified model, the integer 1 should be
indistinguishable from the floating point number 1.0 (except for its
inexactness), and both should behave the same in all numeric contexts.
Clearly, in a unified numeric model, if <tt class="docutils literal"><span class="pre">a==b</span></tt> and <tt class="docutils literal"><span class="pre">c==d</span></tt>, <tt class="docutils literal">a/c</tt> should
equal <tt class="docutils literal">b/d</tt> (taking some liberties due to rounding for inexact numbers), and
since everybody agrees that <tt class="docutils literal">1.0/2.0</tt> equals 0.5, <tt class="docutils literal">1/2</tt> should also equal
0.5.  Likewise, since <tt class="docutils literal"><span class="pre">1//2</span></tt> equals zero, <tt class="docutils literal"><span class="pre">1.0//2.0</span></tt> should also equal
zero.</p>
</div>
<div class="section" id="variations">
<h1><a class="toc-backref" href="#id18">Variations</a></h1>
<p>Aesthetically, <tt class="docutils literal"><span class="pre">x//y</span></tt> doesn't please everyone, and hence several variations
have been proposed.  They are addressed here:</p>
<ul class="simple">
<li><tt class="docutils literal">x div y</tt>.  This would introduce a new keyword.  Since <tt class="docutils literal">div</tt> is a
popular identifier, this would break a fair amount of existing code, unless
the new keyword was only recognized under a future division statement.
Since it is expected that the majority of code that needs to be converted is
dividing integers, this would greatly increase the need for the future
division statement.  Even with a future statement, the general sentiment
against adding new keywords unless absolutely necessary argues against this.</li>
<li><tt class="docutils literal">div(x, y)</tt>.  This makes the conversion of old code much harder.
Replacing <tt class="docutils literal">x/y</tt> with <tt class="docutils literal"><span class="pre">x//y</span></tt> or <tt class="docutils literal">x div y</tt> can be done with a simple
query replace; in most cases the programmer can easily verify that a
particular module only works with integers so all occurrences of <tt class="docutils literal">x/y</tt> can
be replaced.  (The query replace is still needed to weed out slashes
occurring in comments or string literals.)  Replacing <tt class="docutils literal">x/y</tt> with
<tt class="docutils literal">div(x, y)</tt> would require a much more intelligent tool, since the extent
of the expressions to the left and right of the <tt class="docutils literal">/</tt> must be analyzed
before the placement of the <tt class="docutils literal">div(</tt> and <tt class="docutils literal">)</tt> part can be decided.</li>
<li><tt class="docutils literal">x \ y</tt>.  The backslash is already a token, meaning line continuation, and
in general it suggests an <em>escape</em> to Unix eyes.  In addition (this due to
Terry Reedy) this would make things like <tt class="docutils literal"><span class="pre">eval(&quot;x\y&quot;)</span></tt> harder to get
right.</li>
</ul>
</div>
<div class="section" id="alternatives">
<h1><a class="toc-backref" href="#id19">Alternatives</a></h1>
<p>In order to reduce the amount of old code that needs to be converted, several
alternative proposals have been put forth. Here is a brief discussion of each
proposal (or category of proposals).  If you know of an alternative that was
discussed on c.l.py that isn't mentioned here, please mail the second author.</p>
<ul class="simple">
<li>Let <tt class="docutils literal">/</tt> keep its classic semantics; introduce <tt class="docutils literal">//</tt> for true division.
This still leaves a broken operator in the language, and invites to use the
broken behavior.  It also shuts off the road to a unified numeric model a la
<a class="reference external" href="/dev/peps/pep-0228">PEP 228</a> <a class="footnote-reference" href="#id10" id="id2">[0]</a>.</li>
<li>Let int division return a special &quot;portmanteau&quot; type that behaves as an
integer in integer context, but like a float in a float context.  The
problem with this is that after a few operations, the int and the float
value could be miles apart, it's unclear which value should be used in
comparisons, and of course many contexts (like conversion to string) don't
have a clear integer or float preference.</li>
<li>Use a directive to use specific division semantics in a module, rather than
a future statement.  This retains classic division as a permanent wart in
the language, requiring future generations of Python programmers to be
aware of the problem and the remedies.</li>
<li>Use <tt class="docutils literal">from __past__ import division</tt> to use classic division semantics in a
module.  This also retains the classic division as a permanent wart, or at
least for a long time (eventually the past division statement could raise an
<tt class="docutils literal">ImportError</tt>).</li>
<li>Use a directive (or some other way) to specify the Python version for which
a specific piece of code was developed.  This requires future Python
interpreters to be able to emulate <em>exactly</em> several previous versions of
Python, and moreover to do so for multiple versions within the same
interpreter.  This is way too much work.  A much simpler solution is to keep
multiple interpreters installed.  Another argument against this is that the
version directive is almost always overspecified: most code written for
Python X.Y, works for Python X.(Y-1) and X.(Y+1) as well, so specifying X.Y
as a version is more constraining than it needs to be.  At the same time,
there's no way to know at which future or past version the code will break.</li>
</ul>
</div>
<div class="section" id="api-changes">
<h1><a class="toc-backref" href="#id20">API Changes</a></h1>
<p>During the transitional phase, we have to support <em>three</em> division operators
within the same program: classic division (for <tt class="docutils literal">/</tt> in modules without a
future division statement), true division (for <tt class="docutils literal">/</tt> in modules with a future
division statement), and floor division (for <tt class="docutils literal">//</tt>).  Each operator comes in
two flavors: regular, and as an augmented assignment operator (<tt class="docutils literal">/=</tt> or
<tt class="docutils literal">//=</tt>).</p>
<p>The names associated with these variations are:</p>
<ul>
<li><p class="first">Overloaded operator methods:</p>
<pre class="literal-block">
__div__(), __floordiv__(), __truediv__();
__idiv__(), __ifloordiv__(), __itruediv__().
</pre>
</li>
<li><p class="first">Abstract API C functions:</p>
<pre class="literal-block">
PyNumber_Divide(), PyNumber_FloorDivide(),
PyNumber_TrueDivide();

PyNumber_InPlaceDivide(), PyNumber_InPlaceFloorDivide(),
PyNumber_InPlaceTrueDivide().
</pre>
</li>
<li><p class="first">Byte code opcodes:</p>
<pre class="literal-block">
BINARY_DIVIDE, BINARY_FLOOR_DIVIDE, BINARY_TRUE_DIVIDE;
INPLACE_DIVIDE, INPLACE_FLOOR_DIVIDE, INPLACE_TRUE_DIVIDE.
</pre>
</li>
<li><p class="first">PyNumberMethod slots:</p>
<pre class="literal-block">
nb_divide, nb_floor_divide, nb_true_divide,
nb_inplace_divide, nb_inplace_floor_divide,
nb_inplace_true_divide.
</pre>
</li>
</ul>
<p>The added <tt class="docutils literal">PyNumberMethod</tt> slots require an additional flag in <tt class="docutils literal">tp_flags</tt>;
this flag will be named <tt class="docutils literal">Py_TPFLAGS_HAVE_NEWDIVIDE</tt> and will be included in
<tt class="docutils literal">Py_TPFLAGS_DEFAULT</tt>.</p>
<p>The true and floor division APIs will look for the corresponding slots and
call that; when that slot is <tt class="docutils literal">NULL</tt>, they will raise an exception.  There is
no fallback to the classic divide slot.</p>
<p>In Python 3.0, the classic division semantics will be removed; the classic
division APIs will become synonymous with true division.</p>
</div>
<div class="section" id="command-line-option">
<h1><a class="toc-backref" href="#id21">Command Line Option</a></h1>
<p>The <tt class="docutils literal"><span class="pre">-Q</span></tt> command line option takes a string argument that can take four
values: <tt class="docutils literal">old</tt>, <tt class="docutils literal">warn</tt>, <tt class="docutils literal">warnall</tt>, or <tt class="docutils literal">new</tt>.  The default is <tt class="docutils literal">old</tt>
in Python 2.2 but will change to <tt class="docutils literal">warn</tt> in later 2.x versions.  The <tt class="docutils literal">old</tt>
value means the classic division operator acts as described.  The <tt class="docutils literal">warn</tt>
value means the classic division operator issues a warning (a
<tt class="docutils literal">DeprecationWarning</tt> using the standard warning framework) when applied
to ints or longs.  The <tt class="docutils literal">warnall</tt> value also issues warnings for classic
division when applied to floats or complex; this is for use by the
<tt class="docutils literal">fixdiv.py</tt> conversion script mentioned below.  The <tt class="docutils literal">new</tt> value changes
the default globally so that the <tt class="docutils literal">/</tt> operator is always interpreted as
true division.  The <tt class="docutils literal">new</tt> option is only intended for use in certain
educational environments, where true division is required, but asking the
students to include the future division statement in all their code would be a
problem.</p>
<p>This option will not be supported in Python 3.0; Python 3.0 will always
interpret <tt class="docutils literal">/</tt> as true division.</p>
<p>(This option was originally proposed as <tt class="docutils literal"><span class="pre">-D</span></tt>, but that turned out to be an
existing option for Jython, hence the Q -- mnemonic for Quotient.  Other names
have been proposed, like <tt class="docutils literal"><span class="pre">-Qclassic</span></tt>, <tt class="docutils literal"><span class="pre">-Qclassic-warn</span></tt>, <tt class="docutils literal"><span class="pre">-Qtrue</span></tt>, or
<tt class="docutils literal"><span class="pre">-Qold_division</span></tt> etc.; these seem more verbose to me without much advantage.
After all the term classic division is not used in the language at all (only
in the PEP), and the term true division is rarely used in the language -- only
in <tt class="docutils literal">__truediv__</tt>.)</p>
</div>
<div class="section" id="semantics-of-floor-division">
<h1><a class="toc-backref" href="#id22">Semantics of Floor Division</a></h1>
<p>Floor division will be implemented in all the Python numeric types, and will
have the semantics of:</p>
<pre class="literal-block">
a // b == floor(a/b)
</pre>
<p>except that the result type will be the common type into which <em>a</em> and <em>b</em> are
coerced before the operation.</p>
<p>Specifically, if <em>a</em> and <em>b</em> are of the same type, <tt class="docutils literal"><span class="pre">a//b</span></tt> will be of that
type too.  If the inputs are of different types, they are first coerced to a
common type using the same rules used for all other arithmetic operators.</p>
<p>In particular, if <em>a</em> and <em>b</em> are both ints or longs, the result has the same
type and value as for classic division on these types (including the case of
mixed input types; <tt class="docutils literal"><span class="pre">int//long</span></tt> and <tt class="docutils literal"><span class="pre">long//int</span></tt> will both return a long).</p>
<p>For floating point inputs, the result is a float.  For example:</p>
<pre class="literal-block">
3.5//2.0 == 1.0
</pre>
<p>For complex numbers, <tt class="docutils literal">//</tt> raises an exception, since <tt class="docutils literal">floor()</tt> of a
complex number is not allowed.</p>
<p>For user-defined classes and extension types, all semantics are up to the
implementation of the class or type.</p>
</div>
<div class="section" id="semantics-of-true-division">
<h1><a class="toc-backref" href="#id23">Semantics of True Division</a></h1>
<p>True division for ints and longs will convert the arguments to float and then
apply a float division.  That is, even <tt class="docutils literal">2/1</tt> will return a <tt class="docutils literal">float (2.0)</tt>,
not an int.  For floats and complex, it will be the same as classic division.</p>
<p>The 2.2 implementation of true division acts as if the float type had
unbounded range, so that overflow doesn't occur unless the magnitude of the
mathematical <em>result</em> is too large to represent as a float.  For example,
after <tt class="docutils literal">x = 1L &lt;&lt; 40000</tt>, <tt class="docutils literal">float(x)</tt> raises <tt class="docutils literal">OverflowError</tt> (note that
this is also new in 2.2: previously the outcome was platform-dependent, most
commonly a float infinity).  But <tt class="docutils literal">x/x</tt> returns 1.0 without exception,
while <tt class="docutils literal">x/1</tt> raises <tt class="docutils literal">OverflowError</tt>.</p>
<p>Note that for int and long arguments, true division may lose information; this
is in the nature of true division (as long as rationals are not in the
language).  Algorithms that consciously use longs should consider using
<tt class="docutils literal">//</tt>, as true division of longs retains no more than 53 bits of precision
(on most platforms).</p>
<p>If and when a rational type is added to Python (see <a class="reference external" href="/dev/peps/pep-0239">PEP 239</a> <a class="footnote-reference" href="#id12" id="id3">[2]</a>), true
division for ints and longs should probably return a rational.  This avoids
the problem with true division of ints and longs losing information.  But
until then, for consistency, float is the only choice for true division.</p>
</div>
<div class="section" id="the-future-division-statement">
<h1><a class="toc-backref" href="#id24">The Future Division Statement</a></h1>
<p>If <tt class="docutils literal">from __future__ import division</tt> is present in a module, or if
<tt class="docutils literal"><span class="pre">-Qnew</span></tt> is used, the <tt class="docutils literal">/</tt> and <tt class="docutils literal">/=</tt> operators are translated to true
division opcodes; otherwise they are translated to classic division (until
Python 3.0 comes along, where they are always translated to true division).</p>
<p>The future division statement has no effect on the recognition or translation
of <tt class="docutils literal">//</tt> and <tt class="docutils literal">//=</tt>.</p>
<p>See <a class="reference external" href="/dev/peps/pep-0236">PEP 236</a> <a class="footnote-reference" href="#id14" id="id4">[4]</a> for the general rules for future statements.</p>
<p>(It has been proposed to use a longer phrase, like <em>true_division</em> or
<em>modern_division</em>.  These don't seem to add much information.)</p>
</div>
<div class="section" id="open-issues">
<h1><a class="toc-backref" href="#id25">Open Issues</a></h1>
<p>We expect that these issues will be resolved over time, as more feedback is
received or we gather more experience with the initial implementation.</p>
<ul class="simple">
<li>It has been proposed to call <tt class="docutils literal">//</tt> the quotient operator, and the <tt class="docutils literal">/</tt>
operator the ratio operator.  I'm not sure about this -- for some people
quotient is just a synonym for division, and ratio suggests rational
numbers, which is wrong.  I prefer the terminology to be slightly awkward
if that avoids unambiguity.  Also, for some folks <em>quotient</em> suggests
truncation towards zero, not towards infinity as <em>floor division</em>
says explicitly.</li>
<li>It has been argued that a command line option to change the default is
evil.  It can certainly be dangerous in the wrong hands: for example, it
would be impossible to combine a 3rd party library package that requires
<tt class="docutils literal"><span class="pre">-Qnew</span></tt> with another one that requires <tt class="docutils literal"><span class="pre">-Qold</span></tt>.  But I believe that the
VPython folks need a way to enable true division by default, and other
educators might need the same.  These usually have enough control over the
library packages available in their environment.</li>
<li>For classes to have to support all three of <tt class="docutils literal">__div__()</tt>,
<tt class="docutils literal">__floordiv__()</tt> and <tt class="docutils literal">__truediv__()</tt> seems painful; and what to do in
3.0?  Maybe we only need <tt class="docutils literal">__div__()</tt> and <tt class="docutils literal">__floordiv__()</tt>, or maybe at
least true division should try <tt class="docutils literal">__truediv__()</tt> first and <tt class="docutils literal">__div__()</tt>
second.</li>
</ul>
</div>
<div class="section" id="resolved-issues">
<h1><a class="toc-backref" href="#id26">Resolved Issues</a></h1>
<ul>
<li><p class="first">Issue:  For very large long integers, the definition of true division as
returning a float causes problems, since the range of Python longs is much
larger than that of Python floats.  This problem will disappear if and when
rational numbers are supported.</p>
<p>Resolution:  For long true division, Python uses an internal float type with
native double precision but unbounded range, so that OverflowError doesn't
occur unless the quotient is too large to represent as a native double.</p>
</li>
<li><p class="first">Issue:  In the interim, maybe the long-to-float conversion could be made to
raise <tt class="docutils literal">OverflowError</tt> if the long is out of range.</p>
<p>Resolution:  This has been implemented, but, as above, the magnitude of the
inputs to long true division doesn't matter; only the magnitude of the
quotient matters.</p>
</li>
<li><p class="first">Issue:  Tim Peters will make sure that whenever an in-range float is
returned, decent precision is guaranteed.</p>
<p>Resolution:  Provided the quotient of long true division is representable as
a float, it suffers no more than 3 rounding errors:  one each for converting
the inputs to an internal float type with native double precision but
unbounded range, and one more for the division.  However, note that if the
magnitude of the quotient is too <em>small</em> to represent as a native double,
0.0 is returned without exception (&quot;silent underflow&quot;).</p>
</li>
</ul>
</div>
<div class="section" id="faq">
<h1><a class="toc-backref" href="#id27">FAQ</a></h1>
<div class="section" id="when-will-python-3-0-be-released">
<h2><a class="toc-backref" href="#id28">When will Python 3.0 be released?</a></h2>
<blockquote>
We don't plan that long ahead, so we can't say for sure.  We want to allow
at least two years for the transition.  If Python 3.0 comes out sooner,
we'll keep the 2.x line alive for backwards compatibility until at least
two years from the release of Python 2.2.  In practice, you will be able
to continue to use the Python 2.x line for several years after Python 3.0
is released, so you can take your time with the transition.  Sites are
expected to have both Python 2.x and Python 3.x installed simultaneously.</blockquote>
</div>
<div class="section" id="why-isn-t-true-division-called-float-division">
<h2><a class="toc-backref" href="#id29">Why isn't true division called float division?</a></h2>
<blockquote>
Because I want to keep the door open to <em>possibly</em> introducing rationals
and making 1/2 return a rational rather than a float.  See <a class="reference external" href="/dev/peps/pep-0239">PEP 239</a> <a class="footnote-reference" href="#id12" id="id5">[2]</a>.</blockquote>
</div>
<div class="section" id="why-is-there-a-need-for-truediv-and-itruediv">
<h2><a class="toc-backref" href="#id30">Why is there a need for <tt class="docutils literal">__truediv__</tt> and <tt class="docutils literal">__itruediv__</tt>?</a></h2>
<blockquote>
We don't want to make user-defined classes second-class citizens.
Certainly not with the type/class unification going on.</blockquote>
</div>
<div class="section" id="how-do-i-write-code-that-works-under-the-classic-rules-as-well-as-under-the-new-rules-without-using-or-a-future-division-statement">
<h2><a class="toc-backref" href="#id31">How do I write code that works under the classic rules as well as under the new rules without using <tt class="docutils literal">//</tt> or a future division statement?</a></h2>
<blockquote>
Use <tt class="docutils literal">x*1.0/y</tt> for true division, <tt class="docutils literal">divmod(x, y)</tt> <a class="footnote-reference" href="#id10" id="id6">[0]</a> for int
division.  Especially the latter is best hidden inside a function.  You
may also write <tt class="docutils literal"><span class="pre">float(x)/y</span></tt> for true division if you are sure that you
don't expect complex numbers.  If you know your integers are never
negative, you can use <tt class="docutils literal">int(x/y)</tt> -- while the documentation of <tt class="docutils literal">int()</tt>
says that <tt class="docutils literal">int()</tt> can round or truncate depending on the C
implementation, we know of no C implementation that doesn't truncate, and
we're going to change the spec for <tt class="docutils literal">int()</tt> to promise truncation.  Note
that classic division (and floor division) round towards negative
infinity, while <tt class="docutils literal">int()</tt> rounds towards zero, giving different answers
for negative numbers.</blockquote>
</div>
<div class="section" id="how-do-i-specify-the-division-semantics-for-input-compile-execfile-eval-and-exec">
<h2><a class="toc-backref" href="#id32">How do I specify the division semantics for <tt class="docutils literal">input()</tt>, <tt class="docutils literal">compile()</tt>, <tt class="docutils literal">execfile()</tt>, <tt class="docutils literal">eval()</tt> and <tt class="docutils literal">exec</tt>?</a></h2>
<blockquote>
They inherit the choice from the invoking module.  <a class="reference external" href="/dev/peps/pep-0236">PEP 236</a> <a class="footnote-reference" href="#id14" id="id7">[4]</a> now lists
this as a resolved problem, referring to <a class="reference external" href="/dev/peps/pep-0264">PEP 264</a> <a class="footnote-reference" href="#id15" id="id8">[5]</a>.</blockquote>
</div>
<div class="section" id="what-about-code-compiled-by-the-codeop-module">
<h2><a class="toc-backref" href="#id33">What about code compiled by the codeop module?</a></h2>
<blockquote>
This is dealt with properly; see <a class="reference external" href="/dev/peps/pep-0264">PEP 264</a> <a class="footnote-reference" href="#id15" id="id9">[5]</a>.</blockquote>
</div>
<div class="section" id="will-there-be-conversion-tools-or-aids">
<h2><a class="toc-backref" href="#id34">Will there be conversion tools or aids?</a></h2>
<blockquote>
Certainly.  While these are outside the scope of the PEP, I should point
out two simple tools that will be released with Python 2.2a3:
<tt class="docutils literal">Tools/scripts/finddiv.py</tt> finds division operators (slightly smarter
than <tt class="docutils literal">grep /</tt>) and <tt class="docutils literal">Tools/scripts/fixdiv.py</tt> can produce patches based
on run-time analysis.</blockquote>
</div>
<div class="section" id="why-is-my-question-not-answered-here">
<h2><a class="toc-backref" href="#id35">Why is my question not answered here?</a></h2>
<blockquote>
Because we weren't aware of it.  If it's been discussed on c.l.py and you
believe the answer is of general interest, please notify the second
author.  (We don't have the time or inclination to answer every question
sent in private email, hence the requirement that it be discussed on
c.l.py first.)</blockquote>
</div>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id36">Implementation</a></h1>
<p>Essentially everything mentioned here is implemented in CVS and will be
released with Python 2.2a3; most of it was already released with Python 2.2a2.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id37">References</a></h1>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[0]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>, <a class="fn-backref" href="#id6">3</a>)</em> <a class="reference external" href="/dev/peps/pep-0228">PEP 228</a>, Reworking Python's Numeric Model
<a class="reference external" href="http://www.python.org/dev/peps/pep-0228/">http://www.python.org/dev/peps/pep-0228/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><a class="reference external" href="/dev/peps/pep-0237">PEP 237</a>, Unifying Long Integers and Integers, Zadka,
<a class="reference external" href="http://www.python.org/dev/peps/pep-0237/">http://www.python.org/dev/peps/pep-0237/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id5">2</a>)</em> <a class="reference external" href="/dev/peps/pep-0239">PEP 239</a>, Adding a Rational Type to Python, Zadka,
<a class="reference external" href="http://www.python.org/dev/peps/pep-0239/">http://www.python.org/dev/peps/pep-0239/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><a class="reference external" href="/dev/peps/pep-0240">PEP 240</a>, Adding a Rational Literal to Python, Zadka,
<a class="reference external" href="http://www.python.org/dev/peps/pep-0240/">http://www.python.org/dev/peps/pep-0240/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td><em>(<a class="fn-backref" href="#id4">1</a>, <a class="fn-backref" href="#id7">2</a>)</em> <a class="reference external" href="/dev/peps/pep-0236">PEP 236</a>, Back to the __future__, Peters,
<a class="reference external" href="http://www.python.org/dev/peps/pep-0236/">http://www.python.org/dev/peps/pep-0236/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td><em>(<a class="fn-backref" href="#id8">1</a>, <a class="fn-backref" href="#id9">2</a>)</em> <a class="reference external" href="/dev/peps/pep-0264">PEP 264</a>, Future statements in simulated shells
<a class="reference external" href="http://www.python.org/dev/peps/pep-0236/">http://www.python.org/dev/peps/pep-0236/</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id38">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

