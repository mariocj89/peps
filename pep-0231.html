<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">231</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">__findattr__()</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0231.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">barry&#32;&#97;t&#32;python.org (Barry Warsaw)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">30-Nov-2000</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.1</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id16">Introduction</a></li>
<li><a class="reference internal" href="#background" id="id17">Background</a></li>
<li><a class="reference internal" href="#proposal" id="id18">Proposal</a></li>
<li><a class="reference internal" href="#key-differences-with-the-existing-protocol" id="id19">Key Differences with the Existing Protocol</a></li>
<li><a class="reference internal" href="#related-work" id="id20">Related Work</a></li>
<li><a class="reference internal" href="#examples" id="id21">Examples</a></li>
<li><a class="reference internal" href="#reference-implementation" id="id22">Reference Implementation</a></li>
<li><a class="reference internal" href="#references" id="id23">References</a></li>
<li><a class="reference internal" href="#rejection" id="id24">Rejection</a></li>
<li><a class="reference internal" href="#copyright" id="id25">Copyright</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id16">Introduction</a></h1>
<p>This PEP describes an extension to instance attribute lookup and
modification machinery, which allows pure-Python implementations
of many interesting programming models.  This PEP tracks the
status and ownership of this feature.  It contains a description
of the feature and outlines changes necessary to support the
feature.  This PEP summarizes discussions held in mailing list
forums, and provides URLs for further information, where
appropriate.  The CVS revision history of this file contains the
definitive historical record.</p>
</div>
<div class="section" id="background">
<h1><a class="toc-backref" href="#id17">Background</a></h1>
<p>The semantics for Python instances allow the programmer to
customize some aspects of attribute lookup and attribute
modification, through the special methods <tt class="docutils literal">__getattr__()</tt> and
<tt class="docutils literal">__setattr__()</tt> <a class="footnote-reference" href="#id8" id="id1">[1]</a>.</p>
<p>However, because of certain restrictions imposed by these methods,
there are useful programming techniques that can not be written in
Python alone, e.g. strict Java Bean-like <a class="footnote-reference" href="#id9" id="id2">[2]</a> interfaces and Zope
style acquisitions <a class="footnote-reference" href="#id10" id="id3">[3]</a>.  In the latter case, Zope solves this by
including a C extension called ExtensionClass <a class="footnote-reference" href="#id11" id="id4">[5]</a> which modifies
the standard class semantics, and uses a metaclass hook in
Python's class model called alternatively the &quot;Don Beaudry Hook&quot;
or &quot;Don Beaudry Hack&quot; <a class="footnote-reference" href="#id12" id="id5">[6]</a>.</p>
<p>While Zope's approach works, it has several disadvantages.  First,
it requires a C extension.  Second it employs a very arcane, but
truck-sized loophole in the Python machinery.  Third, it can be
difficult for other programmers to use and understand (the
metaclass has well-known brain exploding properties).  And fourth,
because ExtensionClass instances aren't &quot;real&quot; Python instances,
some aspects of the Python runtime system don't work with
ExtensionClass instances.</p>
<p>Proposals for fixing this problem have often been lumped under the
rubric of fixing the &quot;class/type dichotomy&quot;; that is, eliminating
the difference between built-in types and classes <a class="footnote-reference" href="#id13" id="id6">[7]</a>.  While a
laudable goal itself, repairing this rift is not necessary in
order to achieve the types of programming constructs described
above.  This proposal provides an 80% solution with a minimum of
modification to Python's class and instance objects.  It does
nothing to address the type/class dichotomy.</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id18">Proposal</a></h1>
<p>This proposal adds a new special method called <tt class="docutils literal">__findattr__()</tt> with
the following semantics:</p>
<ul class="simple">
<li>If defined in a class, it will be called on all instance
attribute resolutions instead of <tt class="docutils literal">__getattr__()</tt> and
<tt class="docutils literal">__setattr__()</tt>.</li>
<li><tt class="docutils literal">__findattr__()</tt> is never called recursively.  That is, when a
specific instance's <tt class="docutils literal">__findattr__()</tt> is on the call stack, further
attribute accesses for that instance will use the standard
<tt class="docutils literal">__getattr__()</tt> and <tt class="docutils literal">__setattr__()</tt> methods.</li>
<li><tt class="docutils literal">__findattr__()</tt> is called for both attribute access ('getting')
and attribute modification ('setting').  It is not called for
attribute deletion.</li>
<li>When called for getting, it is passed a single argument (not
counting 'self'): the name of the attribute being accessed.</li>
<li>When called for setting, it is called with third argument, which
is the value to set the attribute to.</li>
<li><tt class="docutils literal">__findattr__()</tt> methods have the same caching semantics as
<tt class="docutils literal">__getattr__()</tt> and <tt class="docutils literal">__setattr__()</tt>; i.e. if they are present in the
class at class definition time, they are used, but if they are
subsequently added to a class later they are not.</li>
</ul>
</div>
<div class="section" id="key-differences-with-the-existing-protocol">
<h1><a class="toc-backref" href="#id19">Key Differences with the Existing Protocol</a></h1>
<p><tt class="docutils literal">__findattr__()</tt>'s semantics are different from the existing
protocol in key ways:</p>
<p>First, <tt class="docutils literal">__getattr__()</tt> is never called if the attribute is found in
the instance's <tt class="docutils literal">__dict__</tt>.  This is done for efficiency reasons, and
because otherwise, <tt class="docutils literal">__setattr__()</tt> would have no way to get to the
instance's attributes.</p>
<p>Second, <tt class="docutils literal">__setattr__()</tt> cannot use &quot;normal&quot; syntax for setting
instance attributes, e.g. &quot;self.name = foo&quot; because that would
cause recursive calls to <tt class="docutils literal">__setattr__()</tt>.</p>
<p><tt class="docutils literal">__findattr__()</tt> is always called regardless of whether the
attribute is in <tt class="docutils literal">__dict__</tt> or not, and a flag in the instance object
prevents recursive calls to <tt class="docutils literal">__findattr__()</tt>.  This gives the class
a chance to perform some action for every attribute access.  And
because it is called for both gets and sets, it is easy to write
similar policy for all attribute access.  Further, efficiency is
not a problem because it is only paid when the extended mechanism
is used.</p>
</div>
<div class="section" id="related-work">
<h1><a class="toc-backref" href="#id20">Related Work</a></h1>
<p><a class="reference external" href="/dev/peps/pep-0213">PEP 213</a> <a class="footnote-reference" href="#id15" id="id7">[9]</a> describes a different approach to hooking into
attribute access and modification.  The semantics proposed in <a class="reference external" href="/dev/peps/pep-0213">PEP
213</a> can be implemented using the <tt class="docutils literal">__findattr__()</tt> hook described
here, with one caveat.  The current reference implementation of
<tt class="docutils literal">__findattr__()</tt> does not support hooking on attribute deletion.
This could be added if it's found desirable.  See example below.</p>
</div>
<div class="section" id="examples">
<h1><a class="toc-backref" href="#id21">Examples</a></h1>
<p>One programming style that this proposal allows is a Java
Bean-like interface to objects, where unadorned attribute access
and modification is transparently mapped to a functional
interface.  E.g.</p>
<pre class="literal-block">
class Bean:
    def __init__(self, x):
        self.__myfoo = x

    def __findattr__(self, name, *args):
        if name.startswith('_'):
            # Private names
            if args: setattr(self, name, args[0])
            else:    return getattr(self, name)
        else:
            # Public names
            if args: name = '_set_' + name
            else:    name = '_get_' + name
            return getattr(self, name)(*args)

    def _set_foo(self, x):
        self.__myfoo = x

    def _get_foo(self):
        return self.__myfoo


b = Bean(3)
print b.foo
b.foo = 9
print b.foo
</pre>
<p>A second, more elaborate example is the implementation of both
implicit and explicit acquisition in pure Python:</p>
<pre class="literal-block">
import types

class MethodWrapper:
    def __init__(self, container, method):
        self.__container = container
        self.__method = method

    def __call__(self, *args, **kws):
        return self.__method.im_func(self.__container, *args, **kws)


class WrapperImplicit:
    def __init__(self, contained, container):
        self.__contained = contained
        self.__container = container

    def __repr__(self):
        return '&lt;Wrapper: [%s | %s]&gt;' % (self.__container,
                                         self.__contained)

    def __findattr__(self, name, *args):
        # Some things are our own
        if name.startswith('_WrapperImplicit__'):
            if args: return setattr(self, name, *args)
            else:    return getattr(self, name)
        # setattr stores the name on the contained object directly
        if args:
            return setattr(self.__contained, name, args[0])
        # Other special names
        if name == 'aq_parent':
            return self.__container
        elif name == 'aq_self':
            return self.__contained
        elif name == 'aq_base':
            base = self.__contained
            try:
                while 1:
                    base = base.aq_self
            except AttributeError:
                return base
        # no acquisition for _ names
        if name.startswith('_'):
            return getattr(self.__contained, name)
        # Everything else gets wrapped
        missing = []
        which = self.__contained
        obj = getattr(which, name, missing)
        if obj is missing:
            which = self.__container
            obj = getattr(which, name, missing)
            if obj is missing:
                raise AttributeError, name
        of = getattr(obj, '__of__', missing)
        if of is not missing:
            return of(self)
        elif type(obj) == types.MethodType:
            return MethodWrapper(self, obj)
        return obj


class WrapperExplicit:
    def __init__(self, contained, container):
        self.__contained = contained
        self.__container = container

    def __repr__(self):
        return '&lt;Wrapper: [%s | %s]&gt;' % (self.__container,
                                         self.__contained)

    def __findattr__(self, name, *args):
        # Some things are our own
        if name.startswith('_WrapperExplicit__'):
            if args: return setattr(self, name, *args)
            else:    return getattr(self, name)
        # setattr stores the name on the contained object directly
        if args:
            return setattr(self.__contained, name, args[0])
        # Other special names
        if name == 'aq_parent':
            return self.__container
        elif name == 'aq_self':
            return self.__contained
        elif name == 'aq_base':
            base = self.__contained
            try:
                while 1:
                    base = base.aq_self
            except AttributeError:
                return base
        elif name == 'aq_acquire':
            return self.aq_acquire
        # explicit acquisition only
        obj = getattr(self.__contained, name)
        if type(obj) == types.MethodType:
            return MethodWrapper(self, obj)
        return obj

    def aq_acquire(self, name):
        # Everything else gets wrapped
        missing = []
        which = self.__contained
        obj = getattr(which, name, missing)
        if obj is missing:
            which = self.__container
            obj = getattr(which, name, missing)
            if obj is missing:
                raise AttributeError, name
        of = getattr(obj, '__of__', missing)
        if of is not missing:
            return of(self)
        elif type(obj) == types.MethodType:
            return MethodWrapper(self, obj)
        return obj


class Implicit:
    def __of__(self, container):
        return WrapperImplicit(self, container)

    def __findattr__(self, name, *args):
        # ignore setattrs
        if args:
            return setattr(self, name, args[0])
        obj = getattr(self, name)
        missing = []
        of = getattr(obj, '__of__', missing)
        if of is not missing:
            return of(self)
        return obj


class Explicit(Implicit):
    def __of__(self, container):
        return WrapperExplicit(self, container)


# tests
class C(Implicit):
    color = 'red'

class A(Implicit):
    def report(self):
        return self.color

# simple implicit acquisition
c = C()
a = A()
c.a = a
assert c.a.report() == 'red'

d = C()
d.color = 'green'
d.a = a
assert d.a.report() == 'green'

try:
    a.report()
except AttributeError:
    pass
else:
    assert 0, 'AttributeError expected'


# special names
assert c.a.aq_parent is c
assert c.a.aq_self is a

c.a.d = d
assert c.a.d.aq_base is d
assert c.a is not a


# no acquisition on _ names
class E(Implicit):
    _color = 'purple'

class F(Implicit):
    def report(self):
        return self._color

e = E()
f = F()
e.f = f
try:
    e.f.report()
except AttributeError:
    pass
else:
    assert 0, 'AttributeError expected'


# explicit
class G(Explicit):
    color = 'pink'

class H(Explicit):
    def report(self):
        return self.aq_acquire('color')

    def barf(self):
        return self.color

g = G()
h = H()
g.h = h
assert g.h.report() == 'pink'

i = G()
i.color = 'cyan'
i.h = h
assert i.h.report() == 'cyan'

try:
    g.i.barf()
except AttributeError:
    pass
else:
    assert 0, 'AttributeError expected'
</pre>
<p>C++-like access control can also be accomplished, although less
cleanly because of the difficulty of figuring out what method is
being called from the runtime call stack:</p>
<pre class="literal-block">
import sys
import types

PUBLIC = 0
PROTECTED = 1
PRIVATE = 2

try:
    getframe = sys._getframe
except ImportError:
    def getframe(n):
        try: raise Exception
        except Exception:
            frame = sys.exc_info()[2].tb_frame
        while n &gt; 0:
            frame = frame.f_back
            if frame is None:
                raise ValueError, 'call stack is not deep enough'
        return frame


class AccessViolation(Exception):
    pass


class Access:
    def __findattr__(self, name, *args):
        methcache = self.__dict__.setdefault('__cache__', {})
        missing = []
        obj = getattr(self, name, missing)
        # if obj is missing we better be doing a setattr for
        # the first time
        if obj is not missing and type(obj) == types.MethodType:
            # Digusting hack because there's no way to
            # dynamically figure out what the method being
            # called is from the stack frame.
            methcache[obj.im_func.func_code] = obj.im_class
        #
        # What's the access permissions for this name?
        access, klass = getattr(self, '__access__', {}).get(
            name, (PUBLIC, 0))
        if access is not PUBLIC:
            # Now try to see which method is calling us
            frame = getframe(0).f_back
            if frame is None:
                raise AccessViolation
            # Get the class of the method that's accessing
            # this attribute, by using the code object cache
            if frame.f_code.co_name == '__init__':
                # There aren't entries in the cache for ctors,
                # because the calling mechanism doesn't go
                # through __findattr__().  Are there other
                # methods that might have the same behavior?
                # Since we can't know who's __init__ we're in,
                # for now we'll assume that only protected and
                # public attrs can be accessed.
                if access is PRIVATE:
                    raise AccessViolation
            else:
                methclass = self.__cache__.get(frame.f_code)
                if not methclass:
                    raise AccessViolation
                if access is PRIVATE and methclass is not klass:
                    raise AccessViolation
                if access is PROTECTED and not issubclass(methclass,
                                                          klass):
                    raise AccessViolation
        # If we got here, it must be okay to access the attribute
        if args:
            return setattr(self, name, *args)
        return obj

# tests
class A(Access):
    def __init__(self, foo=0, name='A'):
        self._foo = foo
        # can't set private names in __init__
        self.__initprivate(name)

    def __initprivate(self, name):
        self._name = name

    def getfoo(self):
        return self._foo

    def setfoo(self, newfoo):
        self._foo = newfoo

    def getname(self):
        return self._name

A.__access__ = {'_foo'      : (PROTECTED, A),
                '_name'     : (PRIVATE, A),
                '__dict__'  : (PRIVATE, A),
                '__access__': (PRIVATE, A),
                }

class B(A):
    def setfoo(self, newfoo):
        self._foo = newfoo + 3

    def setname(self, name):
        self._name = name

b = B(1)
b.getfoo()

a = A(1)
assert a.getfoo() == 1
a.setfoo(2)
assert a.getfoo() == 2

try:
    a._foo
except AccessViolation:
    pass
else:
    assert 0, 'AccessViolation expected'

try:
    a._foo = 3
except AccessViolation:
    pass
else:
    assert 0, 'AccessViolation expected'

try:
    a.__dict__['_foo']
except AccessViolation:
    pass
else:
    assert 0, 'AccessViolation expected'


b = B()
assert b.getfoo() == 0
b.setfoo(2)
assert b.getfoo() == 5
try:
    b.setname('B')
except AccessViolation:
    pass
else:
    assert 0, 'AccessViolation expected'

assert b.getname() == 'A'
</pre>
<p>Here's an implementation of the attribute hook described in <a class="reference external" href="/dev/peps/pep-0213">PEP
213</a> (except that hooking on attribute deletion isn't supported by
the current reference implementation).</p>
<pre class="literal-block">
class Pep213:
    def __findattr__(self, name, *args):
        hookname = '__attr_%s__' % name
        if args:
            op = 'set'
        else:
            op = 'get'
        # XXX: op = 'del' currently not supported
        missing = []
        meth = getattr(self, hookname, missing)
        if meth is missing:
            if op == 'set':
                return setattr(self, name, *args)
            else:
                return getattr(self, name)
        else:
            return meth(op, *args)


def computation(i):
    print 'doing computation:', i
    return i + 3


def rev_computation(i):
    print 'doing rev_computation:', i
    return i - 3


class X(Pep213):
    def __init__(self, foo=0):
        self.__foo = foo

    def __attr_foo__(self, op, val=None):
        if op == 'get':
            return computation(self.__foo)
        elif op == 'set':
            self.__foo = rev_computation(val)
        # XXX: 'del' not yet supported

x = X()
fooval = x.foo
print fooval
x.foo = fooval + 5
print x.foo
# del x.foo
</pre>
</div>
<div class="section" id="reference-implementation">
<h1><a class="toc-backref" href="#id22">Reference Implementation</a></h1>
<p>The reference implementation, as a patch to the Python core, can be
found at this URL:</p>
<p><a class="reference external" href="http://sourceforge.net/patch/?func=detailpatch&amp;patch_id=102613&amp;group_id=5470">http://sourceforge.net/patch/?func=detailpatch&amp;patch_id=102613&amp;group_id=5470</a></p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id23">References</a></h1>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://docs.python.org/reference/datamodel.html#customizing-attribute-access">http://docs.python.org/reference/datamodel.html#customizing-attribute-access</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="http://www.javasoft.com/products/javabeans/">http://www.javasoft.com/products/javabeans/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="http://www.digicool.com/releases/ExtensionClass/Acquisition.html">http://www.digicool.com/releases/ExtensionClass/Acquisition.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[5]</a></td><td><a class="reference external" href="http://www.digicool.com/releases/ExtensionClass">http://www.digicool.com/releases/ExtensionClass</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[6]</a></td><td><a class="reference external" href="http://www.python.org/doc/essays/metaclasses/">http://www.python.org/doc/essays/metaclasses/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[7]</a></td><td><a class="reference external" href="http://www.foretec.com/python/workshops/1998-11/dd-ascher-sum.html">http://www.foretec.com/python/workshops/1998-11/dd-ascher-sum.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[8]</td><td><a class="reference external" href="http://docs.python.org/howto/regex.html">http://docs.python.org/howto/regex.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[9]</a></td><td><a class="reference external" href="/dev/peps/pep-0213">PEP 213</a>, Attribute Access Handlers, Prescod
<a class="reference external" href="http://www.python.org/dev/peps/pep-0213/">http://www.python.org/dev/peps/pep-0213/</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="rejection">
<h1><a class="toc-backref" href="#id24">Rejection</a></h1>
<p>There are serious problems with the recursion-protection feature.
As described here it's not thread-safe, and a thread-safe solution
has other problems.  In general, it's not clear how helpful the
recursion-protection feature is; it makes it hard to write code
that needs to be callable inside <tt class="docutils literal">__findattr__</tt> as well as outside
it.  But without the recursion-protection, it's hard to implement
<tt class="docutils literal">__findattr__</tt> at all (since <tt class="docutils literal">__findattr__</tt> would invoke itself
recursively for every attribute it tries to access).  There seems
to be no good solution here.</p>
<p>It's also dubious how useful it is to support <tt class="docutils literal">__findattr__</tt> both
for getting and for setting attributes -- <tt class="docutils literal">__setattr__</tt> gets called
in all cases alrady.</p>
<p>The examples can all be implemented using <tt class="docutils literal">__getattr__</tt> if care is
taken not to store instance variables under their own names.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id25">Copyright</a></h1>
<p>This document has been placed in the Public Domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

