<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">560</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Core support for typing module and generic types</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Ivan Levkivskyi &lt;levkivskyi&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Accepted</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">03-Sep-2017</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.7</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">09-Sep-2017, 14-Nov-2017</td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2017-December/151038.html">https://mail.python.org/pipermail/python-dev/2017-December/151038.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id13">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id14">Rationale</a><ul>
<li><a class="reference internal" href="#performance" id="id15">Performance</a></li>
<li><a class="reference internal" href="#metaclass-conflicts" id="id16">Metaclass conflicts</a></li>
<li><a class="reference internal" href="#hacks-and-bugs-that-will-be-removed-by-this-proposal" id="id17">Hacks and bugs that will be removed by this proposal</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification" id="id18">Specification</a><ul>
<li><a class="reference internal" href="#class-getitem" id="id19"><tt class="docutils literal">__class_getitem__</tt></a></li>
<li><a class="reference internal" href="#mro-entries" id="id20"><tt class="docutils literal">__mro_entries__</tt></a></li>
<li><a class="reference internal" href="#dynamic-class-creation-and-types-resolve-bases" id="id21">Dynamic class creation and <tt class="docutils literal">types.resolve_bases</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility-and-impact-on-users-who-don-t-use-typing" id="id22">Backwards compatibility and impact on users who don't use <tt class="docutils literal">typing</tt></a></li>
<li><a class="reference internal" href="#references" id="id23">References</a></li>
<li><a class="reference internal" href="#copyright" id="id24">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id13">Abstract</a></h1>
<p>Initially <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a> was designed in such way that it would not introduce
<em>any</em> changes to the core CPython interpreter. Now type hints and
the <tt class="docutils literal">typing</tt> module are extensively used by the community, e.g. <a class="reference external" href="/dev/peps/pep-0526">PEP 526</a>
and <a class="reference external" href="/dev/peps/pep-0557">PEP 557</a> extend the usage of type hints, and the backport of <tt class="docutils literal">typing</tt>
on PyPI has 1M downloads/month. Therefore, this restriction can be removed.
It is proposed to add two special methods <tt class="docutils literal">__class_getitem__</tt> and
<tt class="docutils literal">__mro_entries__</tt> to the core CPython for better support of
generic types.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id14">Rationale</a></h1>
<p>The restriction to not modify the core CPython interpreter led to some
design decisions that became questionable when the <tt class="docutils literal">typing</tt> module started
to be widely used. There are three main points of concern:
performance of the <tt class="docutils literal">typing</tt> module, metaclass conflicts, and the large
number of hacks currently used in <tt class="docutils literal">typing</tt>.</p>
<div class="section" id="performance">
<h2><a class="toc-backref" href="#id15">Performance</a></h2>
<p>The <tt class="docutils literal">typing</tt> module is one of the heaviest and slowest modules in
the standard library even with all the optimizations made. Mainly this is
because subscripted generic types (see <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a> for definition of terms used
in this PEP) are class objects (see also <a class="footnote-reference" href="#id7" id="id1">[1]</a>). There are three main ways how
the performance can be improved with the help of the proposed special methods:</p>
<ul class="simple">
<li>Creation of generic classes is slow since the <tt class="docutils literal">GenericMeta.__new__</tt> is
very slow; we will not need it anymore.</li>
<li>Very long method resolution orders (MROs) for generic classes will be
half as long; they are present because we duplicate the <tt class="docutils literal">collections.abc</tt>
inheritance chain in <tt class="docutils literal">typing</tt>.</li>
<li>Instantiation of generic classes will be faster (this is minor however).</li>
</ul>
</div>
<div class="section" id="metaclass-conflicts">
<h2><a class="toc-backref" href="#id16">Metaclass conflicts</a></h2>
<p>All generic types are instances of <tt class="docutils literal">GenericMeta</tt>, so if a user uses
a custom metaclass, then it is hard to make a corresponding class generic.
This is particularly hard for library classes that a user doesn't control.
A workaround is to always mix-in <tt class="docutils literal">GenericMeta</tt>:</p>
<pre class="literal-block">
class AdHocMeta(GenericMeta, LibraryMeta):
    pass

class UserClass(LibraryBase, Generic[T], metaclass=AdHocMeta):
    ...
</pre>
<p>but this is not always practical or even possible. With the help of the
proposed special attributes the <tt class="docutils literal">GenericMeta</tt> metaclass will not be needed.</p>
</div>
<div class="section" id="hacks-and-bugs-that-will-be-removed-by-this-proposal">
<h2><a class="toc-backref" href="#id17">Hacks and bugs that will be removed by this proposal</a></h2>
<ul class="simple">
<li><tt class="docutils literal">_generic_new</tt> hack that exists because <tt class="docutils literal">__init__</tt> is not called on
instances with a type differing form the type whose <tt class="docutils literal">__new__</tt> was called,
<tt class="docutils literal"><span class="pre">C[int]().__class__</span> is C</tt>.</li>
<li><tt class="docutils literal">_next_in_mro</tt> speed hack will be not necessary since subscription will
not create new classes.</li>
<li>Ugly <tt class="docutils literal">sys._getframe</tt> hack. This one is particularly nasty since it looks
like we can't remove it without changes outside <tt class="docutils literal">typing</tt>.</li>
<li>Currently generics do dangerous things with private ABC caches
to fix large memory consumption that grows at least as O(N<sup>2</sup>),
see <a class="footnote-reference" href="#id8" id="id2">[2]</a>. This point is also important because it was recently proposed to
re-implement <tt class="docutils literal">ABCMeta</tt> in C.</li>
<li>Problems with sharing attributes between subscripted generics,
see <a class="footnote-reference" href="#id9" id="id3">[3]</a>. The current solution already uses <tt class="docutils literal">__getattr__</tt> and <tt class="docutils literal">__setattr__</tt>,
but it is still incomplete, and solving this without the current proposal
will be hard and will need <tt class="docutils literal">__getattribute__</tt>.</li>
<li><tt class="docutils literal">_no_slots_copy</tt> hack, where we clean up the class dictionary on every
subscription thus allowing generics with <tt class="docutils literal">__slots__</tt>.</li>
<li>General complexity of the <tt class="docutils literal">typing</tt> module. The new proposal will not
only allow to remove the above mentioned hacks/bugs, but also simplify
the implementation, so that it will be easier to maintain.</li>
</ul>
</div>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id18">Specification</a></h1>
<div class="section" id="class-getitem">
<h2><a class="toc-backref" href="#id19"><tt class="docutils literal">__class_getitem__</tt></a></h2>
<p>The idea of <tt class="docutils literal">__class_getitem__</tt> is simple: it is an exact analog of
<tt class="docutils literal">__getitem__</tt> with an exception that it is called on a class that
defines it, not on its instances. This allows us to avoid
<tt class="docutils literal">GenericMeta.__getitem__</tt> for things like <tt class="docutils literal">Iterable[int]</tt>.
The <tt class="docutils literal">__class_getitem__</tt> is automatically a class method and
does not require <tt class="docutils literal">&#64;classmethod</tt> decorator (similar to
<tt class="docutils literal">__init_subclass__</tt>) and is inherited like normal attributes.
For example:</p>
<pre class="literal-block">
class MyList:
    def __getitem__(self, index):
        return index + 1
    def __class_getitem__(cls, item):
        return f&quot;{cls.__name__}[{item.__name__}]&quot;

class MyOtherList(MyList):
    pass

assert MyList()[0] == 1
assert MyList[int] == &quot;MyList[int]&quot;

assert MyOtherList()[0] == 1
assert MyOtherList[int] == &quot;MyOtherList[int]&quot;
</pre>
<p>Note that this method is used as a fallback, so if a metaclass defines
<tt class="docutils literal">__getitem__</tt>, then that will have the priority.</p>
</div>
<div class="section" id="mro-entries">
<h2><a class="toc-backref" href="#id20"><tt class="docutils literal">__mro_entries__</tt></a></h2>
<p>If an object that is not a class object appears in the tuple of bases of
a class definition, then method <tt class="docutils literal">__mro_entries__</tt> is searched on it.
If found, it is called with the original tuple of bases as an argument.
The result of the call must be a tuple, that is unpacked in the base classes
in place of this object. (If the tuple is empty, this means that the original
bases is simply discarded.) If there are more than one object with
<tt class="docutils literal">__mro_entries__</tt>, then all of them are called with the same original tuple
of bases. This step happens first in the process of creation of a class,
all other steps, including checks for duplicate bases and MRO calculation,
happen normally with the updated bases.</p>
<p>Using the method API instead of just an attribute is necessary to avoid
inconsistent MRO errors, and perform other manipulations that are currently
done by <tt class="docutils literal">GenericMeta.__new__</tt>. The original bases are stored as
<tt class="docutils literal">__orig_bases__</tt> in the class namespace (currently this is also done by
the metaclass). For example:</p>
<pre class="literal-block">
class GenericAlias:
    def __init__(self, origin, item):
        self.origin = origin
        self.item = item
    def __mro_entries__(self, bases):
        return (self.origin,)

class NewList:
    def __class_getitem__(cls, item):
        return GenericAlias(cls, item)

class Tokens(NewList[int]):
    ...

assert Tokens.__bases__ == (NewList,)
assert Tokens.__orig_bases__ == (NewList[int],)
assert Tokens.__mro__ == (Tokens, NewList, object)
</pre>
<p>Resolution using <tt class="docutils literal">__mro_entries__</tt> happens <em>only</em> in bases of a class
definition statement. In all other situations where a class object is
expected, no such resolution will happen, this includes <tt class="docutils literal">isinstance</tt>
and <tt class="docutils literal">issubclass</tt> built-in functions.</p>
<p>NOTE: These two method names are reserved for use by the <tt class="docutils literal">typing</tt> module
and the generic types machinery, and any other use is discouraged.
The reference implementation (with tests) can be found in <a class="footnote-reference" href="#id10" id="id4">[4]</a>, and
the proposal was originally posted and discussed on the <tt class="docutils literal">typing</tt> tracker,
see <a class="footnote-reference" href="#id11" id="id5">[5]</a>.</p>
</div>
<div class="section" id="dynamic-class-creation-and-types-resolve-bases">
<h2><a class="toc-backref" href="#id21">Dynamic class creation and <tt class="docutils literal">types.resolve_bases</tt></a></h2>
<p><tt class="docutils literal">type.__new__</tt> will not perform any MRO entry resolution. So that a direct
call <tt class="docutils literal"><span class="pre">type('Tokens',</span> <span class="pre">(List[int],),</span> {})</tt> will fail. This is done for
performance reasons and to minimize the number of implicit transformations.
Instead, a helper function <tt class="docutils literal">resolve_bases</tt> will be added to
the <tt class="docutils literal">types</tt> module to allow an explicit <tt class="docutils literal">__mro_entries__</tt> resolution in
the context of dynamic class creation. Correspondingly, <tt class="docutils literal">types.new_class</tt>
will be updated to reflect the new class creation steps while maintaining
the backwards compatibility:</p>
<pre class="literal-block">
def new_class(name, bases=(), kwds=None, exec_body=None):
    resolved_bases = resolve_bases(bases)  # This step is added
    meta, ns, kwds = prepare_class(name, resolved_bases, kwds)
    if exec_body is not None:
        exec_body(ns)
    ns['__orig_bases__'] = bases  # This step is added
    return meta(name, resolved_bases, ns, **kwds)
</pre>
</div>
</div>
<div class="section" id="backwards-compatibility-and-impact-on-users-who-don-t-use-typing">
<h1><a class="toc-backref" href="#id22">Backwards compatibility and impact on users who don't use <tt class="docutils literal">typing</tt></a></h1>
<p>This proposal may break code that currently uses the names
<tt class="docutils literal">__class_getitem__</tt> and <tt class="docutils literal">__mro_entries__</tt>.  (But the language
reference explicitly reserves <em>all</em> undocumented dunder names, and
allows &quot;breakage without warning&quot;; see <a class="footnote-reference" href="#id12" id="id6">[6]</a>.)</p>
<p>This proposal will support almost complete backwards compatibility with
the current public generic types API; moreover the <tt class="docutils literal">typing</tt> module is still
provisional. The only two exceptions are that currently
<tt class="docutils literal">issubclass(List[int], List)</tt> returns True, while with this proposal it will
raise <tt class="docutils literal">TypeError</tt>, and <tt class="docutils literal">repr()</tt> of unsubscripted user-defined generics
cannot be tweaked and will coincide with <tt class="docutils literal">repr()</tt> of normal (non-generic)
classes.</p>
<p>With the reference implementation I measured negligible performance effects
(under 1% on a micro-benchmark) for regular (non-generic) classes. At the same
time performance of generics is significantly improved:</p>
<ul class="simple">
<li><tt class="docutils literal">importlib.reload(typing)</tt> is up to 7x faster</li>
<li>Creation of user defined generic classes is up to 4x faster (on a micro-
benchmark with an empty body)</li>
<li>Instantiation of generic classes is up to 5x faster (on a micro-benchmark
with an empty <tt class="docutils literal">__init__</tt>)</li>
<li>Other operations with generic types and instances (like method lookup and
<tt class="docutils literal">isinstance()</tt> checks) are improved by around 10-20%</li>
<li>The only aspect that gets slower with the current proof of concept
implementation is the subscripted generics cache look-up. However it was
already very efficient, so this aspect gives negligible overall impact.</li>
</ul>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id23">References</a></h1>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Discussion following Mark Shannon's presentation at Language Summit
(<a class="reference external" href="https://github.com/python/typing/issues/432">https://github.com/python/typing/issues/432</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Pull Request to implement shared generic ABC caches (merged)
(<a class="reference external" href="https://github.com/python/typing/pull/383">https://github.com/python/typing/pull/383</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>An old bug with setting/accessing attributes on generic types
(<a class="reference external" href="https://github.com/python/typing/issues/392">https://github.com/python/typing/issues/392</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>The reference implementation
(<a class="reference external" href="https://github.com/ilevkivskyi/cpython/pull/2/files">https://github.com/ilevkivskyi/cpython/pull/2/files</a>,
<a class="reference external" href="https://github.com/ilevkivskyi/cpython/tree/new-typing">https://github.com/ilevkivskyi/cpython/tree/new-typing</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>Original proposal
(<a class="reference external" href="https://github.com/python/typing/issues/468">https://github.com/python/typing/issues/468</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td>Reserved classes of identifiers
(<a class="reference external" href="https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers">https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id24">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

