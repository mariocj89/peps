<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">3122</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Delineation of the main module</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-3122.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Brett Cannon</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">27-Apr-2007</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id4">Abstract</a></li>
<li><a class="reference internal" href="#the-problem" id="id5">The Problem</a></li>
<li><a class="reference internal" href="#the-solution" id="id6">The Solution</a></li>
<li><a class="reference internal" href="#implementation" id="id7">Implementation</a></li>
<li><a class="reference internal" href="#transition-plan" id="id8">Transition Plan</a></li>
<li><a class="reference internal" href="#rejected-ideas" id="id9">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#main-built-in" id="id10"><tt class="docutils literal">__main__</tt> built-in</a></li>
<li><a class="reference internal" href="#main-module-attribute" id="id11"><tt class="docutils literal">__main__</tt> module attribute</a></li>
<li><a class="reference internal" href="#use-file-instead-of-name" id="id12">Use <tt class="docutils literal">__file__</tt> instead of <tt class="docutils literal">__name__</tt></a></li>
<li><a class="reference internal" href="#special-string-subclass-for-name-that-overrides-eq" id="id13">Special string subclass for <tt class="docutils literal">__name__</tt> that overrides <tt class="docutils literal">__eq__</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#references" id="id14">References</a></li>
<li><a class="reference internal" href="#copyright" id="id15">Copyright</a></li>
</ul>
</div>
<div class="admonition attention">
<p class="first admonition-title">Attention!</p>
<p class="last">This PEP has been rejected.  Guido views running scripts within a
package as an anti-pattern <a class="footnote-reference" href="#guido-rejection" id="id1">[3]</a>.</p>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id4">Abstract</a></h1>
<p>Because of how name resolution works for relative imports in a world
where <a class="reference external" href="/dev/peps/pep-0328">PEP 328</a> is implemented, the ability to execute modules within a
package ceases being possible.  This failing stems from the fact that
the module being executed as the &quot;main&quot; module replaces its
<tt class="docutils literal">__name__</tt> attribute with <tt class="docutils literal">&quot;__main__&quot;</tt> instead of leaving it as
the absolute name of the module.  This breaks import's ability
to resolve relative imports from the main module into absolute names.</p>
<p>In order to resolve this issue, this PEP proposes to change how the
main module is delineated.  By leaving the <tt class="docutils literal">__name__</tt> attribute in
a module alone and setting <tt class="docutils literal">sys.main</tt> to the name of the main
module this will allow at least some instances of executing a module
within a package that uses relative imports.</p>
<p>This PEP does not address the idea of introducing a module-level
function that is automatically executed like <a class="reference external" href="/dev/peps/pep-0299">PEP 299</a> proposes.</p>
</div>
<div class="section" id="the-problem">
<h1><a class="toc-backref" href="#id5">The Problem</a></h1>
<p>With the introduction of <a class="reference external" href="/dev/peps/pep-0328">PEP 328</a>, relative imports became dependent on
the <tt class="docutils literal">__name__</tt> attribute of the module performing the import.  This
is because the use of dots in a relative import are used to strip away
parts of the calling module's name to calculate where in the package
hierarchy an import should fall (prior to <a class="reference external" href="/dev/peps/pep-0328">PEP 328</a> relative
imports could fail and would fall back on absolute imports which had a
chance of succeeding).</p>
<p>For instance, consider the import <tt class="docutils literal">from .. import spam</tt> made from the
<tt class="docutils literal">bacon.ham.beans</tt> module (<tt class="docutils literal">bacon.ham.beans</tt> is not a package
itself, i.e., does not define <tt class="docutils literal">__path__</tt>).  Name resolution of the
relative import takes the caller's name (<tt class="docutils literal">bacon.ham.beans</tt>), splits
on dots, and then slices off the last n parts based on the level
(which is 2).  In this example both <tt class="docutils literal">ham</tt> and <tt class="docutils literal">beans</tt> are dropped
and <tt class="docutils literal">spam</tt> is joined with what is left (<tt class="docutils literal">bacon</tt>).  This leads to
the proper import of the module <tt class="docutils literal">bacon.spam</tt>.</p>
<p>This reliance on the <tt class="docutils literal">__name__</tt> attribute of a module when handling
relative imports becomes an issue when executing a script within a
package.  Because the executing script has its name set to
<tt class="docutils literal">'__main__'</tt>, import cannot resolve any relative imports, leading to
an <tt class="docutils literal">ImportError</tt>.</p>
<p>For example, assume we have a package named <tt class="docutils literal">bacon</tt> with an
<tt class="docutils literal">__init__.py</tt> file containing:</p>
<pre class="literal-block">
from . import spam
</pre>
<p>Also create a module named <tt class="docutils literal">spam</tt> within the <tt class="docutils literal">bacon</tt> package (it
can be an empty file).  Now if you try to execute the <tt class="docutils literal">bacon</tt>
package (either through <tt class="docutils literal">python bacon/__init__.py</tt> or
<tt class="docutils literal">python <span class="pre">-m</span> bacon</tt>) you will get an <tt class="docutils literal">ImportError</tt> about trying to
do a relative import from within a non-package.  Obviously the import
is valid, but because of the setting of <tt class="docutils literal">__name__</tt> to <tt class="docutils literal">'__main__'</tt>
import thinks that <tt class="docutils literal">bacon/__init__.py</tt> is not in a package since no
dots exist in <tt class="docutils literal">__name__</tt>.  To see how the algorithm works in more
detail, see <tt class="docutils literal">importlib.Import._resolve_name()</tt> in the sandbox
<a class="footnote-reference" href="#importlib" id="id2">[2]</a>.</p>
<p>Currently a work-around is to remove all relative imports in the
module being executed and make them absolute.  This is unfortunate,
though, as one should not be required to use a specific type of
resource in order to make a module in a package be able to be
executed.</p>
</div>
<div class="section" id="the-solution">
<h1><a class="toc-backref" href="#id6">The Solution</a></h1>
<p>The solution to the problem is to not change the value of <tt class="docutils literal">__name__</tt>
in modules.  But there still needs to be a way to let executing code
know it is being executed as a script.  This is handled with a new
attribute in the <tt class="docutils literal">sys</tt> module named <tt class="docutils literal">main</tt>.</p>
<p>When a module is being executed as a script, <tt class="docutils literal">sys.main</tt> will be set
to the name of the module.  This changes the current idiom of:</p>
<pre class="literal-block">
if __name__ == '__main__':
    ...
</pre>
<p>to:</p>
<pre class="literal-block">
import sys
if __name__ == sys.main:
    ...
</pre>
<p>The newly proposed solution does introduce an added line of
boilerplate which is a module import.  But as the solution does not
introduce a new built-in or module attribute (as discussed in
<a class="reference internal" href="#rejected-ideas">Rejected Ideas</a>) it has been deemed worth the extra line.</p>
<p>Another issue with the proposed solution (which also applies to all
rejected ideas as well) is that it does not directly solve the problem
of discovering the name of a file.  Consider <tt class="docutils literal">python bacon/spam.py</tt>.
By the file name alone it is not obvious whether <tt class="docutils literal">bacon</tt> is a
package.  In order to properly find this out both the current
direction must exist on <tt class="docutils literal">sys.path</tt> as well as <tt class="docutils literal">bacon/__init__.py</tt>
existing.</p>
<p>But this is the simple example.  Consider <tt class="docutils literal">python <span class="pre">../spam.py</span></tt>.  From
the file name alone it is not at all clear if <tt class="docutils literal">spam.py</tt> is in a
package or not.  One possible solution is to find out what the
absolute name of <tt class="docutils literal">..</tt>, check if a file named <tt class="docutils literal">__init__.py</tt> exists,
and then look if the directory is on <tt class="docutils literal">sys.path</tt>.  If it is not, then
continue to walk up the directory until no more <tt class="docutils literal">__init__.py</tt> files
are found or the directory is found on <tt class="docutils literal">sys.path</tt>.</p>
<p>This could potentially be an expensive process.  If the package depth
happens to be deep then it could require a large amount of disk access
to discover where the package is anchored on <tt class="docutils literal">sys.path</tt>, if at all.
The stat calls alone can be expensive if the file system the executed
script is on is something like NFS.</p>
<p>Because of these issues, only when the <tt class="docutils literal"><span class="pre">-m</span></tt> command-line argument
(introduced by <a class="reference external" href="/dev/peps/pep-0338">PEP 338</a>) is used will <tt class="docutils literal">__name__</tt> be set.  Otherwise
the fallback semantics of setting <tt class="docutils literal">__name__</tt> to <tt class="docutils literal">&quot;__main__&quot;</tt> will
occur.  <tt class="docutils literal">sys.main</tt> will still be set to the proper value,
regardless of what <tt class="docutils literal">__name__</tt> is set to.</p>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id7">Implementation</a></h1>
<p>When the <tt class="docutils literal"><span class="pre">-m</span></tt> option is used, <tt class="docutils literal">sys.main</tt> will be set to the
argument passed in.  <tt class="docutils literal">sys.argv</tt> will be adjusted as it is currently.
Then the equivalent of <tt class="docutils literal">__import__(self.main)</tt> will occur.  This
differs from current semantics as the <tt class="docutils literal">runpy</tt> module fetches the
code object for the file specified by the module name in order to
explicitly set <tt class="docutils literal">__name__</tt> and other attributes.  This is no longer
needed as import can perform its normal operation in this situation.</p>
<p>If a file name is specified, then <tt class="docutils literal">sys.main</tt> will be set to
<tt class="docutils literal">&quot;__main__&quot;</tt>.  The specified file will then be read and have a code
object created and then be executed with <tt class="docutils literal">__name__</tt> set to
<tt class="docutils literal">&quot;__main__&quot;</tt>.  This mirrors current semantics.</p>
</div>
<div class="section" id="transition-plan">
<h1><a class="toc-backref" href="#id8">Transition Plan</a></h1>
<p>In order for Python 2.6 to be able to support both the current
semantics and the proposed semantics, <tt class="docutils literal">sys.main</tt> will always be set
to <tt class="docutils literal">&quot;__main__&quot;</tt>.  Otherwise no change will occur for Python 2.6.
This unfortunately means that no benefit from this change will occur
in Python 2.6, but it maximizes compatibility for code that is to
work as much as possible with 2.6 and 3.0.</p>
<p>To help transition to the new idiom, 2to3 <a class="footnote-reference" href="#to3" id="id3">[1]</a> will gain a rule to
transform the current <tt class="docutils literal">if __name__ == '__main__': ...</tt> idiom to the
new one.  This will not help with code that checks <tt class="docutils literal">__name__</tt>
outside of the idiom, though.</p>
</div>
<div class="section" id="rejected-ideas">
<h1><a class="toc-backref" href="#id9">Rejected Ideas</a></h1>
<div class="section" id="main-built-in">
<h2><a class="toc-backref" href="#id10"><tt class="docutils literal">__main__</tt> built-in</a></h2>
<p>A counter-proposal to introduce a built-in named <tt class="docutils literal">__main__</tt>.
The value of the built-in would be the name of the module being
executed (just like the proposed <tt class="docutils literal">sys.main</tt>).  This would lead to a
new idiom of:</p>
<pre class="literal-block">
if __name__ == __main__:
    ...
</pre>
<p>A drawback is that the syntactic difference is subtle; the dropping
of quotes around &quot;__main__&quot;.  Some believe that for existing Python
programmers bugs will be introduced where the quotation marks will be
put on by accident.  But one could argue that the bug would be
discovered quickly through testing as it is a very shallow bug.</p>
<p>While the name of built-in could obviously be different (e.g.,
<tt class="docutils literal">main</tt>) the other drawback is that it introduces a new built-in.
With a simple solution such as <tt class="docutils literal">sys.main</tt> being possible without
adding another built-in to Python, this proposal was rejected.</p>
</div>
<div class="section" id="main-module-attribute">
<h2><a class="toc-backref" href="#id11"><tt class="docutils literal">__main__</tt> module attribute</a></h2>
<p>Another proposal was to add a <tt class="docutils literal">__main__</tt> attribute to every module.
For the one that was executing as the main module, the attribute would
have a true value while all other modules had a false value.  This has
a nice consequence of simplify the main module idiom to:</p>
<pre class="literal-block">
if __main__:
    ...
</pre>
<p>The drawback was the introduction of a new module attribute.  It also
required more integration with the import machinery than the proposed
solution.</p>
</div>
<div class="section" id="use-file-instead-of-name">
<h2><a class="toc-backref" href="#id12">Use <tt class="docutils literal">__file__</tt> instead of <tt class="docutils literal">__name__</tt></a></h2>
<p>Any of the proposals could be changed to use the <tt class="docutils literal">__file__</tt>
attribute on modules instead of <tt class="docutils literal">__name__</tt>, including the current
semantics.  The problem with this is that with the proposed solutions
there is the issue of modules having no <tt class="docutils literal">__file__</tt> attribute defined
or having the same value as other modules.</p>
<p>The problem that comes up with the current semantics is you still have
to try to resolve the file path to a module name for the import to
work.</p>
</div>
<div class="section" id="special-string-subclass-for-name-that-overrides-eq">
<h2><a class="toc-backref" href="#id13">Special string subclass for <tt class="docutils literal">__name__</tt> that overrides <tt class="docutils literal">__eq__</tt></a></h2>
<p>One proposal was to define a subclass of <tt class="docutils literal">str</tt> that overrode the
<tt class="docutils literal">__eq__</tt> method so that it would compare equal to <tt class="docutils literal">&quot;__main__&quot;</tt> as
well as the actual name of the module.  In all other respects the
subclass would be the same as <tt class="docutils literal">str</tt>.</p>
<p>This was rejected as it seemed like too much of a hack.</p>
</div>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id14">References</a></h1>
<table class="docutils footnote" frame="void" id="to3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>2to3 tool
(<a class="reference external" href="http://svn.python.org/view/sandbox/trunk/2to3/">http://svn.python.org/view/sandbox/trunk/2to3/</a>) [ViewVC]</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="importlib" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>importlib
(<a class="reference external" href="http://svn.python.org/view/sandbox/trunk/import_in_py/importlib.py?view=markup">http://svn.python.org/view/sandbox/trunk/import_in_py/importlib.py?view=markup</a>)
[ViewVC]</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="guido-rejection" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[3]</a></td><td>Python-Dev email: &quot;PEP to change how the main module is delineated&quot;
(<a class="reference external" href="https://mail.python.org/pipermail/python-3000/2007-April/006793.html">https://mail.python.org/pipermail/python-3000/2007-April/006793.html</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id15">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

