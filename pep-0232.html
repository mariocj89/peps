<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">232</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Function Attributes</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0232.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Barry Warsaw &lt;barry&#32;&#97;t&#32;python.org&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">02-Dec-2000</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.1</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">20-Feb-2001</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id10">Introduction</a></li>
<li><a class="reference internal" href="#background" id="id11">Background</a></li>
<li><a class="reference internal" href="#proposal" id="id12">Proposal</a></li>
<li><a class="reference internal" href="#examples" id="id13">Examples</a><ul>
<li><a class="reference internal" href="#other-uses" id="id14">Other Uses</a></li>
</ul>
</li>
<li><a class="reference internal" href="#future-directions" id="id15">Future Directions</a></li>
<li><a class="reference internal" href="#dissenting-opinion" id="id16">Dissenting Opinion</a></li>
<li><a class="reference internal" href="#reference-implementation" id="id17">Reference Implementation</a></li>
<li><a class="reference internal" href="#references" id="id18">References</a></li>
<li><a class="reference internal" href="#copyright" id="id19">Copyright</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id10">Introduction</a></h1>
<p>This PEP describes an extension to Python, adding attribute
dictionaries to functions and methods.  This PEP tracks the status
and ownership of this feature.  It contains a description of the
feature and outlines changes necessary to support the feature.
This PEP summarizes discussions held in mailing list forums, and
provides URLs for further information, where appropriate.  The CVS
revision history of this file contains the definitive historical
record.</p>
</div>
<div class="section" id="background">
<h1><a class="toc-backref" href="#id11">Background</a></h1>
<p>Functions already have a number of attributes, some of which are
writable, e.g. <tt class="docutils literal">func_doc</tt>, a.k.a. <tt class="docutils literal">func.__doc__</tt>.  <tt class="docutils literal">func_doc</tt>
has the interesting property that there is special syntax in
function (and method) definitions for implicitly setting the
attribute.  This convenience has been exploited over and over again,
overloading docstrings with additional semantics.</p>
<p>For example, John Aycock has written a system where docstrings are
used to define parsing rules. <a class="footnote-reference" href="#id3" id="id1">[1]</a>  Zope's ZPublisher ORB <a class="footnote-reference" href="#id4" id="id2">[2]</a> uses
docstrings to signal publishable methods, i.e. methods that can
be called through the web.</p>
<p>The problem with this approach is that the overloaded semantics
may conflict with each other.  For example, if we wanted to add a
doctest unit test to a Zope method that should not be publishable
through the web.</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id12">Proposal</a></h1>
<p>This proposal adds a new dictionary to function objects, called
<tt class="docutils literal">func_dict</tt> (a.k.a. <tt class="docutils literal">__dict__</tt>).  This dictionary can be set
and get using ordinary attribute set and get syntax.</p>
<p>Methods also gain getter syntax, and they currently access the
attribute through the dictionary of the underlying function
object.  It is not possible to set attributes on bound or unbound
methods, except by doing so explicitly on the underlying function
object.  See the <a class="reference internal" href="#future-directions">Future Directions</a> discussion below for
approaches in subsequent versions of Python.</p>
<p>A function object's <tt class="docutils literal">__dict__</tt> can also be set, but only to a
dictionary object.  Deleting a function's <tt class="docutils literal">__dict__</tt>, or setting
it to anything other than a concrete dictionary object results in a
<tt class="docutils literal">TypeError</tt>.  If no function attributes have ever been set, the
function's <tt class="docutils literal">__dict__</tt> will be empty.</p>
</div>
<div class="section" id="examples">
<h1><a class="toc-backref" href="#id13">Examples</a></h1>
<p>Here are some examples of what you can do with this feature.</p>
<pre class="literal-block">
def a():
    pass

a.publish = 1
a.unittest = '''...'''

if a.publish:
    print a()

if hasattr(a, 'unittest'):
    testframework.execute(a.unittest)

class C:
    def a(self):
        'just a docstring'
        a.publish = 1

c = C()
if c.a.publish:
    publish(c.a())
</pre>
<div class="section" id="other-uses">
<h2><a class="toc-backref" href="#id14">Other Uses</a></h2>
<p>Paul Prescod enumerated a bunch of other uses on the <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2000-April/003364.html">python-dev thread</a> <a class="footnote-reference" href="#id6" id="id7">[4]</a>.</p>
</div>
</div>
<div class="section" id="future-directions">
<h1><a class="toc-backref" href="#id15">Future Directions</a></h1>
<p>Here are a number of future directions to consider.  Any adoption
of these ideas would require a new PEP, which referenced this one,
and would have to be targeted at a Python version subsequent to
the 2.1 release.</p>
<ul>
<li><p class="first">A previous version of this PEP allowed for both setter and
getter of attributes on unbound methods, and only getter on
bound methods.  A number of problems were discovered with this
policy.</p>
<p>Because method attributes were stored in the underlying
function, this caused several potentially surprising results:</p>
<pre class="literal-block">
class C:
    def a(self): pass

c1 = C()
c2 = C()
c1.a.publish = 1
# c2.a.publish would now be == 1 also!
</pre>
<p>Because a change to <tt class="docutils literal">a</tt> bound <tt class="docutils literal">c1</tt> also caused a change to
<tt class="docutils literal">a</tt> bound to <tt class="docutils literal">c2</tt>, setting of attributes on bound methods
was disallowed.  However, even allowing setting of attributes on
unbound methods has its ambiguities:</p>
<pre class="literal-block">
class D(C): pass
class E(C): pass

D.a.publish = 1
# E.a.publish would now be == 1 also!
</pre>
<p>For this reason, the current PEP disallows setting attributes on
either bound or unbound methods, but does allow for getting
attributes on either -- both return the attribute value on the
underlying function object.</p>
<p>A future PEP might propose to implement setting (bound or
unbound) method attributes by setting attributes on the instance
or class, using special naming conventions.  I.e.:</p>
<pre class="literal-block">
class C:
    def a(self): pass

C.a.publish = 1
C.__a_publish__ == 1 # true

c = C()
c.a.publish = 2
c.__a_publish__ == 2 # true

d = C()
d.__a_publish__ == 1 # true
</pre>
<p>Here, a lookup on the instance would look to the instance's
dictionary first, followed by a lookup on the class's
dictionary, and finally a lookup on the function object's
dictionary.</p>
</li>
<li><p class="first">Currently, Python supports function attributes only on Python
functions (i.e. those that are written in Python, not those that
are built-in).  Should it be worthwhile, a separate patch can be
crafted that will add function attributes to built-ins.</p>
</li>
<li><p class="first"><tt class="docutils literal">__doc__</tt> is the only function attribute that currently has
syntactic support for conveniently setting.  It may be
worthwhile to eventually enhance the language for supporting
easy function attribute setting.  Here are some syntaxes
suggested by PEP reviewers:</p>
<pre class="literal-block">
def a {
    'publish' : 1,
    'unittest': '''...''',
    }
    (args):
    # ...

def a(args):
    &quot;&quot;&quot;The usual docstring.&quot;&quot;&quot;
    {'publish' : 1,
     'unittest': '''...''',
     # etc.
     }

def a(args) having (publish = 1):
    # see reference [3]
    pass
</pre>
<p>The BDFL is currently against any such special syntactic support
for setting arbitrary function attributes.  Any syntax proposals
would have to be outlined in new PEPs.</p>
</li>
</ul>
</div>
<div class="section" id="dissenting-opinion">
<h1><a class="toc-backref" href="#id16">Dissenting Opinion</a></h1>
<p>When this was discussed on the python-dev mailing list in April
2000, a number of dissenting opinions were voiced.  For
completeness, the discussion thread starts on <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2000-April/003361.html">python-dev</a> <a class="footnote-reference" href="#id8" id="id9">[5]</a>.</p>
<p>The dissenting arguments appear to fall under the following
categories:</p>
<ul class="simple">
<li>no clear purpose (what does it buy you?)</li>
<li>other ways to do it (e.g. mappings as class attributes)</li>
<li>useless until syntactic support is included</li>
</ul>
<p>Countering some of these arguments is the observation that with
vanilla Python 2.0, <tt class="docutils literal">__doc__</tt> can in fact be set to any type of
object, so some semblance of writable function attributes are
already feasible.  But that approach is yet another corruption of
<tt class="docutils literal">__doc__</tt>.</p>
<p>And while it is of course possible to add mappings to class
objects (or in the case of function attributes, to the function's
module), it is more difficult and less obvious how to extract the
attribute values for inspection.</p>
<p>Finally, it may be desirable to add syntactic support, much the
same way that <tt class="docutils literal">__doc__</tt> syntactic support exists.  This can be
considered separately from the ability to actually set and get
function attributes.</p>
</div>
<div class="section" id="reference-implementation">
<h1><a class="toc-backref" href="#id17">Reference Implementation</a></h1>
<p>This PEP has been accepted and the implementation has been
integrated into Python 2.1.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id18">References</a></h1>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Aycock, &quot;Compiling Little Languages in Python&quot;,
<a class="reference external" href="http://www.foretec.com/python/workshops/1998-11/proceedings/papers/aycock-little/aycock-little.html">http://www.foretec.com/python/workshops/1998-11/proceedings/papers/aycock-little/aycock-little.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="http://classic.zope.org:8080/Documentation/Reference/ORB">http://classic.zope.org:8080/Documentation/Reference/ORB</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>Hudson, Michael, SourceForge patch implementing this syntax,
<a class="reference external" href="http://sourceforge.net/tracker/index.php?func=detail&amp;aid=403441&amp;group_id=5470&amp;atid=305470">http://sourceforge.net/tracker/index.php?func=detail&amp;aid=403441&amp;group_id=5470&amp;atid=305470</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[4]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2000-April/003364.html">https://mail.python.org/pipermail/python-dev/2000-April/003364.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[5]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2000-April/003361.html">https://mail.python.org/pipermail/python-dev/2000-April/003361.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id19">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

