<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">303</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Extend divmod() for Multiple Divisors</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0303.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Thomas Bellman &lt;bellman+pep-divmod&#32;&#97;t&#32;lysator.liu.se&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">31-Dec-2002</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.3</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id3">Abstract</a></li>
<li><a class="reference internal" href="#pronouncement" id="id4">Pronouncement</a></li>
<li><a class="reference internal" href="#specification" id="id5">Specification</a></li>
<li><a class="reference internal" href="#motivation" id="id6">Motivation</a></li>
<li><a class="reference internal" href="#rationale" id="id7">Rationale</a></li>
<li><a class="reference internal" href="#backwards-compatibility" id="id8">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#reference-implementation" id="id9">Reference Implementation</a></li>
<li><a class="reference internal" href="#references" id="id10">References</a></li>
<li><a class="reference internal" href="#copyright" id="id11">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id3">Abstract</a></h1>
<p>This PEP describes an extension to the built-in <tt class="docutils literal">divmod()</tt> function,
allowing it to take multiple divisors, chaining several calls to
<tt class="docutils literal">divmod()</tt> into one.</p>
</div>
<div class="section" id="pronouncement">
<h1><a class="toc-backref" href="#id4">Pronouncement</a></h1>
<p>This PEP is rejected.  Most uses for chained <tt class="docutils literal">divmod()</tt> involve a
constant modulus (in radix conversions for example) and are more
properly coded as a loop.  The example of splitting seconds
into days/hours/minutes/seconds does not generalize to months
and years; rather, the whole use case is handled more flexibly and
robustly by date and time modules.  The other use cases mentioned
in the PEP are somewhat rare in real code.  The proposal is also
problematic in terms of clarity and obviousness.  In the examples,
it is not immediately clear that the argument order is correct or
that the target tuple is of the right length.  Users from other
languages are more likely to understand the standard two argument
form without having to re-read the documentation.  See python-dev
discussion on 17 June 2005 <a class="footnote-reference" href="#id2" id="id1">[1]</a>.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id5">Specification</a></h1>
<p>The built-in <tt class="docutils literal">divmod()</tt> function would be changed to accept multiple
divisors, changing its signature from <tt class="docutils literal">divmod(dividend, divisor)</tt> to
<tt class="docutils literal">divmod(dividend, *divisors)</tt>.  The dividend is divided by the last
divisor, giving a quotient and a remainder.  The quotient is then
divided by the second to last divisor, giving a new quotient and
remainder.  This is repeated until all divisors have been used,
and <tt class="docutils literal">divmod()</tt> then returns a tuple consisting of the quotient from
the last step, and the remainders from all the steps.</p>
<p>A Python implementation of the new <tt class="docutils literal">divmod()</tt> behaviour could look
like:</p>
<pre class="literal-block">
def divmod(dividend, *divisors):
    modulos = ()
    q = dividend
    while divisors:
        q, r = q.__divmod__(divisors[-1])
        modulos = (r,) + modulos
        divisors = divisors[:-1]
    return (q,) + modulos
</pre>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id6">Motivation</a></h1>
<p>Occasionally one wants to perform a chain of <tt class="docutils literal">divmod()</tt> operations,
calling <tt class="docutils literal">divmod()</tt> on the quotient from the previous step, with
varying divisors.  The most common case is probably converting a
number of seconds into weeks, days, hours, minutes and seconds.
This would today be written as:</p>
<pre class="literal-block">
def secs_to_wdhms(seconds):
    m, s = divmod(seconds, 60)
    h, m = divmod(m, 60)
    d, h = divmod(h, 24)
    w, d = divmod(d, 7)
    return (w, d, h, m, s)
</pre>
<p>This is tedious and easy to get wrong each time you need it.</p>
<p>If instead the <tt class="docutils literal">divmod()</tt> built-in is changed according the proposal,
the code for converting seconds to weeks, days, hours, minutes and
seconds then become</p>
<pre class="literal-block">
def secs_to_wdhms(seconds):
    w, d, h, m, s = divmod(seconds, 7, 24, 60, 60)
    return (w, d, h, m, s)
</pre>
<p>which is easier to type, easier to type correctly, and easier to
read.</p>
<p>Other applications are:</p>
<ul class="simple">
<li>Astronomical angles (declination is measured in degrees, minutes
and seconds, right ascension is measured in hours, minutes and
seconds).</li>
<li>Old British currency (1 pound = 20 shilling, 1 shilling = 12 pence).</li>
<li>Anglo-Saxon length units: 1 mile = 1760 yards, 1 yard = 3 feet,
1 foot = 12 inches.</li>
<li>Anglo-Saxon weight units: 1 long ton = 160 stone, 1 stone = 14
pounds, 1 pound = 16 ounce, 1 ounce = 16 dram.</li>
<li>British volumes: 1 gallon = 4 quart, 1 quart = 2 pint, 1 pint
= 20 fluid ounces.</li>
</ul>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id7">Rationale</a></h1>
<p>The idea comes from APL, which has an operator that does this.  (I
don't remember what the operator looks like, and it would probably
be impossible to render in ASCII anyway.)</p>
<p>The APL operator takes a list as its second operand, while this
PEP proposes that each divisor should be a separate argument to
the <tt class="docutils literal">divmod()</tt> function.  This is mainly because it is expected that
the most common uses will have the divisors as constants right in
the call (as the 7, 24, 60, 60 above), and adding a set of
parentheses or brackets would just clutter the call.</p>
<p>Requiring an explicit sequence as the second argument to <tt class="docutils literal">divmod()</tt>
would seriously break backwards compatibility.  Making <tt class="docutils literal">divmod()</tt>
check its second argument for being a sequence is deemed to be too
ugly to contemplate.  And in the case where one <em>does</em> have a
sequence that is computed other-where, it is easy enough to write
<tt class="docutils literal">divmod(x, *divs)</tt> instead.</p>
<p>Requiring at least one divisor, i.e rejecting <tt class="docutils literal">divmod(x)</tt>, has been
considered, but no good reason to do so has come to mind, and is
thus allowed in the name of generality.</p>
<p>Calling <tt class="docutils literal">divmod()</tt> with no divisors should still return a tuple (of
one element).  Code that calls <tt class="docutils literal">divmod()</tt> with a varying number of
divisors, and thus gets a return value with an &quot;unknown&quot; number of
elements, would otherwise have to special case that case.  Code
that <em>knows</em> it is calling <tt class="docutils literal">divmod()</tt> with no divisors is considered
to be too silly to warrant a special case.</p>
<p>Processing the divisors in the other direction, i.e dividing with
the first divisor first, instead of dividing with the last divisor
first, has been considered.  However, the result comes with the
most significant part first and the least significant part last
(think of the chained divmod as a way of splitting a number into
&quot;digits&quot;, with varying weights), and it is reasonable to specify
the divisors (weights) in the same order as the result.</p>
<p>The inverse operation:</p>
<pre class="literal-block">
def inverse_divmod(seq, *factors):
    product = seq[0]
    for x, y in zip(factors, seq[1:]):
        product = product * x + y
    return product
</pre>
<p>could also be useful.  However, writing</p>
<pre class="literal-block">
seconds = (((((w * 7) + d) * 24 + h) * 60 + m) * 60 + s)
</pre>
<p>is less cumbersome both to write and to read than the chained
divmods.  It is therefore deemed to be less important, and its
introduction can be deferred to its own PEP.  Also, such a
function needs a good name, and the PEP author has not managed to
come up with one yet.</p>
<p>Calling <tt class="docutils literal"><span class="pre">divmod(&quot;spam&quot;)</span></tt> does not raise an error, despite strings
supporting neither division nor modulo.  However, unless we know
the other object too, we can't determine whether <tt class="docutils literal">divmod()</tt> would
work or not, and thus it seems silly to forbid it.</p>
</div>
<div class="section" id="backwards-compatibility">
<h1><a class="toc-backref" href="#id8">Backwards Compatibility</a></h1>
<p>Any module that replaces the <tt class="docutils literal">divmod()</tt> function in the <tt class="docutils literal">__builtin__</tt>
module, may cause other modules using the new syntax to break.  It
is expected that this is very uncommon.</p>
<p>Code that expects a <tt class="docutils literal">TypeError</tt> exception when calling <tt class="docutils literal">divmod()</tt> with
anything but two arguments will break.  This is also expected to
be very uncommon.</p>
<p>No other issues regarding backwards compatibility are known.</p>
</div>
<div class="section" id="reference-implementation">
<h1><a class="toc-backref" href="#id9">Reference Implementation</a></h1>
<p>Not finished yet, but it seems a rather straightforward
new implementation of the function <tt class="docutils literal">builtin_divmod()</tt> in
<tt class="docutils literal">Python/bltinmodule.c</tt>.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id10">References</a></h1>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Raymond Hettinger, &quot;Propose rejection of <a class="reference external" href="/dev/peps/pep-0303">PEP 303</a> -- Extend divmod() for
Multiple Divisors&quot; <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2005-June/054283.html">https://mail.python.org/pipermail/python-dev/2005-June/054283.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id11">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>

