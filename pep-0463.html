<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">463</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Exception-catching expressions</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0463.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Chris Angelico &lt;rosuav&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">15-Feb-2014</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.5</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">20-Feb-2014, 16-Feb-2014</td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2014-March/133118.html">https://mail.python.org/pipermail/python-dev/2014-March/133118.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#rejection-notice" id="id44">Rejection Notice</a></li>
<li><a class="reference internal" href="#abstract" id="id45">Abstract</a></li>
<li><a class="reference internal" href="#motivation" id="id46">Motivation</a></li>
<li><a class="reference internal" href="#rationale" id="id47">Rationale</a></li>
<li><a class="reference internal" href="#proposal" id="id48">Proposal</a></li>
<li><a class="reference internal" href="#alternative-proposals" id="id49">Alternative Proposals</a></li>
<li><a class="reference internal" href="#example-usage" id="id50">Example usage</a><ul>
<li><a class="reference internal" href="#narrowing-of-exception-catching-scope" id="id51">Narrowing of exception-catching scope</a></li>
</ul>
</li>
<li><a class="reference internal" href="#comparisons-with-other-languages" id="id52">Comparisons with other languages</a></li>
<li><a class="reference internal" href="#deferred-sub-proposals" id="id53">Deferred sub-proposals</a><ul>
<li><a class="reference internal" href="#multiple-except-clauses" id="id54">Multiple except clauses</a></li>
<li><a class="reference internal" href="#capturing-the-exception-object" id="id55">Capturing the exception object</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rejected-sub-proposals" id="id56">Rejected sub-proposals</a><ul>
<li><a class="reference internal" href="#finally-clause" id="id57">finally clause</a></li>
<li><a class="reference internal" href="#bare-except-having-different-meaning" id="id58">Bare except having different meaning</a></li>
<li><a class="reference internal" href="#bare-except-clauses" id="id59">Bare except clauses</a></li>
<li><a class="reference internal" href="#parentheses-around-the-except-clauses" id="id60">Parentheses around the except clauses</a></li>
<li><a class="reference internal" href="#short-hand-for-except-pass" id="id61">Short-hand for &quot;except: pass&quot;</a></li>
</ul>
</li>
<li><a class="reference internal" href="#common-objections" id="id62">Common objections</a><ul>
<li><a class="reference internal" href="#colons-always-introduce-suites" id="id63">Colons always introduce suites</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id15" id="id64">References</a></li>
<li><a class="reference internal" href="#copyright" id="id65">Copyright</a></li>
</ul>
</div>
<div class="section" id="rejection-notice">
<h1><a class="toc-backref" href="#id44">Rejection Notice</a></h1>
<p>From <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2014-March/133118.html">https://mail.python.org/pipermail/python-dev/2014-March/133118.html</a>:</p>
<p>&quot;&quot;&quot;
I want to reject this PEP. I think the proposed syntax is acceptable given
the desired semantics, although it's still a bit jarring. It's probably no
worse than the colon used with lambda (which echoes the colon used in a def
just like the colon here echoes the one in a try/except) and definitely
better than the alternatives listed.</p>
<p>But the thing I can't get behind are the motivation and rationale. I don't
think that e.g. dict.get() would be unnecessary once we have except
expressions, and I disagree with the position that EAFP is better than
LBYL, or &quot;generally recommended&quot; by Python. (Where do you get that? From
the same sources that are so obsessed with DRY they'd rather introduce a
higher-order-function than repeat one line of code? :-)</p>
<p>This is probably the most you can get out of me as far as a pronouncement.
Given that the language summit is coming up I'd be happy to dive deeper in
my reasons for rejecting it there (if there's demand).</p>
<p>I do think that (apart from never explaining those dreadful acronyms :-)
this was a well-written and well-researched PEP, and I think you've done a
great job moderating the discussion, collecting objections, reviewing
alternatives, and everything else that is required to turn a heated debate
into a PEP. Well done Chris (and everyone who helped), and good luck with
your next PEP!
&quot;&quot;&quot;</p>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id45">Abstract</a></h1>
<p>Just as <a class="reference external" href="/dev/peps/pep-0308">PEP 308</a> introduced a means of value-based conditions in an
expression, this system allows exception-based conditions to be used
as part of an expression.</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id46">Motivation</a></h1>
<p>A number of functions and methods have parameters which will cause
them to return a specified value instead of raising an exception.  The
current system is ad-hoc and inconsistent, and requires that each
function be individually written to have this functionality; not all
support this.</p>
<ul class="simple">
<li>dict.get(key, default) - second positional argument in place of
KeyError</li>
<li>next(iter, default) - second positional argument in place of
StopIteration</li>
<li>list.pop() - no way to return a default</li>
<li>seq[index] - no way to handle a bounds error</li>
<li>min(sequence, default=default) - keyword argument in place of
ValueError</li>
<li>statistics.mean(data) - no way to handle an empty iterator</li>
</ul>
<p>Had this facility existed early in Python's history, there would have been
no need to create dict.get() and related methods; the one obvious way to
handle an absent key would be to respond to the exception.  One method is
written which signals the absence in one way, and one consistent technique
is used to respond to the absence.  Instead, we have dict.get(), and as of
Python 3.4, we also have min(... default=default), and myriad others.  We
have a LBYL syntax for testing inside an expression, but there is currently
no EAFP notation; compare the following:</p>
<pre class="literal-block">
# LBYL:
if key in dic:
    process(dic[key])
else:
    process(None)
# As an expression:
process(dic[key] if key in dic else None)

# EAFP:
try:
    process(dic[key])
except KeyError:
    process(None)
# As an expression:
process(dic[key] except KeyError: None)
</pre>
<p>Python generally recommends the EAFP policy, but must then proliferate
utility functions like dic.get(key,None) to enable this.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id47">Rationale</a></h1>
<p>The current system requires that a function author predict the need
for a default, and implement support for it.  If this is not done, a
full try/except block is needed.</p>
<p>Since try/except is a statement, it is impossible to catch exceptions
in the middle of an expression.  Just as if/else does for conditionals
and lambda does for function definitions, so does this allow exception
catching in an expression context.</p>
<p>This provides a clean and consistent way for a function to provide a
default: it simply raises an appropriate exception, and the caller
catches it.</p>
<p>With some situations, an LBYL technique can be used (checking if some
sequence has enough length before indexing into it, for instance). This is
not safe in all cases, but as it is often convenient, programmers will be
tempted to sacrifice the safety of EAFP in favour of the notational brevity
of LBYL. Additionally, some LBYL techniques (eg involving getattr with
three arguments) warp the code into looking like literal strings rather
than attribute lookup, which can impact readability. A convenient EAFP
notation solves all of this.</p>
<p>There's no convenient way to write a helper function to do this; the
nearest is something ugly using either lambda:</p>
<pre class="literal-block">
def except_(expression, exception_list, default):
    try:
        return expression()
    except exception_list:
        return default()
value = except_(lambda: 1/x, ZeroDivisionError, lambda: float(&quot;nan&quot;))
</pre>
<p>which is clunky, and unable to handle multiple exception clauses; or
eval:</p>
<pre class="literal-block">
def except_(expression, exception_list, default):
    try:
        return eval(expression, globals_of_caller(), locals_of_caller())
    except exception_list as exc:
        l = locals_of_caller().copy()
        l['exc'] = exc
        return eval(default, globals_of_caller(), l)

def globals_of_caller():
    return sys._getframe(2).f_globals

def locals_of_caller():
    return sys._getframe(2).f_locals

value = except_(&quot;&quot;&quot;1/x&quot;&quot;&quot;,ZeroDivisionError,&quot;&quot;&quot; &quot;Can't divide by zero&quot; &quot;&quot;&quot;)
</pre>
<p>which is even clunkier, and relies on implementation-dependent hacks.
(Writing globals_of_caller() and locals_of_caller() for interpreters
other than CPython is left as an exercise for the reader.)</p>
<p>Raymond Hettinger <a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2014-February/025443.html">expresses</a> <a class="footnote-reference" href="#id16" id="id17">[1]</a> a desire for such a consistent
API. Something similar has been <a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2013-March/019760.html">requested</a> <a class="footnote-reference" href="#id18" id="id19">[2]</a> <a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2009-August/005441.html">multiple</a> <a class="footnote-reference" href="#id20" id="id21">[3]</a> <a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2008-August/001801.html">times</a> <a class="footnote-reference" href="#id22" id="id23">[4]</a>
in the past.</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id48">Proposal</a></h1>
<p>Just as the 'or' operator and the three part 'if-else' expression give
short circuiting methods of catching a falsy value and replacing it,
this syntax gives a short-circuiting method of catching an exception
and replacing it.</p>
<p>This currently works:</p>
<pre class="literal-block">
lst = [1, 2, None, 3]
value = lst[2] or &quot;No value&quot;
</pre>
<p>The proposal adds this:</p>
<pre class="literal-block">
lst = [1, 2]
value = (lst[2] except IndexError: &quot;No value&quot;)
</pre>
<p>Specifically, the syntax proposed is:</p>
<pre class="literal-block">
(expr except exception_list: default)
</pre>
<p>where expr, exception_list, and default are all expressions.  First,
expr is evaluated.  If no exception is raised, its value is the value
of the overall expression.  If any exception is raised, exception_list
is evaluated, and should result in either a type or a tuple, just as
with the statement form of try/except.  Any matching exception will
result in the corresponding default expression being evaluated and
becoming the value of the expression.  As with the statement form of
try/except, non-matching exceptions will propagate upward.</p>
<p>Parentheses are required around the entire expression, unless they
would be completely redundant, according to the same rules as generator
expressions follow. This guarantees correct interpretation of nested
except-expressions, and allows for future expansion of the syntax -
see below on multiple except clauses.</p>
<p>Note that the current proposal does not allow the exception object to
be captured. Where this is needed, the statement form must be used.
(See below for discussion and elaboration on this.)</p>
<p>This ternary operator would be between lambda and if/else in
precedence.</p>
<p>Consider this example of a two-level cache:</p>
<pre class="literal-block">
for key in sequence:
    x = (lvl1[key] except KeyError: (lvl2[key] except KeyError: f(key)))
    # do something with x
</pre>
<p>This cannot be rewritten as:</p>
<pre class="literal-block">
x = lvl1.get(key, lvl2.get(key, f(key)))
</pre>
<p>which, despite being shorter, defeats the purpose of the cache, as it must
calculate a default value to pass to get(). The .get() version calculates
backwards; the exception-testing version calculates forwards, as would be
expected. The nearest useful equivalent would be:</p>
<pre class="literal-block">
x = lvl1.get(key) or lvl2.get(key) or f(key)
</pre>
<p>which depends on the values being nonzero, as well as depending on the cache
object supporting this functionality.</p>
</div>
<div class="section" id="alternative-proposals">
<h1><a class="toc-backref" href="#id49">Alternative Proposals</a></h1>
<p>Discussion on python-ideas brought up the following syntax suggestions:</p>
<pre class="literal-block">
value = expr except default if Exception [as e]
value = expr except default for Exception [as e]
value = expr except default from Exception [as e]
value = expr except Exception [as e] return default
value = expr except (Exception [as e]: default)
value = expr except Exception [as e] try default
value = expr except Exception [as e] continue with default
value = default except Exception [as e] else expr
value = try expr except Exception [as e]: default
value = expr except default # Catches anything
value = expr except(Exception) default # Catches only the named type(s)
value = default if expr raise Exception
value = expr or else default if Exception
value = expr except Exception [as e] -&gt; default
value = expr except Exception [as e] pass default
</pre>
<p>It has also been suggested that a new keyword be created, rather than
reusing an existing one.  Such proposals fall into the same structure
as the last form, but with a different keyword in place of 'pass'.
Suggestions include 'then', 'when', and 'use'. Also, in the context of
the &quot;default if expr raise Exception&quot; proposal, it was suggested that a
new keyword &quot;raises&quot; be used.</p>
<p>All forms involving the 'as' capturing clause have been deferred from
this proposal in the interests of simplicity, but are preserved in the
table above as an accurate record of suggestions.</p>
<p>The four forms most supported by this proposal are, in order:</p>
<pre class="literal-block">
value = (expr except Exception: default)
value = (expr except Exception -&gt; default)
value = (expr except Exception pass default)
value = (expr except Exception then default)
</pre>
<p>All four maintain left-to-right evaluation order: first the base expression,
then the exception list, and lastly the default.  This is important, as the
expressions are evaluated lazily.  By comparison, several of the ad-hoc
alternatives listed above must (by the nature of functions) evaluate their
default values eagerly.  The preferred form, using the colon, parallels
try/except by using &quot;except exception_list:&quot;, and parallels lambda by having
&quot;keyword name_list: subexpression&quot;; it also can be read as mapping Exception
to the default value, dict-style.  Using the arrow introduces a token many
programmers will not be familiar with, and which currently has no similar
meaning, but is otherwise quite readable.  The English word &quot;pass&quot; has a
vaguely similar meaning (consider the common usage &quot;pass by value/reference&quot;
for function arguments), and &quot;pass&quot; is already a keyword, but as its meaning
is distinctly unrelated, this may cause confusion.  Using &quot;then&quot; makes sense
in English, but this introduces a new keyword to the language - albeit one
not in common use, but a new keyword all the same.</p>
<p>Left to right evaluation order is extremely important to readability, as it
parallels the order most expressions are evaluated.  Alternatives such as:</p>
<pre class="literal-block">
value = (expr except default if Exception)
</pre>
<p>break this, by first evaluating the two ends, and then coming to the middle;
while this may not seem terrible (as the exception list will usually be a
constant), it does add to the confusion when multiple clauses meet, either
with multiple except/if or with the existing if/else, or a combination.
Using the preferred order, subexpressions will always be evaluated from
left to right, no matter how the syntax is nested.</p>
<p>Keeping the existing notation, but shifting the mandatory parentheses, we
have the following suggestion:</p>
<pre class="literal-block">
value = expr except (Exception: default)
value = expr except(Exception: default)
</pre>
<p>This is reminiscent of a function call, or a dict initializer.  The colon
cannot be confused with introducing a suite, but on the other hand, the new
syntax guarantees lazy evaluation, which a dict does not.  The potential
to reduce confusion is considered unjustified by the corresponding potential
to increase it.</p>
</div>
<div class="section" id="example-usage">
<h1><a class="toc-backref" href="#id50">Example usage</a></h1>
<p>For each example, an approximately-equivalent statement form is given,
to show how the expression will be parsed.  These are not always
strictly equivalent, but will accomplish the same purpose.  It is NOT
safe for the interpreter to translate one into the other.</p>
<p>A number of these examples are taken directly from the Python standard
library, with file names and line numbers correct as of early Feb 2014.
Many of these patterns are extremely common.</p>
<p>Retrieve an argument, defaulting to None:</p>
<pre class="literal-block">
cond = (args[1] except IndexError: None)

# Lib/pdb.py:803:
try:
    cond = args[1]
except IndexError:
    cond = None
</pre>
<p>Fetch information from the system if available:</p>
<pre class="literal-block">
pwd = (os.getcwd() except OSError: None)

# Lib/tkinter/filedialog.py:210:
try:
    pwd = os.getcwd()
except OSError:
    pwd = None
</pre>
<p>Attempt a translation, falling back on the original:</p>
<pre class="literal-block">
e.widget = (self._nametowidget(W) except KeyError: W)

# Lib/tkinter/__init__.py:1222:
try:
    e.widget = self._nametowidget(W)
except KeyError:
    e.widget = W
</pre>
<p>Read from an iterator, continuing with blank lines once it's
exhausted:</p>
<pre class="literal-block">
line = (readline() except StopIteration: '')

# Lib/lib2to3/pgen2/tokenize.py:370:
try:
    line = readline()
except StopIteration:
    line = ''
</pre>
<p>Retrieve platform-specific information (note the DRY improvement);
this particular example could be taken further, turning a series of
separate assignments into a single large dict initialization:</p>
<pre class="literal-block">
# sys.abiflags may not be defined on all platforms.
_CONFIG_VARS['abiflags'] = (sys.abiflags except AttributeError: '')

# Lib/sysconfig.py:529:
try:
    _CONFIG_VARS['abiflags'] = sys.abiflags
except AttributeError:
    # sys.abiflags may not be defined on all platforms.
    _CONFIG_VARS['abiflags'] = ''
</pre>
<p>Retrieve an indexed item, defaulting to None (similar to dict.get):</p>
<pre class="literal-block">
def getNamedItem(self, name):
    return (self._attrs[name] except KeyError: None)

# Lib/xml/dom/minidom.py:573:
def getNamedItem(self, name):
    try:
        return self._attrs[name]
    except KeyError:
        return None
</pre>
<p>Translate numbers to names, falling back on the numbers:</p>
<pre class="literal-block">
g = (grp.getgrnam(tarinfo.gname)[2] except KeyError: tarinfo.gid)
u = (pwd.getpwnam(tarinfo.uname)[2] except KeyError: tarinfo.uid)

# Lib/tarfile.py:2198:
try:
    g = grp.getgrnam(tarinfo.gname)[2]
except KeyError:
    g = tarinfo.gid
try:
    u = pwd.getpwnam(tarinfo.uname)[2]
except KeyError:
    u = tarinfo.uid
</pre>
<p>Look up an attribute, falling back on a default:</p>
<pre class="literal-block">
mode = (f.mode except AttributeError: 'rb')

# Lib/aifc.py:882:
if hasattr(f, 'mode'):
    mode = f.mode
else:
    mode = 'rb'

return (sys._getframe(1) except AttributeError: None)
# Lib/inspect.py:1350:
return sys._getframe(1) if hasattr(sys, &quot;_getframe&quot;) else None
</pre>
<p>Perform some lengthy calculations in EAFP mode, handling division by
zero as a sort of sticky NaN:</p>
<pre class="literal-block">
value = (calculate(x) except ZeroDivisionError: float(&quot;nan&quot;))

try:
    value = calculate(x)
except ZeroDivisionError:
    value = float(&quot;nan&quot;)
</pre>
<p>Calculate the mean of a series of numbers, falling back on zero:</p>
<pre class="literal-block">
value = (statistics.mean(lst) except statistics.StatisticsError: 0)

try:
    value = statistics.mean(lst)
except statistics.StatisticsError:
    value = 0
</pre>
<p>Looking up objects in a sparse list of overrides:</p>
<pre class="literal-block">
(overrides[x] or default except IndexError: default).ping()

try:
    (overrides[x] or default).ping()
except IndexError:
    default.ping()
</pre>
<div class="section" id="narrowing-of-exception-catching-scope">
<h2><a class="toc-backref" href="#id51">Narrowing of exception-catching scope</a></h2>
<p>The following examples, taken directly from Python's standard library,
demonstrate how the scope of the try/except can be conveniently narrowed.
To do this with the statement form of try/except would require a temporary
variable, but it's far cleaner as an expression.</p>
<p>Lib/ipaddress.py:343:</p>
<pre class="literal-block">
try:
    ips.append(ip.ip)
except AttributeError:
    ips.append(ip.network_address)
</pre>
<p>Becomes:</p>
<pre class="literal-block">
ips.append(ip.ip except AttributeError: ip.network_address)
</pre>
<p>The expression form is nearly equivalent to this:</p>
<pre class="literal-block">
try:
    _ = ip.ip
except AttributeError:
    _ = ip.network_address
ips.append(_)
</pre>
<p>Lib/tempfile.py:130:</p>
<pre class="literal-block">
try:
    dirlist.append(_os.getcwd())
except (AttributeError, OSError):
    dirlist.append(_os.curdir)
</pre>
<p>Becomes:</p>
<pre class="literal-block">
dirlist.append(_os.getcwd() except (AttributeError, OSError): _os.curdir)
</pre>
<p>Lib/asyncore.py:264:</p>
<pre class="literal-block">
try:
    status.append('%s:%d' % self.addr)
except TypeError:
    status.append(repr(self.addr))
</pre>
<p>Becomes:</p>
<pre class="literal-block">
status.append('%s:%d' % self.addr except TypeError: repr(self.addr))
</pre>
<p>In each case, the narrowed scope of the try/except ensures that an unexpected
exception (for instance, AttributeError if &quot;append&quot; were misspelled) does not
get caught by the same handler.  This is sufficiently unlikely to be reason
to break the call out into a separate line (as per the five line example
above), but it is a small benefit gained as a side-effect of the conversion.</p>
</div>
</div>
<div class="section" id="comparisons-with-other-languages">
<h1><a class="toc-backref" href="#id52">Comparisons with other languages</a></h1>
<p>(With thanks to Andrew Barnert for compiling this section. Note that the
examples given here do not reflect the current version of the proposal,
and need to be edited.)</p>
<p><a class="reference external" href="http://www.skorks.com/2009/09/ruby-exceptions-and-exception-handling/">Ruby's</a> <a class="footnote-reference" href="#id24" id="id25">[5]</a> &quot;begin…rescue…rescue…else…ensure…end&quot; is an expression
(potentially with statements inside it).  It has the equivalent of an &quot;as&quot;
clause, and the equivalent of bare except.  And it uses no punctuation or
keyword between the bare except/exception class/exception class with as
clause and the value.  (And yes, it's ambiguous unless you understand
Ruby's statement/expression rules.)</p>
<pre class="literal-block">
x = begin computation() rescue MyException =&gt; e default(e) end;
x = begin computation() rescue MyException default() end;
x = begin computation() rescue default() end;
x = begin computation() rescue MyException default() rescue OtherException other() end;
</pre>
<p>In terms of this PEP:</p>
<pre class="literal-block">
x = computation() except MyException as e default(e)
x = computation() except MyException default(e)
x = computation() except default(e)
x = computation() except MyException default() except OtherException other()
</pre>
<p><a class="reference external" href="http://erlang.org/doc/reference_manual/expressions.html#id79284">Erlang</a> <a class="footnote-reference" href="#id26" id="id27">[6]</a> has a try expression that looks like this</p>
<pre class="literal-block">
x = try computation() catch MyException:e -&gt; default(e) end;
x = try computation() catch MyException:e -&gt; default(e); OtherException:e -&gt; other(e) end;
</pre>
<p>The class and &quot;as&quot; name are mandatory, but you can use &quot;_&quot; for either.
There's also an optional &quot;when&quot; guard on each, and a &quot;throw&quot; clause that
you can catch, which I won't get into.  To handle multiple exceptions,
you just separate the clauses with semicolons, which I guess would map
to commas in Python.  So:</p>
<pre class="literal-block">
x = try computation() except MyException as e -&gt; default(e)
x = try computation() except MyException as e -&gt; default(e), OtherException as e-&gt;other_default(e)
</pre>
<p>Erlang also has a &quot;catch&quot; expression, which, despite using the same keyword,
is completely different, and you don't want to know about it.</p>
<p>The ML family has two different ways of dealing with this, &quot;handle&quot; and
&quot;try&quot;; the difference between the two is that &quot;try&quot; pattern-matches the
exception, which gives you the effect of multiple except clauses and as
clauses.  In either form, the handler clause is punctuated by &quot;=&gt;&quot; in
some dialects, &quot;-&gt;&quot; in others.</p>
<p>To avoid confusion, I'll write the function calls in Python style.</p>
<p>Here's <a class="reference external" href="http://www.cs.cmu.edu/~rwh/introsml/core/exceptions.htm">SML's</a> <a class="footnote-reference" href="#id28" id="id29">[7]</a> &quot;handle&quot;</p>
<pre class="literal-block">
let x = computation() handle MyException =&gt; default();;
</pre>
<p>Here's <a class="reference external" href="http://www2.lib.uchicago.edu/keith/ocaml-class/exceptions.html">OCaml's</a> <a class="footnote-reference" href="#id30" id="id31">[8]</a> &quot;try&quot;</p>
<pre class="literal-block">
let x = try computation() with MyException explanation -&gt; default(explanation);;

let x = try computation() with

    MyException(e) -&gt; default(e)
  | MyOtherException() -&gt; other_default()
  | (e) -&gt; fallback(e);;
</pre>
<p>In terms of this PEP, these would be something like:</p>
<pre class="literal-block">
x = computation() except MyException =&gt; default()
x = try computation() except MyException e -&gt; default()
x = (try computation()
     except MyException as e -&gt; default(e)
     except MyOtherException -&gt; other_default()
     except BaseException as e -&gt; fallback(e))
</pre>
<p>Many ML-inspired but not-directly-related languages from academia mix things
up, usually using more keywords and fewer symbols. So, the <a class="reference external" href="http://mozart.github.io/mozart-v1/doc-1.4.0/tutorial/node5.html">Oz</a> <a class="footnote-reference" href="#id32" id="id33">[9]</a> would map
to Python as</p>
<pre class="literal-block">
x = try computation() catch MyException as e then default(e)
</pre>
<p>Many Lisp-derived languages, like <a class="reference external" href="http://clojure.org/special_forms#Special%20Forms--(try%20expr*%20catch-clause*%20finally-clause?)">Clojure,</a> <a class="footnote-reference" href="#id34" id="id35">[10]</a> implement try/catch as special
forms (if you don't know what that means, think function-like macros), so you
write, effectively</p>
<pre class="literal-block">
try(computation(), catch(MyException, explanation, default(explanation)))

try(computation(),
    catch(MyException, explanation, default(explanation)),
    catch(MyOtherException, explanation, other_default(explanation)))
</pre>
<p>In Common Lisp, this is done with a slightly clunkier <a class="reference external" href="http://clhs.lisp.se/Body/m_hand_1.htm">&quot;handler-case&quot; macro,</a> <a class="footnote-reference" href="#id36" id="id37">[11]</a>
but the basic idea is the same.</p>
<p>The Lisp style is, surprisingly, used by some languages that don't have
macros, like Lua, where <a class="reference external" href="http://www.gammon.com.au/scripts/doc.php?lua=xpcall">xpcall</a> <a class="footnote-reference" href="#id38" id="id39">[12]</a> takes functions. Writing lambdas
Python-style instead of Lua-style</p>
<pre class="literal-block">
x = xpcall(lambda: expression(), lambda e: default(e))
</pre>
<p>This actually returns (true, expression()) or (false, default(e)), but I think we can ignore that part.</p>
<p>Haskell is actually similar to Lua here (except that it's all done
with monads, of course):</p>
<pre class="literal-block">
x = do catch(lambda: expression(), lambda e: default(e))
</pre>
<p>You can write a pattern matching expression within the function to decide
what to do with it; catching and re-raising exceptions you don't want is
cheap enough to be idiomatic.</p>
<p>But Haskell infixing makes this nicer:</p>
<pre class="literal-block">
x = do expression() `catch` lambda: default()
x = do expression() `catch` lambda e: default(e)
</pre>
<p>And that makes the parallel between the lambda colon and the except
colon in the proposal much more obvious:</p>
<pre class="literal-block">
x = expression() except Exception: default()
x = expression() except Exception as e: default(e)
</pre>
<p><a class="reference external" href="http://wiki.tcl.tk/902">Tcl</a> <a class="footnote-reference" href="#id40" id="id41">[13]</a> has the other half of Lua's xpcall; catch is a function which returns
true if an exception was caught, false otherwise, and you get the value out
in other ways.  And it's all built around the implicit quote-and-exec
that everything in Tcl is based on, making it even harder to describe in
Python terms than Lisp macros, but something like</p>
<pre class="literal-block">
if {[ catch(&quot;computation()&quot;) &quot;explanation&quot;]} { default(explanation) }
</pre>
<p><a class="reference external" href="http://smalltalk.gnu.org/wiki/exceptions">Smalltalk</a> <a class="footnote-reference" href="#id42" id="id43">[14]</a> is also somewhat hard to map to Python. The basic version
would be</p>
<pre class="literal-block">
x := computation() on:MyException do:default()
</pre>
<p>... but that's basically Smalltalk's passing-arguments-with-colons
syntax, not its exception-handling syntax.</p>
</div>
<div class="section" id="deferred-sub-proposals">
<h1><a class="toc-backref" href="#id53">Deferred sub-proposals</a></h1>
<div class="section" id="multiple-except-clauses">
<h2><a class="toc-backref" href="#id54">Multiple except clauses</a></h2>
<p>An examination of use-cases shows that this is not needed as often as
it would be with the statement form, and as its syntax is a point on
which consensus has not been reached, the entire feature is deferred.</p>
<p>Multiple 'except' keywords could be used, and they will all catch
exceptions raised in the original expression (only):</p>
<pre class="literal-block">
# Will catch any of the listed exceptions thrown by expr;
# any exception thrown by a default expression will propagate.
value = (expr
    except Exception1: default1
    except Exception2: default2
    # ... except ExceptionN: defaultN
)
</pre>
<p>Currently, one of the following forms must be used:</p>
<pre class="literal-block">
# Will catch an Exception2 thrown by either expr or default1
value = (
    (expr except Exception1: default1)
    except Exception2: default2
)
# Will catch an Exception2 thrown by default1 only
value = (expr except Exception1:
    (default1 except Exception2: default2)
)
</pre>
<p>Listing multiple exception clauses without parentheses is a syntax error
(see above), and so a future version of Python is free to add this feature
without breaking any existing code.</p>
</div>
<div class="section" id="capturing-the-exception-object">
<h2><a class="toc-backref" href="#id55">Capturing the exception object</a></h2>
<p>In a try/except block, the use of 'as' to capture the exception object
creates a local name binding, and implicitly deletes that binding (to
avoid creating a reference loop) in a finally clause.  In an expression
context, this makes little sense, and a proper sub-scope would be
required to safely capture the exception object - something akin to the
way a list comprehension is handled.  However, CPython currently
implements a comprehension's subscope with a nested function call, which
has consequences in some contexts such as class definitions, and is
therefore unsuitable for this proposal.  Should there be, in future, a
way to create a true subscope (which could simplify comprehensions,
except expressions, with blocks, and possibly more), then this proposal
could be revived; until then, its loss is not a great one, as the simple
exception handling that is well suited to the expression notation used
here is generally concerned only with the type of the exception, and not
its value - further analysis below.</p>
<p>This syntax would, admittedly, allow a convenient way to capture
exceptions in interactive Python; returned values are captured by &quot;_&quot;,
but exceptions currently are not. This could be spelled:</p>
<pre class="literal-block">
&gt;&gt;&gt; (expr except Exception as e: e)
</pre>
<p>An examination of the Python standard library shows that, while the use
of 'as' is fairly common (occurring in roughly one except clause in five),
it is extremely <em>uncommon</em> in the cases which could logically be converted
into the expression form.  Its few uses can simply be left unchanged.
Consequently, in the interests of simplicity, the 'as' clause is not
included in this proposal.  A subsequent Python version can add this without
breaking any existing code, as 'as' is already a keyword.</p>
<p>One example where this could possibly be useful is Lib/imaplib.py:568:</p>
<pre class="literal-block">
try: typ, dat = self._simple_command('LOGOUT')
except: typ, dat = 'NO', ['%s: %s' % sys.exc_info()[:2]]
</pre>
<p>This could become:</p>
<pre class="literal-block">
typ, dat = (self._simple_command('LOGOUT')
    except BaseException as e: ('NO', '%s: %s' % (type(e), e)))
</pre>
<p>Or perhaps some other variation. This is hardly the most compelling use-case,
but an intelligent look at this code could tidy it up significantly.  In the
absence of further examples showing any need of the exception object, I have
opted to defer indefinitely the recommendation.</p>
</div>
</div>
<div class="section" id="rejected-sub-proposals">
<h1><a class="toc-backref" href="#id56">Rejected sub-proposals</a></h1>
<div class="section" id="finally-clause">
<h2><a class="toc-backref" href="#id57">finally clause</a></h2>
<p>The statement form try... finally or try... except... finally has no
logical corresponding expression form.  Therefore, the finally keyword
is not a part of this proposal, in any way.</p>
</div>
<div class="section" id="bare-except-having-different-meaning">
<h2><a class="toc-backref" href="#id58">Bare except having different meaning</a></h2>
<p>With several of the proposed syntaxes, omitting the exception type name
would be easy and concise, and would be tempting. For convenience's sake,
it might be advantageous to have a bare 'except' clause mean something
more useful than &quot;except BaseException&quot;. Proposals included having it
catch Exception, or some specific set of &quot;common exceptions&quot; (subclasses
of a new type called ExpressionError), or have it look for a tuple named
ExpressionError in the current scope, with a built-in default such as
(ValueError, UnicodeError, AttributeError, EOFError, IOError, OSError,
LookupError, NameError, ZeroDivisionError). All of these were rejected,
for several reasons.</p>
<ul class="simple">
<li>First and foremost, consistency with the statement form of try/except
would be broken. Just as a list comprehension or ternary if expression
can be explained by &quot;breaking it out&quot; into its vertical statement form,
an expression-except should be able to be explained by a relatively
mechanical translation into a near-equivalent statement. Any form of
syntax common to both should therefore have the same semantics in each,
and above all should not have the subtle difference of catching more in
one than the other, as it will tend to attract unnoticed bugs.</li>
<li>Secondly, the set of appropriate exceptions to catch would itself be
a huge point of contention. It would be impossible to predict exactly
which exceptions would &quot;make sense&quot; to be caught; why bless some of them
with convenient syntax and not others?</li>
<li>And finally (this partly because the recommendation was that a bare
except should be actively encouraged, once it was reduced to a &quot;reasonable&quot;
set of exceptions), any situation where you catch an exception you don't
expect to catch is an unnecessary bug magnet.</li>
</ul>
<p>Consequently, the use of a bare 'except' is down to two possibilities:
either it is syntactically forbidden in the expression form, or it is
permitted with the exact same semantics as in the statement form (namely,
that it catch BaseException and be unable to capture it with 'as').</p>
</div>
<div class="section" id="bare-except-clauses">
<h2><a class="toc-backref" href="#id59">Bare except clauses</a></h2>
<p><a class="reference external" href="/dev/peps/pep-0008">PEP 8</a> rightly advises against the use of a bare 'except'. While it is
syntactically legal in a statement, and for backward compatibility must
remain so, there is little value in encouraging its use. In an expression
except clause, &quot;except:&quot; is a SyntaxError; use the equivalent long-hand
form &quot;except BaseException:&quot; instead. A future version of Python MAY choose
to reinstate this, which can be done without breaking compatibility.</p>
</div>
<div class="section" id="parentheses-around-the-except-clauses">
<h2><a class="toc-backref" href="#id60">Parentheses around the except clauses</a></h2>
<p>Should it be legal to parenthesize the except clauses, separately from
the expression that could raise? Example:</p>
<pre class="literal-block">
value = expr (
    except Exception1 [as e]: default1
    except Exception2 [as e]: default2
    # ... except ExceptionN [as e]: defaultN
)
</pre>
<p>This is more compelling when one or both of the deferred sub-proposals
of multiple except clauses and/or exception capturing is included.  In
their absence, the parentheses would be thus:</p>
<pre class="literal-block">
value = expr except ExceptionType: default
value = expr (except ExceptionType: default)
</pre>
<p>The advantage is minimal, and the potential to confuse a reader into
thinking the except clause is separate from the expression, or into thinking
this is a function call, makes this non-compelling.  The expression can, of
course, be parenthesized if desired, as can the default:</p>
<pre class="literal-block">
value = (expr) except ExceptionType: (default)
</pre>
<p>As the entire expression is now required to be in parentheses (which had not
been decided at the time when this was debated), there is less need to
delineate this section, and in many cases it would be redundant.</p>
</div>
<div class="section" id="short-hand-for-except-pass">
<h2><a class="toc-backref" href="#id61">Short-hand for &quot;except: pass&quot;</a></h2>
<p>The following was been suggested as a similar
short-hand, though not technically an expression:</p>
<pre class="literal-block">
statement except Exception: pass

try:
    statement
except Exception:
    pass
</pre>
<p>For instance, a common use-case is attempting the removal of a file:</p>
<pre class="literal-block">
os.unlink(some_file) except OSError: pass
</pre>
<p>There is an equivalent already in Python 3.4, however, in contextlib:</p>
<pre class="literal-block">
from contextlib import suppress
with suppress(OSError): os.unlink(some_file)
</pre>
<p>As this is already a single line (or two with a break after the colon),
there is little need of new syntax and a confusion of statement vs
expression to achieve this.</p>
</div>
</div>
<div class="section" id="common-objections">
<h1><a class="toc-backref" href="#id62">Common objections</a></h1>
<div class="section" id="colons-always-introduce-suites">
<h2><a class="toc-backref" href="#id63">Colons always introduce suites</a></h2>
<p>While it is true that many of Python's syntactic elements use the colon to
introduce a statement suite (if, while, with, for, etcetera), this is not
by any means the sole use of the colon. Currently, Python syntax includes
four cases where a colon introduces a subexpression:</p>
<ul class="simple">
<li>dict display - { ... key:value ... }</li>
<li>slice notation - [start:stop:step]</li>
<li>function definition - parameter : annotation</li>
<li>lambda - arg list: return value</li>
</ul>
<p>This proposal simply adds a fifth:</p>
<ul class="simple">
<li>except-expression - exception list: result</li>
</ul>
<p>Style guides and <a class="reference external" href="/dev/peps/pep-0008">PEP 8</a> should recommend not having the colon at the end of
a wrapped line, which could potentially look like the introduction of a
suite, but instead advocate wrapping before the exception list, keeping the
colon clearly between two expressions.</p>
</div>
</div>
<div class="section" id="id15">
<h1><a class="toc-backref" href="#id64">References</a></h1>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[1]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2014-February/025443.html">https://mail.python.org/pipermail/python-ideas/2014-February/025443.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id19">[2]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2013-March/019760.html">https://mail.python.org/pipermail/python-ideas/2013-March/019760.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id21">[3]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2009-August/005441.html">https://mail.python.org/pipermail/python-ideas/2009-August/005441.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id23">[4]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2008-August/001801.html">https://mail.python.org/pipermail/python-ideas/2008-August/001801.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id24" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id25">[5]</a></td><td><a class="reference external" href="http://www.skorks.com/2009/09/ruby-exceptions-and-exception-handling/">http://www.skorks.com/2009/09/ruby-exceptions-and-exception-handling/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id26" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id27">[6]</a></td><td><a class="reference external" href="http://erlang.org/doc/reference_manual/expressions.html#id79284">http://erlang.org/doc/reference_manual/expressions.html#id79284</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id28" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id29">[7]</a></td><td><a class="reference external" href="http://www.cs.cmu.edu/~rwh/introsml/core/exceptions.htm">http://www.cs.cmu.edu/~rwh/introsml/core/exceptions.htm</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id30" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id31">[8]</a></td><td><a class="reference external" href="http://www2.lib.uchicago.edu/keith/ocaml-class/exceptions.html">http://www2.lib.uchicago.edu/keith/ocaml-class/exceptions.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id32" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id33">[9]</a></td><td><a class="reference external" href="http://mozart.github.io/mozart-v1/doc-1.4.0/tutorial/node5.html">http://mozart.github.io/mozart-v1/doc-1.4.0/tutorial/node5.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id34" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id35">[10]</a></td><td><a class="reference external" href="http://clojure.org/special_forms#Special%20Forms--(try%20expr*%20catch-clause*%20finally-clause?)">http://clojure.org/special_forms#Special%20Forms--(try%20expr*%20catch-clause*%20finally-clause?)</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id36" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id37">[11]</a></td><td><a class="reference external" href="http://clhs.lisp.se/Body/m_hand_1.htm">http://clhs.lisp.se/Body/m_hand_1.htm</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id38" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id39">[12]</a></td><td><a class="reference external" href="http://www.gammon.com.au/scripts/doc.php?lua=xpcall">http://www.gammon.com.au/scripts/doc.php?lua=xpcall</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id40" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id41">[13]</a></td><td><a class="reference external" href="http://wiki.tcl.tk/902">http://wiki.tcl.tk/902</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id42" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id43">[14]</a></td><td><a class="reference external" href="http://smalltalk.gnu.org/wiki/exceptions">http://smalltalk.gnu.org/wiki/exceptions</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id65">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

