<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">448</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Additional Unpacking Generalizations</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0448.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Joshua Landau &lt;joshua&#32;&#97;t&#32;landau.ws&gt;</td>
</tr>
<tr class="field"><th class="field-name">Discussions-To:</th><td class="field-body"><a class="reference external" href="mailto:python-ideas&#64;python.org?subject=PEP%20448">python-ideas&#32;&#97;t&#32;python.org</a></td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">29-Jun-2013</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.5</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id6">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id7">Rationale</a></li>
<li><a class="reference internal" href="#specification" id="id8">Specification</a></li>
<li><a class="reference internal" href="#disadvantages" id="id9">Disadvantages</a></li>
<li><a class="reference internal" href="#variations" id="id10">Variations</a></li>
<li><a class="reference internal" href="#approval" id="id11">Approval</a></li>
<li><a class="reference internal" href="#implementation" id="id12">Implementation</a></li>
<li><a class="reference internal" href="#references" id="id13">References</a></li>
<li><a class="reference internal" href="#copyright" id="id14">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id6">Abstract</a></h1>
<p>This PEP proposes extended usages of the <tt class="docutils literal">*</tt> iterable unpacking
operator and <tt class="docutils literal">**</tt> dictionary unpacking operators
to allow unpacking in more positions, an arbitrary number of
times, and in additional circumstances.  Specifically,
in function calls, in comprehensions and generator expressions, and
in displays.</p>
<p>Function calls are proposed to support an arbitrary number of
unpackings rather than just one:</p>
<pre class="literal-block">
&gt;&gt;&gt; print(*[1], *[2], 3)
1 2 3
&gt;&gt;&gt; dict(**{'x': 1}, y=2, **{'z': 3})
{'x': 1, 'y': 2, 'z': 3}
</pre>
<p>Unpacking is proposed to be allowed inside tuple, list, set,
and dictionary displays:</p>
<pre class="literal-block">
&gt;&gt;&gt; *range(4), 4
(0, 1, 2, 3, 4)
&gt;&gt;&gt; [*range(4), 4]
[0, 1, 2, 3, 4]
&gt;&gt;&gt; {*range(4), 4}
{0, 1, 2, 3, 4}
&gt;&gt;&gt; {'x': 1, **{'y': 2}}
{'x': 1, 'y': 2}
</pre>
<p>In dictionaries, later values will always override earlier ones:</p>
<pre class="literal-block">
&gt;&gt;&gt; {'x': 1, **{'x': 2}}
{'x': 2}

&gt;&gt;&gt; {**{'x': 2}, 'x': 1}
{'x': 1}
</pre>
<p>This PEP does not include unpacking operators inside list, set and
dictionary comprehensions although this has not been ruled out for
future proposals.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id7">Rationale</a></h1>
<p>Current usage of the <tt class="docutils literal">*</tt> iterable unpacking operator features
unnecessary restrictions that can harm readability.</p>
<p>Unpacking multiple times has an obvious rationale.  When you want to
unpack several iterables into a function definition or follow an unpack
with more positional arguments, the most natural way would be to write:</p>
<pre class="literal-block">
function(**kw_arguments, **more_arguments)

function(*arguments, argument)
</pre>
<p>Simple examples where this is useful are <tt class="docutils literal">print</tt> and <tt class="docutils literal">str.format</tt>.
Instead, you could be forced to write:</p>
<pre class="literal-block">
kwargs = dict(kw_arguments)
kwargs.update(more_arguments)
function(**kwargs)

args = list(arguments)
args.append(arg)
function(*args)
</pre>
<p>or, if you know to do so:</p>
<pre class="literal-block">
from collections import ChainMap
function(**ChainMap(more_arguments, arguments))

from itertools import chain
function(*chain(args, [arg]))
</pre>
<p>which add unnecessary line-noise and, with the first methods, causes
duplication of work.</p>
<p>There are two primary rationales for unpacking inside of containers.
Firstly there is a symmetry of assignment, where <tt class="docutils literal">fst, *other, lst =
elems</tt> and <tt class="docutils literal">elems = fst, *other, lst</tt> are approximate inverses,
ignoring the specifics of types.  This, in effect, simplifies the
language by removing special cases.</p>
<p>Secondly, it vastly simplifies types of &quot;addition&quot; such as combining
dictionaries, and does so in an unambiguous and well-defined way:</p>
<pre class="literal-block">
combination = {**first_dictionary, &quot;x&quot;: 1, &quot;y&quot;: 2}
</pre>
<p>instead of:</p>
<pre class="literal-block">
combination = first_dictionary.copy()
combination.update({&quot;x&quot;: 1, &quot;y&quot;: 2})
</pre>
<p>which is especially important in contexts where expressions are
preferred.  This is also useful as a more readable way of summing
iterables into a list, such as <tt class="docutils literal">my_list + list(my_tuple) +
list(my_range)</tt> which is now equivalent to just <tt class="docutils literal">[*my_list,
*my_tuple, *my_range]</tt>.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id8">Specification</a></h1>
<p>Function calls may accept an unbounded number of <tt class="docutils literal">*</tt> and <tt class="docutils literal">**</tt>
unpackings.  There will be no restriction of the order of positional
arguments with relation to <tt class="docutils literal">*</tt> unpackings nor any restriction of the
order of keyword arguments with relation to <tt class="docutils literal">**</tt> unpackings.</p>
<p>Function calls continue to have the restriction that keyword arguments
must follow positional arguments and <tt class="docutils literal">**</tt> unpackings must additionally
follow <tt class="docutils literal">*</tt> unpackings.</p>
<p>Currently, if an argument is given multiple times — such as a
positional argument given both positionally and by keyword — a
<tt class="docutils literal">TypeError</tt> is raised.  This remains true for duplicate arguments
provided through multiple <tt class="docutils literal">**</tt> unpackings,
e.g. <tt class="docutils literal"><span class="pre">f(**{'x':</span> 2}, <span class="pre">**{'x':</span> 3})</tt>, except that the error will be
detected at runtime.</p>
<p>A function looks like this:</p>
<pre class="literal-block">
function(
    argument or *args, argument or *args, ...,
    kwargument or *args, kwargument or *args, ...,
    kwargument or **kwargs, kwargument or **kwargs, ...
)
</pre>
<p>Tuples, lists, sets and dictionaries will allow unpacking.  This will
act as if the elements from unpacked items were inserted in order at
the site of unpacking, much as happens in unpacking in a function-call.
Dictionaries require <tt class="docutils literal">**</tt> unpacking; all the others require <tt class="docutils literal">*</tt> unpacking.</p>
<p>The keys in a dictionary remain in a right-to-left priority order, so
<tt class="docutils literal"><span class="pre">{**{'a':</span> 1}, 'a': 2, <span class="pre">**{'a':</span> 3}}</tt> evaluates to <tt class="docutils literal">{'a': 3}</tt>.  There
is no restriction on the number or position of unpackings.</p>
</div>
<div class="section" id="disadvantages">
<h1><a class="toc-backref" href="#id9">Disadvantages</a></h1>
<p>The allowable orders for arguments in a function call are more
complicated than before.  The simplest explanation for the rules
may be &quot;positional arguments precede keyword arguments and <tt class="docutils literal">**</tt>
unpacking; <tt class="docutils literal">*</tt> unpacking precedes <tt class="docutils literal">**</tt> unpacking&quot;.</p>
<p>Whilst <tt class="docutils literal">*elements, = iterable</tt> causes <tt class="docutils literal">elements</tt> to be a list,
<tt class="docutils literal">elements = *iterable,</tt> causes <tt class="docutils literal">elements</tt> to be a tuple.  The
reason for this may confuse people unfamiliar with the construct.</p>
<p>Concerns have been raised about the unexpected difference between
duplicate keys in dictionaries being allowed but duplicate keys
in function call syntax raising an error.  Although this is already
the case with current syntax, this proposal might exacerbate the
issue.  It remains to be seen how much of an issue this is in practice.</p>
</div>
<div class="section" id="variations">
<h1><a class="toc-backref" href="#id10">Variations</a></h1>
<p>The PEP originally considered whether the ordering of argument types
in a function call (positional, keyword, <tt class="docutils literal">*</tt> or <tt class="docutils literal">**</tt>) could become
less strict. This met little support so the idea was shelved.</p>
<p>Earlier iterations of this PEP allowed unpacking operators inside
list, set, and dictionary comprehensions as a flattening operator
over iterables of containers:</p>
<pre class="literal-block">
&gt;&gt;&gt; ranges = [range(i) for i in range(5)]
&gt;&gt;&gt; [*item for item in ranges]
[0, 0, 1, 0, 1, 2, 0, 1, 2, 3]

&gt;&gt;&gt; {*item for item in ranges}
{0, 1, 2, 3}
</pre>
<p>This was met with a mix of strong concerns about readability and mild
support. In order not to disadvantage the less controversial aspects
of the PEP, this was not accepted with the rest of the proposal.</p>
<p>Unbracketed comprehensions in function calls, such as <tt class="docutils literal">f(x for x in it)</tt>,
are already valid.  These could be extended to:</p>
<pre class="literal-block">
f(*x for x in it) == f((*x for x in it))
f(**x for x in it) == f({**x for x in it})
</pre>
<p>However, it wasn't clear if this was the best behaviour or if it should
unpack into the arguments of the call to <cite>f</cite>. Since this is likely to be
confusing and is of only very marginal utility, it is not included in this
PEP.  Instead, these will throw a <tt class="docutils literal">SyntaxError</tt> and comprehensions with
explicit brackets should be used instead.</p>
</div>
<div class="section" id="approval">
<h1><a class="toc-backref" href="#id11">Approval</a></h1>
<p>This PEP was accepted by Guido on February 25, 2015 <a class="footnote-reference" href="#id3" id="id1">[1]</a>.</p>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id12">Implementation</a></h1>
<p>An implementation for Python 3.5 is found at Issue 2292 on bug tracker <a class="footnote-reference" href="#id4" id="id2">[2]</a>.
This currently includes support for unpacking inside comprehensions, which
should be removed.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id13">References</a></h1>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>PEP accepted, &quot;<a class="reference external" href="/dev/peps/pep-0448">PEP 448</a> review&quot;, Guido van Rossum
(<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2015-February/138564.html">https://mail.python.org/pipermail/python-dev/2015-February/138564.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Issue 2292, &quot;Missing <cite>*</cite>-unpacking generalizations&quot;, Thomas Wouters
(<a class="reference external" href="http://bugs.python.org/issue2292">http://bugs.python.org/issue2292</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>Discussion on Python-ideas list,
&quot;list / array comprehensions extension&quot;, Alexander Heger
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2011-December/013097.html">https://mail.python.org/pipermail/python-ideas/2011-December/013097.html</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id14">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

