<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">558</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Defined semantics for locals()</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Nick Coghlan &lt;ncoghlan&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Draft</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">2017-09-08</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.7</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">2017-09-08</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id16">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id17">Rationale</a></li>
<li><a class="reference internal" href="#proposal" id="id18">Proposal</a><ul>
<li><a class="reference internal" href="#new-locals-documentation" id="id19">New <tt class="docutils literal">locals()</tt> documentation</a></li>
<li><a class="reference internal" href="#module-scope" id="id20">Module scope</a></li>
<li><a class="reference internal" href="#class-scope" id="id21">Class scope</a></li>
<li><a class="reference internal" href="#function-scope" id="id22">Function scope</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cpython-implementation-changes" id="id23">CPython Implementation Changes</a></li>
<li><a class="reference internal" href="#design-discussion" id="id24">Design Discussion</a><ul>
<li><a class="reference internal" href="#ensuring-locals-returns-a-shared-snapshot-at-function-scope" id="id25">Ensuring <tt class="docutils literal">locals()</tt> returns a shared snapshot at function scope</a></li>
<li><a class="reference internal" href="#ensuring-any-semantic-changes-are-restricted-to-tracing-mode" id="id26">Ensuring any semantic changes are restricted to tracing mode</a></li>
<li><a class="reference internal" href="#what-happens-with-the-default-args-for-eval-and-exec" id="id27">What happens with the default args for <tt class="docutils literal">eval()</tt> and <tt class="docutils literal">exec()</tt>?</a></li>
<li><a class="reference internal" href="#historical-semantics-at-function-scope" id="id28">Historical semantics at function scope</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation" id="id29">Implementation</a></li>
<li><a class="reference internal" href="#acknowledgements" id="id30">Acknowledgements</a></li>
<li><a class="reference internal" href="#references" id="id31">References</a></li>
<li><a class="reference internal" href="#copyright" id="id32">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id16">Abstract</a></h1>
<p>The semantics of the <tt class="docutils literal">locals()</tt> builtin have historically been underspecified
and hence implementation dependent.</p>
<p>This PEP proposes formally standardising on the behaviour of the CPython 3.6
reference implementation for most execution scopes, with some adjustments to the
behaviour at function scope to make it more predictable and independent of the
presence or absence of tracing functions.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id17">Rationale</a></h1>
<p>While the precise semantics of the <tt class="docutils literal">locals()</tt> builtin are nominally undefined,
in practice, many Python programs depend on it behaving exactly as it behaves in
CPython (at least when no tracing functions are installed).</p>
<p>Other implementations such as PyPy are currently replicating that behaviour,
up to and including replication of local variable mutation bugs that
can arise when a trace hook is installed <a class="footnote-reference" href="#id11" id="id1">[1]</a>.</p>
<p>While we consider CPython's current behaviour when no trace hooks are installed
acceptable and desirable, we consider the current behaviour when trace hooks
are installed to be problematic, as it causes bugs like <a class="footnote-reference" href="#id11" id="id2">[1]</a> <em>without</em> reliably
enabling the desired functionality of allowing debuggers like <tt class="docutils literal">pdb</tt> to mutate
local variables <a class="footnote-reference" href="#id13" id="id3">[3]</a>.</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id18">Proposal</a></h1>
<p>The expected semantics of the <tt class="docutils literal">locals()</tt> builtin change based on the current
execution scope. For this purpose, the defined scopes of execution are:</p>
<ul class="simple">
<li>module scope: top-level module code, as well as any other code executed using
<tt class="docutils literal">exec()</tt> or <tt class="docutils literal">eval()</tt> with a single namespace</li>
<li>class scope: code in the body of a <tt class="docutils literal">class</tt> statement, as well as any other
code executed using <tt class="docutils literal">exec()</tt> or <tt class="docutils literal">eval()</tt> with separate local and global
namespaces</li>
<li>function scope: code in the body of a <tt class="docutils literal">def</tt> or <tt class="docutils literal">async def</tt> statement</li>
</ul>
<p>We also allow interpreters to define two &quot;modes&quot; of execution, with only the
first mode being considered part of the language specification itself:</p>
<ul class="simple">
<li>regular operation: the way the interpreter behaves by default</li>
<li>tracing mode: the way the interpreter behaves when a trace hook has been
registered in one or more threads via an implementation dependent mechanism
like <tt class="docutils literal">sys.settrace</tt> (<a class="footnote-reference" href="#id14" id="id4">[4]</a>) in CPython's <tt class="docutils literal">sys</tt> module or
<tt class="docutils literal">PyEval_SetTrace</tt> (<a class="footnote-reference" href="#id15" id="id5">[5]</a>) in CPython's C API</li>
</ul>
<p>For regular operation, this PEP proposes elevating the current behaviour of
the CPython reference implementation to become part of the language
specification.</p>
<p>For tracing mode, this PEP proposes changes to CPython's behaviour at function
scope that bring the <tt class="docutils literal">locals()</tt> builtin semantics closer to those used in
regular operation, while also making the related frame API semantics clearer
and easier for interactive debuggers to rely on.</p>
<div class="section" id="new-locals-documentation">
<h2><a class="toc-backref" href="#id19">New <tt class="docutils literal">locals()</tt> documentation</a></h2>
<p>The heart of this proposal is to revise the documentation for the <tt class="docutils literal">locals()</tt>
builtin to read as follows:</p>
<blockquote>
<p>Return a dictionary representing the current local symbol table, with
variable names as the keys, and their currently bound references as the
values. This will always be the same dictionary for a given runtime
execution frame.</p>
<p>At module scope, as well as when using <tt class="docutils literal">exec()</tt> or <tt class="docutils literal">eval()</tt> with a
single namespace, this function returns the same namespace as <tt class="docutils literal">globals()</tt>.</p>
<p>At class scope, it returns the namespace that will be passed to the
metaclass constructor.</p>
<p>When using <tt class="docutils literal">exec()</tt> or <tt class="docutils literal">eval()</tt> with separate local and global
namespaces, it returns the local namespace passed in to the function call.</p>
<p>At function scope (including for generators and coroutines), it returns a
dynamic snapshot of the function's local variables and any nonlocal cell
references. In this case, changes made via the snapshot are <em>not</em> written
back to the corresponding local variables or nonlocal cell references, and
any such changes to the snapshot will be overwritten if the snapshot is
subsequently refreshed (e.g. by another call to <tt class="docutils literal">locals()</tt>).</p>
<p>CPython implementation detail: the dynamic snapshot for the current frame
will be implicitly refreshed before each call to the trace function when a
trace function is active.</p>
</blockquote>
<p>For reference, the current documentation of this builtin reads as follows:</p>
<blockquote>
<p>Update and return a dictionary representing the current local symbol table.
Free variables are returned by locals() when it is called in function
blocks, but not in class blocks.</p>
<p>Note: The contents of this dictionary should not be modified; changes may
not affect the values of local and free variables used by the interpreter.</p>
</blockquote>
</div>
<div class="section" id="module-scope">
<h2><a class="toc-backref" href="#id20">Module scope</a></h2>
<p>At module scope, as well as when using <tt class="docutils literal">exec()</tt> or <tt class="docutils literal">eval()</tt> with a
single namespace, <tt class="docutils literal">locals()</tt> must return the same object as <tt class="docutils literal">globals()</tt>,
which must be the actual execution namespace (available as
<tt class="docutils literal"><span class="pre">inspect.currentframe().f_locals</span></tt> in implementations that provide access
to frame objects).</p>
<p>Variable assignments during subsequent code execution in the same scope must
dynamically change the contents of the returned mapping, and changes to the
returned mapping must change the values bound to local variable names in the
execution environment.</p>
<p>The semantics at module scope are required to be the same in both tracing
mode (if provided by the implementation) and in regular operation.</p>
<p>To capture this expectation as part of the language specification, the following
paragraph will be added to the documentation for <tt class="docutils literal">locals()</tt>:</p>
<blockquote>
At module scope, as well as when using <tt class="docutils literal">exec()</tt> or <tt class="docutils literal">eval()</tt> with a
single namespace, this function returns the same namespace as <tt class="docutils literal">globals()</tt>.</blockquote>
<p>This part of the proposal does not require any changes to the reference
implementation - it is standardisation of the current behaviour.</p>
</div>
<div class="section" id="class-scope">
<h2><a class="toc-backref" href="#id21">Class scope</a></h2>
<p>At class scope, as well as when using <tt class="docutils literal">exec()</tt> or <tt class="docutils literal">eval()</tt> with separate
global and local namespaces, <tt class="docutils literal">locals()</tt> must return the specified local
namespace (which may be supplied by the metaclass <tt class="docutils literal">__prepare__</tt> method
in the case of classes). As for module scope, this must be a direct reference
to the actual execution namespace (available as
<tt class="docutils literal"><span class="pre">inspect.currentframe().f_locals</span></tt> in implementations that provide access
to frame objects).</p>
<p>Variable assignments during subsequent code execution in the same scope must
change the contents of the returned mapping, and changes to the returned mapping
must change the values bound to local variable names in the
execution environment.</p>
<p>The mapping returned by <tt class="docutils literal">locals()</tt> will <em>not</em> be used as the actual class
namespace underlying the defined class (the class creation process will copy
the contents to a fresh dictionary that is only accessible by going through the
class machinery).</p>
<p>For nested classes defined inside a function, any nonlocal cells referenced from
the class scope are <em>not</em> included in the <tt class="docutils literal">locals()</tt> mapping.</p>
<p>The semantics at class scope are required to be the same in both tracing
mode (if provided by the implementation) and in regular operation.</p>
<p>To capture this expectation as part of the language specification, the following
two paragraphs will be added to the documentation for <tt class="docutils literal">locals()</tt>:</p>
<blockquote>
<p>When using <tt class="docutils literal">exec()</tt> or <tt class="docutils literal">eval()</tt> with separate local and global
namespaces, [this function] returns the given local namespace.</p>
<p>At class scope, it returns the namespace that will be passed to the metaclass
constructor.</p>
</blockquote>
<p>This part of the proposal does not require any changes to the reference
implementation - it is standardisation of the current behaviour.</p>
</div>
<div class="section" id="function-scope">
<h2><a class="toc-backref" href="#id22">Function scope</a></h2>
<p>At function scope, interpreter implementations are granted significant freedom
to optimise local variable access, and hence are NOT required to permit
arbitrary modification of local and nonlocal variable bindings through the
mapping returned from <tt class="docutils literal">locals()</tt>.</p>
<p>Historically, this leniency has been described in the language specification
with the words &quot;The contents of this dictionary should not be modified; changes
may not affect the values of local and free variables used by the interpreter.&quot;</p>
<p>This PEP proposes to change that text to instead say:</p>
<blockquote>
<p>At function scope (including for generators and coroutines), [this function]
returns a
dynamic snapshot of the function's local variables and any nonlocal cell
references. In this case, changes made via the snapshot are <em>not</em> written
back to the corresponding local variables or nonlocal cell references, and
any such changes to the snapshot will be overwritten if the snapshot is
subsequently refreshed (e.g. by another call to <tt class="docutils literal">locals()</tt>).</p>
<p>CPython implementation detail: the dynamic snapshot for the currently
executing frame will be implicitly refreshed before each call to the trace
function when a trace function is active.</p>
</blockquote>
<p>This part of the proposal <em>does</em> require changes to the CPython reference
implementation, as while it accurately describes the behaviour in regular
operation, the &quot;write back&quot; strategy currently used to support namespace changes
from trace functions doesn't comply with it (and also causes the quirky
behavioural problems mentioned in the Rationale).</p>
</div>
</div>
<div class="section" id="cpython-implementation-changes">
<h1><a class="toc-backref" href="#id23">CPython Implementation Changes</a></h1>
<p>The current cause of CPython's tracing mode quirks (both the side effects from
simply installing a tracing function and the fact that writing values back to
function locals only works for the specific function being traced) is the way
that locals mutation support for trace hooks is currently implemented: the
<tt class="docutils literal">PyFrame_LocalsToFast</tt> function.</p>
<p>When a trace function is installed, CPython currently does the following for
function frames (those where the code object uses &quot;fast locals&quot; semantics):</p>
<ol class="arabic simple">
<li>Calls <tt class="docutils literal">PyFrame_FastToLocals</tt> to update the dynamic snapshot</li>
<li>Calls the trace hook (with tracing of the hook itself disabled)</li>
<li>Calls <tt class="docutils literal">PyFrame_LocalsToFast</tt> to capture any changes made to the dynamic
snapshot</li>
</ol>
<p>This approach is problematic for a few different reasons:</p>
<ul class="simple">
<li>Even if the trace function doesn't mutate the snapshot, the final step resets
any cell references back to the state they were in before the trace function
was called (this is the root cause of the bug report in <a class="footnote-reference" href="#id11" id="id6">[1]</a>)</li>
<li>If the trace function <em>does</em> mutate the snapshot, but then does something
that causes the snapshot to be refreshed, those changes are lost (this is
one aspect of the bug report in <a class="footnote-reference" href="#id13" id="id7">[3]</a>)</li>
<li>If the trace function attempts to mutate the local variables of a frame other
than the one being traced (e.g. <tt class="docutils literal">frame.f_back.f_locals</tt>), those changes
will almost certainly be lost (this is another aspect of the bug report in
<a class="footnote-reference" href="#id13" id="id8">[3]</a>)</li>
<li>If a <tt class="docutils literal">locals()</tt> reference is passed to another function, and <em>that</em>
function mutates the snapshot namespace, then those changes <em>may</em> be written
back to the execution frame <em>if</em> a trace hook is installed</li>
</ul>
<p>The proposed resolution to this problem is to take advantage of the fact that
whereas functions typically access their <em>own</em> namespace using the language
defined <tt class="docutils literal">locals()</tt> builtin, trace functions necessarily use the implementation
dependent <tt class="docutils literal">frame.f_locals</tt> interface, as a frame reference is what gets
passed to hook implementations.</p>
<p>In regular operation, nothing will change - <tt class="docutils literal">frame.f_locals</tt> will be a direct
reference to the dynamic snapshot, and <tt class="docutils literal">locals()</tt> will return a reference to
that snapshot. This reflects the fact that it's only CPython's tracing mode
semantics that are currently problematic.</p>
<p>In tracing mode, however, we will change <tt class="docutils literal">frame.f_locals</tt> to instead return
a dedicated proxy type (probably implemented as a private subclass of
<tt class="docutils literal">types.MappingProxyType</tt>) that has two internal attributes not exposed as
part of either the Python or public C API:</p>
<ul class="simple">
<li><em>mapping</em>: the dynamic snapshot that would be returned by <tt class="docutils literal">frame.f_locals</tt>
during regular operation</li>
<li><em>frame</em>: the underlying frame that the snapshot is for</li>
</ul>
<p>The <tt class="docutils literal">locals()</tt> builtin would be aware of this proxy type, and continue to
return a reference to the dynamic snapshot even when in tracing mode.</p>
<p>As long as the process remains in tracing mode, then <tt class="docutils literal">__setitem__</tt> and
<tt class="docutils literal">__delitem__</tt> operations on the proxy will affect not only the dynamic
snapshot, but <em>also</em> the corresponding fast local or cell reference on the
underlying frame.</p>
<p>If the process leaves tracing mode (i.e. all previously installed trace hooks
are uninstalled), then any already created proxy objects will remain in place,
but their <tt class="docutils literal">__setitem__</tt> and <tt class="docutils literal">__delitem__</tt> methods will skip mutating
the underlying frame.</p>
<p>At the C API layer, <tt class="docutils literal">PyEval_GetLocals()</tt> will implement the same semantics
as the Python level <tt class="docutils literal">locals()</tt> builtin, and a new <tt class="docutils literal">PyFrame_GetLocals(frame)</tt>
accessor API will be provided to allow the proxy bypass logic to be encapsulated
entirely inside the frame implementation. The C level equivalent of accessing
<tt class="docutils literal">pyframe.f_locals</tt> in Python will be to access <tt class="docutils literal"><span class="pre">cframe-&gt;f_locals</span></tt> directly
(the one difference is that the Python descriptor will continue to include an
implicit snapshot refresh).</p>
<p>The <tt class="docutils literal">PyFrame_LocalsToFast()</tt> function will be changed to always emit
<tt class="docutils literal">RuntimeError</tt>, explaining that it is no longer a supported operation, and
affected code should be updated to rely on the write-through tracing mode
proxy instead.</p>
</div>
<div class="section" id="design-discussion">
<h1><a class="toc-backref" href="#id24">Design Discussion</a></h1>
<div class="section" id="ensuring-locals-returns-a-shared-snapshot-at-function-scope">
<h2><a class="toc-backref" href="#id25">Ensuring <tt class="docutils literal">locals()</tt> returns a shared snapshot at function scope</a></h2>
<p>The <tt class="docutils literal">locals()</tt> builtin is a required part of the language, and in the
reference implementation it has historically returned a mutable mapping with
the following characteristics:</p>
<ul class="simple">
<li>each call to <tt class="docutils literal">locals()</tt> returns the <em>same</em> mapping</li>
<li>for namespaces where <tt class="docutils literal">locals()</tt> returns a reference to something other than
the actual local execution namespace, each call to <tt class="docutils literal">locals()</tt> updates the
mapping with the current state of the local variables and any referenced
nonlocal cells</li>
<li>changes to the returned mapping <em>usually</em> aren't written back to the
local variable bindings or the nonlocal cell references, but write backs
can be triggered by doing one of the following:<ul>
<li>installing a Python level trace hook (write backs then happen whenever
the trace hook is called)</li>
<li>running a function level wildcard import (requires bytecode injection in Py3)</li>
<li>running an <tt class="docutils literal">exec</tt> statement in the function's scope (Py2 only, since
<tt class="docutils literal">exec</tt> became an ordinary builtin in Python 3)</li>
</ul>
</li>
</ul>
<p>The proposal in this PEP aims to retain the first two properties (to maintain
backwards compatibility with as much code as possible) while ensuring that
simply installing a trace hook can't enable rebinding of function locals via
the <tt class="docutils literal">locals()</tt> builtin (whereas enabling rebinding via
<tt class="docutils literal"><span class="pre">inspect.currentframe().f_locals</span></tt> is fully intended).</p>
</div>
<div class="section" id="ensuring-any-semantic-changes-are-restricted-to-tracing-mode">
<h2><a class="toc-backref" href="#id26">Ensuring any semantic changes are restricted to tracing mode</a></h2>
<p>It would be possible to say that <tt class="docutils literal">frame.f_locals</tt> should <em>always</em> return a
write-through proxy, even in regular operation.</p>
<p>This PEP avoids that option for a couple of key reasons, one pragmatic and one
more philosophical:</p>
<ul class="simple">
<li>Object allocations and method wrappers aren't free, and tracing functions
aren't the only operations that access frame locals from outside the function.
Restricting the changes to tracing mode means that the additional memory and
execution time overhead of these changes are going to be as close to zero in
regular operation as we can possibly make them</li>
<li>&quot;Don't change what isn't broken&quot;: the current tracing mode problems are caused
by a requirement that's specific to tracing mode (support for external
rebinding of function local variable references), so it makes sense to also
restrict any related fixes to tracing mode</li>
</ul>
</div>
<div class="section" id="what-happens-with-the-default-args-for-eval-and-exec">
<h2><a class="toc-backref" href="#id27">What happens with the default args for <tt class="docutils literal">eval()</tt> and <tt class="docutils literal">exec()</tt>?</a></h2>
<p>These are formally defined as inheriting <tt class="docutils literal">globals()</tt> and <tt class="docutils literal">locals()</tt> from
the calling scope by default.</p>
<p>There doesn't seem to be any reason for the PEP to change this.</p>
</div>
<div class="section" id="historical-semantics-at-function-scope">
<h2><a class="toc-backref" href="#id28">Historical semantics at function scope</a></h2>
<p>The current semantics of mutating <tt class="docutils literal">locals()</tt> and <tt class="docutils literal">frame.f_locals</tt> in CPython
are rather quirky due to historical implementation details:</p>
<ul class="simple">
<li>actual execution uses the fast locals array for local variable bindings and
cell references for nonlocal variables</li>
<li>there's a <tt class="docutils literal">PyFrame_FastToLocals</tt> operation that populates the frame's
<tt class="docutils literal">f_locals</tt> attribute based on the current state of the fast locals array
and any referenced cells. This exists for three reasons:<ul>
<li>allowing trace functions to read the state of local variables</li>
<li>allowing traceback processors to read the state of local variables</li>
<li>allowing <tt class="docutils literal">locals()</tt> to read the state of local variables</li>
</ul>
</li>
<li>a direct reference to <tt class="docutils literal">frame.f_locals</tt> is returned from <tt class="docutils literal">locals()</tt>, so if
you hand out multiple concurrent references, then all those references will be
to the exact same dictionary</li>
<li>the two common calls to the reverse operation, <tt class="docutils literal">PyFrame_LocalsToFast</tt>, were
removed in the migration to Python 3: <tt class="docutils literal">exec</tt> is no longer a statement (and
hence can no longer affect function local namespaces), and the compiler now
disallows the use of <tt class="docutils literal">from module import *</tt> operations at function scope</li>
<li>however, two obscure calling paths remain: <tt class="docutils literal">PyFrame_LocalsToFast</tt> is called
as part of returning from a trace function (which allows debuggers to make
changes to the local variable state), and you can also still inject the
<tt class="docutils literal">IMPORT_STAR</tt> opcode when creating a function directly from a code object
rather than via the compiler</li>
</ul>
<p>This proposal deliberately <em>doesn't</em> formalise these semantics as is, since they
only make sense in terms of the historical evolution of the language and the
reference implementation, rather than being deliberately designed.</p>
</div>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id29">Implementation</a></h1>
<p>The reference implementation update is TBD - when available, it will be linked
from <a class="footnote-reference" href="#id12" id="id9">[2]</a>.</p>
</div>
<div class="section" id="acknowledgements">
<h1><a class="toc-backref" href="#id30">Acknowledgements</a></h1>
<p>Thanks to Nathaniel J. Smith for proposing the write-through proxy idea in
<a class="footnote-reference" href="#id11" id="id10">[1]</a> and pointing out some critical design flaws in earlier iterations of the
PEP that attempted to avoid introducing such a proxy.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id31">References</a></h1>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>, <a class="fn-backref" href="#id6">3</a>, <a class="fn-backref" href="#id10">4</a>)</em> Broken local variable assignment given threads + trace hook + closure
(<a class="reference external" href="https://bugs.python.org/issue30744">https://bugs.python.org/issue30744</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[2]</a></td><td>Clarify the required behaviour of <tt class="docutils literal">locals()</tt>
(<a class="reference external" href="https://bugs.python.org/issue17960">https://bugs.python.org/issue17960</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id7">2</a>, <a class="fn-backref" href="#id8">3</a>)</em> Updating function local variables from pdb is unreliable
(<a class="reference external" href="https://bugs.python.org/issue9633">https://bugs.python.org/issue9633</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>CPython's Python API for installing trace hooks
(<a class="reference external" href="https://docs.python.org/dev/library/sys.html#sys.settrace">https://docs.python.org/dev/library/sys.html#sys.settrace</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>CPython's C API for installing trace hooks
(<a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyEval_SetTrace">https://docs.python.org/3/c-api/init.html#c.PyEval_SetTrace</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id32">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

