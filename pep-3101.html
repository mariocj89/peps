<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">3101</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Advanced String Formatting</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-3101.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Talin &lt;viridia&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">16-Apr-2006</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.0</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">28-Apr-2006, 6-May-2006, 10-Jun-2007, 14-Aug-2007, 14-Sep-2008</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id13">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id14">Rationale</a></li>
<li><a class="reference internal" href="#specification" id="id15">Specification</a><ul>
<li><a class="reference internal" href="#string-methods" id="id16">String Methods</a></li>
<li><a class="reference internal" href="#format-strings" id="id17">Format Strings</a></li>
<li><a class="reference internal" href="#simple-and-compound-field-names" id="id18">Simple and Compound Field Names</a></li>
<li><a class="reference internal" href="#format-specifiers" id="id19">Format Specifiers</a></li>
<li><a class="reference internal" href="#standard-format-specifiers" id="id20">Standard Format Specifiers</a></li>
<li><a class="reference internal" href="#explicit-conversion-flag" id="id21">Explicit Conversion Flag</a></li>
<li><a class="reference internal" href="#controlling-formatting-on-a-per-type-basis" id="id22">Controlling Formatting on a Per-Type Basis</a></li>
<li><a class="reference internal" href="#user-defined-formatting" id="id23">User-Defined Formatting</a></li>
<li><a class="reference internal" href="#formatter-methods" id="id24">Formatter Methods</a></li>
<li><a class="reference internal" href="#customizing-formatters" id="id25">Customizing Formatters</a></li>
<li><a class="reference internal" href="#error-handling" id="id26">Error handling</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alternate-syntax" id="id27">Alternate Syntax</a></li>
<li><a class="reference internal" href="#alternate-feature-proposals" id="id28">Alternate Feature Proposals</a></li>
<li><a class="reference internal" href="#security-considerations" id="id29">Security Considerations</a></li>
<li><a class="reference internal" href="#sample-implementation" id="id30">Sample Implementation</a></li>
<li><a class="reference internal" href="#backwards-compatibility" id="id31">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#references" id="id32">References</a></li>
<li><a class="reference internal" href="#copyright" id="id33">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id13">Abstract</a></h1>
<p>This PEP proposes a new system for built-in string formatting
operations, intended as a replacement for the existing '%' string
formatting operator.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id14">Rationale</a></h1>
<p>Python currently provides two methods of string interpolation:</p>
<ul class="simple">
<li>The '%' operator for strings. <a class="footnote-reference" href="#id7" id="id1">[1]</a></li>
<li>The string.Template module. <a class="footnote-reference" href="#id8" id="id2">[2]</a></li>
</ul>
<p>The primary scope of this PEP concerns proposals for built-in
string formatting operations (in other words, methods of the
built-in string type).</p>
<p>The '%' operator is primarily limited by the fact that it is a
binary operator, and therefore can take at most two arguments.
One of those arguments is already dedicated to the format string,
leaving all other variables to be squeezed into the remaining
argument.  The current practice is to use either a dictionary or a
tuple as the second argument, but as many people have commented
<a class="footnote-reference" href="#id9" id="id3">[3]</a>, this lacks flexibility.  The &quot;all or nothing&quot; approach
(meaning that one must choose between only positional arguments,
or only named arguments) is felt to be overly constraining.</p>
<p>While there is some overlap between this proposal and
string.Template, it is felt that each serves a distinct need,
and that one does not obviate the other.  This proposal is for
a mechanism which, like '%', is efficient for small strings
which are only used once, so, for example, compilation of a
string into a template is not contemplated in this proposal,
although the proposal does take care to define format strings
and the API in such a way that an efficient template package
could reuse the syntax and even some of the underlying
formatting code.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id15">Specification</a></h1>
<p>The specification will consist of the following parts:</p>
<ul class="simple">
<li>Specification of a new formatting method to be added to the
built-in string class.</li>
<li>Specification of functions and flag values to be added to
the string module, so that the underlying formatting engine
can be used with additional options.</li>
<li>Specification of a new syntax for format strings.</li>
<li>Specification of a new set of special methods to control the
formatting and conversion of objects.</li>
<li>Specification of an API for user-defined formatting classes.</li>
<li>Specification of how formatting errors are handled.</li>
</ul>
<p>Note on string encodings: When discussing this PEP in the context
of Python 3.0, it is assumed that all strings are unicode strings,
and that the use of the word 'string' in the context of this
document will generally refer to a Python 3.0 string, which is
the same as Python 2.x unicode object.</p>
<p>In the context of Python 2.x, the use of the word 'string' in this
document refers to an object which may either be a regular string
or a unicode object.  All of the function call interfaces
described in this PEP can be used for both strings and unicode
objects, and in all cases there is sufficient information
to be able to properly deduce the output string type (in
other words, there is no need for two separate APIs).
In all cases, the type of the format string dominates - that
is, the result of the conversion will always result in an object
that contains the same representation of characters as the
input format string.</p>
<div class="section" id="string-methods">
<h2><a class="toc-backref" href="#id16">String Methods</a></h2>
<p>The built-in string class (and also the unicode class in 2.6) will
gain a new method, 'format', which takes an arbitrary number of
positional and keyword arguments:</p>
<pre class="literal-block">
&quot;The story of {0}, {1}, and {c}&quot;.format(a, b, c=d)
</pre>
<p>Within a format string, each positional argument is identified
with a number, starting from zero, so in the above example, 'a' is
argument 0 and 'b' is argument 1.  Each keyword argument is
identified by its keyword name, so in the above example, 'c' is
used to refer to the third argument.</p>
<p>There is also a global built-in function, 'format' which formats
a single value:</p>
<pre class="literal-block">
print(format(10.0, &quot;7.3g&quot;))
</pre>
<p>This function is described in a later section.</p>
</div>
<div class="section" id="format-strings">
<h2><a class="toc-backref" href="#id17">Format Strings</a></h2>
<p>Format strings consist of intermingled character data and markup.</p>
<p>Character data is data which is transferred unchanged from the
format string to the output string; markup is not transferred from
the format string directly to the output, but instead is used to
define 'replacement fields' that describe to the format engine
what should be placed in the output string in place of the markup.</p>
<p>Brace characters ('curly braces') are used to indicate a
replacement field within the string:</p>
<pre class="literal-block">
&quot;My name is {0}&quot;.format('Fred')
</pre>
<p>The result of this is the string:</p>
<pre class="literal-block">
&quot;My name is Fred&quot;
</pre>
<p>Braces can be escaped by doubling:</p>
<pre class="literal-block">
&quot;My name is {0} :-{{}}&quot;.format('Fred')
</pre>
<p>Which would produce:</p>
<pre class="literal-block">
&quot;My name is Fred :-{}&quot;
</pre>
<p>The element within the braces is called a 'field'.  Fields consist
of a 'field name', which can either be simple or compound, and an
optional 'format specifier'.</p>
</div>
<div class="section" id="simple-and-compound-field-names">
<h2><a class="toc-backref" href="#id18">Simple and Compound Field Names</a></h2>
<p>Simple field names are either names or numbers.  If numbers, they
must be valid base-10 integers; if names, they must be valid
Python identifiers.  A number is used to identify a positional
argument, while a name is used to identify a keyword argument.</p>
<p>A compound field name is a combination of multiple simple field
names in an expression:</p>
<pre class="literal-block">
&quot;My name is {0.name}&quot;.format(open('out.txt', 'w'))
</pre>
<p>This example shows the use of the 'getattr' or 'dot' operator
in a field expression.  The dot operator allows an attribute of
an input value to be specified as the field value.</p>
<p>Unlike some other programming languages, you cannot embed arbitrary
expressions in format strings.  This is by design - the types of
expressions that you can use is deliberately limited.  Only two operators
are supported: the '.' (getattr) operator, and the '[]' (getitem)
operator.  The reason for allowing these operators is that they don't
normally have side effects in non-pathological code.</p>
<p>An example of the 'getitem' syntax:</p>
<pre class="literal-block">
&quot;My name is {0[name]}&quot;.format(dict(name='Fred'))
</pre>
<p>It should be noted that the use of 'getitem' within a format string
is much more limited than its conventional usage.  In the above example,
the string 'name' really is the literal string 'name', not a variable
named 'name'.  The rules for parsing an item key are very simple.
If it starts with a digit, then it is treated as a number, otherwise
it is used as a string.</p>
<p>Because keys are not quote-delimited, it is not possible to
specify arbitrary dictionary keys (e.g., the strings &quot;10&quot; or
&quot;:-]&quot;) from within a format string.</p>
<p>Implementation note: The implementation of this proposal is
not required to enforce the rule about a simple or dotted name
being a valid Python identifier.  Instead, it will rely on the
getattr function of the underlying object to throw an exception if
the identifier is not legal.  The <tt class="docutils literal">str.format()</tt> function will have
a minimalist parser which only attempts to figure out when it is
&quot;done&quot; with an identifier (by finding a '.' or a ']', or '}',
etc.).</p>
</div>
<div class="section" id="format-specifiers">
<h2><a class="toc-backref" href="#id19">Format Specifiers</a></h2>
<p>Each field can also specify an optional set of 'format
specifiers' which can be used to adjust the format of that field.
Format specifiers follow the field name, with a colon (':')
character separating the two:</p>
<pre class="literal-block">
&quot;My name is {0:8}&quot;.format('Fred')
</pre>
<p>The meaning and syntax of the format specifiers depends on the
type of object that is being formatted, but there is a standard
set of format specifiers used for any object that does not
override them.</p>
<p>Format specifiers can themselves contain replacement fields.
For example, a field whose field width is itself a parameter
could be specified via:</p>
<pre class="literal-block">
&quot;{0:{1}}&quot;.format(a, b)
</pre>
<p>These 'internal' replacement fields can only occur in the format
specifier part of the replacement field.  Internal replacement fields
cannot themselves have format specifiers.  This implies also that
replacement fields cannot be nested to arbitrary levels.</p>
<p>Note that the doubled '}' at the end, which would normally be
escaped, is not escaped in this case.  The reason is because
the '{{' and '}}' syntax for escapes is only applied when used
<strong>outside</strong> of a format field.  Within a format field, the brace
characters always have their normal meaning.</p>
<p>The syntax for format specifiers is open-ended, since a class
can override the standard format specifiers.  In such cases,
the <tt class="docutils literal">str.format()</tt> method merely passes all of the characters between
the first colon and the matching brace to the relevant underlying
formatting method.</p>
</div>
<div class="section" id="standard-format-specifiers">
<h2><a class="toc-backref" href="#id20">Standard Format Specifiers</a></h2>
<p>If an object does not define its own format specifiers, a standard
set of format specifiers is used.  These are similar in concept to
the format specifiers used by the existing '%' operator, however
there are also a number of differences.</p>
<p>The general form of a standard format specifier is:</p>
<pre class="literal-block">
[[fill]align][sign][#][0][minimumwidth][.precision][type]
</pre>
<p>The brackets ([]) indicate an optional element.</p>
<p>Then the optional align flag can be one of the following:</p>
<pre class="literal-block">
'&lt;' - Forces the field to be left-aligned within the available
      space (This is the default.)
'&gt;' - Forces the field to be right-aligned within the
      available space.
'=' - Forces the padding to be placed after the sign (if any)
      but before the digits.  This is used for printing fields
      in the form '+000000120'. This alignment option is only
      valid for numeric types.
'^' - Forces the field to be centered within the available
      space.
</pre>
<p>Note that unless a minimum field width is defined, the field
width will always be the same size as the data to fill it, so
that the alignment option has no meaning in this case.</p>
<p>The optional 'fill' character defines the character to be used to
pad the field to the minimum width.  The fill character, if present,
must be followed by an alignment flag.</p>
<p>The 'sign' option is only valid for numeric types, and can be one
of the following:</p>
<pre class="literal-block">
'+'  - indicates that a sign should be used for both
       positive as well as negative numbers
'-'  - indicates that a sign should be used only for negative
       numbers (this is the default behavior)
' '  - indicates that a leading space should be used on
       positive numbers
</pre>
<p>If the '#' character is present, integers use the 'alternate form'
for formatting.  This means that binary, octal, and hexadecimal
output will be prefixed with '0b', '0o', and '0x', respectively.</p>
<p>'width' is a decimal integer defining the minimum field width.  If
not specified, then the field width will be determined by the
content.</p>
<p>If the width field is preceded by a zero ('0') character, this enables
zero-padding.  This is equivalent to an alignment type of '=' and a
fill character of '0'.</p>
<p>The 'precision' is a decimal number indicating how many digits
should be displayed after the decimal point in a floating point
conversion.  For non-numeric types the field indicates the maximum
field size - in other words, how many characters will be used from
the field content.  The precision is ignored for integer conversions.</p>
<p>Finally, the 'type' determines how the data should be presented.</p>
<p>The available integer presentation types are:</p>
<pre class="literal-block">
'b' - Binary. Outputs the number in base 2.
'c' - Character. Converts the integer to the corresponding
      Unicode character before printing.
'd' - Decimal Integer. Outputs the number in base 10.
'o' - Octal format. Outputs the number in base 8.
'x' - Hex format. Outputs the number in base 16, using lower-
      case letters for the digits above 9.
'X' - Hex format. Outputs the number in base 16, using upper-
      case letters for the digits above 9.
'n' - Number. This is the same as 'd', except that it uses the
      current locale setting to insert the appropriate
      number separator characters.
'' (None) - the same as 'd'
</pre>
<p>The available floating point presentation types are:</p>
<pre class="literal-block">
'e' - Exponent notation. Prints the number in scientific
      notation using the letter 'e' to indicate the exponent.
'E' - Exponent notation. Same as 'e' except it converts the
      number to uppercase.
'f' - Fixed point. Displays the number as a fixed-point
      number.
'F' - Fixed point. Same as 'f' except it converts the number
      to uppercase.
'g' - General format. This prints the number as a fixed-point
      number, unless the number is too large, in which case
      it switches to 'e' exponent notation.
'G' - General format. Same as 'g' except switches to 'E'
      if the number gets to large.
'n' - Number. This is the same as 'g', except that it uses the
      current locale setting to insert the appropriate
      number separator characters.
'%' - Percentage. Multiplies the number by 100 and displays
      in fixed ('f') format, followed by a percent sign.
'' (None) - similar to 'g', except that it prints at least one
      digit after the decimal point.
</pre>
<p>Objects are able to define their own format specifiers to
replace the standard ones.  An example is the 'datetime' class,
whose format specifiers might look something like the
arguments to the <tt class="docutils literal">strftime()</tt> function:</p>
<pre class="literal-block">
&quot;Today is: {0:%a %b %d %H:%M:%S %Y}&quot;.format(datetime.now())
</pre>
<p>For all built-in types, an empty format specification will produce
the equivalent of <tt class="docutils literal">str(value)</tt>.  It is recommended that objects
defining their own format specifiers follow this convention as
well.</p>
</div>
<div class="section" id="explicit-conversion-flag">
<h2><a class="toc-backref" href="#id21">Explicit Conversion Flag</a></h2>
<p>The explicit conversion flag is used to transform the format field value
before it is formatted.  This can be used to override the type-specific
formatting behavior, and format the value as if it were a more
generic type.  Currently, two explicit conversion flags are
recognized:</p>
<pre class="literal-block">
!r - convert the value to a string using repr().
!s - convert the value to a string using str().
</pre>
<p>These flags are placed before the format specifier:</p>
<pre class="literal-block">
&quot;{0!r:20}&quot;.format(&quot;Hello&quot;)
</pre>
<p>In the preceding example, the string &quot;Hello&quot; will be printed, with quotes,
in a field of at least 20 characters width.</p>
<p>A custom Formatter class can define additional conversion flags.
The built-in formatter will raise a ValueError if an invalid
conversion flag is specified.</p>
</div>
<div class="section" id="controlling-formatting-on-a-per-type-basis">
<h2><a class="toc-backref" href="#id22">Controlling Formatting on a Per-Type Basis</a></h2>
<p>Each Python type can control formatting of its instances by defining
a <tt class="docutils literal">__format__</tt> method.  The <tt class="docutils literal">__format__</tt> method is responsible for
interpreting the format specifier, formatting the value, and
returning the resulting string.</p>
<p>The new, global built-in function 'format' simply calls this special
method, similar to how <tt class="docutils literal">len()</tt> and <tt class="docutils literal">str()</tt> simply call their respective
special methods:</p>
<pre class="literal-block">
def format(value, format_spec):
    return value.__format__(format_spec)
</pre>
<p>It is safe to call this function with a value of &quot;None&quot; (because the
&quot;None&quot; value in Python is an object and can have methods.)</p>
<p>Several built-in types, including 'str', 'int', 'float', and 'object'
define <tt class="docutils literal">__format__</tt> methods.  This means that if you derive from any of
those types, your class will know how to format itself.</p>
<p>The <tt class="docutils literal">object.__format__</tt> method is the simplest: It simply converts the
object to a string, and then calls format again:</p>
<pre class="literal-block">
class object:
    def __format__(self, format_spec):
        return format(str(self), format_spec)
</pre>
<p>The <tt class="docutils literal">__format__</tt> methods for 'int' and 'float' will do numeric formatting
based on the format specifier.  In some cases, these formatting
operations may be delegated to other types.  So for example, in the case
where the 'int' formatter sees a format type of 'f' (meaning 'float')
it can simply cast the value to a float and call <tt class="docutils literal">format()</tt> again.</p>
<p>Any class can override the <tt class="docutils literal">__format__</tt> method to provide custom
formatting for that type:</p>
<pre class="literal-block">
class AST:
    def __format__(self, format_spec):
        ...
</pre>
<p>Note for Python 2.x: The 'format_spec' argument will be either
a string object or a unicode object, depending on the type of the
original format string.  The <tt class="docutils literal">__format__</tt> method should test the type
of the specifiers parameter to determine whether to return a string or
unicode object.  It is the responsibility of the <tt class="docutils literal">__format__</tt> method
to return an object of the proper type.</p>
<p>Note that the 'explicit conversion' flag mentioned above is not passed
to the <tt class="docutils literal">__format__</tt> method.  Rather, it is expected that the conversion
specified by the flag will be performed before calling <tt class="docutils literal">__format__</tt>.</p>
</div>
<div class="section" id="user-defined-formatting">
<h2><a class="toc-backref" href="#id23">User-Defined Formatting</a></h2>
<p>There will be times when customizing the formatting of fields
on a per-type basis is not enough.  An example might be a
spreadsheet application, which displays hash marks '#' when a value
is too large to fit in the available space.</p>
<p>For more powerful and flexible formatting, access to the underlying
format engine can be obtained through the 'Formatter' class that
lives in the 'string' module.  This class takes additional options
which are not accessible via the normal str.format method.</p>
<p>An application can subclass the Formatter class to create its own
customized formatting behavior.</p>
<p>The PEP does not attempt to exactly specify all methods and
properties defined by the <tt class="docutils literal">Formatter</tt> class; instead, those will be
defined and documented in the initial implementation.  However, this
PEP will specify the general requirements for the <tt class="docutils literal">Formatter</tt> class,
which are listed below.</p>
<p>Although <tt class="docutils literal">string.format()</tt> does not directly use the <tt class="docutils literal">Formatter</tt> class
to do formatting, both use the same underlying implementation.  The
reason that <tt class="docutils literal">string.format()</tt> does not use the <tt class="docutils literal">Formatter</tt> class directly
is because &quot;string&quot; is a built-in type, which means that all of its
methods must be implemented in C, whereas <tt class="docutils literal">Formatter</tt> is a Python
class.  <tt class="docutils literal">Formatter</tt> provides an extensible wrapper around the same
C functions as are used by <tt class="docutils literal">string.format()</tt>.</p>
</div>
<div class="section" id="formatter-methods">
<h2><a class="toc-backref" href="#id24">Formatter Methods</a></h2>
<p>The <tt class="docutils literal">Formatter</tt> class takes no initialization arguments:</p>
<pre class="literal-block">
fmt = Formatter()
</pre>
<p>The public API methods of class <tt class="docutils literal">Formatter</tt> are as follows:</p>
<pre class="literal-block">
-- format(format_string, *args, **kwargs)
-- vformat(format_string, args, kwargs)
</pre>
<p>'format' is the primary API method.  It takes a format template,
and an arbitrary set of positional and keyword arguments.
'format' is just a wrapper that calls 'vformat'.</p>
<p>'vformat' is the function that does the actual work of formatting.  It
is exposed as a separate function for cases where you want to pass in
a predefined dictionary of arguments, rather than unpacking and
repacking the dictionary as individual arguments using the <tt class="docutils literal">*args</tt> and
<tt class="docutils literal">**kwds</tt> syntax.  'vformat' does the work of breaking up the format
template string into character data and replacement fields.  It calls
the 'get_positional' and 'get_index' methods as appropriate (described
below.)</p>
<p><tt class="docutils literal">Formatter</tt> defines the following overridable methods:</p>
<pre class="literal-block">
-- get_value(key, args, kwargs)
-- check_unused_args(used_args, args, kwargs)
-- format_field(value, format_spec)
</pre>
<p>'get_value' is used to retrieve a given field value.  The 'key' argument
will be either an integer or a string.  If it is an integer, it represents
the index of the positional argument in 'args'; If it is a string, then
it represents a named argument in 'kwargs'.</p>
<p>The 'args' parameter is set to the list of positional arguments to
'vformat', and the 'kwargs' parameter is set to the dictionary of
positional arguments.</p>
<p>For compound field names, these functions are only called for the
first component of the field name; subsequent components are handled
through normal attribute and indexing operations.</p>
<p>So for example, the field expression '0.name' would cause 'get_value'
to be called with a 'key' argument of 0.  The 'name' attribute will be
looked up after 'get_value' returns by calling the built-in 'getattr'
function.</p>
<p>If the index or keyword refers to an item that does not exist, then an
<tt class="docutils literal">IndexError/KeyError</tt> should be raised.</p>
<p>'check_unused_args' is used to implement checking for unused arguments
if desired.  The arguments to this function is the set of all argument
keys that were actually referred to in the format string (integers for
positional arguments, and strings for named arguments), and a reference
to the args and kwargs that was passed to vformat.  The set of unused
args can be calculated from these parameters.  'check_unused_args'
is assumed to throw an exception if the check fails.</p>
<p>'format_field' simply calls the global 'format' built-in.  The method
is provided so that subclasses can override it.</p>
<p>To get a better understanding of how these functions relate to each
other, here is pseudocode that explains the general operation of
vformat:</p>
<pre class="literal-block">
def vformat(format_string, args, kwargs):

  # Output buffer and set of used args
  buffer = StringIO.StringIO()
  used_args = set()

  # Tokens are either format fields or literal strings
  for token in self.parse(format_string):
    if is_format_field(token):
      # Split the token into field value and format spec
      field_spec, _, format_spec = token.partition(&quot;:&quot;)

      # Check for explicit type conversion
      explicit, _, field_spec  = field_spec.rpartition(&quot;!&quot;)

      # 'first_part' is the part before the first '.' or '['
      # Assume that 'get_first_part' returns either an int or
      # a string, depending on the syntax.
      first_part = get_first_part(field_spec)
      value = self.get_value(first_part, args, kwargs)

      # Record the fact that we used this arg
      used_args.add(first_part)

      # Handle [subfield] or .subfield. Assume that 'components'
      # returns an iterator of the various subfields, not including
      # the first part.
      for comp in components(field_spec):
        value = resolve_subfield(value, comp)

      # Handle explicit type conversion
      if explicit == 'r':
        value = repr(value)
      elif explicit == 's':
        value = str(value)

      # Call the global 'format' function and write out the converted
      # value.
      buffer.write(self.format_field(value, format_spec))

    else:
      buffer.write(token)

  self.check_unused_args(used_args, args, kwargs)
  return buffer.getvalue()
</pre>
<p>Note that the actual algorithm of the Formatter class (which will be
implemented in C) may not be the one presented here.  (It's likely
that the actual implementation won't be a 'class' at all - rather,
vformat may just call a C function which accepts the other overridable
methods as arguments.)  The primary purpose of this code example is to
illustrate the order in which overridable methods are called.</p>
</div>
<div class="section" id="customizing-formatters">
<h2><a class="toc-backref" href="#id25">Customizing Formatters</a></h2>
<p>This section describes some typical ways that Formatter objects
can be customized.</p>
<p>To support alternative format-string syntax, the 'vformat' method
can be overridden to alter the way format strings are parsed.</p>
<p>One common desire is to support a 'default' namespace, so that
you don't need to pass in keyword arguments to the <tt class="docutils literal">format()</tt>
method, but can instead use values in a pre-existing namespace.
This can easily be done by overriding <tt class="docutils literal">get_value()</tt> as follows:</p>
<pre class="literal-block">
class NamespaceFormatter(Formatter):
   def __init__(self, namespace={}):
       Formatter.__init__(self)
       self.namespace = namespace

   def get_value(self, key, args, kwds):
       if isinstance(key, str):
           try:
               # Check explicitly passed arguments first
               return kwds[key]
           except KeyError:
               return self.namespace[key]
       else:
           Formatter.get_value(key, args, kwds)
</pre>
<p>One can use this to easily create a formatting function that allows
access to global variables, for example:</p>
<pre class="literal-block">
fmt = NamespaceFormatter(globals())

greeting = &quot;hello&quot;
print(fmt.format(&quot;{greeting}, world!&quot;))
</pre>
<p>A similar technique can be done with the <tt class="docutils literal">locals()</tt> dictionary to
gain access to the locals dictionary.</p>
<p>It would also be possible to create a 'smart' namespace formatter
that could automatically access both locals and globals through
snooping of the calling stack.  Due to the need for compatibility
with the different versions of Python, such a capability will not
be included in the standard library, however it is anticipated
that someone will create and publish a recipe for doing this.</p>
<p>Another type of customization is to change the way that built-in
types are formatted by overriding the 'format_field' method.  (For
non-built-in types, you can simply define a <tt class="docutils literal">__format__</tt> special
method on that type.)  So for example, you could override the
formatting of numbers to output scientific notation when needed.</p>
</div>
<div class="section" id="error-handling">
<h2><a class="toc-backref" href="#id26">Error handling</a></h2>
<p>There are two classes of exceptions which can occur during formatting:
exceptions generated by the formatter code itself, and exceptions
generated by user code (such as a field object's 'getattr' function).</p>
<p>In general, exceptions generated by the formatter code itself are
of the &quot;ValueError&quot; variety -- there is an error in the actual &quot;value&quot;
of the format string.  (This is not always true; for example, the
<tt class="docutils literal">string.format()</tt> function might be passed a non-string as its first
parameter, which would result in a <tt class="docutils literal">TypeError</tt>.)</p>
<p>The text associated with these internally generated <tt class="docutils literal">ValueError</tt>
exceptions will indicate the location of the exception inside
the format string, as well as the nature of the exception.</p>
<p>For exceptions generated by user code, a trace record and
dummy frame will be added to the traceback stack to help
in determining the location in the string where the exception
occurred.  The inserted traceback will indicate that the
error occurred at:</p>
<pre class="literal-block">
File &quot;&lt;format_string&gt;;&quot;, line XX, in column_YY
</pre>
<p>where XX and YY represent the line and character position
information in the string, respectively.</p>
</div>
</div>
<div class="section" id="alternate-syntax">
<h1><a class="toc-backref" href="#id27">Alternate Syntax</a></h1>
<p>Naturally, one of the most contentious issues is the syntax of the
format strings, and in particular the markup conventions used to
indicate fields.</p>
<p>Rather than attempting to exhaustively list all of the various
proposals, I will cover the ones that are most widely used
already.</p>
<ul>
<li><p class="first">Shell variable syntax: <tt class="docutils literal">$name</tt> and <tt class="docutils literal">$(name)</tt> (or in some variants,
<tt class="docutils literal">${name}</tt>).  This is probably the oldest convention out there, and
is used by Perl and many others.  When used without the braces,
the length of the variable is determined by lexically scanning
until an invalid character is found.</p>
<p>This scheme is generally used in cases where interpolation is
implicit - that is, in environments where any string can contain
interpolation variables, and no special substitution function
need be invoked.  In such cases, it is important to prevent the
interpolation behavior from occurring accidentally, so the '$'
(which is otherwise a relatively uncommonly-used character) is
used to signal when the behavior should occur.</p>
<p>It is the author's opinion, however, that in cases where the
formatting is explicitly invoked, that less care needs to be
taken to prevent accidental interpolation, in which case a
lighter and less unwieldy syntax can be used.</p>
</li>
<li><p class="first">printf and its cousins ('%'), including variations that add a
field index, so that fields can be interpolated out of order.</p>
</li>
<li><p class="first">Other bracket-only variations.  Various MUDs (Multi-User
Dungeons) such as MUSH have used brackets (e.g. <tt class="docutils literal">[name]</tt>) to do
string interpolation.  The Microsoft .Net libraries uses braces
(<tt class="docutils literal">{}</tt>), and a syntax which is very similar to the one in this
proposal, although the syntax for format specifiers is quite
different. <a class="footnote-reference" href="#id10" id="id4">[4]</a></p>
</li>
<li><p class="first">Backquoting.  This method has the benefit of minimal syntactical
clutter, however it lacks many of the benefits of a function
call syntax (such as complex expression arguments, custom
formatters, etc.).</p>
</li>
<li><p class="first">Other variations include Ruby's <tt class="docutils literal">#{}</tt>, PHP's <tt class="docutils literal">{$name}</tt>, and so
on.</p>
</li>
</ul>
<p>Some specific aspects of the syntax warrant additional comments:</p>
<p>1) Backslash character for escapes.  The original version of
this PEP used backslash rather than doubling to escape a bracket.
This worked because backslashes in Python string literals that
don't conform to a standard backslash sequence such as <tt class="docutils literal">\n</tt>
are left unmodified.  However, this caused a certain amount
of confusion, and led to potential situations of multiple
recursive escapes, i.e. <tt class="docutils literal"><span class="pre">\\\\{</span></tt> to place a literal backslash
in front of a bracket.</p>
<p>2) The use of the colon character (':') as a separator for
format specifiers.  This was chosen simply because that's
what .Net uses.</p>
</div>
<div class="section" id="alternate-feature-proposals">
<h1><a class="toc-backref" href="#id28">Alternate Feature Proposals</a></h1>
<p>Restricting attribute access: An earlier version of the PEP
restricted the ability to access attributes beginning with a
leading underscore, for example &quot;{0}._private&quot;.  However, this
is a useful ability to have when debugging, so the feature
was dropped.</p>
<p>Some developers suggested that the ability to do 'getattr' and
'getitem' access should be dropped entirely.  However, this
is in conflict with the needs of another set of developers who
strongly lobbied for the ability to pass in a large dict as a
single argument (without flattening it into individual keyword
arguments using the <tt class="docutils literal">**kwargs</tt> syntax) and then have the format
string refer to dict entries individually.</p>
<p>There has also been suggestions to expand the set of expressions
that are allowed in a format string.  However, this was seen
to go against the spirit of TOOWTDI, since the same effect can
be achieved in most cases by executing the same expression on
the parameter before it's passed in to the formatting function.
For cases where the format string is being use to do arbitrary
formatting in a data-rich environment, it's recommended to use
a template engine specialized for this purpose, such as
Genshi <a class="footnote-reference" href="#id11" id="id5">[5]</a> or Cheetah <a class="footnote-reference" href="#id12" id="id6">[6]</a>.</p>
<p>Many other features were considered and rejected because they
could easily be achieved by subclassing <tt class="docutils literal">Formatter</tt> instead of
building the feature into the base implementation.  This includes
alternate syntax, comments in format strings, and many others.</p>
</div>
<div class="section" id="security-considerations">
<h1><a class="toc-backref" href="#id29">Security Considerations</a></h1>
<p>Historically, string formatting has been a common source of
security holes in web-based applications, particularly if the
string formatting system allows arbitrary expressions to be
embedded in format strings.</p>
<p>The best way to use string formatting in a way that does not
create potential security holes is to never use format strings
that come from an untrusted source.</p>
<p>Barring that, the next best approach is to ensure that string
formatting has no side effects.  Because of the open nature of
Python, it is impossible to guarantee that any non-trivial
operation has this property.  What this PEP does is limit the
types of expressions in format strings to those in which visible
side effects are both rare and strongly discouraged by the
culture of Python developers.  So for example, attribute access
is allowed because it would be considered pathological to write
code where the mere access of an attribute has visible side
effects (whether the code has <strong>invisible</strong> side effects - such
as creating a cache entry for faster lookup - is irrelevant.)</p>
</div>
<div class="section" id="sample-implementation">
<h1><a class="toc-backref" href="#id30">Sample Implementation</a></h1>
<p>An implementation of an earlier version of this PEP was created by
Patrick Maupin and Eric V. Smith, and can be found in the pep3101
sandbox at:</p>
<blockquote>
<a class="reference external" href="http://svn.python.org/view/sandbox/trunk/pep3101/">http://svn.python.org/view/sandbox/trunk/pep3101/</a></blockquote>
</div>
<div class="section" id="backwards-compatibility">
<h1><a class="toc-backref" href="#id31">Backwards Compatibility</a></h1>
<p>Backwards compatibility can be maintained by leaving the existing
mechanisms in place.  The new system does not collide with any of
the method names of the existing string formatting techniques, so
both systems can co-exist until it comes time to deprecate the
older system.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id32">References</a></h1>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Python Library Reference - String formating operations
<a class="reference external" href="http://docs.python.org/library/stdtypes.html#string-formatting-operations">http://docs.python.org/library/stdtypes.html#string-formatting-operations</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Python Library References - Template strings
<a class="reference external" href="http://docs.python.org/library/string.html#string.Template">http://docs.python.org/library/string.html#string.Template</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>[Python-3000] String formating operations in python 3k
<a class="reference external" href="https://mail.python.org/pipermail/python-3000/2006-April/000285.html">https://mail.python.org/pipermail/python-3000/2006-April/000285.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>Composite Formatting - [.Net Framework Developer's Guide]
<a class="reference external" href="http://msdn.microsoft.com/library/en-us/cpguide/html/cpconcompositeformatting.asp?frame=true">http://msdn.microsoft.com/library/en-us/cpguide/html/cpconcompositeformatting.asp?frame=true</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>Genshi templating engine.
<a class="reference external" href="http://genshi.edgewall.org/">http://genshi.edgewall.org/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td>Cheetah - The Python-Powered Template Engine.
<a class="reference external" href="http://www.cheetahtemplate.org/">http://www.cheetahtemplate.org/</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id33">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

