<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">242</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Numeric Kinds</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0242.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">paul&#32;&#97;t&#32;pfdubois.com (Paul F. Dubois)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">17-Mar-2001</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.2</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">17-Apr-2001</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id2">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id3">Rationale</a></li>
<li><a class="reference internal" href="#supported-kinds-of-ints-and-floats" id="id4">Supported Kinds of Ints and Floats</a></li>
<li><a class="reference internal" href="#kind-objects" id="id5">Kind Objects</a></li>
<li><a class="reference internal" href="#attributes-of-module-kinds" id="id6">Attributes of Module kinds</a></li>
<li><a class="reference internal" href="#complex-numbers" id="id7">Complex Numbers</a></li>
<li><a class="reference internal" href="#examples" id="id8">Examples</a></li>
<li><a class="reference internal" href="#open-issues" id="id9">Open Issues</a></li>
<li><a class="reference internal" href="#rejection" id="id10">Rejection</a></li>
<li><a class="reference internal" href="#copyright" id="id11">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id2">Abstract</a></h1>
<p>This proposal gives the user optional control over the precision
and range of numeric computations so that a computation can be
written once and run anywhere with at least the desired precision
and range.  It is backward compatible with existing code.  The
meaning of decimal literals is clarified.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id3">Rationale</a></h1>
<p>Currently it is impossible in every language except Fortran 90 to
write a program in a portable way that uses floating point and
gets roughly the same answer regardless of platform -- or refuses
to compile if that is not possible.  Python currently has only one
floating point type, equal to a C double in the C implementation.</p>
<p>No type exists corresponding to single or quad floats.  It would
complicate the language to try to introduce such types directly
and their subsequent use would not be portable.  This proposal is
similar to the Fortran 90 &quot;kind&quot; solution, adapted to the Python
environment.  With this facility an entire calculation can be
switched from one level of precision to another by changing a
single line.  If the desired precision does not exist on a
particular machine, the program will fail rather than get the
wrong answer.  Since coding in this style would involve an early
call to the routine that will fail, this is the next best thing to
not compiling.</p>
</div>
<div class="section" id="supported-kinds-of-ints-and-floats">
<h1><a class="toc-backref" href="#id4">Supported Kinds of Ints and Floats</a></h1>
<p>Complex numbers are treated separately below, since Python can be
built without them.</p>
<p>Each Python compiler may define as many &quot;kinds&quot; of integer and
floating point numbers as it likes, except that it must support at
least two kinds of integer corresponding to the existing int and
long, and must support at least one kind of floating point number,
equivalent to the present float.</p>
<p>The range and precision of these required kinds are processor
dependent, as at present, except for the &quot;long integer&quot; kind,
which can hold an arbitrary integer.</p>
<p>The built-in functions <tt class="docutils literal">int()</tt>, <tt class="docutils literal">long()</tt>, and <tt class="docutils literal">float()</tt> convert inputs
to these default kinds as they do at present.  (Note that a
Unicode string is actually a different &quot;kind&quot; of string and that a
sufficiently knowledgeable person might be able to expand this PEP
to cover that case.)</p>
<p>Within each type (integer, floating) the compiler supports a
linearly-ordered set of kinds, with the ordering determined by the
ability to hold numbers of an increased range and/or precision.</p>
</div>
<div class="section" id="kind-objects">
<h1><a class="toc-backref" href="#id5">Kind Objects</a></h1>
<p>Two new standard functions are defined in a module named &quot;kinds&quot;.
They return callable objects called kind objects.  Each int or
floating kind object f has the signature <tt class="docutils literal">result = f(x)</tt>, and each
complex kind object has the signature <tt class="docutils literal">result = f(x, y=0.)</tt>.</p>
<dl class="docutils">
<dt><tt class="docutils literal">int_kind(n)</tt></dt>
<dd>For an integer argument <tt class="docutils literal">n &gt;= 1</tt>, return a callable object whose
result is an integer kind that will hold an integer number in
the open interval (<tt class="docutils literal"><span class="pre">-10**n</span></tt>, <tt class="docutils literal"><span class="pre">10**n</span></tt>).  The kind object accepts
arguments that are integers including longs.  If <tt class="docutils literal">n == 0</tt>,
returns the kind object corresponding to the Python literal 0.</dd>
<dt><tt class="docutils literal">float_kind(nd, n)</tt></dt>
<dd><p class="first">For <tt class="docutils literal">nd &gt;= 0</tt> and <tt class="docutils literal">n &gt;= 1</tt>, return a callable object whose result
is a floating point kind that will hold a floating-point
number with at least nd digits of precision and a base-10
exponent in the closed interval <tt class="docutils literal"><span class="pre">[-n,</span> n]</tt>.  The kind object
accepts arguments that are integer or float.</p>
<p class="last">If nd and n are both zero, returns the kind object
corresponding to the Python literal 0.0.</p>
</dd>
</dl>
<p>The compiler will return a kind object corresponding to the least
of its available set of kinds for that type that has the desired
properties.  If no kind with the desired qualities exists in a
given implementation an <tt class="docutils literal">OverflowError</tt> exception is thrown.  A kind
function converts its argument to the target kind, but if the
result does not fit in the target kind's range, an <tt class="docutils literal">OverflowError</tt>
exception is thrown.</p>
<p>Besides their callable behavior, kind objects have attributes
giving the traits of the kind in question.</p>
<ol class="arabic simple">
<li><tt class="docutils literal">name</tt> is the name of the kind.  The standard kinds are called
int, long, double.</li>
<li><tt class="docutils literal">typecode</tt> is a single-letter string that would be appropriate
for use with <tt class="docutils literal">Numeric</tt> or module <tt class="docutils literal">array</tt> to form an array of this
kind.  The standard types' typecodes are 'i', 'O', 'd'
respectively.</li>
<li>Integer kinds have these additional attributes: <tt class="docutils literal">MAX</tt>, equal to
the maximum permissible integer of this kind, or <tt class="docutils literal">None</tt> for the
long kind. <tt class="docutils literal">MIN</tt>, equal to the most negative permissible integer
of this kind, or <tt class="docutils literal">None</tt> for the long kind.</li>
<li>Float kinds have these additional attributes whose properties
are equal to the corresponding value for the corresponding C
type in the standard header file &quot;float.h&quot;.  <tt class="docutils literal">MAX</tt>, <tt class="docutils literal">MIN</tt>, <tt class="docutils literal">DIG</tt>,
<tt class="docutils literal">MANT_DIG</tt>, <tt class="docutils literal">EPSILON</tt>, <tt class="docutils literal">MAX_EXP</tt>, <tt class="docutils literal">MAX_10_EXP</tt>, <tt class="docutils literal">MIN_EXP</tt>,
<tt class="docutils literal">MIN_10_EXP</tt>, <tt class="docutils literal">RADIX</tt>, <tt class="docutils literal">ROUNDS</tt>
(== <tt class="docutils literal">FLT_RADIX</tt>, <tt class="docutils literal">FLT_ROUNDS</tt> in float.h).  These
values are of type integer except for <tt class="docutils literal">MAX</tt>, <tt class="docutils literal">MIN</tt>, and <tt class="docutils literal">EPSILON</tt>,
which are of the Python floating type to which the kind
corresponds.</li>
</ol>
</div>
<div class="section" id="attributes-of-module-kinds">
<h1><a class="toc-backref" href="#id6">Attributes of Module kinds</a></h1>
<p><tt class="docutils literal">int_kinds</tt> is a list of the available integer kinds, sorted from lowest
to highest kind.  By definition, <tt class="docutils literal"><span class="pre">int_kinds[-1]</span></tt> is the long kind.</p>
<p><tt class="docutils literal">float_kinds</tt> is a list of the available floating point kinds, sorted
from lowest to highest kind.</p>
<p><tt class="docutils literal">default_int_kind</tt> is the kind object corresponding to the Python
literal 0</p>
<p><tt class="docutils literal">default_long_kind</tt> is the kind object corresponding to the Python
literal 0L</p>
<p><tt class="docutils literal">default_float_kind</tt> is the kind object corresponding to the Python
literal 0.0</p>
</div>
<div class="section" id="complex-numbers">
<h1><a class="toc-backref" href="#id7">Complex Numbers</a></h1>
<p>If supported, complex numbers have real and imaginary parts that
are floating-point numbers with the same kind.  A Python compiler
must support a complex analog of each floating point kind it
supports, if it supports complex numbers at all.</p>
<p>If complex numbers are supported, the following are available in
module kinds:</p>
<dl class="docutils">
<dt><tt class="docutils literal">complex_kind(nd, n)</tt></dt>
<dd>Return a callable object whose result is a complex kind that
will hold a complex number each of whose components (.real,
.imag) is of kind <tt class="docutils literal">float_kind(nd, n)</tt>.  The kind object will
accept one argument that is of any integer, real, or complex
kind, or two arguments, each integer or real.</dd>
</dl>
<p><tt class="docutils literal">complex_kinds</tt> is a list of the available complex kinds, sorted
from lowest to highest kind.</p>
<p><tt class="docutils literal">default_complex_kind</tt> is the kind object corresponding to the
Python literal 0.0j.  The name of this kind
is doublecomplex, and its typecode is 'D'.</p>
<p>Complex kind objects have these addition attributes:</p>
<p><tt class="docutils literal">floatkind</tt> is the kind object of the corresponding float type.</p>
</div>
<div class="section" id="examples">
<h1><a class="toc-backref" href="#id8">Examples</a></h1>
<p>In module myprecision.py:</p>
<pre class="literal-block">
import kinds
tinyint = kinds.int_kind(1)
single = kinds.float_kind(6, 90)
double = kinds.float_kind(15, 300)
csingle = kinds.complex_kind(6, 90)
</pre>
<p>In the rest of my code:</p>
<pre class="literal-block">
from myprecision import tinyint, single, double, csingle
n = tinyint(3)
x = double(1.e20)
z = 1.2
# builtin float gets you the default float kind, properties unknown
w = x * float(x)
# but in the following case we know w has kind &quot;double&quot;.
w = x * double(z)

u = csingle(x + z * 1.0j)
u2 = csingle(x+z, 1.0)
</pre>
<p>Note how that entire code can then be changed to a higher
precision by changing the arguments in myprecision.py.</p>
<p>Comment: note that you aren't promised that single != double; but
you are promised that <tt class="docutils literal">double(1.e20)</tt> will hold a number with 15
decimal digits of precision and a range up to <tt class="docutils literal"><span class="pre">10**300</span></tt> or that the
<tt class="docutils literal">float_kind</tt> call will fail.</p>
</div>
<div class="section" id="open-issues">
<h1><a class="toc-backref" href="#id9">Open Issues</a></h1>
<p>No open issues have been raised at this time.</p>
</div>
<div class="section" id="rejection">
<h1><a class="toc-backref" href="#id10">Rejection</a></h1>
<p>This PEP has been closed by the author.  The kinds module will not
be added to the standard library.</p>
<p>There was no opposition to the proposal but only mild interest in
using it, not enough to justify adding the module to the standard
library.  Instead, it will be made available as a separate
distribution item at the Numerical Python site.  At the next
release of Numerical Python, it will no longer be a part of the
Numeric distribution.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id11">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

