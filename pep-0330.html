<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">330</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Python Bytecode Verification</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0330.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Michel Pelletier &lt;michel&#32;&#97;t&#32;users.sourceforge.net&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">17-Jun-2004</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.6?</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id3">Abstract</a></li>
<li><a class="reference internal" href="#pronouncement" id="id4">Pronouncement</a></li>
<li><a class="reference internal" href="#motivation" id="id5">Motivation</a></li>
<li><a class="reference internal" href="#static-constraints-on-bytecode-instructions" id="id6">Static Constraints on Bytecode Instructions</a></li>
<li><a class="reference internal" href="#static-constraints-on-bytecode-instruction-operands" id="id7">Static Constraints on Bytecode Instruction Operands</a></li>
<li><a class="reference internal" href="#structural-constraints-between-bytecode-instructions" id="id8">Structural Constraints between Bytecode Instructions</a></li>
<li><a class="reference internal" href="#implementation" id="id9">Implementation</a></li>
<li><a class="reference internal" href="#verification-issues" id="id10">Verification Issues</a></li>
<li><a class="reference internal" href="#required-changes" id="id11">Required Changes</a></li>
<li><a class="reference internal" href="#references" id="id12">References</a></li>
<li><a class="reference internal" href="#copyright" id="id13">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id3">Abstract</a></h1>
<p>If Python Virtual Machine (PVM) bytecode is not &quot;well-formed&quot; it
is possible to crash or exploit the PVM by causing various errors
such as under/overflowing the value stack or reading/writing into
arbitrary areas of the PVM program space.  Most of these kinds of
errors can be eliminated by verifying that PVM bytecode does not
violate a set of simple constraints before execution.</p>
<p>This PEP proposes a set of constraints on the format and structure
of Python Virtual Machine (PVM) bytecode and provides an
implementation in Python of this verification process.</p>
</div>
<div class="section" id="pronouncement">
<h1><a class="toc-backref" href="#id4">Pronouncement</a></h1>
<p>Guido believes that a verification tool has some value.  If
someone wants to add it to <tt class="docutils literal">Tools/scripts</tt>, no PEP is required.</p>
<p>Such a tool may have value for validating the output from
&quot;bytecodehacks&quot; or from direct edits of PYC files.  As security
measure, its value is somewhat limited because perfectly valid
bytecode can still do horrible things.  That situation could
change if the concept of restricted execution were to be
successfully resurrected.</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id5">Motivation</a></h1>
<p>The Python Virtual Machine executes Python programs that have been
compiled from the Python language into a bytecode representation.
The PVM assumes that any bytecode being executed is &quot;well-formed&quot;
with regard to a number implicit constraints.  Some of these
constraints are checked at run-time, but most of them are not due
to the overhead they would create.</p>
<p>When running in debug mode the PVM does do several run-time checks
to ensure that any particular bytecode cannot violate these
constraints that, to a degree, prevent bytecode from crashing or
exploiting the interpreter.  These checks add a measurable
overhead to the interpreter, and are typically turned off in
common use.</p>
<p>Bytecode that is not well-formed and executed by a PVM not running
in debug mode may create a variety of fatal and non-fatal errors.
Typically, ill-formed code will cause the PVM to seg-fault and
cause the OS to immediately and abruptly terminate the
interpreter.</p>
<p>Conceivably, ill-formed bytecode could exploit the interpreter and
allow Python bytecode to execute arbitrary C-level machine
instructions or to modify private, internal data structures in the
interpreter.  If used cleverly this could subvert any form of
security policy an application may want to apply to its objects.</p>
<p>Practically, it would be difficult for a malicious user to
&quot;inject&quot; invalid bytecode into a PVM for the purposes of
exploitation, but not impossible.  Buffer overflow and memory
overwrite attacks are commonly understood, particularly when the
exploit payload is transmitted unencrypted over a network or when
a file or network security permission weakness is used as a
foothold for further attacks.</p>
<p>Ideally, no bytecode should ever be allowed to read or write
underlying C-level data structures to subvert the operation of the
PVM, whether the bytecode was maliciously crafted or not.  A
simple pre-execution verification step could ensure that bytecode
cannot over/underflow the value stack or access other sensitive
areas of PVM program space at run-time.</p>
<p>This PEP proposes several validation steps that should be taken on
Python bytecode before it is executed by the PVM so that it
compiles with static and structure constraints on its instructions
and their operands.  These steps are simple and catch a large
class of invalid bytecode that can cause crashes.  There is also
some possibility that some run-time checks can be eliminated up
front by a verification pass.</p>
<p>There is, of course, no way to verify that bytecode is &quot;completely
safe&quot;, for every definition of complete and safe.  Even with
bytecode verification, Python programs can and most likely in the
future will seg-fault for a variety of reasons and continue to
cause many different classes of run-time errors, fatal or not.
The verification step proposed here simply plugs an easy hole that
can cause a large class of fatal and subtle errors at the bytecode
level.</p>
<p>Currently, the Java Virtual Machine (JVM) verifies Java bytecode
in a way very similar to what is proposed here.  The JVM
Specification version 2 <a class="footnote-reference" href="#id2" id="id1">[1]</a>, Sections 4.8 and 4.9 were therefore
used as a basis for some of the constraints explained below.  Any
Python bytecode verification implementation at a minimum must
enforce these constraints, but may not be limited to them.</p>
</div>
<div class="section" id="static-constraints-on-bytecode-instructions">
<h1><a class="toc-backref" href="#id6">Static Constraints on Bytecode Instructions</a></h1>
<ol class="arabic simple">
<li>The bytecode string must not be empty. (<tt class="docutils literal">len(co_code) &gt; 0</tt>).</li>
<li>The bytecode string cannot exceed a maximum size
(<tt class="docutils literal">len(co_code) &lt; sizeof(unsigned char) - 1</tt>).</li>
<li>The first instruction in the bytecode string begins at index 0.</li>
<li>Only valid byte-codes with the correct number of operands can
be in the bytecode string.</li>
</ol>
</div>
<div class="section" id="static-constraints-on-bytecode-instruction-operands">
<h1><a class="toc-backref" href="#id7">Static Constraints on Bytecode Instruction Operands</a></h1>
<ol class="arabic simple">
<li>The target of a jump instruction must be within the code
boundaries and must fall on an instruction, never between an
instruction and its operands.</li>
<li>The operand of a <tt class="docutils literal">LOAD_*</tt> instruction must be a valid index into
its corresponding data structure.</li>
<li>The operand of a <tt class="docutils literal">STORE_*</tt> instruction must be a valid index
into its corresponding data structure.</li>
</ol>
</div>
<div class="section" id="structural-constraints-between-bytecode-instructions">
<h1><a class="toc-backref" href="#id8">Structural Constraints between Bytecode Instructions</a></h1>
<ol class="arabic simple">
<li>Each instruction must only be executed with the appropriate
number of arguments in the value stack, regardless of the
execution path that leads to its invocation.</li>
<li>If an instruction can be executed along several different
execution paths, the value stack must have the same depth prior
to the execution of the instruction, regardless of the path
taken.</li>
<li>At no point during execution can the value stack grow to a
depth greater than that implied by <tt class="docutils literal">co_stacksize</tt>.</li>
<li>Execution never falls off the bottom of <tt class="docutils literal">co_code</tt>.</li>
</ol>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id9">Implementation</a></h1>
<p>This PEP is the working document for a Python bytecode
verification implementation written in Python.  This
implementation is not used implicitly by the PVM before executing
any bytecode, but is to be used explicitly by users concerned
about possibly invalid bytecode with the following snippet:</p>
<pre class="literal-block">
import verify
verify.verify(object)
</pre>
<p>The <tt class="docutils literal">verify</tt> module provides a <tt class="docutils literal">verify</tt> function which accepts the
same kind of arguments as <tt class="docutils literal">dis.dis</tt>: classes, methods, functions,
or code objects.  It verifies that the object's bytecode is
well-formed according to the specifications of this PEP.</p>
<p>If the code is well-formed the call to <tt class="docutils literal">verify</tt> returns silently
without error.  If an error is encountered, it throws a
<tt class="docutils literal">VerificationError</tt> whose argument indicates the cause of the
failure.  It is up to the programmer whether or not to handle the
error in some way or execute the invalid code regardless.</p>
<p>Phillip Eby has proposed a pseudo-code algorithm for bytecode
stack depth verification used by the reference implementation.</p>
</div>
<div class="section" id="verification-issues">
<h1><a class="toc-backref" href="#id10">Verification Issues</a></h1>
<p>This PEP describes only a small number of verifications.  While
discussion and analysis will lead to many more, it is highly
possible that future verification may need to be done or custom,
project-specific verifications.  For this reason, it might be
desirable to add a verification registration interface to the test
implementation to register future verifiers.  The need for this is
minimal since custom verifiers can subclass and extend the current
implementation for added behavior.</p>
</div>
<div class="section" id="required-changes">
<h1><a class="toc-backref" href="#id11">Required Changes</a></h1>
<p>Armin Rigo noted that several byte-codes will need modification in
order for their stack effect to be statically analyzed.  These are
<tt class="docutils literal">END_FINALLY</tt>, <tt class="docutils literal">POP_BLOCK</tt>, and <tt class="docutils literal">MAKE_CLOSURE</tt>.  Armin and Guido have
already agreed on how to correct the instructions.  Currently the
Python implementation punts on these instructions.</p>
<p>This PEP does not propose to add the verification step to the
interpreter, but only to provide the Python implementation in the
standard library for optional use.  Whether or not this
verification procedure is translated into C, included with the PVM
or enforced in any way is left for future discussion.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id12">References</a></h1>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>The Java Virtual Machine Specification 2nd Edition
<a class="reference external" href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id13">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>

