<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">517</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">A build-system independent format for source trees</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0517.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Nathaniel J. Smith &lt;njs&#32;&#97;t&#32;pobox.com&gt;,
Thomas Kluyver &lt;thomas&#32;&#97;t&#32;kluyver.me.uk&gt;</td>
</tr>
<tr class="field"><th class="field-name">BDFL-Delegate:</th><td class="field-body">Nick Coghlan &lt;ncoghlan&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Discussions-To:</th><td class="field-body">&lt;<a class="reference external" href="mailto:distutils-sig&#64;python.org?subject=PEP%20517">distutils-sig&#32;&#97;t&#32;python.org</a>&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Accepted</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">30-Sep-2015</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">1 Oct 2015, 25 Oct 2015, 19 May 2017, 11 Sep 2017</td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/distutils-sig/2017-September/031548.html">https://mail.python.org/pipermail/distutils-sig/2017-September/031548.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id2">Abstract</a></li>
<li><a class="reference internal" href="#provisional-acceptance" id="id3">Provisional Acceptance</a></li>
<li><a class="reference internal" href="#terminology-and-goals" id="id4">Terminology and goals</a></li>
<li><a class="reference internal" href="#source-trees" id="id5">Source trees</a></li>
<li><a class="reference internal" href="#build-backend-interface" id="id6">Build backend interface</a><ul>
<li><a class="reference internal" href="#mandatory-hooks" id="id7">Mandatory hooks</a><ul>
<li><a class="reference internal" href="#build-wheel" id="id8">build_wheel</a></li>
<li><a class="reference internal" href="#build-sdist" id="id9">build_sdist</a></li>
</ul>
</li>
<li><a class="reference internal" href="#optional-hooks" id="id10">Optional hooks</a><ul>
<li><a class="reference internal" href="#get-requires-for-build-wheel" id="id11">get_requires_for_build_wheel</a></li>
<li><a class="reference internal" href="#prepare-metadata-for-build-wheel" id="id12">prepare_metadata_for_build_wheel</a></li>
<li><a class="reference internal" href="#get-requires-for-build-sdist" id="id13">get_requires_for_build_sdist</a></li>
</ul>
</li>
<li><a class="reference internal" href="#config-settings" id="id14">Config settings</a></li>
<li><a class="reference internal" href="#build-environment" id="id15">Build environment</a><ul>
<li><a class="reference internal" href="#recommendations-for-build-frontends-non-normative" id="id16">Recommendations for build frontends (non-normative)</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#source-distributions" id="id17">Source distributions</a></li>
<li><a class="reference internal" href="#evolutionary-notes" id="id18">Evolutionary notes</a></li>
<li><a class="reference internal" href="#rejected-options" id="id19">Rejected options</a></li>
<li><a class="reference internal" href="#appendix-a-comparison-to-pep-516" id="id20">Appendix A: Comparison to PEP 516</a><ul>
<li><a class="reference internal" href="#other-differences" id="id21">Other differences</a></li>
</ul>
</li>
<li><a class="reference internal" href="#copyright" id="id22">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id2">Abstract</a></h1>
<p>While <tt class="docutils literal">distutils</tt> / <tt class="docutils literal">setuptools</tt> have taken us a long way, they
suffer from three serious problems: (a) they're missing important
features like usable build-time dependency declaration,
autoconfiguration, and even basic ergonomic niceties like <a class="reference external" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</a>-compliant
version number management, and (b) extending them is difficult, so
while there do exist various solutions to the above problems, they're
often quirky, fragile, and expensive to maintain, and yet (c) it's
very difficult to use anything else, because distutils/setuptools
provide the standard interface for installing packages expected by
both users and installation tools like <tt class="docutils literal">pip</tt>.</p>
<p>Previous efforts (e.g. distutils2 or setuptools itself) have attempted
to solve problems (a) and/or (b). This proposal aims to solve (c).</p>
<p>The goal of this PEP is get distutils-sig out of the business of being
a gatekeeper for Python build systems. If you want to use distutils,
great; if you want to use something else, then that should be easy to
do using standardized methods. The difficulty of interfacing with
distutils means that there aren't many such systems right now, but to
give a sense of what we're thinking about see <a class="reference external" href="https://github.com/takluyver/flit">flit</a> or <a class="reference external" href="https://cournape.github.io/Bento/">bento</a>. Fortunately, wheels have now
solved many of the hard problems here -- e.g. it's no longer necessary
that a build system also know about every possible installation
configuration -- so pretty much all we really need from a build system
is that it have some way to spit out standard-compliant wheels and
sdists.</p>
<p>We therefore propose a new, relatively minimal interface for
installation tools like <tt class="docutils literal">pip</tt> to interact with package source trees
and source distributions.</p>
</div>
<div class="section" id="provisional-acceptance">
<h1><a class="toc-backref" href="#id3">Provisional Acceptance</a></h1>
<p>In accordance with the PyPA's specication process, this PEP has been
<a class="reference external" href="https://www.pypa.io/en/latest/specifications/#provisional-acceptance">provisionally accepted</a>
for initial implementation in <tt class="docutils literal">pip</tt> and other PyPA tools.</p>
<p>During this time, the specification is still subject to revision based
on real world experience with those initial implementations.</p>
</div>
<div class="section" id="terminology-and-goals">
<h1><a class="toc-backref" href="#id4">Terminology and goals</a></h1>
<p>A <em>source tree</em> is something like a VCS checkout. We need a standard
interface for installing from this format, to support usages like
<tt class="docutils literal">pip install <span class="pre">some-directory/</span></tt>.</p>
<p>A <em>source distribution</em> is a static snapshot representing a particular
release of some source code, like <tt class="docutils literal"><span class="pre">lxml-3.4.4.zip</span></tt>. Source
distributions serve many purposes: they form an archival record of
releases, they provide a stupid-simple de facto standard for tools
that want to ingest and process large corpora of code, possibly
written in many languages (e.g. code search), they act as the input to
downstream packaging systems like Debian/Fedora/Conda/..., and so
forth. In the Python ecosystem they additionally have a particularly
important role to play, because packaging tools like <tt class="docutils literal">pip</tt> are able
to use source distributions to fulfill binary dependencies, e.g. if
there is a distribution <tt class="docutils literal">foo.whl</tt> which declares a dependency on
<tt class="docutils literal">bar</tt>, then we need to support the case where <tt class="docutils literal">pip install bar</tt> or
<tt class="docutils literal">pip install foo</tt> automatically locates the sdist for <tt class="docutils literal">bar</tt>,
downloads it, builds it, and installs the resulting package.</p>
<p>Source distributions are also known as <em>sdists</em> for short.</p>
<p>A <em>build frontend</em> is a tool that users might run that takes arbitrary
source trees or source distributions and builds wheels from them. The
actual building is done by each source tree's <em>build backend</em>. In a
command like <tt class="docutils literal">pip wheel <span class="pre">some-directory/</span></tt>, pip is acting as a build
frontend.</p>
<p>An <em>integration frontend</em> is a tool that users might run that takes a
set of package requirements (e.g. a requirements.txt file) and
attempts to update a working environment to satisfy those
requirements. This may require locating, building, and installing a
combination of wheels and sdists. In a command like <tt class="docutils literal">pip install
<span class="pre">lxml==2.4.0</span></tt>, pip is acting as an integration frontend.</p>
</div>
<div class="section" id="source-trees">
<h1><a class="toc-backref" href="#id5">Source trees</a></h1>
<p>There is an existing, legacy source tree format involving
<tt class="docutils literal">setup.py</tt>. We don't try to specify it further; its de facto
specification is encoded in the source code and documentation of
<tt class="docutils literal">distutils</tt>, <tt class="docutils literal">setuptools</tt>, <tt class="docutils literal">pip</tt>, and other tools. We'll refer
to it as the <tt class="docutils literal">setup.py</tt>-style.</p>
<p>Here we define a new style of source tree based around the
<tt class="docutils literal">pyproject.toml</tt> file defined in <a class="reference external" href="/dev/peps/pep-0518">PEP 518</a>, extending the
<tt class="docutils literal"><span class="pre">[build-system]</span></tt> table in that file with one additional key,
<tt class="docutils literal"><span class="pre">build-backend</span></tt>. Here's an example of how it would look:</p>
<pre class="literal-block">
[build-system]
# Defined by PEP 518:
requires = [&quot;flit&quot;]
# Defined by this PEP:
build-backend = &quot;flit.api:main&quot;
</pre>
<p><tt class="docutils literal"><span class="pre">build-backend</span></tt> is a string naming a Python object that will be
used to perform the build (see below for details). This is formatted
following the same <tt class="docutils literal">module:object</tt> syntax as a <tt class="docutils literal">setuptools</tt> entry
point. For instance, if the string is <tt class="docutils literal">&quot;flit.api:main&quot;</tt> as in the
example above, this object would be looked up by executing the
equivalent of:</p>
<pre class="literal-block">
import flit.api
backend = flit.api.main
</pre>
<p>It's also legal to leave out the <tt class="docutils literal">:object</tt> part, e.g.</p>
<pre class="literal-block">
build-backend = &quot;flit.api&quot;
</pre>
<p>which acts like:</p>
<pre class="literal-block">
import flit.api
backend = flit.api
</pre>
<p>Formally, the string should satisfy this grammar:</p>
<pre class="literal-block">
identifier = (letter | '_') (letter | '_' | digit)*
module_path = identifier ('.' identifier)*
object_path = identifier ('.' identifier)*
entry_point = module_path (':' object_path)?
</pre>
<p>And we import <tt class="docutils literal">module_path</tt> and then lookup
<tt class="docutils literal">module_path.object_path</tt> (or just <tt class="docutils literal">module_path</tt> if
<tt class="docutils literal">object_path</tt> is missing).</p>
<p>When importing the module path, we do <em>not</em> look in the directory containing the
source tree, unless that would be on <tt class="docutils literal">sys.path</tt> anyway (e.g. because it is
specified in PYTHONPATH). Although Python automatically adds the working
directory to <tt class="docutils literal">sys.path</tt> in some situations, code to resolve the backend should
not be affected by this.</p>
<p>If the <tt class="docutils literal">pyproject.toml</tt> file is absent, or the <tt class="docutils literal"><span class="pre">build-backend</span></tt>
key is missing, the source tree is not using this specification, and
tools should fall back to running <tt class="docutils literal">setup.py</tt>.</p>
<p>Where the <tt class="docutils literal"><span class="pre">build-backend</span></tt> key exists, it takes precedence over
<tt class="docutils literal">setup.py</tt>, and source trees need not include <tt class="docutils literal">setup.py</tt> at all.
Projects may still wish to include a <tt class="docutils literal">setup.py</tt> for compatibility
with tools that do not use this spec.</p>
</div>
<div class="section" id="build-backend-interface">
<h1><a class="toc-backref" href="#id6">Build backend interface</a></h1>
<p>The build backend object is expected to have attributes which provide
some or all of the following hooks. The common <tt class="docutils literal">config_settings</tt>
argument is described after the individual hooks.</p>
<div class="section" id="mandatory-hooks">
<h2><a class="toc-backref" href="#id7">Mandatory hooks</a></h2>
<div class="section" id="build-wheel">
<h3><a class="toc-backref" href="#id8">build_wheel</a></h3>
<pre class="literal-block">
build_wheel(wheel_directory, config_settings=None, metadata_directory=None):
    ...
</pre>
<p>Must build a .whl file, and place it in the specified <tt class="docutils literal">wheel_directory</tt>. It
must return the basename (not the full path) of the <tt class="docutils literal">.whl</tt> file it creates,
as a unicode string.</p>
<p>If the build frontend has previously called <tt class="docutils literal">prepare_metadata_for_build_wheel</tt>
and depends on the wheel resulting from this call to have metadata
matching this earlier call, then it should provide the path to the created
<tt class="docutils literal"><span class="pre">.dist-info</span></tt> directory as the <tt class="docutils literal">metadata_directory</tt> argument. If this
argument is provided, then <tt class="docutils literal">build_wheel</tt> MUST produce a wheel with identical
metadata. The directory passed in by the build frontend MUST be
identical to the directory created by <tt class="docutils literal">prepare_metadata_for_build_wheel</tt>,
including any unrecognized files it created.</p>
<p>Backends which do not provide the <tt class="docutils literal">prepare_metadata_for_build_wheel</tt> hook may
either silently ignore the <tt class="docutils literal">metadata_directory</tt> parameter to <tt class="docutils literal">build_wheel</tt>,
or else raise an exception when it is set to anything other than <tt class="docutils literal">None</tt>.</p>
<p>To ensure that wheels from different sources are built the same way, frontends
may call <tt class="docutils literal">build_sdist</tt> first, and then call <tt class="docutils literal">build_wheel</tt> in the unpacked
sdist. But if the backend indicates that it is missing some requirements for
creating an sdist (see below), the frontend will fall back to calling
<tt class="docutils literal">build_wheel</tt> in the source directory.</p>
<p>The source directory may be read-only. Backends should therefore be
prepared to build without creating or modifying any files in the source
directory, but they may opt not to handle this case, in which case
failures will be visible to the user. Frontends are not responsible for
any special handling of read-only source directories.</p>
<p>The backend may store intermediate artifacts in cache locations or
temporary directories. The presence or absence of any caches should not
make a material difference to the final result of the build.</p>
</div>
<div class="section" id="build-sdist">
<h3><a class="toc-backref" href="#id9">build_sdist</a></h3>
<pre class="literal-block">
def build_sdist(sdist_directory, config_settings=None):
    ...
</pre>
<p>Must build a .tar.gz source distribution and place it in the specified
<tt class="docutils literal">sdist_directory</tt>. It must return the basename (not the full path) of the
<tt class="docutils literal">.tar.gz</tt> file it creates, as a unicode string.</p>
<p>A .tar.gz source distribution (sdist) contains a single top-level directory called
<tt class="docutils literal"><span class="pre">{name}-{version}</span></tt> (e.g. <tt class="docutils literal"><span class="pre">foo-1.0</span></tt>), containing the source files of the
package. This directory must also contain the
<tt class="docutils literal">pyproject.toml</tt> from the build directory, and a PKG-INFO file containing
metadata in the format described in
<a class="reference external" href="https://www.python.org/dev/peps/pep-0345/">PEP 345</a>. Although historically
zip files have also been used as sdists, this hook should produce a gzipped
tarball. This is already the more common format for sdists, and having a
consistent format makes for simpler tooling.</p>
<p>The generated tarball should use the modern POSIX.1-2001 pax tar format, which
specifies UTF-8 based file names. This is not yet the default for the tarfile
module shipped with Python 3.6, so backends using the tarfile module need to
explicitly pass <tt class="docutils literal">format=tarfile.PAX_FORMAT</tt>.</p>
<p>Some backends may have extra requirements for creating sdists, such as version
control tools. However, some frontends may prefer to make intermediate sdists
when producing wheels, to ensure consistency.
If the backend cannot produce an sdist because a dependency is missing, or
for another well understood reason, it should raise an exception of a specific
type which it makes available as <tt class="docutils literal">UnsupportedOperation</tt> on the backend object.
If the frontend gets this exception while building an sdist as an intermediate
for a wheel, it should fall back to building a wheel directly.
The backend does not need to define this exception type if it would never raise
it.</p>
</div>
</div>
<div class="section" id="optional-hooks">
<h2><a class="toc-backref" href="#id10">Optional hooks</a></h2>
<div class="section" id="get-requires-for-build-wheel">
<h3><a class="toc-backref" href="#id11">get_requires_for_build_wheel</a></h3>
<pre class="literal-block">
def get_requires_for_build_wheel(config_settings=None):
    ...
</pre>
<p>This hook MUST return an additional list of strings containing <a class="reference external" href="/dev/peps/pep-0508">PEP 508</a>
dependency specifications, above and beyond those specified in the
<tt class="docutils literal">pyproject.toml</tt> file, to be installed when calling the <tt class="docutils literal">build_wheel</tt> or
<tt class="docutils literal">prepare_metadata_for_build_wheel</tt> hooks.</p>
<p>Example:</p>
<pre class="literal-block">
def get_requires_for_build_wheel(config_settings):
    return [&quot;wheel &gt;= 0.25&quot;, &quot;setuptools&quot;]
</pre>
<p>If not defined, the default implementation is equivalent to <tt class="docutils literal">return []</tt>.</p>
</div>
<div class="section" id="prepare-metadata-for-build-wheel">
<h3><a class="toc-backref" href="#id12">prepare_metadata_for_build_wheel</a></h3>
<pre class="literal-block">
def prepare_metadata_for_build_wheel(metadata_directory, config_settings=None):
    ...
</pre>
<p>Must create a <tt class="docutils literal"><span class="pre">.dist-info</span></tt> directory containing wheel metadata
inside the specified <tt class="docutils literal">metadata_directory</tt> (i.e., creates a directory
like <tt class="docutils literal"><span class="pre">{metadata_directory}/{package}-{version}.dist-info/</span></tt>). This
directory MUST be a valid <tt class="docutils literal"><span class="pre">.dist-info</span></tt> directory as defined in the
wheel specification, except that it need not contain <tt class="docutils literal">RECORD</tt> or
signatures. The hook MAY also create other files inside this
directory, and a build frontend MUST preserve, but otherwise ignore, such files;
the intention
here is that in cases where the metadata depends on build-time
decisions, the build backend may need to record these decisions in
some convenient format for re-use by the actual wheel-building step.</p>
<p>This must return the basename (not the full path) of the <tt class="docutils literal"><span class="pre">.dist-info</span></tt>
directory it creates, as a unicode string.</p>
<p>If a build frontend needs this information and the method is
not defined, it should call <tt class="docutils literal">build_wheel</tt> and look at the resulting
metadata directly.</p>
</div>
<div class="section" id="get-requires-for-build-sdist">
<h3><a class="toc-backref" href="#id13">get_requires_for_build_sdist</a></h3>
<pre class="literal-block">
def get_requires_for_build_sdist(config_settings=None):
  ...
</pre>
<p>This hook MUST return an additional list of strings containing <a class="reference external" href="/dev/peps/pep-0508">PEP 508</a>
dependency specifications, above and beyond those specified in the
<tt class="docutils literal">pyproject.toml</tt> file. These dependencies will be installed when calling the
<tt class="docutils literal">build_sdist</tt> hook.</p>
<p>If not defined, the default implementation is equivalent to <tt class="docutils literal">return []</tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Editable installs</p>
<p>This PEP originally specified another hook, <tt class="docutils literal">install_editable</tt>, to do an
editable install (as with <tt class="docutils literal">pip install <span class="pre">-e</span></tt>). It was removed due to the
complexity of the topic, but may be specified in a later PEP.</p>
<p class="last">Briefly, the questions to be answered include: what reasonable ways existing
of implementing an 'editable install'? Should the backend or the frontend
pick how to make an editable install? And if the frontend does, what does it
need from the backend to do so.</p>
</div>
</div>
</div>
<div class="section" id="config-settings">
<h2><a class="toc-backref" href="#id14">Config settings</a></h2>
<pre class="literal-block">
config_settings
</pre>
<p>This argument, which is passed to all hooks, is an arbitrary
dictionary provided as an &quot;escape hatch&quot; for users to pass ad-hoc
configuration into individual package builds. Build backends MAY
assign any semantics they like to this dictionary. Build frontends
SHOULD provide some mechanism for users to specify arbitrary
string-key/string-value pairs to be placed in this dictionary. For
example, they might support some syntax like <tt class="docutils literal"><span class="pre">--package-config</span>
CC=gcc</tt>. Build frontends MAY also provide arbitrary other mechanisms
for users to place entries in this dictionary. For example, <tt class="docutils literal">pip</tt>
might choose to map a mix of modern and legacy command line arguments
like:</p>
<pre class="literal-block">
pip install                                           \
  --package-config CC=gcc                             \
  --global-option=&quot;--some-global-option&quot;              \
  --build-option=&quot;--build-option1&quot;                    \
  --build-option=&quot;--build-option2&quot;
</pre>
<p>into a <tt class="docutils literal">config_settings</tt> dictionary like:</p>
<pre class="literal-block">
{
 &quot;CC&quot;: &quot;gcc&quot;,
 &quot;--global-option&quot;: [&quot;--some-global-option&quot;],
 &quot;--build-option&quot;: [&quot;--build-option1&quot;, &quot;--build-option2&quot;],
}
</pre>
<p>Of course, it's up to users to make sure that they pass options which
make sense for the particular build backend and package that they are
building.</p>
<p>The hooks may be called with positional or keyword arguments, so backends
implementing them should be careful to make sure that their signatures match
both the order and the names of the arguments above.</p>
<p>All hooks are run with working directory set to the root of the source
tree, and MAY print arbitrary informational text on stdout and
stderr. They MUST NOT read from stdin, and the build frontend MAY
close stdin before invoking the hooks.</p>
<p>The build frontend may capture stdout and/or stderr from the backend. If the
backend detects that an output stream is not a terminal/console (e.g.
<tt class="docutils literal">not sys.stdout.isatty()</tt>), it SHOULD ensure that any output it writes to that
stream is UTF-8 encoded. The build frontend MUST NOT fail if captured output is
not valid UTF-8, but it MAY not preserve all the information in that case (e.g.
it may decode using the <em>replace</em> error handler in Python). If the output stream
is a terminal, the build backend is responsible for presenting its output
accurately, as for any program running in a terminal.</p>
<p>If a hook raises an exception, or causes the process to terminate,
then this indicates an error.</p>
</div>
<div class="section" id="build-environment">
<h2><a class="toc-backref" href="#id15">Build environment</a></h2>
<p>One of the responsibilities of a build frontend is to set up the
Python environment in which the build backend will run.</p>
<p>We do not require that any particular &quot;virtual environment&quot; mechanism
be used; a build frontend might use virtualenv, or venv, or no special
mechanism at all. But whatever mechanism is used MUST meet the
following criteria:</p>
<ul>
<li><p class="first">All requirements specified by the project's build-requirements must
be available for import from Python. In particular:</p>
<ul class="simple">
<li>The <tt class="docutils literal">get_requires_for_build_wheel</tt> and <tt class="docutils literal">get_requires_for_build_sdist</tt> hooks are
executed in an environment which contains the bootstrap requirements
specified in the <tt class="docutils literal">pyproject.toml</tt> file.</li>
<li>The <tt class="docutils literal">prepare_metadata_for_build_wheel</tt> and <tt class="docutils literal">build_wheel</tt> hooks are
executed in an environment which contains the
bootstrap requirements from <tt class="docutils literal">pyproject.toml</tt> and those specified by the
<tt class="docutils literal">get_requires_for_build_wheel</tt> hook.</li>
<li>The <tt class="docutils literal">build_sdist</tt> hook is executed in an environment which contains the
bootstrap requirements from <tt class="docutils literal">pyproject.toml</tt> and those specified by the
<tt class="docutils literal">get_requires_for_build_sdist</tt> hook.</li>
</ul>
</li>
<li><p class="first">This must remain true even for new Python subprocesses spawned by
the build environment, e.g. code like:</p>
<pre class="literal-block">
import sys, subprocess
subprocess.check_call([sys.executable, ...])
</pre>
<p>must spawn a Python process which has access to all the project's
build-requirements. This is necessary e.g. for build backends that
want to run legacy <tt class="docutils literal">setup.py</tt> scripts in a subprocess.</p>
</li>
<li><p class="first">All command-line scripts provided by the build-required packages
must be present in the build environment's PATH. For example, if a
project declares a build-requirement on <a class="reference external" href="https://flit.readthedocs.org/en/latest/">flit</a>, then the following must
work as a mechanism for running the flit command-line tool:</p>
<pre class="literal-block">
import subprocess
subprocess.check_call([&quot;flit&quot;, ...])
</pre>
</li>
</ul>
<p>A build backend MUST be prepared to function in any environment which
meets the above criteria. In particular, it MUST NOT assume that it
has access to any packages except those that are present in the
stdlib, or that are explicitly declared as build-requirements.</p>
<p>Frontends should call each hook in a fresh subprocess, so that backends are
free to change process global state (such as environment variables or the
working directory). A Python library will be provided which frontends can use
to easily call hooks this way.</p>
<div class="section" id="recommendations-for-build-frontends-non-normative">
<h3><a class="toc-backref" href="#id16">Recommendations for build frontends (non-normative)</a></h3>
<p>A build frontend MAY use any mechanism for setting up a build
environment that meets the above criteria. For example, simply
installing all build-requirements into the global environment would be
sufficient to build any compliant package -- but this would be
sub-optimal for a number of reasons. This section contains
non-normative advice to frontend implementors.</p>
<p>A build frontend SHOULD, by default, create an isolated environment
for each build, containing only the standard library and any
explicitly requested build-dependencies. This has two benefits:</p>
<ul class="simple">
<li>It allows for a single installation run to build multiple packages
that have contradictory build-requirements. E.g. if package1
build-requires pbr==1.8.1, and package2 build-requires pbr==1.7.2,
then these cannot both be installed simultaneously into the global
environment -- which is a problem when the user requests <tt class="docutils literal">pip
install package1 package2</tt>. Or if the user already has pbr==1.8.1
installed in their global environment, and a package build-requires
pbr==1.7.2, then downgrading the user's version would be rather
rude.</li>
<li>It acts as a kind of public health measure to maximize the number of
packages that actually do declare accurate build-dependencies. We
can write all the strongly worded admonitions to package authors we
want, but if build frontends don't enforce isolation by default,
then we'll inevitably end up with lots of packages on PyPI that
build fine on the original author's machine and nowhere else, which
is a headache that no-one needs.</li>
</ul>
<p>However, there will also be situations where build-requirements are
problematic in various ways. For example, a package author might
accidentally leave off some crucial requirement despite our best
efforts; or, a package might declare a build-requirement on <tt class="docutils literal">foo &gt;=
1.0</tt> which worked great when 1.0 was the latest version, but now 1.1
is out and it has a showstopper bug; or, the user might decide to
build a package against numpy==1.7 -- overriding the package's
preferred numpy==1.8 -- to guarantee that the resulting build will be
compatible at the C ABI level with an older version of numpy (even if
this means the resulting build is unsupported upstream). Therefore,
build frontends SHOULD provide some mechanism for users to override
the above defaults. For example, a build frontend could have a
<tt class="docutils literal"><span class="pre">--build-with-system-site-packages</span></tt> option that causes the
<tt class="docutils literal"><span class="pre">--system-site-packages</span></tt> option to be passed to
virtualenv-or-equivalent when creating build environments, or a
<tt class="docutils literal"><span class="pre">--build-requirements-override=my-requirements.txt</span></tt> option that
overrides the project's normal build-requirements.</p>
<p>The general principle here is that we want to enforce hygiene on
package <em>authors</em>, while still allowing <em>end-users</em> to open up the
hood and apply duct tape when necessary.</p>
</div>
</div>
</div>
<div class="section" id="source-distributions">
<h1><a class="toc-backref" href="#id17">Source distributions</a></h1>
<p>We continue with the legacy sdist format, adding some new restrictions.
This format is mostly
undefined, but basically comes down to: a file named
<tt class="docutils literal"><span class="pre">{NAME}-{VERSION}.{EXT}</span></tt>, which unpacks into a buildable source tree
called <tt class="docutils literal"><span class="pre">{NAME}-{VERSION}/</span></tt>. Traditionally these have always
contained <tt class="docutils literal">setup.py</tt>-style source trees; we now allow them to also
contain <tt class="docutils literal">pyproject.toml</tt>-style source trees.</p>
<p>Integration frontends require that an sdist named
<tt class="docutils literal"><span class="pre">{NAME}-{VERSION}.{EXT}</span></tt> will generate a wheel named
<tt class="docutils literal"><span class="pre">{NAME}-{VERSION}-{COMPAT-INFO}.whl</span></tt>.</p>
<p>The new restrictions for sdists built by <a class="reference external" href="/dev/peps/pep-0517">PEP 517</a> backends are:</p>
<ul class="simple">
<li>They will be gzipped tar archives, with the <tt class="docutils literal">.tar.gz</tt> extension. Zip
archives, or other compression formats for tarballs, are not allowed at
present.</li>
<li>Tar archives must be created in the modern POSIX.1-2001 pax tar format, which
uses UTF-8 for file names.</li>
<li>The source tree contained in an sdist is expected to include the
<tt class="docutils literal">pyproject.toml</tt> file.</li>
</ul>
</div>
<div class="section" id="evolutionary-notes">
<h1><a class="toc-backref" href="#id18">Evolutionary notes</a></h1>
<p>A goal here is to make it as simple as possible to convert old-style
sdists to new-style sdists. (E.g., this is one motivation for
supporting dynamic build requirements.) The ideal would be that there
would be a single static <tt class="docutils literal">pyproject.toml</tt> that could be dropped into any
&quot;version 0&quot; VCS checkout to convert it to the new shiny. This is
probably not 100% possible, but we can get close, and it's important
to keep track of how close we are... hence this section.</p>
<p>A rough plan would be: Create a build system package
(<tt class="docutils literal">setuptools_pypackage</tt> or whatever) that knows how to speak
whatever hook language we come up with, and convert them into calls to
<tt class="docutils literal">setup.py</tt>. This will probably require some sort of hooking or
monkeypatching to setuptools to provide a way to extract the
<tt class="docutils literal">setup_requires=</tt> argument when needed, and to provide a new version
of the sdist command that generates the new-style format. This all
seems doable and sufficient for a large proportion of packages (though
obviously we'll want to prototype such a system before we finalize
anything here). (Alternatively, these changes could be made to
setuptools itself rather than going into a separate package.)</p>
<p>But there remain two obstacles that mean we probably won't be able to
automatically upgrade packages to the new format:</p>
<ol class="arabic simple">
<li>There currently exist packages which insist on particular packages
being available in their environment before setup.py is
executed. This means that if we decide to execute build scripts in
an isolated virtualenv-like environment, then projects will need to
check whether they do this, and if so then when upgrading to the
new system they will have to start explicitly declaring these
dependencies (either via <tt class="docutils literal">setup_requires=</tt> or via static
declaration in <tt class="docutils literal">pyproject.toml</tt>).</li>
<li>There currently exist packages which do not declare consistent
metadata (e.g. <tt class="docutils literal">egg_info</tt> and <tt class="docutils literal">bdist_wheel</tt> might get different
<tt class="docutils literal">install_requires=</tt>). When upgrading to the new system, projects
will have to evaluate whether this applies to them, and if so they
will need to stop doing that.</li>
</ol>
</div>
<div class="section" id="rejected-options">
<h1><a class="toc-backref" href="#id19">Rejected options</a></h1>
<ul class="simple">
<li>We discussed making the wheel and sdist hooks build unpacked directories
containing the same contents as their respective archives. In some cases this
could avoid the need to pack and unpack an archive, but this seems like
premature optimisation. It's advantageous for tools to work with archives
as the canonical interchange formats (especially for wheels, where the archive
format is already standardised). Close control of archive creation is
important for reproducible builds. And it's not clear that tasks requiring an
unpacked distribution will be more common than those requiring an archive.</li>
<li>We considered an extra hook to copy files to a build directory before invoking
<tt class="docutils literal">build_wheel</tt>. Looking at existing build systems, we found that passing
a build directory into <tt class="docutils literal">build_wheel</tt> made more sense for many tools than
pre-emptively copying files into a build directory.</li>
<li>The idea of passing <tt class="docutils literal">build_wheel</tt> a build directory was then also deemed an
unnecessary complication. Build tools can use a temporary directory or a cache
directory to store intermediate files while building. If there is a need, a
frontend-controlled cache directory could be added in the future.</li>
<li>For <tt class="docutils literal">build_sdist</tt> to signal a failure for an expected reason, various
options were debated at great length, including raising
<tt class="docutils literal">NotImplementedError</tt> and returning either <tt class="docutils literal">NotImplemented</tt> or <tt class="docutils literal">None</tt>.
Please do not attempt to reopen this discussion without an <em>extremely</em> good
reason, because we are quite tired of it.</li>
<li>Allowing the backend to be imported from files in the source tree would be
more consistent with the way Python imports often work. However, not allowing
this prevents confusing errors from clashing module names. Projects which
need to provide their own backend could use a special proxy backend which
loads the hooks from the source tree, so the flexibility is not lost.</li>
</ul>
</div>
<div class="section" id="appendix-a-comparison-to-pep-516">
<h1>Appendix A: Comparison to <a class="reference external" href="/dev/peps/pep-0516">PEP 516</a></h1>
<p><a class="reference external" href="/dev/peps/pep-0516">PEP 516</a> is a competing proposal to specify a build system interface, which
has now been rejected in favour of this PEP. The primary difference is
that our build backend is defined via a Python hook-based interface
rather than a command-line based interface.</p>
<p>This appendix documents the arguments advanced for this PEP over <a class="reference external" href="/dev/peps/pep-0516">PEP 516</a>.</p>
<p>We do <em>not</em> expect that specifying Python hooks rather than command line
interfaces will, by itself, reduce the
complexity of calling into the backend, because build frontends will
in any case want to run hooks inside a child -- this is important to
isolate the build frontend itself from the backend code and to better
control the build backends execution environment. So under both
proposals, there will need to be some code in <tt class="docutils literal">pip</tt> to spawn a
subprocess and talk to some kind of command-line/IPC interface, and
there will need to be some code in the subprocess that knows how to
parse these command line arguments and call the actual build backend
implementation. So this diagram applies to all proposals equally:</p>
<pre class="literal-block">
+-----------+          +---------------+           +----------------+
| frontend  | -spawn-&gt; | child cmdline | -Python-&gt; |    backend     |
|   (pip)   |          |   interface   |           | implementation |
+-----------+          +---------------+           +----------------+
</pre>
<p>The key difference between the two approaches is how these interface
boundaries map onto project structure:</p>
<pre class="literal-block">
.-= This PEP =-.

+-----------+          +---------------+    |      +----------------+
| frontend  | -spawn-&gt; | child cmdline | -Python-&gt; |    backend     |
|   (pip)   |          |   interface   |    |      | implementation |
+-----------+          +---------------+    |      +----------------+
                                            |
|______________________________________|    |
   Owned by pip, updated in lockstep        |
                                            |
                                            |
                                 PEP-defined interface boundary
                               Changes here require distutils-sig


.-= Alternative =-.

+-----------+    |     +---------------+           +----------------+
| frontend  | -spawn-&gt; | child cmdline | -Python-&gt; |    backend     |
|   (pip)   |    |     |   interface   |           | implementation |
+-----------+    |     +---------------+           +----------------+
                 |
                 |     |____________________________________________|
                 |      Owned by build backend, updated in lockstep
                 |
    PEP-defined interface boundary
  Changes here require distutils-sig
</pre>
<p>By moving the PEP-defined interface boundary into Python code, we gain
three key advantages.</p>
<p><strong>First</strong>, because there will likely be only a small number of build
frontends (<tt class="docutils literal">pip</tt>, and... maybe a few others?), while there will
likely be a long tail of custom build backends (since these are chosen
separately by each package to match their particular build
requirements), the actual diagrams probably look more like:</p>
<pre class="literal-block">
.-= This PEP =-.

+-----------+          +---------------+           +----------------+
| frontend  | -spawn-&gt; | child cmdline | -Python+&gt; |    backend     |
|   (pip)   |          |   interface   |        |  | implementation |
+-----------+          +---------------+        |  +----------------+
                                                |
                                                |  +----------------+
                                                +&gt; |    backend     |
                                                |  | implementation |
                                                |  +----------------+
                                                :
                                                :

.-= Alternative =-.

+-----------+          +---------------+           +----------------+
| frontend  | -spawn+&gt; | child cmdline | -Python-&gt; |    backend     |
|   (pip)   |       |  |   interface   |           | implementation |
+-----------+       |  +---------------+           +----------------+
                    |
                    |  +---------------+           +----------------+
                    +&gt; | child cmdline | -Python-&gt; |    backend     |
                    |  |   interface   |           | implementation |
                    |  +---------------+           +----------------+
                    :
                    :
</pre>
<p>That is, this PEP leads to less total code in the overall
ecosystem. And in particular, it reduces the barrier to entry of
making a new build system. For example, this is a complete, working
build backend:</p>
<pre class="literal-block">
# mypackage_custom_build_backend.py
import os.path
import pathlib
import shutil

SDIST_NAME = &quot;mypackage-0.1&quot;
SDIST_FILENAME = SDIST_NAME + &quot;.tar.gz&quot;
WHEEL_FILENAME = &quot;mypackage-0.1-py2.py3-none-any.whl&quot;

#################
# sdist creation
#################

def _exclude_hidden_and_special_files(archive_entry):
    &quot;&quot;&quot;Tarfile filter to exclude hidden and special files from the archive&quot;&quot;&quot;
    if entry.isfile() or entry.isdir():
        if not os.path.basename(archive_entry.name).startswith(&quot;.&quot;):
            return archive_entry
    return None

def _make_sdist(sdist_dir):
    &quot;&quot;&quot;Make an sdist and return both the Python object and its filename&quot;&quot;&quot;
    sdist_path = pathlib.Path(sdist_dir) / SDIST_FILENAME
    sdist = tarfile.open(sdist_path, &quot;w:gz&quot;, format=tarfile.PAX_FORMAT)
    # Tar up the whole directory, minus hidden and special files
    sdist.add(os.getcwd(), arcname=SDIST_NAME,
              filter=_exclude_hidden_and_special_files)
    return sdist, SDIST_FILENAME

def build_sdist(sdist_dir, config_settings):
    &quot;&quot;&quot;PEP 517 sdist creation hook&quot;&quot;&quot;
    sdist, sdist_filename = _make_sdist(sdist_dir)
    return sdist_filename

#################
# wheel creation
#################

def get_requires_for_build_wheel(config_settings):
    &quot;&quot;&quot;PEP 517 wheel building dependency definition hook&quot;&quot;&quot;
    # As a simple static requirement, this could also just be
    # listed in the project's build system dependencies instead
    return [&quot;wheel&quot;]

def build_wheel(wheel_directory,
                metadata_directory=None, config_settings=None):
    &quot;&quot;&quot;PEP 517 wheel creation hook&quot;&quot;&quot;
    from wheel.archive import archive_wheelfile
    path = os.path.join(wheel_directory, WHEEL_FILENAME)
    archive_wheelfile(path, &quot;src/&quot;)
    return WHEEL_FILENAME
</pre>
<p>Of course, this is a <em>terrible</em> build backend: it requires the user to
have manually set up the wheel metadata in
<tt class="docutils literal"><span class="pre">src/mypackage-0.1.dist-info/</span></tt>; when the version number changes it
must be manually updated in multiple places... but it works, and more features
could be added incrementally. Much experience suggests that large successful
projects often originate as quick hacks (e.g., Linux -- &quot;just a hobby,
won't be big and professional&quot;; <a class="reference external" href="https://en.wikipedia.org/wiki/IPython#Grants_and_awards">IPython/Jupyter</a> -- <cite>a grad
student's ` ``$PYTHONSTARTUP`</cite> file
&lt;<a class="reference external" href="http://blog.fperez.org/2012/01/ipython-notebook-historical.html">http://blog.fperez.org/2012/01/ipython-notebook-historical.html</a>&gt;`_),
so if our goal is to encourage the growth of a vibrant ecosystem of
good build tools, it's important to minimize the barrier to entry.</p>
<p><strong>Second</strong>, because Python provides a simpler yet richer structure for
describing interfaces, we remove unnecessary complexity from the
specification -- and specifications are the worst place for
complexity, because changing specifications requires painful
consensus-building across many stakeholders. In the command-line
interface approach, we have to come up with ad hoc ways to map
multiple different kinds of inputs into a single linear command line
(e.g. how do we avoid collisions between user-specified configuration
arguments and PEP-defined arguments? how do we specify optional
arguments? when working with a Python interface these questions have
simple, obvious answers). When spawning and managing subprocesses,
there are many fiddly details that must be gotten right, subtle
cross-platform differences, and some of the most obvious approaches --
e.g., using stdout to return data for the <tt class="docutils literal">build_requires</tt> operation
-- can create unexpected pitfalls (e.g., what happens when computing
the build requirements requires spawning some child processes, and
these children occasionally print an error message to stdout?
obviously a careful build backend author can avoid this problem, but
the most obvious way of defining a Python interface removes this
possibility entirely, because the hook return value is clearly
demarcated).</p>
<p>In general, the need to isolate build backends into their own process
means that we can't remove IPC complexity entirely -- but by placing
both sides of the IPC channel under the control of a single project,
we make it much cheaper to fix bugs in the IPC interface than if
fixing bugs requires coordinated agreement and coordinated changes
across the ecosystem.</p>
<p><strong>Third</strong>, and most crucially, the Python hook approach gives us much
more powerful options for evolving this specification in the future.</p>
<p>For concreteness, imagine that next year we add a new
<tt class="docutils literal">build_sdist_from_vcs</tt> hook, which provides an alternative to the current
<tt class="docutils literal">build_sdist</tt> hook where the frontend is responsible for passing
version control tracking metadata to backends (including indicating when all
on disk files are tracked), rather than individual backends having to query that
information themselves. In order to manage the transition, we'd want it to be
possible for build frontends to transparently use <tt class="docutils literal">build_sdist_from_vcs</tt> when
available and fall back onto <tt class="docutils literal">build_sdist</tt> otherwise; and we'd want it to be
possible for build backends to define both methods, for compatibility
with both old and new build frontends.</p>
<p>Furthermore, our mechanism should also fulfill two more goals: (a) If
new versions of e.g. <tt class="docutils literal">pip</tt> and <tt class="docutils literal">flit</tt> are both updated to support
the new interface, then this should be sufficient for it to be used;
in particular, it should <em>not</em> be necessary for every project that
<em>uses</em> <tt class="docutils literal">flit</tt> to update its individual <tt class="docutils literal">pyproject.toml</tt> file. (b)
We do not want to have to spawn extra processes just to perform this
negotiation, because process spawns can easily become a bottleneck when
deploying large multi-package stacks on some platforms (Windows).</p>
<p>In the interface described here, all of these goals are easy to
achieve. Because <tt class="docutils literal">pip</tt> controls the code that runs inside the child
process, it can easily write it to do something like:</p>
<pre class="literal-block">
command, backend, args = parse_command_line_args(...)
if command == &quot;build_sdist&quot;:
   if hasattr(backend, &quot;build_sdist_from_vcs&quot;):
       backend.build_sdist_from_vcs(...)
   elif hasattr(backend, &quot;build_sdist&quot;):
       backend.build_sdist(...)
   else:
       # error handling
</pre>
<p>In the alternative where the public interface boundary is placed at
the subprocess call, this is not possible -- either we need to spawn
an extra process just to query what interfaces are supported (as was
included in an earlier draft of <a class="reference external" href="/dev/peps/pep-0516">PEP 516</a>, an alternative to this), or
else we give up on autonegotiation entirely (as in the current version
of that PEP), meaning that any changes in the interface will require
N individual packages to update their <tt class="docutils literal">pyproject.toml</tt> files before
any change can go live, and that any changes will necessarily be
restricted to new releases.</p>
<p>One specific consequence of this is that in this PEP, we're able to
make the <tt class="docutils literal">prepare_metadata_for_build_wheel</tt> command optional. In our design,
this can be readily handled by build frontends, which can put code in
their subprocess runner like:</p>
<pre class="literal-block">
def dump_wheel_metadata(backend, working_dir):
    &quot;&quot;&quot;Dumps wheel metadata to working directory.

       Returns absolute path to resulting metadata directory
    &quot;&quot;&quot;
    if hasattr(backend, &quot;prepare_metadata_for_build_wheel&quot;):
        subdir = backend.prepare_metadata_for_build_wheel(working_dir)
    else:
        wheel_fname = backend.build_wheel(working_dir))
        already_built = os.path.join(working_dir, &quot;ALREADY_BUILT_WHEEL&quot;)
        with open(already_built, &quot;w&quot;) as f:
            f.write(wheel_fname)
        subdir = unzip_metadata(os.path.join(working_dir, wheel_fname))
    return os.path.join(working_dir, subdir)

def ensure_wheel_is_built(backend, output_dir, working_dir, metadata_dir):
    &quot;&quot;&quot;Ensures built wheel is available in output directory

       Returns absolute path to resulting wheel file
    &quot;&quot;&quot;
    already_built = os.path.join(working_dir, &quot;ALREADY_BUILT_WHEEL&quot;)
    if os.path.exists(already_built):
        with open(already_built, &quot;r&quot;) as f:
            wheel_fname = f.read().strip()
        working_path = os.path.join(working_dir, wheel_fname)
        final_path = os.path.join(output_dir, wheel_fname)
        os.rename(working_path, final_path)
        os.remove(already_built)
    else:
        wheel_fname = backend.build_wheel(output_dir, metadata_dir=metadata_dir)
    return os.path.join(output_dir, wheel_fname)
</pre>
<p>and thus expose a totally uniform interface to the rest of the frontend,
with no extra subprocess calls, no duplicated builds, etc. But
obviously this is the kind of code that you only want to write as part
of a private, within-project interface (e.g. the given example requires that
the working directory be shared between the two calls, but not with any
other wheel builds, and that the return value from the metadata helper function
will be passed back in to the wheel building one).</p>
<p>(And, of course, making the <tt class="docutils literal">metadata</tt> command optional is one piece
of lowering the barrier to entry for developing new backends, as discussed
above.)</p>
<div class="section" id="other-differences">
<h2><a class="toc-backref" href="#id21">Other differences</a></h2>
<p>Besides the key command line versus Python hook difference described
above, there are a few other differences in this proposal:</p>
<ul class="simple">
<li>Metadata command is optional (as described above).</li>
<li>We return metadata as a directory, rather than a single METADATA
file. This aligns better with the way that in practice wheel metadata
is distributed across multiple files (e.g. entry points), and gives us
more options in the future. (For example, instead of following the <a class="reference external" href="/dev/peps/pep-0426">PEP
426</a> proposal of switching the format of METADATA to JSON, we might
decide to keep the existing METADATA the way it is for backcompat,
while adding new extensions as JSON &quot;sidecar&quot; files inside the same
directory. Or maybe not; the point is it keeps our options more open.)</li>
<li>We provide a mechanism for passing information between the metadata
step and the wheel building step. I guess everyone probably will
agree this is a good idea?</li>
<li>We provide more detailed recommendations about the build environment,
but these aren't normative anyway.</li>
</ul>
</div>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id22">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

