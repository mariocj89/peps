<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">371</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Addition of the multiprocessing package to the standard library</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0371.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Jesse Noller &lt;jnoller&#32;&#97;t&#32;gmail.com&gt;,
Richard Oudkerk &lt;r.m.oudkerk&#32;&#97;t&#32;googlemail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">06-May-2008</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.6 / 3.0</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id15">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id16">Rationale</a></li>
<li><a class="reference internal" href="#the-distributed-problem" id="id17">The &quot;Distributed&quot; Problem</a></li>
<li><a class="reference internal" href="#performance-comparison" id="id18">Performance Comparison</a></li>
<li><a class="reference internal" href="#maintenance" id="id19">Maintenance</a></li>
<li><a class="reference internal" href="#api-naming" id="id20">API Naming</a></li>
<li><a class="reference internal" href="#timing-schedule" id="id21">Timing/Schedule</a></li>
<li><a class="reference internal" href="#open-issues" id="id22">Open Issues</a></li>
<li><a class="reference internal" href="#closed-issues" id="id23">Closed Issues</a></li>
<li><a class="reference internal" href="#references" id="id24">References</a></li>
<li><a class="reference internal" href="#copyright" id="id25">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id15">Abstract</a></h1>
<p>This PEP proposes the inclusion of the <tt class="docutils literal">pyProcessing</tt> <a class="footnote-reference" href="#id7" id="id1">[1]</a> package
into the Python standard library, renamed to &quot;multiprocessing&quot;.</p>
<p>The <tt class="docutils literal">processing</tt> package mimics the standard library <tt class="docutils literal">threading</tt>
module functionality to provide a process-based approach to
threaded programming allowing end-users to dispatch multiple
tasks that effectively side-step the global interpreter lock.</p>
<p>The package also provides server and client functionality
(<tt class="docutils literal">processing.Manager</tt>) to provide remote sharing and management of
objects and tasks so that applications may not only leverage
multiple cores on the local machine, but also distribute objects
and tasks across a cluster of networked machines.</p>
<p>While the distributed capabilities of the package are beneficial,
the primary focus of this PEP is the core threading-like API and
capabilities of the package.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id16">Rationale</a></h1>
<p>The current CPython interpreter implements the Global Interpreter
Lock (GIL) and barring work in Python 3000 or other versions
currently planned <a class="footnote-reference" href="#id8" id="id2">[2]</a>, the GIL will remain as-is within the
CPython interpreter for the foreseeable future.  While the GIL
itself enables clean and easy to maintain C code for the
interpreter and extensions base, it is frequently an issue for
those Python programmers who are leveraging multi-core machines.</p>
<p>The GIL itself prevents more than a single thread from running
within the interpreter at any given point in time, effectively
removing Python's ability to take advantage of multi-processor
systems.</p>
<p>The pyprocessing package offers a method to side-step the GIL
allowing applications within CPython to take advantage of
multi-core architectures without asking users to completely change
their programming paradigm (i.e.: dropping threaded programming
for another &quot;concurrent&quot; approach - Twisted, Actors, etc).</p>
<p>The Processing package offers CPython a &quot;known API&quot; which mirrors
albeit in a <a class="reference external" href="/dev/peps/pep-0008">PEP 8</a> compliant manner, that of the threading API,
with known semantics and easy scalability.</p>
<p>In the future, the package might not be as relevant should the
CPython interpreter enable &quot;true&quot; threading, however for some
applications, forking an OS process may sometimes be more
desirable than using lightweight threads, especially on those
platforms where process creation is fast and optimized.</p>
<p>For example, a simple threaded application:</p>
<pre class="literal-block">
from threading import Thread as worker

def afunc(number):
    print number * 3

t = worker(target=afunc, args=(4,))
t.start()
t.join()
</pre>
<p>The pyprocessing package mirrored the API so well, that with a
simple change of the import to:</p>
<pre class="literal-block">
from processing import process as worker
</pre>
<p>The code would now execute through the processing.process class.
Obviously, with the renaming of the API to <a class="reference external" href="/dev/peps/pep-0008">PEP 8</a> compliance there
would be additional renaming which would need to occur within
user applications, however minor.</p>
<p>This type of compatibility means that, with a minor (in most cases)
change in code, users' applications will be able to leverage all
cores and processors on a given machine for parallel execution.
In many cases the pyprocessing package is even faster than the
normal threading approach for I/O bound programs.  This of course,
takes into account that the pyprocessing package is in optimized C
code, while the threading module is not.</p>
</div>
<div class="section" id="the-distributed-problem">
<h1><a class="toc-backref" href="#id17">The &quot;Distributed&quot; Problem</a></h1>
<p>In the discussion on Python-Dev about the inclusion of this
package <a class="footnote-reference" href="#id9" id="id3">[3]</a> there was confusion about the intentions this PEP with
an attempt to solve the &quot;Distributed&quot; problem - frequently
comparing the functionality of this package with other solutions
like MPI-based communication <a class="footnote-reference" href="#id10" id="id4">[4]</a>, CORBA, or other distributed
object approaches <a class="footnote-reference" href="#id11" id="id5">[5]</a>.</p>
<p>The &quot;distributed&quot; problem is large and varied.  Each programmer
working within this domain has either very strong opinions about
their favorite module/method or a highly customized problem for
which no existing solution works.</p>
<p>The acceptance of this package does not preclude or recommend that
programmers working on the &quot;distributed&quot; problem not examine other
solutions for their problem domain.  The intent of including this
package is to provide entry-level capabilities for local
concurrency and the basic support to spread that concurrency
across a network of machines - although the two are not tightly
coupled, the pyprocessing package could in fact, be used in
conjunction with any of the other solutions including MPI/etc.</p>
<p>If necessary - it is possible to completely decouple the local
concurrency abilities of the package from the
network-capable/shared aspects of the package.  Without serious
concerns or cause however, the author of this PEP does not
recommend that approach.</p>
</div>
<div class="section" id="performance-comparison">
<h1><a class="toc-backref" href="#id18">Performance Comparison</a></h1>
<p>As we all know - there are &quot;lies, damned lies, and benchmarks&quot;.
These speed comparisons, while aimed at showcasing the performance
of the pyprocessing package, are by no means comprehensive or
applicable to all possible use cases or environments.  Especially
for those platforms with sluggish process forking timing.</p>
<p>All benchmarks were run using the following:</p>
<ul class="simple">
<li>4 Core Intel Xeon CPU &#64; 3.00GHz</li>
<li>16 GB of RAM</li>
<li>Python 2.5.2 compiled on Gentoo Linux (kernel 2.6.18.6)</li>
<li>pyProcessing 0.52</li>
</ul>
<p>All of the code for this can be downloaded from
<a class="reference external" href="http://jessenoller.com/code/bench-src.tgz">http://jessenoller.com/code/bench-src.tgz</a></p>
<p>The basic method of execution for these benchmarks is in the
run_benchmarks.py script, which is simply a wrapper to execute a
target function through a single threaded (linear), multi-threaded
(via threading), and multi-process (via pyprocessing) function for
a static number of iterations with increasing numbers of execution
loops and/or threads.</p>
<p>The run_benchmarks.py script executes each function 100 times,
picking the best run of that 100 iterations via the timeit module.</p>
<p>First, to identify the overhead of the spawning of the workers, we
execute a function which is simply a pass statement (empty):</p>
<pre class="literal-block">
cmd: python run_benchmarks.py empty_func.py
Importing empty_func
Starting tests ...
non_threaded (1 iters)  0.000001 seconds
threaded (1 threads)    0.000796 seconds
processes (1 procs)     0.000714 seconds

non_threaded (2 iters)  0.000002 seconds
threaded (2 threads)    0.001963 seconds
processes (2 procs)     0.001466 seconds

non_threaded (4 iters)  0.000002 seconds
threaded (4 threads)    0.003986 seconds
processes (4 procs)     0.002701 seconds

non_threaded (8 iters)  0.000003 seconds
threaded (8 threads)    0.007990 seconds
processes (8 procs)     0.005512 seconds
</pre>
<p>As you can see, process forking via the pyprocessing package is
faster than the speed of building and then executing the threaded
version of the code.</p>
<p>The second test calculates 50000 Fibonacci numbers inside of each
thread (isolated and shared nothing):</p>
<pre class="literal-block">
cmd: python run_benchmarks.py fibonacci.py
Importing fibonacci
Starting tests ...
non_threaded (1 iters)  0.195548 seconds
threaded (1 threads)    0.197909 seconds
processes (1 procs)     0.201175 seconds

non_threaded (2 iters)  0.397540 seconds
threaded (2 threads)    0.397637 seconds
processes (2 procs)     0.204265 seconds

non_threaded (4 iters)  0.795333 seconds
threaded (4 threads)    0.797262 seconds
processes (4 procs)     0.206990 seconds

non_threaded (8 iters)  1.591680 seconds
threaded (8 threads)    1.596824 seconds
processes (8 procs)     0.417899 seconds
</pre>
<p>The third test calculates the sum of all primes below 100000,
again sharing nothing:</p>
<pre class="literal-block">
cmd: run_benchmarks.py crunch_primes.py
Importing crunch_primes
Starting tests ...
non_threaded (1 iters)  0.495157 seconds
threaded (1 threads)    0.522320 seconds
processes (1 procs)     0.523757 seconds

non_threaded (2 iters)  1.052048 seconds
threaded (2 threads)    1.154726 seconds
processes (2 procs)     0.524603 seconds

non_threaded (4 iters)  2.104733 seconds
threaded (4 threads)    2.455215 seconds
processes (4 procs)     0.530688 seconds

non_threaded (8 iters)  4.217455 seconds
threaded (8 threads)    5.109192 seconds
processes (8 procs)     1.077939 seconds
</pre>
<p>The reason why tests two and three focused on pure numeric
crunching is to showcase how the current threading implementation
does hinder non-I/O applications.  Obviously, these tests could be
improved to use a queue for coordination of results and chunks of
work but that is not required to show the performance of the
package and core processing.process module.</p>
<p>The next test is an I/O bound test.  This is normally where we see
a steep improvement in the threading module approach versus a
single-threaded approach.  In this case, each worker is opening a
descriptor to lorem.txt, randomly seeking within it and writing
lines to /dev/null:</p>
<pre class="literal-block">
cmd: python run_benchmarks.py file_io.py
Importing file_io
Starting tests ...
non_threaded (1 iters)  0.057750 seconds
threaded (1 threads)    0.089992 seconds
processes (1 procs)     0.090817 seconds

non_threaded (2 iters)  0.180256 seconds
threaded (2 threads)    0.329961 seconds
processes (2 procs)     0.096683 seconds

non_threaded (4 iters)  0.370841 seconds
threaded (4 threads)    1.103678 seconds
processes (4 procs)     0.101535 seconds

non_threaded (8 iters)  0.749571 seconds
threaded (8 threads)    2.437204 seconds
processes (8 procs)     0.203438 seconds
</pre>
<p>As you can see, pyprocessing is still faster on this I/O operation
than using multiple threads.  And using multiple threads is slower
than the single threaded execution itself.</p>
<p>Finally, we will run a socket-based test to show network I/O
performance.  This function grabs a URL from a server on the LAN
that is a simple error page from tomcat.  It gets the page 100
times.  The network is silent, and a 10G connection:</p>
<pre class="literal-block">
cmd: python run_benchmarks.py url_get.py
Importing url_get
Starting tests ...
non_threaded (1 iters)  0.124774 seconds
threaded (1 threads)    0.120478 seconds
processes (1 procs)     0.121404 seconds

non_threaded (2 iters)  0.239574 seconds
threaded (2 threads)    0.146138 seconds
processes (2 procs)     0.138366 seconds

non_threaded (4 iters)  0.479159 seconds
threaded (4 threads)    0.200985 seconds
processes (4 procs)     0.188847 seconds

non_threaded (8 iters)  0.960621 seconds
threaded (8 threads)    0.659298 seconds
processes (8 procs)     0.298625 seconds
</pre>
<p>We finally see threaded performance surpass that of
single-threaded execution, but the pyprocessing package is still
faster when increasing the number of workers.  If you stay with
one or two threads/workers, then the timing between threads and
pyprocessing is fairly close.</p>
<p>One item of note however, is that there is an implicit overhead
within the pyprocessing package's <tt class="docutils literal">Queue</tt> implementation due to the
object serialization.</p>
<p>Alec Thomas provided a short example based on the
run_benchmarks.py script to demonstrate this overhead versus the
default <tt class="docutils literal">Queue</tt> implementation:</p>
<pre class="literal-block">
cmd: run_bench_queue.py
non_threaded (1 iters)  0.010546 seconds
threaded (1 threads)    0.015164 seconds
processes (1 procs)     0.066167 seconds

non_threaded (2 iters)  0.020768 seconds
threaded (2 threads)    0.041635 seconds
processes (2 procs)     0.084270 seconds

non_threaded (4 iters)  0.041718 seconds
threaded (4 threads)    0.086394 seconds
processes (4 procs)     0.144176 seconds

non_threaded (8 iters)  0.083488 seconds
threaded (8 threads)    0.184254 seconds
processes (8 procs)     0.302999 seconds
</pre>
<p>Additional benchmarks can be found in the pyprocessing package's
source distribution's examples/ directory.  The examples will be
included in the package's documentation.</p>
</div>
<div class="section" id="maintenance">
<h1><a class="toc-backref" href="#id19">Maintenance</a></h1>
<p>Richard M. Oudkerk - the author of the pyprocessing package has
agreed to maintain the package within Python SVN.  Jesse Noller
has volunteered to also help maintain/document and test the
package.</p>
</div>
<div class="section" id="api-naming">
<h1><a class="toc-backref" href="#id20">API Naming</a></h1>
<p>While the aim of the package's API is designed to closely mimic that of
the threading and <tt class="docutils literal">Queue</tt> modules as of python 2.x, those modules are not
<a class="reference external" href="/dev/peps/pep-0008">PEP 8</a> compliant. It has been decided that instead of adding the package
&quot;as is&quot; and therefore perpetuating the non-<a class="reference external" href="/dev/peps/pep-0008">PEP 8</a> compliant naming, we
will rename all APIs, classes, etc to be fully <a class="reference external" href="/dev/peps/pep-0008">PEP 8</a> compliant.</p>
<p>This change does affect the ease-of-drop in replacement for those using
the threading module, but that is an acceptable side-effect in the view
of the authors, especially given that the threading module's own API
will change.</p>
<p>Issue 3042 in the tracker proposes that for Python 2.6 there will be
two APIs for the threading module - the current one, and the <a class="reference external" href="/dev/peps/pep-0008">PEP 8</a>
compliant one. Warnings about the upcoming removal of the original
java-style API will be issued when -3 is invoked.</p>
<p>In Python 3000, the threading API will become <a class="reference external" href="/dev/peps/pep-0008">PEP 8</a> compliant, which
means that the multiprocessing module and the threading module will
again have matching APIs.</p>
</div>
<div class="section" id="timing-schedule">
<h1><a class="toc-backref" href="#id21">Timing/Schedule</a></h1>
<p>Some concerns have been raised about the timing/lateness of this
PEP for the 2.6 and 3.0 releases this year, however it is felt by
both the authors and others that the functionality this package
offers surpasses the risk of inclusion.</p>
<p>However, taking into account the desire not to destabilize
Python-core, some refactoring of pyprocessing's code &quot;into&quot;
Python-core can be withheld until the next 2.x/3.x releases.  This
means that the actual risk to Python-core is minimal, and largely
constrained to the actual package itself.</p>
</div>
<div class="section" id="open-issues">
<h1><a class="toc-backref" href="#id22">Open Issues</a></h1>
<ul class="simple">
<li>Confirm no &quot;default&quot; remote connection capabilities, if needed
enable the remote security mechanisms by default for those
classes which offer remote capabilities.</li>
<li>Some of the API (<tt class="docutils literal">Queue</tt> methods <tt class="docutils literal">qsize()</tt>, <tt class="docutils literal">task_done()</tt> and <tt class="docutils literal">join()</tt>)
either need to be added, or the reason for their exclusion needs
to be identified and documented clearly.</li>
</ul>
</div>
<div class="section" id="closed-issues">
<h1><a class="toc-backref" href="#id23">Closed Issues</a></h1>
<ul class="simple">
<li>The <tt class="docutils literal">PyGILState</tt> bug patch submitted in issue 1683 by roudkerk
must be applied for the package unit tests to work.</li>
<li>Existing documentation has to be moved to ReST formatting.</li>
<li>Reliance on ctypes: The <tt class="docutils literal">pyprocessing</tt> package's reliance on
ctypes prevents the package from functioning on platforms where
ctypes is not supported.  This is not a restriction of this
package, but rather of ctypes.</li>
<li>DONE: Rename top-level package from &quot;pyprocessing&quot; to
&quot;multiprocessing&quot;.</li>
<li>DONE: Also note that the default behavior of process spawning
does not make it compatible with use within IDLE as-is, this
will be examined as a bug-fix or &quot;setExecutable&quot; enhancement.</li>
<li>DONE: Add in &quot;multiprocessing.setExecutable()&quot; method to override the
default behavior of the package to spawn processes using the
current executable name rather than the Python interpreter.  Note
that Mark Hammond has suggested a factory-style interface for
this <a class="footnote-reference" href="#id13" id="id6">[7]</a>.</li>
</ul>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id24">References</a></h1>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>PyProcessing home page
<a class="reference external" href="http://pyprocessing.berlios.de/">http://pyprocessing.berlios.de/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>See Adam Olsen's &quot;safe threading&quot; project
<a class="reference external" href="http://code.google.com/p/python-safethread/">http://code.google.com/p/python-safethread/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>See: Addition of &quot;pyprocessing&quot; module to standard lib.
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2008-May/079417.html">https://mail.python.org/pipermail/python-dev/2008-May/079417.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td><a class="reference external" href="http://mpi4py.scipy.org/">http://mpi4py.scipy.org/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>See &quot;Cluster Computing&quot;
<a class="reference external" href="http://wiki.python.org/moin/ParallelProcessing">http://wiki.python.org/moin/ParallelProcessing</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[6]</td><td>The original run_benchmark.py code was published in Python
Magazine in December 2007: &quot;Python Threads and the Global
Interpreter Lock&quot; by Jesse Noller.  It has been modified for
this PEP.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[7]</a></td><td><a class="reference external" href="http://groups.google.com/group/python-dev2/msg/54cf06d15cbcbc34">http://groups.google.com/group/python-dev2/msg/54cf06d15cbcbc34</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[8]</td><td>Addition Python-Dev discussion
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2008-June/080011.html">https://mail.python.org/pipermail/python-dev/2008-June/080011.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id25">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

