<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">284</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Integer for-loops</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0284.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">David Eppstein &lt;eppstein&#32;&#97;t&#32;ics.uci.edu&gt;,
Greg Ewing &lt;greg.ewing&#32;&#97;t&#32;canterbury.ac.nz&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">1-Mar-2002</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.3</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id12">Abstract</a></li>
<li><a class="reference internal" href="#pronouncement" id="id13">Pronouncement</a></li>
<li><a class="reference internal" href="#rationale" id="id14">Rationale</a></li>
<li><a class="reference internal" href="#specification" id="id15">Specification</a></li>
<li><a class="reference internal" href="#issues" id="id16">Issues</a></li>
<li><a class="reference internal" href="#implementation" id="id17">Implementation</a></li>
<li><a class="reference internal" href="#references" id="id18">References</a></li>
<li><a class="reference internal" href="#copyright" id="id19">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id12">Abstract</a></h1>
<p>This PEP proposes to simplify iteration over intervals of
integers, by extending the range of expressions allowed after a
&quot;for&quot; keyword to allow three-way comparisons such as</p>
<pre class="literal-block">
for lower &lt;= var &lt; upper:
</pre>
<p>in place of the current</p>
<pre class="literal-block">
for item in list:
</pre>
<p>syntax.  The resulting loop or list iteration will loop over all
values of var that make the comparison true, starting from the
left endpoint of the given interval.</p>
</div>
<div class="section" id="pronouncement">
<h1><a class="toc-backref" href="#id13">Pronouncement</a></h1>
<p>This PEP is rejected.  There were a number of fixable issues with
the proposal (see the fixups listed in Raymond Hettinger's
python-dev post on 18 June 2005 <a class="footnote-reference" href="#id11" id="id1">[5]</a>).  However, even with the fixups the
proposal did not garner support.  Specifically, Guido did not buy
the premise that the <tt class="docutils literal">range()</tt> format needed fixing, &quot;The whole point
(15 years ago) of <tt class="docutils literal">range()</tt> was to <em>avoid</em> needing syntax to specify a
loop over numbers. I think it's worked out well and there's nothing
that needs to be fixed (except <tt class="docutils literal">range()</tt> needs to become an iterator,
which it will in Python 3.0).&quot;</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id14">Rationale</a></h1>
<p>One of the most common uses of for-loops in Python is to iterate
over an interval of integers.  Python provides functions <tt class="docutils literal">range()</tt>
and <tt class="docutils literal">xrange()</tt> to generate lists and iterators for such intervals,
which work best for the most frequent case: half-open intervals
increasing from zero.  However, the <tt class="docutils literal">range()</tt> syntax is more awkward
for open or closed intervals, and lacks symmetry when reversing
the order of iteration.  In addition, the call to an unfamiliar
function makes it difficult for newcomers to Python to understand
code that uses <tt class="docutils literal">range()</tt> or <tt class="docutils literal">xrange()</tt>.</p>
<p>The perceived lack of a natural, intuitive integer iteration
syntax has led to heated debate on python-list, and spawned at
least four PEPs before this one.  <a class="reference external" href="/dev/peps/pep-0204">PEP 204</a> <a class="footnote-reference" href="#id7" id="id2">[1]</a> (rejected) proposed
to re-use Python's slice syntax for integer ranges, leading to a
terser syntax but not solving the readability problem of
multi-argument <tt class="docutils literal">range()</tt>.  <a class="reference external" href="/dev/peps/pep-0212">PEP 212</a> <a class="footnote-reference" href="#id8" id="id3">[2]</a> (deferred) proposed several
syntaxes for directly converting a list to a sequence of integer
indices, in place of the current idiom</p>
<pre class="literal-block">
range(len(list))
</pre>
<p>for such conversion, and <a class="reference external" href="/dev/peps/pep-0281">PEP 281</a> <a class="footnote-reference" href="#id9" id="id4">[3]</a> proposes to simplify the same
idiom by allowing it to be written as</p>
<pre class="literal-block">
range(list).
</pre>
<p><a class="reference external" href="/dev/peps/pep-0276">PEP 276</a> <a class="footnote-reference" href="#id10" id="id5">[4]</a> proposes to allow automatic conversion of integers to
iterators, simplifying the most common half-open case but not
addressing the complexities of other types of interval.
Additional alternatives have been discussed on python-list.</p>
<p>The solution described here is to allow a three-way comparison
after a &quot;for&quot; keyword, both in the context of a for-loop and of a
list comprehension:</p>
<pre class="literal-block">
for lower &lt;= var &lt; upper:
</pre>
<p>This would cause iteration over an interval of consecutive
integers, beginning at the left bound in the comparison and ending
at the right bound.  The exact comparison operations used would
determine whether the interval is open or closed at either end and
whether the integers are considered in ascending or descending
order.</p>
<p>This syntax closely matches standard mathematical notation, so is
likely to be more familiar to Python novices than the current
<tt class="docutils literal">range()</tt> syntax.  Open and closed interval endpoints are equally
easy to express, and the reversal of an integer interval can be
formed simply by swapping the two endpoints and reversing the
comparisons.  In addition, the semantics of such a loop would
closely resemble one way of interpreting the existing Python
for-loops:</p>
<pre class="literal-block">
for item in list
</pre>
<p>iterates over exactly those values of item that cause the
expression</p>
<pre class="literal-block">
item in list
</pre>
<p>to be true.  Similarly, the new format</p>
<pre class="literal-block">
for lower &lt;= var &lt; upper:
</pre>
<p>would iterate over exactly those integer values of var that cause
the expression</p>
<pre class="literal-block">
lower &lt;= var &lt; upper
</pre>
<p>to be true.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id15">Specification</a></h1>
<p>We propose to extend the syntax of a for statement, currently</p>
<pre class="literal-block">
for_stmt: &quot;for&quot; target_list &quot;in&quot; expression_list &quot;:&quot; suite
      [&quot;else&quot; &quot;:&quot; suite]
</pre>
<p>as described below:</p>
<pre class="literal-block">
for_stmt: &quot;for&quot; for_test &quot;:&quot; suite [&quot;else&quot; &quot;:&quot; suite]
for_test: target_list &quot;in&quot; expression_list |
        or_expr less_comp or_expr less_comp or_expr |
        or_expr greater_comp or_expr greater_comp or_expr
less_comp: &quot;&lt;&quot; | &quot;&lt;=&quot;
greater_comp: &quot;&gt;&quot; | &quot;&gt;=&quot;
</pre>
<p>Similarly, we propose to extend the syntax of list comprehensions,
currently</p>
<pre class="literal-block">
list_for: &quot;for&quot; expression_list &quot;in&quot; testlist [list_iter]
</pre>
<p>by replacing it with:</p>
<pre class="literal-block">
list_for: &quot;for&quot; for_test [list_iter]
</pre>
<p>In all cases the expression formed by for_test would be subject to
the same precedence rules as comparisons in expressions.  The two
comp_operators in a for_test must be required to be both of
similar types, unlike chained comparisons in expressions which do
not have such a restriction.</p>
<p>We refer to the two or_expr's occurring on the left and right
sides of the for-loop syntax as the bounds of the loop, and the
middle or_expr as the variable of the loop.  When a for-loop using
the new syntax is executed, the expressions for both bounds will
be evaluated, and an iterator object created that iterates through
all integers between the two bounds according to the comparison
operations used.  The iterator will begin with an integer equal or
near to the left bound, and then step through the remaining
integers with a step size of +1 or -1 if the comparison operation
is in the set described by less_comp or greater_comp respectively.
The execution will then proceed as if the expression had been</p>
<pre class="literal-block">
for variable in iterator
</pre>
<p>where &quot;variable&quot; refers to the variable of the loop and &quot;iterator&quot;
refers to the iterator created for the given integer interval.</p>
<p>The values taken by the loop variable in an integer for-loop may
be either plain integers or long integers, according to the
magnitude of the bounds.  Both bounds of an integer for-loop must
evaluate to a real numeric type (integer, long, or float).  Any
other value will cause the for-loop statement to raise a <tt class="docutils literal">TypeError</tt>
exception.</p>
</div>
<div class="section" id="issues">
<h1><a class="toc-backref" href="#id16">Issues</a></h1>
<p>The following issues were raised in discussion of this and related
proposals on the Python list.</p>
<ul>
<li><p class="first">Should the right bound be evaluated once, or every time through
the loop?  Clearly, it only makes sense to evaluate the left
bound once.  For reasons of consistency and efficiency, we have
chosen the same convention for the right bound.</p>
</li>
<li><p class="first">Although the new syntax considerably simplifies integer
for-loops, list comprehensions using the new syntax are not as
simple.  We feel that this is appropriate since for-loops are
more frequent than comprehensions.</p>
</li>
<li><p class="first">The proposal does not allow access to integer iterator objects
such as would be created by <tt class="docutils literal">xrange</tt>.  True, but we see this as a
shortcoming in the general list-comprehension syntax, beyond the
scope of this proposal.  In addition, <tt class="docutils literal">xrange()</tt> will still be
available.</p>
</li>
<li><p class="first">The proposal does not allow increments other than 1 and -1.
More general arithmetic progressions would need to be created by
<tt class="docutils literal">range()</tt> or <tt class="docutils literal">xrange()</tt>, or by a list comprehension syntax such as</p>
<pre class="literal-block">
[2*x for 0 &lt;= x &lt;= 100]
</pre>
</li>
<li><p class="first">The position of the loop variable in the middle of a three-way
comparison is not as apparent as the variable in the present</p>
<pre class="literal-block">
for item in list
</pre>
<p>syntax, leading to a possible loss of readability.  We feel that
this loss is outweighed by the increase in readability from a
natural integer iteration syntax.</p>
</li>
<li><p class="first">To some extent, this PEP addresses the same issues as <a class="reference external" href="/dev/peps/pep-0276">PEP 276</a>
<a class="footnote-reference" href="#id10" id="id6">[4]</a>.  We feel that the two PEPs are not in conflict since <a class="reference external" href="/dev/peps/pep-0276">PEP
276</a> is primarily concerned with half-open ranges starting in 0
(the easy case of <tt class="docutils literal">range()</tt>) while this PEP is primarily concerned
with simplifying all other cases.  However, if this PEP is
approved, its new simpler syntax for integer loops could to some
extent reduce the motivation for <a class="reference external" href="/dev/peps/pep-0276">PEP 276</a>.</p>
</li>
<li><p class="first">It is not clear whether it makes sense to allow floating point
bounds for an integer loop: if a float represents an inexact
value, how can it be used to determine an exact sequence of
integers?  On the other hand, disallowing float bounds would
make it difficult to use <tt class="docutils literal">floor()</tt> and <tt class="docutils literal">ceiling()</tt> in integer
for-loops, as it is difficult to use them now with <tt class="docutils literal">range()</tt>.  We
have erred on the side of flexibility, but this may lead to some
implementation difficulties in determining the smallest and
largest integer values that would cause a given comparison to be
true.</p>
</li>
<li><p class="first">Should types other than int, long, and float be allowed as
bounds?  Another choice would be to convert all bounds to
integers by <tt class="docutils literal">int()</tt>, and allow as bounds anything that can be so
converted instead of just floats.  However, this would change
the semantics: <tt class="docutils literal">0.3 &lt;= x</tt> is not the same as <tt class="docutils literal">int(0.3) &lt;= x</tt>, and it
would be confusing for a loop with 0.3 as lower bound to start
at zero.  Also, in general <tt class="docutils literal">int(f)</tt> can be very far from <tt class="docutils literal">f</tt>.</p>
</li>
</ul>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id17">Implementation</a></h1>
<p>An implementation is not available at this time.  Implementation
is not expected to pose any great difficulties: the new syntax
could, if necessary, be recognized by parsing a general expression
after each &quot;for&quot; keyword and testing whether the top level
operation of the expression is &quot;in&quot; or a three-way comparison.
The Python compiler would convert any instance of the new syntax
into a loop over the items in a special iterator object.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id18">References</a></h1>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td><a class="reference external" href="/dev/peps/pep-0204">PEP 204</a>, Range Literals
<a class="reference external" href="http://www.python.org/dev/peps/pep-0204/">http://www.python.org/dev/peps/pep-0204/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td><a class="reference external" href="/dev/peps/pep-0212">PEP 212</a>, Loop Counter Iteration
<a class="reference external" href="http://www.python.org/dev/peps/pep-0212/">http://www.python.org/dev/peps/pep-0212/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td><a class="reference external" href="/dev/peps/pep-0281">PEP 281</a>, Loop Counter Iteration with range and xrange
<a class="reference external" href="http://www.python.org/dev/peps/pep-0281/">http://www.python.org/dev/peps/pep-0281/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td><em>(<a class="fn-backref" href="#id5">1</a>, <a class="fn-backref" href="#id6">2</a>)</em> <a class="reference external" href="/dev/peps/pep-0276">PEP 276</a>, Simple Iterator for ints
<a class="reference external" href="http://www.python.org/dev/peps/pep-0276/">http://www.python.org/dev/peps/pep-0276/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[5]</a></td><td>Raymond Hettinger, Propose updating <a class="reference external" href="/dev/peps/pep-0284">PEP 284</a> -- Integer for-loops
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2005-June/054316.html">https://mail.python.org/pipermail/python-dev/2005-June/054316.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id19">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
fill-column: 70
End: -->
</div>

