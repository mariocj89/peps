<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">487</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Simpler customisation of class creation</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0487.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Martin Teichmann &lt;lkb.teichmann&#32;&#97;t&#32;gmail.com&gt;,</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">27-Feb-2015</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.6</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">27-Feb-2015, 5-Feb-2016, 24-Jun-2016, 2-Jul-2016, 13-Jul-2016</td>
</tr>
<tr class="field"><th class="field-name">Replaces:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0422">422</a></td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2016-July/145629.html">https://mail.python.org/pipermail/python-dev/2016-July/145629.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id5">Abstract</a></li>
<li><a class="reference internal" href="#background" id="id6">Background</a></li>
<li><a class="reference internal" href="#proposal" id="id7">Proposal</a></li>
<li><a class="reference internal" href="#key-benefits" id="id8">Key Benefits</a><ul>
<li><a class="reference internal" href="#easier-inheritance-of-definition-time-behaviour" id="id9">Easier inheritance of definition time behaviour</a></li>
<li><a class="reference internal" href="#reduced-chance-of-metaclass-conflicts" id="id10">Reduced chance of metaclass conflicts</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-ways-of-using-classes" id="id11">New Ways of Using Classes</a><ul>
<li><a class="reference internal" href="#subclass-registration" id="id12">Subclass registration</a></li>
<li><a class="reference internal" href="#trait-descriptors" id="id13">Trait descriptors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-details" id="id14">Implementation Details</a></li>
<li><a class="reference internal" href="#reference-implementation" id="id15">Reference Implementation</a></li>
<li><a class="reference internal" href="#backward-compatibility-issues" id="id16">Backward compatibility issues</a></li>
<li><a class="reference internal" href="#rejected-design-options" id="id17">Rejected Design Options</a><ul>
<li><a class="reference internal" href="#calling-the-hook-on-the-class-itself" id="id18">Calling the hook on the class itself</a></li>
<li><a class="reference internal" href="#other-variants-of-calling-the-hooks" id="id19">Other variants of calling the hooks</a></li>
<li><a class="reference internal" href="#requiring-an-explicit-decorator-on-init-subclass" id="id20">Requiring an explicit decorator on <tt class="docutils literal">__init_subclass__</tt></a></li>
<li><a class="reference internal" href="#a-more-new-like-hook" id="id21">A more <tt class="docutils literal">__new__</tt>-like hook</a></li>
<li><a class="reference internal" href="#adding-a-class-attribute-with-the-attribute-order" id="id22">Adding a class attribute with the attribute order</a></li>
</ul>
</li>
<li><a class="reference internal" href="#history" id="id23">History</a></li>
<li><a class="reference internal" href="#references" id="id24">References</a></li>
<li><a class="reference internal" href="#copyright" id="id25">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id5">Abstract</a></h1>
<p>Currently, customising class creation requires the use of a custom metaclass.
This custom metaclass then persists for the entire lifecycle of the class,
creating the potential for spurious metaclass conflicts.</p>
<p>This PEP proposes to instead support a wide range of customisation
scenarios through a new <tt class="docutils literal">__init_subclass__</tt> hook in the class body,
and a hook to initialize attributes.</p>
<p>The new mechanism should be easier to understand and use than
implementing a custom metaclass, and thus should provide a gentler
introduction to the full power of Python's metaclass machinery.</p>
</div>
<div class="section" id="background">
<h1><a class="toc-backref" href="#id6">Background</a></h1>
<p>Metaclasses are a powerful tool to customize class creation. They have,
however, the problem that there is no automatic way to combine metaclasses.
If one wants to use two metaclasses for a class, a new metaclass combining
those two needs to be created, typically manually.</p>
<p>This need often occurs as a surprise to a user: inheriting from two base
classes coming from two different libraries suddenly raises the necessity
to manually create a combined metaclass, where typically one is not
interested in those details about the libraries at all. This becomes
even worse if one library starts to make use of a metaclass which it
has not done before. While the library itself continues to work perfectly,
suddenly every code combining those classes with classes from another library
fails.</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id7">Proposal</a></h1>
<p>While there are many possible ways to use a metaclass, the vast majority
of use cases falls into just three categories: some initialization code
running after class creation, the initialization of descriptors and
keeping the order in which class attributes were defined.</p>
<p>The first two categories can easily be achieved by having simple hooks
into the class creation:</p>
<ol class="arabic simple">
<li>An <tt class="docutils literal">__init_subclass__</tt> hook that initializes
all subclasses of a given class.</li>
<li>upon class creation, a <tt class="docutils literal">__set_name__</tt> hook is called on all the
attribute (descriptors) defined in the class, and</li>
</ol>
<p>The third category is the topic of another PEP, <a class="reference external" href="/dev/peps/pep-0520">PEP 520</a>.</p>
<p>As an example, the first use case looks as follows:</p>
<pre class="literal-block">
&gt;&gt;&gt; class QuestBase:
...    # this is implicitly a &#64;classmethod (see below for motivation)
...    def __init_subclass__(cls, swallow, **kwargs):
...        cls.swallow = swallow
...        super().__init_subclass__(**kwargs)

&gt;&gt;&gt; class Quest(QuestBase, swallow=&quot;african&quot;):
...    pass

&gt;&gt;&gt; Quest.swallow
'african'
</pre>
<p>The base class <tt class="docutils literal">object</tt> contains an empty <tt class="docutils literal">__init_subclass__</tt>
method which serves as an endpoint for cooperative multiple inheritance.
Note that this method has no keyword arguments, meaning that all
methods which are more specialized have to process all keyword
arguments.</p>
<p>This general proposal is not a new idea (it was first suggested for
inclusion in the language definition <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2001-November/018651.html">more than 10 years ago</a> <a class="footnote-reference" href="#id1" id="id2">[1]</a>, and a
similar mechanism has long been supported by <a class="reference external" href="http://docs.zope.org/zope_secrets/extensionclass.html">Zope's ExtensionClass</a> <a class="footnote-reference" href="#id3" id="id4">[2]</a>),
but the situation has changed sufficiently in recent years that
the idea is worth reconsidering for inclusion.</p>
<p>The second part of the proposal adds an <tt class="docutils literal">__set_name__</tt>
initializer for class attributes, especially if they are descriptors.
Descriptors are defined in the body of a
class, but they do not know anything about that class, they do not
even know the name they are accessed with. They do get to know their
owner once <tt class="docutils literal">__get__</tt> is called, but still they do not know their
name. This is unfortunate, for example they cannot put their
associated value into their object's <tt class="docutils literal">__dict__</tt> under their name,
since they do not know that name.  This problem has been solved many
times, and is one of the most important reasons to have a metaclass in
a library. While it would be easy to implement such a mechanism using
the first part of the proposal, it makes sense to have one solution
for this problem for everyone.</p>
<p>To give an example of its usage, imagine a descriptor representing weak
referenced values:</p>
<pre class="literal-block">
import weakref

class WeakAttribute:
    def __get__(self, instance, owner):
        return instance.__dict__[self.name]()

    def __set__(self, instance, value):
        instance.__dict__[self.name] = weakref.ref(value)

    # this is the new initializer:
    def __set_name__(self, owner, name):
        self.name = name
</pre>
<p>Such a <tt class="docutils literal">WeakAttribute</tt> may, for example, be used in a tree structure
where one wants to avoid cyclic references via the parent:</p>
<pre class="literal-block">
class TreeNode:
    parent = WeakAttribute()

    def __init__(self, parent):
        self.parent = parent
</pre>
<p>Note that the <tt class="docutils literal">parent</tt> attribute is used like a normal attribute,
yet the tree contains no cyclic references and can thus be easily
garbage collected when out of use. The <tt class="docutils literal">parent</tt> attribute magically
becomes <tt class="docutils literal">None</tt> once the parent ceases existing.</p>
<p>While this example looks very trivial, it should be noted that until
now such an attribute cannot be defined without the use of a metaclass.
And given that such a metaclass can make life very hard, this kind of
attribute does not exist yet.</p>
<p>Initializing descriptors could simply be done in the
<tt class="docutils literal">__init_subclass__</tt> hook. But this would mean that descriptors can
only be used in classes that have the proper hook, the generic version
like in the example would not work generally. One could also call
<tt class="docutils literal">__set_name__</tt> from within the base implementation of
<tt class="docutils literal">object.__init_subclass__</tt>. But given that it is a common mistake
to forget to call <tt class="docutils literal">super()</tt>, it would happen too often that suddenly
descriptors are not initialized.</p>
</div>
<div class="section" id="key-benefits">
<h1><a class="toc-backref" href="#id8">Key Benefits</a></h1>
<div class="section" id="easier-inheritance-of-definition-time-behaviour">
<h2><a class="toc-backref" href="#id9">Easier inheritance of definition time behaviour</a></h2>
<p>Understanding Python's metaclasses requires a deep understanding of
the type system and the class construction process. This is legitimately
seen as challenging, due to the need to keep multiple moving parts (the code,
the metaclass hint, the actual metaclass, the class object, instances of the
class object) clearly distinct in your mind. Even when you know the rules,
it's still easy to make a mistake if you're not being extremely careful.</p>
<p>Understanding the proposed implicit class initialization hook only requires
ordinary method inheritance, which isn't quite as daunting a task. The new
hook provides a more gradual path towards understanding all of the phases
involved in the class definition process.</p>
</div>
<div class="section" id="reduced-chance-of-metaclass-conflicts">
<h2><a class="toc-backref" href="#id10">Reduced chance of metaclass conflicts</a></h2>
<p>One of the big issues that makes library authors reluctant to use metaclasses
(even when they would be appropriate) is the risk of metaclass conflicts.
These occur whenever two unrelated metaclasses are used by the desired
parents of a class definition. This risk also makes it very difficult to
<em>add</em> a metaclass to a class that has previously been published without one.</p>
<p>By contrast, adding an <tt class="docutils literal">__init_subclass__</tt> method to an existing type poses
a similar level of risk to adding an <tt class="docutils literal">__init__</tt> method: technically, there
is a risk of breaking poorly implemented subclasses, but when that occurs,
it is recognised as a bug in the subclass rather than the library author
breaching backwards compatibility guarantees.</p>
</div>
</div>
<div class="section" id="new-ways-of-using-classes">
<h1><a class="toc-backref" href="#id11">New Ways of Using Classes</a></h1>
<div class="section" id="subclass-registration">
<h2><a class="toc-backref" href="#id12">Subclass registration</a></h2>
<p>Especially when writing a plugin system, one likes to register new
subclasses of a plugin baseclass. This can be done as follows:</p>
<pre class="literal-block">
class PluginBase:
    subclasses = []

    def __init_subclass__(cls, **kwargs):
        super().__init_subclass__(**kwargs)
        cls.subclasses.append(cls)
</pre>
<p>In this example, <tt class="docutils literal">PluginBase.subclasses</tt> will contain a plain list of all
subclasses in the entire inheritance tree.  One should note that this also
works nicely as a mixin class.</p>
</div>
<div class="section" id="trait-descriptors">
<h2><a class="toc-backref" href="#id13">Trait descriptors</a></h2>
<p>There are many designs of Python descriptors in the wild which, for
example, check boundaries of values. Often those &quot;traits&quot; need some support
of a metaclass to work. This is how this would look like with this
PEP:</p>
<pre class="literal-block">
class Trait:
    def __init__(self, minimum, maximum):
        self.minimum = minimum
        self.maximum = maximum

    def __get__(self, instance, owner):
        return instance.__dict__[self.key]

    def __set__(self, instance, value):
        if self.minimum &lt; value &lt; self.maximum:
            instance.__dict__[self.key] = value
        else:
            raise ValueError(&quot;value not in range&quot;)

    def __set_name__(self, owner, name):
        self.key = name
</pre>
</div>
</div>
<div class="section" id="implementation-details">
<h1><a class="toc-backref" href="#id14">Implementation Details</a></h1>
<p>The hooks are called in the following order: <tt class="docutils literal">type.__new__</tt> calls
the <tt class="docutils literal">__set_name__</tt> hooks on the descriptor after the new class has been
initialized. Then it calls <tt class="docutils literal">__init_subclass__</tt> on the base class, on
<tt class="docutils literal">super()</tt>, to be precise. This means that subclass initializers already
see the fully initialized descriptors. This way, <tt class="docutils literal">__init_subclass__</tt> users
can fix all descriptors again if this is needed.</p>
<p>Another option would have been to call <tt class="docutils literal">__set_name__</tt> in the base
implementation of <tt class="docutils literal">object.__init_subclass__</tt>. This way it would be possible
even to prevent <tt class="docutils literal">__set_name__</tt> from being called. Most of the times,
however, such a prevention would be accidental, as it often happens that a call
to <tt class="docutils literal">super()</tt> is forgotten.</p>
<p>As a third option, all the work could have been done in <tt class="docutils literal">type.__init__</tt>.
Most metaclasses do their work in <tt class="docutils literal">__new__</tt>, as this is recommended by
the documentation. Many metaclasses modify their arguments before they
pass them over to <tt class="docutils literal"><span class="pre">super().__new__</span></tt>. For compatibility with those kind
of classes, the hooks should be called from <tt class="docutils literal">__new__</tt>.</p>
<p>Another small change should be done: in the current implementation of
CPython, <tt class="docutils literal">type.__init__</tt> explicitly forbids the use of keyword arguments,
while <tt class="docutils literal">type.__new__</tt> allows for its attributes to be shipped as keyword
arguments. This is weirdly incoherent, and thus it should be forbidden.
While it would be possible to retain the current behavior, it would be better
if this was fixed, as it is probably not used at all: the only use case would
be that at metaclass calls its <tt class="docutils literal"><span class="pre">super().__new__</span></tt> with <em>name</em>, <em>bases</em> and
<em>dict</em> (yes, <em>dict</em>, not <em>namespace</em> or <em>ns</em> as mostly used with modern
metaclasses) as keyword arguments. This should not be done. This little
change simplifies the implementation of this PEP significantly, while
improving the coherence of Python overall.</p>
<p>As a second change, the new <tt class="docutils literal">type.__init__</tt> just ignores keyword
arguments. Currently, it insists that no keyword arguments are given. This
leads to a (wanted) error if one gives keyword arguments to a class declaration
if the metaclass does not process them. Metaclass authors that do want to
accept keyword arguments must filter them out by overriding <tt class="docutils literal">__init___</tt>.</p>
<p>In the new code, it is not <tt class="docutils literal">__init__</tt> that complains about keyword arguments,
but <tt class="docutils literal">__init_subclass__</tt>, whose default implementation takes no arguments. In
a classical inheritance scheme using the method resolution order, each
<tt class="docutils literal">__init_subclass__</tt> may take out it's keyword arguments until none are left,
which is checked by the default implementation of <tt class="docutils literal">__init_subclass__</tt>.</p>
<p>For readers who prefer reading Python over English, this PEP proposes to
replace the current <tt class="docutils literal">type</tt> and <tt class="docutils literal">object</tt> with the following:</p>
<pre class="literal-block">
class NewType(type):
    def __new__(cls, *args, **kwargs):
        if len(args) != 3:
            return super().__new__(cls, *args)
        name, bases, ns = args
        init = ns.get('__init_subclass__')
        if isinstance(init, types.FunctionType):
            ns['__init_subclass__'] = classmethod(init)
        self = super().__new__(cls, name, bases, ns)
        for k, v in self.__dict__.items():
            func = getattr(v, '__set_name__', None)
            if func is not None:
                func(self, k)
        super(self, self).__init_subclass__(**kwargs)
        return self

    def __init__(self, name, bases, ns, **kwargs):
        super().__init__(name, bases, ns)

class NewObject(object):
    &#64;classmethod
    def __init_subclass__(cls):
        pass
</pre>
</div>
<div class="section" id="reference-implementation">
<h1><a class="toc-backref" href="#id15">Reference Implementation</a></h1>
<p>The reference implementation for this PEP is attached to
<a class="reference external" href="http://bugs.python.org/issue27366">issue 27366</a>.</p>
</div>
<div class="section" id="backward-compatibility-issues">
<h1><a class="toc-backref" href="#id16">Backward compatibility issues</a></h1>
<p>The exact calling sequence in <tt class="docutils literal">type.__new__</tt> is slightly changed, raising
fears of backwards compatibility. It should be assured by tests that common use
cases behave as desired.</p>
<p>The following class definitions (except the one defining the metaclass)
continue to fail with a <tt class="docutils literal">TypeError</tt> as superfluous class arguments are passed:</p>
<pre class="literal-block">
class MyMeta(type):
    pass

class MyClass(metaclass=MyMeta, otherarg=1):
    pass

MyMeta(&quot;MyClass&quot;, (), otherargs=1)

import types
types.new_class(&quot;MyClass&quot;, (), dict(metaclass=MyMeta, otherarg=1))
types.prepare_class(&quot;MyClass&quot;, (), dict(metaclass=MyMeta, otherarg=1))
</pre>
<p>A metaclass defining only a <tt class="docutils literal">__new__</tt> method which is interested in keyword
arguments now does not need to define an <tt class="docutils literal">__init__</tt> method anymore, as the
default <tt class="docutils literal">type.__init__</tt> ignores keyword arguments. This is nicely in line
with the recommendation to override <tt class="docutils literal">__new__</tt> in metaclasses instead of
<tt class="docutils literal">__init__</tt>. The following code does not fail anymore:</p>
<pre class="literal-block">
class MyMeta(type):
    def __new__(cls, name, bases, namespace, otherarg):
        return super().__new__(cls, name, bases, namespace)

class MyClass(metaclass=MyMeta, otherarg=1):
    pass
</pre>
<p>Only defining an <tt class="docutils literal">__init__</tt> method in a metaclass continues to fail with
<tt class="docutils literal">TypeError</tt> if keyword arguments are given:</p>
<pre class="literal-block">
class MyMeta(type):
    def __init__(self, name, bases, namespace, otherarg):
        super().__init__(name, bases, namespace)

class MyClass(metaclass=MyMeta, otherarg=1):
    pass
</pre>
<p>Defining both <tt class="docutils literal">__init__</tt> and <tt class="docutils literal">__new__</tt> continues to work fine.</p>
<p>About the only thing that stops working is passing the arguments of
<tt class="docutils literal">type.__new__</tt> as keyword arguments:</p>
<pre class="literal-block">
class MyMeta(type):
    def __new__(cls, name, bases, namespace):
        return super().__new__(cls, name=name, bases=bases,
                               dict=namespace)

class MyClass(metaclass=MyMeta):
    pass
</pre>
<p>This will now raise <tt class="docutils literal">TypeError</tt>, but this is weird code, and easy
to fix even if someone used this feature.</p>
</div>
<div class="section" id="rejected-design-options">
<h1><a class="toc-backref" href="#id17">Rejected Design Options</a></h1>
<div class="section" id="calling-the-hook-on-the-class-itself">
<h2><a class="toc-backref" href="#id18">Calling the hook on the class itself</a></h2>
<p>Adding an <tt class="docutils literal">__autodecorate__</tt> hook that would be called on the class
itself was the proposed idea of <a class="reference external" href="/dev/peps/pep-0422">PEP 422</a>.  Most examples work the same
way or even better if the hook is called only on strict subclasses. In general,
it is much easier to arrange to explicitly call the hook on the class in which it
is defined (to opt-in to such a behavior) than to opt-out (by remember to check for
<tt class="docutils literal">cls is __class</tt> in the hook body), meaning that one does not want the hook to be
called on the class it is defined in.</p>
<p>This becomes most evident if the class in question is designed as a
mixin: it is very unlikely that the code of the mixin is to be
executed for the mixin class itself, as it is not supposed to be a
complete class on its own.</p>
<p>The original proposal also made major changes in the class
initialization process, rendering it impossible to back-port the
proposal to older Python versions.</p>
<p>When it's desired to also call the hook on the base class, two mechanisms are available:</p>
<ol class="arabic simple">
<li>Introduce an additional mixin class just to hold the <tt class="docutils literal">__init_subclass__</tt>
implementation. The original &quot;base&quot; class can then list the new mixin as its
first parent class.</li>
<li>Implement the desired behaviour as an independent class decorator, and apply that
decorator explicitly to the base class, and then implicitly to subclasses via
<tt class="docutils literal">__init_subclass__</tt>.</li>
</ol>
<p>Calling <tt class="docutils literal">__init_subclass__</tt> explicitly from a class decorator will generally be
undesirable, as this will also typically call <tt class="docutils literal">__subclass_init__</tt> a second time on
the parent class, which is unlikely to be desired behaviour.</p>
</div>
<div class="section" id="other-variants-of-calling-the-hooks">
<h2><a class="toc-backref" href="#id19">Other variants of calling the hooks</a></h2>
<p>Other names for the hook were presented, namely <tt class="docutils literal">__decorate__</tt> or
<tt class="docutils literal">__autodecorate__</tt>. This proposal opts for <tt class="docutils literal">__init_subclass__</tt> as
it is very close to the <tt class="docutils literal">__init__</tt> method, just for the subclass,
while it is not very close to decorators, as it does not return the
class.</p>
<p>For the <tt class="docutils literal">__set_name__</tt> hook other names have been proposed as well,
<tt class="docutils literal">__set_owner__</tt>, <tt class="docutils literal">__set_ownership__</tt> and <tt class="docutils literal">__init_descriptor__</tt>.</p>
</div>
<div class="section" id="requiring-an-explicit-decorator-on-init-subclass">
<h2><a class="toc-backref" href="#id20">Requiring an explicit decorator on <tt class="docutils literal">__init_subclass__</tt></a></h2>
<p>One could require the explicit use of <tt class="docutils literal">&#64;classmethod</tt> on the
<tt class="docutils literal">__init_subclass__</tt> decorator. It was made implicit since there's no
sensible interpretation for leaving it out, and that case would need
to be detected anyway in order to give a useful error message.</p>
<p>This decision was reinforced after noticing that the user experience of
defining <tt class="docutils literal">__prepare__</tt> and forgetting the <tt class="docutils literal">&#64;classmethod</tt> method
decorator is singularly incomprehensible (particularly since <a class="reference external" href="/dev/peps/pep-3115">PEP 3115</a>
documents it as an ordinary method, and the current documentation doesn't
explicitly say anything one way or the other).</p>
</div>
<div class="section" id="a-more-new-like-hook">
<h2><a class="toc-backref" href="#id21">A more <tt class="docutils literal">__new__</tt>-like hook</a></h2>
<p>In <a class="reference external" href="/dev/peps/pep-0422">PEP 422</a> the hook worked more like the <tt class="docutils literal">__new__</tt> method than the
<tt class="docutils literal">__init__</tt> method, meaning that it returned a class instead of
modifying one. This allows a bit more flexibility, but at the cost
of much harder implementation and undesired side effects.</p>
</div>
<div class="section" id="adding-a-class-attribute-with-the-attribute-order">
<h2><a class="toc-backref" href="#id22">Adding a class attribute with the attribute order</a></h2>
<p>This got its own <a class="reference external" href="/dev/peps/pep-0520">PEP 520</a>.</p>
</div>
</div>
<div class="section" id="history">
<h1><a class="toc-backref" href="#id23">History</a></h1>
<p>This used to be a competing proposal to <a class="reference external" href="/dev/peps/pep-0422">PEP 422</a> by Nick Coghlan and Daniel
Urban. <a class="reference external" href="/dev/peps/pep-0422">PEP 422</a> intended to achieve the same goals as this PEP, but with a
different way of implementation.  In the meantime, <a class="reference external" href="/dev/peps/pep-0422">PEP 422</a> has been withdrawn
favouring this approach.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id24">References</a></h1>
<table class="docutils footnote" frame="void" id="id1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2001-November/018651.html">https://mail.python.org/pipermail/python-dev/2001-November/018651.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[2]</a></td><td><a class="reference external" href="http://docs.zope.org/zope_secrets/extensionclass.html">http://docs.zope.org/zope_secrets/extensionclass.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id25">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

