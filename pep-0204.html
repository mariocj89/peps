<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">204</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Range Literals</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0204.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">thomas&#32;&#97;t&#32;python.org (Thomas Wouters)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">14-Jul-2000</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.0</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id5">Introduction</a></li>
<li><a class="reference internal" href="#list-ranges" id="id6">List ranges</a></li>
<li><a class="reference internal" href="#slice-indices" id="id7">Slice Indices</a></li>
<li><a class="reference internal" href="#the-proposed-solution" id="id8">The Proposed Solution</a></li>
<li><a class="reference internal" href="#reference-implementation" id="id9">Reference Implementation</a></li>
<li><a class="reference internal" href="#open-issues" id="id10">Open issues</a></li>
<li><a class="reference internal" href="#rejection" id="id11">Rejection</a></li>
<li><a class="reference internal" href="#copyright" id="id12">Copyright</a></li>
<li><a class="reference internal" href="#references" id="id13">References</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id5">Introduction</a></h1>
<p>This PEP describes the &quot;range literal&quot; proposal for Python 2.0.
This PEP tracks the status and ownership of this feature, slated
for introduction in Python 2.0.  It contains a description of the
feature and outlines changes necessary to support the feature.
This PEP summarizes discussions held in mailing list forums, and
provides URLs for further information, where appropriate.  The CVS
revision history of this file contains the definitive historical
record.</p>
</div>
<div class="section" id="list-ranges">
<h1><a class="toc-backref" href="#id6">List ranges</a></h1>
<p>Ranges are sequences of numbers of a fixed stepping, often used in
for-loops.  The Python for-loop is designed to iterate over a
sequence directly:</p>
<pre class="literal-block">
&gt;&gt;&gt; l = ['a', 'b', 'c', 'd']
&gt;&gt;&gt; for item in l:
...     print item
a
b
c
d
</pre>
<p>However, this solution is not always prudent.  Firstly, problems
arise when altering the sequence in the body of the for-loop,
resulting in the for-loop skipping items.  Secondly, it is not
possible to iterate over, say, every second element of the
sequence.  And thirdly, it is sometimes necessary to process an
element based on its index, which is not readily available in the
above construct.</p>
<p>For these instances, and others where a range of numbers is
desired, Python provides the <tt class="docutils literal">range</tt> builtin function, which
creates a list of numbers.  The <tt class="docutils literal">range</tt> function takes three
arguments, <em>start</em>, <em>end</em> and <em>step</em>.  <em>start</em> and <em>step</em> are
optional, and default to 0 and 1, respectively.</p>
<p>The <tt class="docutils literal">range</tt> function creates a list of numbers, starting at
<em>start</em>, with a step of <em>step</em>, up to, but not including <em>end</em>, so
that <tt class="docutils literal">range(10)</tt> produces a list that has exactly 10 items, the
numbers 0 through 9.</p>
<p>Using the <tt class="docutils literal">range</tt> function, the above example would look like
this:</p>
<pre class="literal-block">
&gt;&gt;&gt; for i in range(len(l)):
...     print l[i]
a
b
c
d
</pre>
<p>Or, to start at the second element of <tt class="docutils literal">l</tt> and processing only
every second element from then on:</p>
<pre class="literal-block">
&gt;&gt;&gt; for i in range(1, len(l), 2):
...     print l[i]
b
d
</pre>
<p>There are several disadvantages with this approach:</p>
<ul class="simple">
<li>Clarity of purpose: Adding another function call, possibly with
extra arithmetic to determine the desired length and step of the
list, does not improve readability of the code.  Also, it is
possible to &quot;shadow&quot; the builtin <tt class="docutils literal">range</tt> function by supplying a
local or global variable with the same name, effectively
replacing it.  This may or may not be a desired effect.</li>
<li>Efficiency: because the <tt class="docutils literal">range</tt> function can be overridden, the
Python compiler cannot make assumptions about the for-loop, and
has to maintain a separate loop counter.</li>
<li>Consistency: There already is a syntax that is used to denote
ranges, as shown below.  This syntax uses the exact same
arguments, though all optional, in the exact same way.  It seems
logical to extend this syntax to ranges, to form &quot;range
literals&quot;.</li>
</ul>
</div>
<div class="section" id="slice-indices">
<h1><a class="toc-backref" href="#id7">Slice Indices</a></h1>
<p>In Python, a sequence can be indexed in one of two ways:
retrieving a single item, or retrieving a range of items.
Retrieving a range of items results in a new object of the same
type as the original sequence, containing zero or more items from
the original sequence.  This is done using a &quot;range notation&quot;:</p>
<pre class="literal-block">
&gt;&gt;&gt; l[2:4]
['c', 'd']
</pre>
<p>This range notation consists of zero, one or two indices separated
by a colon.  The first index is the <em>start</em> index, the second the
<em>end</em>.  When either is left out, they default to respectively the
start and the end of the sequence.</p>
<p>There is also an extended range notation, which incorporates
<em>step</em> as well.  Though this notation is not currently supported
by most builtin types, if it were, it would work as follows:</p>
<pre class="literal-block">
&gt;&gt;&gt; l[1:4:2]
['b', 'd']
</pre>
<p>The third &quot;argument&quot; to the slice syntax is exactly the same as
the <em>step</em> argument to <tt class="docutils literal">range()</tt>.  The underlying mechanisms of the
standard, and these extended slices, are sufficiently different
and inconsistent that many classes and extensions outside of
mathematical packages do not implement support for the extended
variant.  While this should be resolved, it is beyond the scope of
this PEP.</p>
<p>Extended slices do show, however, that there is already a
perfectly valid and applicable syntax to denote ranges in a way
that solve all of the earlier stated disadvantages of the use of
the <tt class="docutils literal">range()</tt> function:</p>
<ul class="simple">
<li>It is clearer, more concise syntax, which has already proven to
be both intuitive and easy to learn.</li>
<li>It is consistent with the other use of ranges in Python
(e.g. slices).</li>
<li>Because it is built-in syntax, instead of a builtin function, it
cannot be overridden.  This means both that a viewer can be
certain about what the code does, and that an optimizer will not
have to worry about <tt class="docutils literal">range()</tt> being &quot;shadowed&quot;.</li>
</ul>
</div>
<div class="section" id="the-proposed-solution">
<h1><a class="toc-backref" href="#id8">The Proposed Solution</a></h1>
<p>The proposed implementation of range-literals combines the syntax
for list literals with the syntax for (extended) slices, to form
range literals:</p>
<pre class="literal-block">
&gt;&gt;&gt; [1:10]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; [:5]
[0, 1, 2, 3, 4]
&gt;&gt;&gt; [5:1:-1]
[5, 4, 3, 2]
</pre>
<p>There is one minor difference between range literals and the slice
syntax: though it is possible to omit all of <em>start</em>, <em>end</em> and
<em>step</em> in slices, it does not make sense to omit <em>end</em> in range
literals.  In slices, <em>end</em> would default to the end of the list,
but this has no meaning in range literals.</p>
</div>
<div class="section" id="reference-implementation">
<h1><a class="toc-backref" href="#id9">Reference Implementation</a></h1>
<p>The proposed implementation can be found on SourceForge <a class="footnote-reference" href="#id3" id="id1">[1]</a>.  It
adds a new bytecode, <tt class="docutils literal">BUILD_RANGE</tt>, that takes three arguments from
the stack and builds a list on the bases of those.  The list is
pushed back on the stack.</p>
<p>The use of a new bytecode is necessary to be able to build ranges
based on other calculations, whose outcome is not known at compile
time.</p>
<p>The code introduces two new functions to <tt class="docutils literal">listobject.c</tt>, which are
currently hovering between private functions and full-fledged API
calls.</p>
<p><tt class="docutils literal">PyList_FromRange()</tt> builds a list from start, end and step,
returning NULL if an error occurs.  Its prototype is:</p>
<pre class="literal-block">
PyObject * PyList_FromRange(long start, long end, long step)
</pre>
<p><tt class="docutils literal">PyList_GetLenOfRange()</tt> is a helper function used to determine the
length of a range.  Previously, it was a static function in
<tt class="docutils literal">bltinmodule.c</tt>, but is now necessary in both <tt class="docutils literal">listobject.c</tt> and
<tt class="docutils literal">bltinmodule.c</tt> (for <tt class="docutils literal">xrange</tt>).  It is made non-static solely to avoid
code duplication.  Its prototype is:</p>
<pre class="literal-block">
long PyList_GetLenOfRange(long start, long end, long step)
</pre>
</div>
<div class="section" id="open-issues">
<h1><a class="toc-backref" href="#id10">Open issues</a></h1>
<ul>
<li><p class="first">One possible solution to the discrepancy of requiring the <em>end</em>
argument in range literals is to allow the range syntax to
create a &quot;generator&quot;, rather than a list, such as the <tt class="docutils literal">xrange</tt>
builtin function does.  However, a generator would not be a
list, and it would be impossible, for instance, to assign to
items in the generator, or append to it.</p>
<p>The range syntax could conceivably be extended to include tuples
(i.e. immutable lists), which could then be safely implemented
as generators.  This may be a desirable solution, especially for
large number arrays: generators require very little in the way
of storage and initialization, and there is only a small
performance impact in calculating and creating the appropriate
number on request.  (TBD: is there any at all? Cursory testing
suggests equal performance even in the case of ranges of length
1)</p>
<p>However, even if idea was adopted, would it be wise to &quot;special
case&quot; the second argument, making it optional in one instance of
the syntax, and non-optional in other cases ?</p>
</li>
<li><p class="first">Should it be possible to mix range syntax with normal list
literals, creating a single list?  E.g.:</p>
<pre class="literal-block">
&gt;&gt;&gt; [5, 6, 1:6, 7, 9]
</pre>
<p>to create:</p>
<pre class="literal-block">
[5, 6, 1, 2, 3, 4, 5, 7, 9]
</pre>
</li>
<li><p class="first">How should range literals interact with another proposed new
feature, &quot;list comprehensions&quot; <a class="footnote-reference" href="#id4" id="id2">[2]</a>?  Specifically, should it be
possible to create lists in list comprehensions?  E.g.:</p>
<pre class="literal-block">
&gt;&gt;&gt; [x:y for x in (1, 2) y in (3, 4)]
</pre>
<p>Should this example return a single list with multiple ranges:</p>
<pre class="literal-block">
[1, 2, 1, 2, 3, 2, 2, 3]
</pre>
<p>Or a list of lists, like so:</p>
<pre class="literal-block">
[[1, 2], [1, 2, 3], [2]_, [2, 3]]
</pre>
<p>However, as the syntax and semantics of list comprehensions are
still subject of hot debate, these issues are probably best
addressed by the &quot;list comprehensions&quot; PEP.</p>
</li>
<li><p class="first">Range literals accept objects other than integers: it performs
<tt class="docutils literal">PyInt_AsLong()</tt> on the objects passed in, so as long as the
objects can be coerced into integers, they will be accepted.
The resulting list, however, is always composed of standard
integers.</p>
<p>Should range literals create a list of the passed-in type?  It
might be desirable in the cases of other builtin types, such as
longs and strings:</p>
<pre class="literal-block">
&gt;&gt;&gt; [ 1L : 2L&lt;&lt;64 : 2&lt;&lt;32L ]
&gt;&gt;&gt; [&quot;a&quot;:&quot;z&quot;:&quot;b&quot;]
&gt;&gt;&gt; [&quot;a&quot;:&quot;z&quot;:2]
</pre>
<p>However, this might be too much &quot;magic&quot; to be obvious.  It might
also present problems with user-defined classes: even if the
base class can be found and a new instance created, the instance
may require additional arguments to <tt class="docutils literal">__init__</tt>, causing the
creation to fail.</p>
</li>
<li><p class="first">The <tt class="docutils literal">PyList_FromRange()</tt> and <tt class="docutils literal">PyList_GetLenOfRange()</tt> functions need
to be classified: are they part of the API, or should they be
made private functions?</p>
</li>
</ul>
</div>
<div class="section" id="rejection">
<h1><a class="toc-backref" href="#id11">Rejection</a></h1>
<p>After careful consideration, and a period of meditation, this
proposal has been rejected. The open issues, as well as some
confusion between ranges and slice syntax, raised enough questions
for Guido not to accept it for Python 2.0, and later to reject the
proposal altogether. The new syntax and its intentions were deemed
not obvious enough.</p>
<p>[ TBD: Guido, amend/confirm this, please. Preferably both; this
is a PEP, it should contain <em>all</em> the reasons for rejection
and/or reconsideration, for future reference. ]</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id12">Copyright</a></h1>
<p>This document has been placed in the Public Domain.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id13">References</a></h1>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://sourceforge.net/patch/?func=detailpatch&amp;patch_id=100902&amp;group_id=5470">http://sourceforge.net/patch/?func=detailpatch&amp;patch_id=100902&amp;group_id=5470</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="/dev/peps/pep-0202">PEP 202</a>, List Comprehensions</td></tr>
</tbody>
</table>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

