<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">311</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Simplified Global Interpreter Lock Acquisition for Extensions</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0311.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Mark Hammond &lt;mhammond&#32;&#97;t&#32;skippinet.com.au&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">05-Feb-2003</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">05-Feb-2003 14-Feb-2003 19-Apr-2003</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id3">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id4">Rationale</a></li>
<li><a class="reference internal" href="#limitations-and-exclusions" id="id5">Limitations and Exclusions</a></li>
<li><a class="reference internal" href="#proposal" id="id6">Proposal</a></li>
<li><a class="reference internal" href="#design-and-implementation" id="id7">Design and Implementation</a></li>
<li><a class="reference internal" href="#implementation" id="id8">Implementation</a></li>
<li><a class="reference internal" href="#references" id="id9">References</a></li>
<li><a class="reference internal" href="#copyright" id="id10">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id3">Abstract</a></h1>
<p>This PEP proposes a simplified API for access to the Global
Interpreter Lock (GIL) for Python extension modules.
Specifically, it provides a solution for authors of complex
multi-threaded extensions, where the current state of Python
(i.e., the state of the GIL is unknown.</p>
<p>This PEP proposes a new API, for platforms built with threading
support, to manage the Python thread state.  An implementation
strategy is proposed, along with an initial, platform independent
implementation.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id4">Rationale</a></h1>
<p>The current Python interpreter state API is suitable for simple,
single-threaded extensions, but quickly becomes incredibly complex
for non-trivial, multi-threaded extensions.</p>
<p>Currently Python provides two mechanisms for dealing with the GIL:</p>
<ul class="simple">
<li><tt class="docutils literal">Py_BEGIN_ALLOW_THREADS</tt> and <tt class="docutils literal">Py_END_ALLOW_THREADS</tt> macros.
These macros are provided primarily to allow a simple Python
extension that already owns the GIL to temporarily release it
while making an &quot;external&quot; (ie, non-Python), generally
expensive, call.  Any existing Python threads that are blocked
waiting for the GIL are then free to run.  While this is fine
for extensions making calls from Python into the outside world,
it is no help for extensions that need to make calls into Python
when the thread state is unknown.</li>
<li><tt class="docutils literal">PyThreadState</tt> and <tt class="docutils literal">PyInterpreterState</tt> APIs.
These API functions allow an extension/embedded application to
acquire the GIL, but suffer from a serious boot-strapping
problem - they require you to know the state of the Python
interpreter and of the GIL before they can be used.  One
particular problem is for extension authors that need to deal
with threads never before seen by Python, but need to call
Python from this thread.  It is very difficult, delicate and
error prone to author an extension where these &quot;new&quot; threads
always know the exact state of the GIL, and therefore can
reliably interact with this API.</li>
</ul>
<p>For these reasons, the question of how such extensions should
interact with Python is quickly becoming a FAQ.  The main impetus
for this PEP, a thread on python-dev <a class="footnote-reference" href="#id2" id="id1">[1]</a>, immediately identified
the following projects with this exact issue:</p>
<ul class="simple">
<li>The win32all extensions</li>
<li>Boost</li>
<li>ctypes</li>
<li>Python-GTK bindings</li>
<li>Uno</li>
<li>PyObjC</li>
<li>Mac toolbox</li>
<li>PyXPCOM</li>
</ul>
<p>Currently, there is no reasonable, portable solution to this
problem, forcing each extension author to implement their own
hand-rolled version.  Further, the problem is complex, meaning
many implementations are likely to be incorrect, leading to a
variety of problems that will often manifest simply as &quot;Python has
hung&quot;.</p>
<p>While the biggest problem in the existing thread-state API is the
lack of the ability to query the current state of the lock, it is
felt that a more complete, simplified solution should be offered
to extension authors.  Such a solution should encourage authors to
provide error-free, complex extension modules that take full
advantage of Python's threading mechanisms.</p>
</div>
<div class="section" id="limitations-and-exclusions">
<h1><a class="toc-backref" href="#id5">Limitations and Exclusions</a></h1>
<p>This proposal identifies a solution for extension authors with
complex multi-threaded requirements, but that only require a
single &quot;PyInterpreterState&quot;.  There is no attempt to cater for
extensions that require multiple interpreter states.  At the time
of writing, no extension has been identified that requires
multiple PyInterpreterStates, and indeed it is not clear if that
facility works correctly in Python itself.</p>
<p>This API will not perform automatic initialization of Python, or
initialize Python for multi-threaded operation.  Extension authors
must continue to call <tt class="docutils literal">Py_Initialize()</tt>, and for multi-threaded
applications, <tt class="docutils literal">PyEval_InitThreads()</tt>.  The reason for this is that
the first thread to call <tt class="docutils literal">PyEval_InitThreads()</tt> is nominated as the
&quot;main thread&quot; by Python, and so forcing the extension author to
specify the main thread (by forcing her to make this first call)
removes ambiguity.  As <tt class="docutils literal">Py_Initialize()</tt> must be called before
<tt class="docutils literal">PyEval_InitThreads()</tt>, and as both of these functions currently
support being called multiple times, the burden this places on
extension authors is considered reasonable.</p>
<p>It is intended that this API be all that is necessary to acquire
the Python GIL.  Apart from the existing, standard
<tt class="docutils literal">Py_BEGIN_ALLOW_THREADS</tt> and <tt class="docutils literal">Py_END_ALLOW_THREADS</tt> macros, it is
assumed that no additional thread state API functions will be used
by the extension.  Extensions with such complicated requirements
are free to continue to use the existing thread state API.</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id6">Proposal</a></h1>
<p>This proposal recommends a new API be added to Python to simplify
the management of the GIL.  This API will be available on all
platforms built with <tt class="docutils literal">WITH_THREAD</tt> defined.</p>
<p>The intent is that assuming Python has correctly been initialized,
an extension author be able to use a small, well-defined &quot;prologue
dance&quot;, at any time and on any thread, which will ensure Python
is ready to be used on that thread.  After the extension has
finished with Python, it must also perform an &quot;epilogue dance&quot; to
release any resources previously acquired.  Ideally, these dances
can be expressed in a single line.</p>
<p>Specifically, the following new APIs are proposed:</p>
<pre class="literal-block">
/* Ensure that the current thread is ready to call the Python
   C API, regardless of the current state of Python, or of its
   thread lock.  This may be called as many times as desired
   by a thread so long as each call is matched with a call to
   PyGILState_Release().  In general, other thread-state APIs may
   be used between _Ensure() and _Release() calls, so long as the
   thread-state is restored to its previous state before the Release().
   For example, normal use of the Py_BEGIN_ALLOW_THREADS/
   Py_END_ALLOW_THREADS macros are acceptable.

   The return value is an opaque &quot;handle&quot; to the thread state when
   PyGILState_Acquire() was called, and must be passed to
   PyGILState_Release() to ensure Python is left in the same state. Even
   though recursive calls are allowed, these handles can *not* be
   shared - each unique call to PyGILState_Ensure must save the handle
   for its call to PyGILState_Release.

   When the function returns, the current thread will hold the GIL.

   Failure is a fatal error.
*/
PyAPI_FUNC(PyGILState_STATE) PyGILState_Ensure(void);

/* Release any resources previously acquired.  After this call, Python's
   state will be the same as it was prior to the corresponding
   PyGILState_Acquire call (but generally this state will be unknown to
   the caller, hence the use of the GILState API.)

   Every call to PyGILState_Ensure must be matched by a call to
   PyGILState_Release on the same thread.
*/
PyAPI_FUNC(void) PyGILState_Release(PyGILState_STATE);
</pre>
<p>Common usage will be:</p>
<pre class="literal-block">
void SomeCFunction(void)
{
    /* ensure we hold the lock */
    PyGILState_STATE state = PyGILState_Ensure();
    /* Use the Python API */
    ...
    /* Restore the state of Python */
    PyGILState_Release(state);
}
</pre>
</div>
<div class="section" id="design-and-implementation">
<h1><a class="toc-backref" href="#id7">Design and Implementation</a></h1>
<p>The general operation of <tt class="docutils literal">PyGILState_Ensure()</tt> will be:</p>
<ul class="simple">
<li>assert Python is initialized.</li>
<li>Get a <tt class="docutils literal">PyThreadState</tt> for the current thread, creating and saving
if necessary.</li>
<li>remember the current state of the lock (owned/not owned)</li>
<li>If the current state does not own the GIL, acquire it.</li>
<li>Increment a counter for how many calls to <tt class="docutils literal">PyGILState_Ensure</tt> have been
made on the current thread.</li>
<li>return</li>
</ul>
<p>The general operation of <tt class="docutils literal">PyGILState_Release()</tt> will be:</p>
<ul class="simple">
<li>assert our thread currently holds the lock.</li>
<li>If old state indicates lock was previously unlocked, release GIL.</li>
<li>Decrement the <tt class="docutils literal">PyGILState_Ensure</tt> counter for the thread.</li>
<li>If counter == 0:<ul>
<li>release and delete the <tt class="docutils literal">PyThreadState</tt>.</li>
<li>forget the <tt class="docutils literal">ThreadState</tt> as being owned by the thread.</li>
</ul>
</li>
<li>return</li>
</ul>
<p>It is assumed that it is an error if two discrete <tt class="docutils literal">PyThreadStates</tt>
are used for a single thread.  Comments in <tt class="docutils literal">pystate.h</tt> (&quot;State
unique per thread&quot;) support this view, although it is never
directly stated.  Thus, this will require some implementation of
Thread Local Storage.  Fortunately, a platform independent
implementation of Thread Local Storage already exists in the
Python source tree, in the SGI threading port.  This code will be
integrated into the platform independent Python core, but in such
a way that platforms can provide a more optimal implementation if
desired.</p>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id8">Implementation</a></h1>
<p>An implementation of this proposal can be found at
<a class="reference external" href="http://www.python.org/sf/684256">http://www.python.org/sf/684256</a></p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id9">References</a></h1>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>David Abrahams, Extension modules, Threading, and the GIL
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2002-December/031424.html">https://mail.python.org/pipermail/python-dev/2002-December/031424.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id10">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>

