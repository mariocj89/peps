<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">544</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Protocols: Structural subtyping (static duck typing)</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0544.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Ivan Levkivskyi &lt;levkivskyi&#32;&#97;t&#32;gmail.com&gt;, Jukka Lehtosalo &lt;jukka.lehtosalo&#32;&#97;t&#32;iki.fi&gt;, ≈Åukasz Langa &lt;lukasz&#32;&#97;t&#32;langa.pl&gt;</td>
</tr>
<tr class="field"><th class="field-name">Discussions-To:</th><td class="field-body">Python-Dev &lt;<a class="reference external" href="mailto:python-dev&#64;python.org?subject=PEP%20544">python-dev&#32;&#97;t&#32;python.org</a>&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Draft</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">05-Mar-2017</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.7</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id16">Abstract</a></li>
<li><a class="reference internal" href="#rationale-and-goals" id="id17">Rationale and Goals</a><ul>
<li><a class="reference internal" href="#nominal-vs-structural-subtyping" id="id18">Nominal vs structural subtyping</a></li>
<li><a class="reference internal" href="#non-goals" id="id19">Non-goals</a></li>
</ul>
</li>
<li><a class="reference internal" href="#existing-approaches-to-structural-subtyping" id="id20">Existing Approaches to Structural Subtyping</a></li>
<li><a class="reference internal" href="#id8" id="id21">Specification</a><ul>
<li><a class="reference internal" href="#terminology" id="id22">Terminology</a></li>
<li><a class="reference internal" href="#defining-a-protocol" id="id23">Defining a protocol</a></li>
<li><a class="reference internal" href="#protocol-members" id="id24">Protocol members</a></li>
<li><a class="reference internal" href="#explicitly-declaring-implementation" id="id25">Explicitly declaring implementation</a></li>
<li><a class="reference internal" href="#merging-and-extending-protocols" id="id26">Merging and extending protocols</a></li>
<li><a class="reference internal" href="#generic-protocols" id="id27">Generic protocols</a></li>
<li><a class="reference internal" href="#recursive-protocols" id="id28">Recursive protocols</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-protocols" id="id29">Using Protocols</a><ul>
<li><a class="reference internal" href="#subtyping-relationships-with-other-types" id="id30">Subtyping relationships with other types</a></li>
<li><a class="reference internal" href="#unions-and-intersections-of-protocols" id="id31">Unions and intersections of protocols</a></li>
<li><a class="reference internal" href="#type-with-protocols" id="id32"><tt class="docutils literal">Type[]</tt> with protocols</a></li>
<li><a class="reference internal" href="#newtype-and-type-aliases" id="id33"><tt class="docutils literal">NewType()</tt> and type aliases</a></li>
<li><a class="reference internal" href="#runtime-decorator-and-narrowing-types-by-isinstance" id="id34"><tt class="docutils literal">&#64;runtime</tt> decorator and narrowing types by <tt class="docutils literal">isinstance()</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-protocols-in-python-2-7-3-5" id="id35">Using Protocols in Python 2.7 - 3.5</a></li>
<li><a class="reference internal" href="#runtime-implementation-of-protocol-classes" id="id36">Runtime Implementation of Protocol Classes</a><ul>
<li><a class="reference internal" href="#implementation-details" id="id37">Implementation details</a></li>
<li><a class="reference internal" href="#changes-in-the-typing-module" id="id38">Changes in the typing module</a></li>
<li><a class="reference internal" href="#introspection" id="id39">Introspection</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rejected-postponed-ideas" id="id40">Rejected/Postponed Ideas</a><ul>
<li><a class="reference internal" href="#make-every-class-a-protocol-by-default" id="id41">Make every class a protocol by default</a></li>
<li><a class="reference internal" href="#protocols-subclassing-normal-classes" id="id42">Protocols subclassing normal classes</a></li>
<li><a class="reference internal" href="#support-optional-protocol-members" id="id43">Support optional protocol members</a></li>
<li><a class="reference internal" href="#allow-only-protocol-methods-and-force-use-of-getters-and-setters" id="id44">Allow only protocol methods and force use of getters and setters</a></li>
<li><a class="reference internal" href="#support-non-protocol-members" id="id45">Support non-protocol members</a></li>
<li><a class="reference internal" href="#make-protocols-interoperable-with-other-approaches" id="id46">Make protocols interoperable with other approaches</a></li>
<li><a class="reference internal" href="#use-assignments-to-check-explicitly-that-a-class-implements-a-protocol" id="id47">Use assignments to check explicitly that a class implements a protocol</a></li>
<li><a class="reference internal" href="#support-isinstance-checks-by-default" id="id48">Support <tt class="docutils literal">isinstance()</tt> checks by default</a></li>
<li><a class="reference internal" href="#provide-a-special-intersection-type-construct" id="id49">Provide a special intersection type construct</a></li>
<li><a class="reference internal" href="#prohibit-explicit-subclassing-of-protocols-by-non-protocols" id="id50">Prohibit explicit subclassing of protocols by non-protocols</a></li>
<li><a class="reference internal" href="#covariant-subtyping-of-mutable-attributes" id="id51">Covariant subtyping of mutable attributes</a></li>
<li><a class="reference internal" href="#overriding-inferred-variance-of-protocol-classes" id="id52">Overriding inferred variance of protocol classes</a></li>
<li><a class="reference internal" href="#support-adapters-and-adaptation" id="id53">Support adapters and adaptation</a></li>
<li><a class="reference internal" href="#call-structural-base-types-interfaces" id="id54">Call structural base types &quot;interfaces&quot;</a></li>
<li><a class="reference internal" href="#make-protocols-special-objects-at-runtime-rather-that-normal-abcs" id="id55">Make protocols special objects at runtime rather that normal ABCs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility" id="id56">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#implementation" id="id57">Implementation</a></li>
<li><a class="reference internal" href="#references" id="id58">References</a></li>
<li><a class="reference internal" href="#copyright" id="id59">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id16">Abstract</a></h1>
<p>Type hints introduced in <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a> can be used to specify type metadata
for static type checkers and other third party tools. However, <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a>
only specifies the semantics of <em>nominal</em> subtyping. In this PEP we specify
static and runtime semantics of protocol classes that will provide a support
for <em>structural</em> subtyping (static duck typing).</p>
</div>
<div class="section" id="rationale-and-goals">
<span id="rationale"></span><h1><a class="toc-backref" href="#id17">Rationale and Goals</a></h1>
<p>Currently, <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a> and the <tt class="docutils literal">typing</tt> module <a class="citation-reference" href="#typing" id="id1">[typing]</a> define abstract
base classes for several common Python protocols such as <tt class="docutils literal">Iterable</tt> and
<tt class="docutils literal">Sized</tt>. The problem with them is that a class has to be explicitly marked
to support them, which is unpythonic and unlike what one would
normally do in idiomatic dynamically typed Python code. For example,
this conforms to <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a>:</p>
<pre class="literal-block">
from typing import Sized, Iterable, Iterator

class Bucket(Sized, Iterable[int]):
    ...
    def __len__(self) -&gt; int: ...
    def __iter__(self) -&gt; Iterator[int]: ...
</pre>
<p>The same problem appears with user-defined ABCs: they must be explicitly
subclassed or registered. This is particularly difficult to do with library
types as the type objects may be hidden deep in the implementation
of the library. Also, extensive use of ABCs might impose additional
runtime costs.</p>
<p>The intention of this PEP is to solve all these problems
by allowing users to write the above code without explicit base classes in
the class definition, allowing <tt class="docutils literal">Bucket</tt> to be implicitly considered
a subtype of both <tt class="docutils literal">Sized</tt> and <tt class="docutils literal">Iterable[int]</tt> by static type checkers
using structural <a class="citation-reference" href="#wiki-structural" id="id2">[wiki-structural]</a> subtyping:</p>
<pre class="literal-block">
from typing import Iterator, Iterable

class Bucket:
    ...
    def __len__(self) -&gt; int: ...
    def __iter__(self) -&gt; Iterator[int]: ...

def collect(items: Iterable[int]) -&gt; int: ...
result: int = collect(Bucket())  # Passes type check
</pre>
<p>Note that ABCs in <tt class="docutils literal">typing</tt> module already provide structural behavior
at runtime, <tt class="docutils literal"><span class="pre">isinstance(Bucket(),</span> Iterable)</tt> returns <tt class="docutils literal">True</tt>.
The main goal of this proposal is to support such behavior statically.
The same functionality will be provided for user-defined protocols, as
specified below. The above code with a protocol class matches common Python
conventions much better. It is also automatically extensible and works
with additional, unrelated classes that happen to implement
the required protocol.</p>
<div class="section" id="nominal-vs-structural-subtyping">
<h2><a class="toc-backref" href="#id18">Nominal vs structural subtyping</a></h2>
<p>Structural subtyping is natural for Python programmers since it matches
the runtime semantics of duck typing: an object that has certain properties
is treated independently of its actual runtime class.
However, as discussed in <a class="reference external" href="/dev/peps/pep-0483">PEP 483</a>, both nominal and structural
subtyping have their strengths and weaknesses. Therefore, in this PEP we
<em>do not propose</em> to replace the nominal subtyping described by <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a> with
structural subtyping completely. Instead, protocol classes as specified in
this PEP complement normal classes, and users are free to choose
where to apply a particular solution. See section on <a class="reference internal" href="#rejected">rejected</a> ideas at the
end of this PEP for additional motivation.</p>
</div>
<div class="section" id="non-goals">
<h2><a class="toc-backref" href="#id19">Non-goals</a></h2>
<p>At runtime, protocol classes will be simple ABCs. There is no intent to
provide sophisticated runtime instance and class checks against protocol
classes. This would be difficult and error-prone and will contradict the logic
of <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a>. As well, following <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a> and <a class="reference external" href="/dev/peps/pep-0526">PEP 526</a> we state that protocols are
<strong>completely optional</strong>:</p>
<ul class="simple">
<li>No runtime semantics will be imposed for variables or parameters annotated
with a protocol class.</li>
<li>Any checks will be performed only by third-party type checkers and
other tools.</li>
<li>Programmers are free to not use them even if they use type annotations.</li>
<li>There is no intent to make protocols non-optional in the future.</li>
</ul>
<p>To reiterate, providing complex runtime semantics for protocol classes
is not a goal of this PEP, the main goal is to provide a support and standards
for <em>static</em> structural subtyping. The possibility to use protocols
in the runtime context as ABCs is rather a minor bonus that exists mostly
to provide a seamless transition for projects that already use ABCs.</p>
</div>
</div>
<div class="section" id="existing-approaches-to-structural-subtyping">
<h1><a class="toc-backref" href="#id20">Existing Approaches to Structural Subtyping</a></h1>
<p>Before describing the actual specification, we review and comment on existing
approaches related to structural subtyping in Python and other languages:</p>
<ul>
<li><p class="first"><tt class="docutils literal">zope.interface</tt> <a class="citation-reference" href="#zope-interfaces" id="id3">[zope-interfaces]</a> was one of the first widely used
approaches to structural subtyping in Python. It is implemented by providing
special classes to distinguish interface classes from normal classes,
to mark interface attributes, and to explicitly declare implementation.
For example:</p>
<pre class="literal-block">
from zope.interface import Interface, Attribute, implementer

class IEmployee(Interface):

    name = Attribute(&quot;Name of employee&quot;)

    def do(work):
        &quot;&quot;&quot;Do some work&quot;&quot;&quot;

&#64;implementer(IEmployee)
class Employee:

    name = 'Anonymous'

    def do(self, work):
        return work.start()
</pre>
<p>Zope interfaces support various contracts and constraints for interface
classes. For example:</p>
<pre class="literal-block">
from zope.interface import invariant

def required_contact(obj):
    if not (obj.email or obj.phone):
        raise Exception(&quot;At least one contact info is required&quot;)

class IPerson(Interface):

    name = Attribute(&quot;Name&quot;)
    email = Attribute(&quot;Email Address&quot;)
    phone = Attribute(&quot;Phone Number&quot;)

    invariant(required_contact)
</pre>
<p>Even more detailed invariants are supported. However, Zope interfaces rely
entirely on runtime validation. Such focus on runtime properties goes
beyond the scope of the current proposal, and static support for invariants
might be difficult to implement. However, the idea of marking an interface
class with a special base class is reasonable and easy to implement both
statically and at runtime.</p>
</li>
<li><p class="first">Python abstract base classes <a class="citation-reference" href="#abstract-classes" id="id4">[abstract-classes]</a> are the standard
library tool to provide some functionality similar to structural subtyping.
The drawback of this approach is the necessity to either subclass
the abstract class or register an implementation explicitly:</p>
<pre class="literal-block">
from abc import ABC

class MyTuple(ABC):
    pass

MyTuple.register(tuple)

assert issubclass(tuple, MyTuple)
assert isinstance((), MyTuple)
</pre>
<p>As mentioned in the <a class="reference internal" href="#rationale">rationale</a>, we want to avoid such necessity, especially
in static context. However, in a runtime context, ABCs are good candidates for
protocol classes and they are already used extensively in
the <tt class="docutils literal">typing</tt> module.</p>
</li>
<li><p class="first">Abstract classes defined in <tt class="docutils literal">collections.abc</tt> module <a class="citation-reference" href="#collections-abc" id="id5">[collections-abc]</a>
are slightly more advanced since they implement a custom
<tt class="docutils literal">__subclasshook__()</tt> method that allows runtime structural checks without
explicit registration:</p>
<pre class="literal-block">
from collections.abc import Iterable

class MyIterable:
    def __iter__(self):
        return []

assert isinstance(MyIterable(), Iterable)
</pre>
<p>Such behavior seems to be a perfect fit for both runtime and static behavior
of protocols. As discussed in <a class="reference internal" href="#rationale">rationale</a>, we propose to add static support
for such behavior. In addition, to allow users to achieve such runtime
behavior for <em>user-defined</em> protocols a special <tt class="docutils literal">&#64;runtime</tt> decorator will
be provided, see detailed <a class="reference internal" href="#discussion">discussion</a> below.</p>
</li>
<li><p class="first">TypeScript <a class="citation-reference" href="#typescript" id="id6">[typescript]</a> provides support for user-defined classes and
interfaces. Explicit implementation declaration is not required and
structural subtyping is verified statically. For example:</p>
<pre class="literal-block">
interface LabeledItem {
    label: string;
    size?: int;
}

function printLabel(obj: LabeledItem) {
    console.log(obj.label);
}

let myObj = {size: 10, label: &quot;Size 10 Object&quot;};
printLabel(myObj);
</pre>
<p>Note that optional interface members are supported. Also, TypeScript
prohibits redundant members in implementations. While the idea of
optional members looks interesting, it would complicate this proposal and
it is not clear how useful it will be. Therefore it is proposed to postpone
this; see <a class="reference internal" href="#rejected">rejected</a> ideas. In general, the idea of static protocol
checking without runtime implications looks reasonable, and basically
this proposal follows the same line.</p>
</li>
<li><p class="first">Go <a class="citation-reference" href="#golang" id="id7">[golang]</a> uses a more radical approach and makes interfaces the primary
way to provide type information. Also, assignments are used to explicitly
ensure implementation:</p>
<pre class="literal-block">
type SomeInterface interface {
    SomeMethod() ([]byte, error)
}

if _, ok := someval.(SomeInterface); ok {
    fmt.Printf(&quot;value implements some interface&quot;)
}
</pre>
<p>Both these ideas are questionable in the context of this proposal. See
the section on <a class="reference internal" href="#rejected">rejected</a> ideas.</p>
</li>
</ul>
</div>
<div class="section" id="id8">
<span id="specification"></span><h1><a class="toc-backref" href="#id21">Specification</a></h1>
<div class="section" id="terminology">
<h2><a class="toc-backref" href="#id22">Terminology</a></h2>
<p>We propose to use the term <em>protocols</em> for types supporting structural
subtyping. The reason is that the term <em>iterator protocol</em>,
for example, is widely understood in the community, and coming up with
a new term for this concept in a statically typed context would just create
confusion.</p>
<p>This has the drawback that the term <em>protocol</em> becomes overloaded with
two subtly different meanings: the first is the traditional, well-known but
slightly fuzzy concept of protocols such as iterator; the second is the more
explicitly defined concept of protocols in statically typed code.
The distinction is not important most of the time, and in other
cases we propose to just add a qualifier such as <em>protocol classes</em>
when referring to the static type concept.</p>
<p>If a class includes a protocol in its MRO, the class is called
an <em>explicit</em> subclass of the protocol. If a class is a structural subtype
of a protocol, it is said to implement the protocol and to be compatible
with a protocol. If a class is compatible with a protocol but the protocol
is not included in the MRO, the class is an <em>implicit</em> subtype
of the protocol. (Note that one can explicitly subclass a protocol and
still not implement it if a protocol attribute is set to <tt class="docutils literal">None</tt>
in the subclass, see Python <a class="citation-reference" href="#data-model" id="id9">[data-model]</a> for details.)</p>
<p>The attributes (variables and methods) of a protocol that are mandatory
for other class in order to be considered a structural subtype are called
protocol members.</p>
</div>
<div class="section" id="defining-a-protocol">
<span id="definition"></span><h2><a class="toc-backref" href="#id23">Defining a protocol</a></h2>
<p>Protocols are defined by including a special new class <tt class="docutils literal">typing.Protocol</tt>
(an instance of <tt class="docutils literal">abc.ABCMeta</tt>) in the base classes list, typically
at the end of the list. Here is a simple example:</p>
<pre class="literal-block">
from typing import Protocol

class SupportsClose(Protocol):
    def close(self) -&gt; None:
        ...
</pre>
<p>Now if one defines a class <tt class="docutils literal">Resource</tt> with a <tt class="docutils literal">close()</tt> method that has
a compatible signature, it would implicitly be a subtype of
<tt class="docutils literal">SupportsClose</tt>, since the structural subtyping is used for
protocol types:</p>
<pre class="literal-block">
class Resource:
    ...
    def close(self) -&gt; None:
        self.file.close()
        self.lock.release()
</pre>
<p>Apart from few restrictions explicitly mentioned below, protocol types can
be used in every context where a normal types can:</p>
<pre class="literal-block">
def close_all(things: Iterable[SupportsClose]) -&gt; None:
    for t in things:
        t.close()

f = open('foo.txt')
r = Resource()
close_all([f, r])  # OK!
close_all([1])     # Error: 'int' has no 'close' method
</pre>
<p>Note that both the user-defined class <tt class="docutils literal">Resource</tt> and the built-in
<tt class="docutils literal">IO</tt> type (the return type of <tt class="docutils literal">open()</tt>) are considered subtypes of
<tt class="docutils literal">SupportsClose</tt>, because they provide a <tt class="docutils literal">close()</tt> method with
a compatible type signature.</p>
</div>
<div class="section" id="protocol-members">
<h2><a class="toc-backref" href="#id24">Protocol members</a></h2>
<p>All methods defined in the protocol class body are protocol members, both
normal and decorated with <tt class="docutils literal">&#64;abstractmethod</tt>. If any parameters of a
protocol method are not annotated, then their types are assumed to be <tt class="docutils literal">Any</tt>
(see <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a>). Bodies of protocol methods are type checked.
An abstract method that should not be called via <tt class="docutils literal">super()</tt> ought to raise
<tt class="docutils literal">NotImplementedError</tt>. Example:</p>
<pre class="literal-block">
from typing import Protocol
from abc import abstractmethod

class Example(Protocol):
    def first(self) -&gt; int:     # This is a protocol member
        return 42

    &#64;abstractmethod
    def second(self) -&gt; int:    # Method without a default implementation
        raise NotImplementedError
</pre>
<p>Static methods, class methods, and properties are equally allowed
in protocols.</p>
<p>To define a protocol variable, one can use <a class="reference external" href="/dev/peps/pep-0526">PEP 526</a> variable
annotations in the class body. Additional attributes <em>only</em> defined in
the body of a method by assignment via <tt class="docutils literal">self</tt> are not allowed. The rationale
for this is that the protocol class implementation is often not shared by
subtypes, so the interface should not depend on the default implementation.
Examples:</p>
<pre class="literal-block">
from typing import Protocol, List

class Template(Protocol):
    name: str        # This is a protocol member
    value: int = 0   # This one too (with default)

    def method(self) -&gt; None:
        self.temp: List[int] = [] # Error in type checker

class Concrete:
    def __init__(self, name: str, value: int) -&gt; None:
        self.name = name
        self.value = value

var: Template = Concrete('value', 42)  # OK
</pre>
<p>To distinguish between protocol class variables and protocol instance
variables, the special <tt class="docutils literal">ClassVar</tt> annotation should be used as specified
by <a class="reference external" href="/dev/peps/pep-0526">PEP 526</a>. By default, protocol variables as defined above are considered
readable and writable. To define a read-only protocol variable, one can use
an (abstract) property.</p>
</div>
<div class="section" id="explicitly-declaring-implementation">
<h2><a class="toc-backref" href="#id25">Explicitly declaring implementation</a></h2>
<p>To explicitly declare that a certain class implements a given protocol,
it can be used as a regular base class. In this case a class could use
default implementations of protocol members. <tt class="docutils literal">typing.Sequence</tt> is a good
example of a protocol with useful default methods. Static analysis tools are
expected to automatically detect that a class implements a given protocol.
So while it's possible to subclass a protocol explicitly, it's <em>not necessary</em>
to do so for the sake of type-checking.</p>
<p>The default implementations cannot be used if
the subtype relationship is implicit and only via structural
subtyping -- the semantics of inheritance is not changed. Examples:</p>
<pre class="literal-block">
class PColor(Protocol):
    &#64;abstractmethod
    def draw(self) -&gt; str:
        ...
    def complex_method(self) -&gt; int:
        # some complex code here

class NiceColor(PColor):
    def draw(self) -&gt; str:
        return &quot;deep blue&quot;

class BadColor(PColor):
    def draw(self) -&gt; str:
        return super().draw()  # Error, no default implementation

class ImplicitColor:   # Note no 'PColor' base here
    def draw(self) -&gt; str:
        return &quot;probably gray&quot;
    def comlex_method(self) -&gt; int:
        # class needs to implement this

nice: NiceColor
another: ImplicitColor

def represent(c: PColor) -&gt; None:
    print(c.draw(), c.complex_method())

represent(nice) # OK
represent(another) # Also OK
</pre>
<p>Note that there is little difference between explicit and implicit
subtypes, the main benefit of explicit subclassing is to get some protocol
methods &quot;for free&quot;. In addition, type checkers can statically verify that
the class actually implements the protocol correctly:</p>
<pre class="literal-block">
class RGB(Protocol):
    rgb: Tuple[int, int, int]

    &#64;abstractmethod
    def intensity(self) -&gt; int:
        return 0

class Point(RGB):
    def __init__(self, red: int, green: int, blue: str) -&gt; None:
        self.rgb = red, green, blue  # Error, 'blue' must be 'int'

    # Type checker might warn that 'intensity' is not defined
</pre>
<p>A class can explicitly inherit from multiple protocols and also from normal
classes. In this case methods are resolved using normal MRO and a type checker
verifies that all subtyping are correct. The semantics of <tt class="docutils literal">&#64;abstractmethod</tt>
is not changed, all of them must be implemented by an explicit subclass
before it can be instantiated.</p>
</div>
<div class="section" id="merging-and-extending-protocols">
<h2><a class="toc-backref" href="#id26">Merging and extending protocols</a></h2>
<p>The general philosophy is that protocols are mostly like regular ABCs,
but a static type checker will handle them specially. Subclassing a protocol
class would not turn the subclass into a protocol unless it also has
<tt class="docutils literal">typing.Protocol</tt> as an explicit base class. Without this base, the class
is &quot;downgraded&quot; to a regular ABC that cannot be used with structural
subtyping. The rationale for this rule is that we don't want to accidentally
have some class act as a protocol just because one of its base classes
happens to be one. We still slightly prefer nominal subtyping over structural
subtyping in the static typing world.</p>
<p>A subprotocol can be defined by having <em>both</em> one or more protocols as
immediate base classes and also having <tt class="docutils literal">typing.Protocol</tt> as an immediate
base class:</p>
<pre class="literal-block">
from typing import Sized, Protocol

class SizedAndClosable(Sized, Protocol):
    def close(self) -&gt; None:
        ...
</pre>
<p>Now the protocol <tt class="docutils literal">SizedAndClosable</tt> is a protocol with two methods,
<tt class="docutils literal">__len__</tt> and <tt class="docutils literal">close</tt>. If one omits <tt class="docutils literal">Protocol</tt> in the base class list,
this would be a regular (non-protocol) class that must implement <tt class="docutils literal">Sized</tt>.
Alternatively, one can implement <tt class="docutils literal">SizedAndClosable</tt> protocol by merging
the <tt class="docutils literal">SupportsClose</tt> protocol from the example in the <a class="reference internal" href="#definition">definition</a> section
with <tt class="docutils literal">typing.Sized</tt>:</p>
<pre class="literal-block">
from typing import Sized

class SupportsClose(Protocol):
    def close(self) -&gt; None:
        ...

class SizedAndClosable(Sized, SupportsClose, Protocol):
    pass
</pre>
<p>The two definitions of <tt class="docutils literal">SizedAndClosable</tt> are equivalent.
Subclass relationships between protocols are not meaningful when
considering subtyping, since structural compatibility is
the criterion, not the MRO.</p>
<p>If <tt class="docutils literal">Protocol</tt> is included in the base class list, all the other base classes
must be protocols. A protocol can't extend a regular class, see <a class="reference internal" href="#rejected">rejected</a>
ideas for rationale. Note that rules around explicit subclassing are different
from regular ABCs, where abstractness is simply defined by having at least one
abstract method being unimplemented. Protocol classes must be marked
<em>explicitly</em>.</p>
</div>
<div class="section" id="generic-protocols">
<h2><a class="toc-backref" href="#id27">Generic protocols</a></h2>
<p>Generic protocols are important. For example, <tt class="docutils literal">SupportsAbs</tt>, <tt class="docutils literal">Iterable</tt>
and <tt class="docutils literal">Iterator</tt> are generic protocols. They are defined similar to normal
non-protocol generic types:</p>
<pre class="literal-block">
class Iterable(Protocol[T]):
    &#64;abstractmethod
    def __iter__(self) -&gt; Iterator[T]:
        ...
</pre>
<p><tt class="docutils literal">Protocol[T, S, <span class="pre">...]</span></tt> is allowed as a shorthand for
<tt class="docutils literal">Protocol, Generic[T, S, <span class="pre">...]</span></tt>.</p>
<p>User-defined generic protocols support explicitly declared variance.
Type checkers will warn if the inferred variance is different from
the declared variance. Examples:</p>
<pre class="literal-block">
T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)

class Box(Protocol[T_co]):
    def content(self) -&gt; T_co:
        ...

box: Box[float]
second_box: Box[int]
box = second_box  # This is OK due to the covariance of 'Box'.

class Sender(Protocol[T_contra]):
    def send(self, data: T_contra) -&gt; int:
        ...

sender: Sender[float]
new_sender: Sender[int]
new_sender = sender  # OK, 'Sender' is contravariant.

class Proto(Protocol[T]):
    attr: T  # this class is invariant, since it has a mutable attribute

var: Proto[float]
another_var: Proto[int]
var = another_var  # Error! 'Proto[float]' is incompatible with 'Proto[int]'.
</pre>
<p>Note that unlike nominal classes, de-facto covariant protocols cannot be
declared as invariant, since this can break transitivity of subtyping
(see <a class="reference internal" href="#rejected">rejected</a> ideas for details). For example:</p>
<pre class="literal-block">
T = TypeVar('T')

class AnotherBox(Protocol[T]):  # Error, this protocol is covariant in T,
    def content(self) -&gt; T:     # not invariant.
        ...
</pre>
</div>
<div class="section" id="recursive-protocols">
<h2><a class="toc-backref" href="#id28">Recursive protocols</a></h2>
<p>Recursive protocols are also supported. Forward references to the protocol
class names can be given as strings as specified by <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a>. Recursive
protocols are useful for representing self-referential data structures
like trees in an abstract fashion:</p>
<pre class="literal-block">
class Traversable(Protocol):
    def leaves(self) -&gt; Iterable['Traversable']:
        ...
</pre>
<p>Note that for recursive protocols, a class is considered a subtype of
the protocol in situations where the decision depends on itself.
Continuing the previous example:</p>
<pre class="literal-block">
class SimpleTree:
    def leaves(self) -&gt; List['SimpleTree']:
        ...

root: Traversable = SimpleTree()  # OK

class Tree(Generic[T]):
    def leaves(self) -&gt; List['Tree[T]']:
        ...

def walk(graph: Traversable) -&gt; None:
    ...
tree: Tree[float] = Tree()
walk(tree)  # OK, 'Tree[float]' is a subtype of 'Traversable'
</pre>
</div>
</div>
<div class="section" id="using-protocols">
<h1><a class="toc-backref" href="#id29">Using Protocols</a></h1>
<div class="section" id="subtyping-relationships-with-other-types">
<h2><a class="toc-backref" href="#id30">Subtyping relationships with other types</a></h2>
<p>Protocols cannot be instantiated, so there are no values whose
runtime type is a protocol. For variables and parameters with protocol types,
subtyping relationships are subject to the following rules:</p>
<ul class="simple">
<li>A protocol is never a subtype of a concrete type.</li>
<li>A concrete type <tt class="docutils literal">X</tt> is a subtype of protocol <tt class="docutils literal">P</tt>
if and only if <tt class="docutils literal">X</tt> implements all protocol members of <tt class="docutils literal">P</tt> with
compatible types. In other words, subtyping with respect to a protocol is
always structural.</li>
<li>A protocol <tt class="docutils literal">P1</tt> is a subtype of another protocol <tt class="docutils literal">P2</tt> if <tt class="docutils literal">P1</tt> defines
all protocol members of <tt class="docutils literal">P2</tt> with compatible types.</li>
</ul>
<p>Generic protocol types follow the same rules of variance as non-protocol
types. Protocol types can be used in all contexts where any other types
can be used, such as in <tt class="docutils literal">Union</tt>, <tt class="docutils literal">ClassVar</tt>, type variables bounds, etc.
Generic protocols follow the rules for generic abstract classes, except for
using structural compatibility instead of compatibility defined by
inheritance relationships.</p>
<p>Static type checkers will recognize protocol implementations, even if the
corresponding protocols are <em>not imported</em>:</p>
<pre class="literal-block">
# file lib.py
from typing import Sized

T = TypeVar('T', contravariant=True)
class ListLike(Sized, Protocol[T]):
    def append(self, x: T) -&gt; None:
        pass

def populate(lst: ListLike[int]) -&gt; None:
    ...

# file main.py
from lib import populate  # Note that ListLike is NOT imported

class MockStack:
    def __len__(self) -&gt; int:
        return 42
    def append(self, x: int) -&gt; None:
        print(x)

populate([1, 2, 3])    # Passes type check
populate(MockStack())  # Also OK
</pre>
</div>
<div class="section" id="unions-and-intersections-of-protocols">
<h2><a class="toc-backref" href="#id31">Unions and intersections of protocols</a></h2>
<p><tt class="docutils literal">Union</tt> of protocol classes behaves the same way as for non-protocol
classes. For example:</p>
<pre class="literal-block">
from typing import Union, Optional, Protocol

class Exitable(Protocol):
    def exit(self) -&gt; int:
        ...
class Quittable(Protocol):
    def quit(self) -&gt; Optional[int]:
        ...

def finish(task: Union[Exitable, Quittable]) -&gt; int:
    ...
class DefaultJob:
    ...
    def quit(self) -&gt; int:
        return 0
finish(DefaultJob()) # OK
</pre>
<p>One can use multiple inheritance to define an intersection of protocols.
Example:</p>
<pre class="literal-block">
from typing import Sequence, Hashable

class HashableFloats(Sequence[float], Hashable, Protocol):
    pass

def cached_func(args: HashableFloats) -&gt; float:
    ...
cached_func((1, 2, 3)) # OK, tuple is both hashable and sequence
</pre>
<p>If this will prove to be a widely used scenario, then a special
intersection type construct could be added in future as specified by <a class="reference external" href="/dev/peps/pep-0483">PEP 483</a>,
see <a class="reference internal" href="#rejected">rejected</a> ideas for more details.</p>
</div>
<div class="section" id="type-with-protocols">
<h2><a class="toc-backref" href="#id32"><tt class="docutils literal">Type[]</tt> with protocols</a></h2>
<p>Variables and parameters annotated with <tt class="docutils literal">Type[Proto]</tt> accept only concrete
(non-protocol) subtypes of <tt class="docutils literal">Proto</tt>. The main reason for this is to allow
instantiation of parameters with such type. For example:</p>
<pre class="literal-block">
class Proto(Protocol):
    &#64;abstractmethod
    def meth(self) -&gt; int:
        ...
class Concrete:
    def meth(self) -&gt; int:
        return 42

def fun(cls: Type[Proto]) -&gt; int:
    return cls().meth() # OK
fun(Proto)              # Error
fun(Concrete)           # OK
</pre>
<p>The same rule applies to variables:</p>
<pre class="literal-block">
var: Type[Proto]
var = Proto    # Error
var = Concrete # OK
var().meth()   # OK
</pre>
<p>Assigning an ABC or a protocol class to a variable is allowed if it is
not explicitly typed, and such assignment creates a type alias.
For normal (non-abstract) classes, the behavior of <tt class="docutils literal">Type[]</tt> is
not changed.</p>
</div>
<div class="section" id="newtype-and-type-aliases">
<h2><a class="toc-backref" href="#id33"><tt class="docutils literal">NewType()</tt> and type aliases</a></h2>
<p>Protocols are essentially anonymous. To emphasize this point, static type
checkers might refuse protocol classes inside <tt class="docutils literal">NewType()</tt> to avoid an
illusion that a distinct type is provided:</p>
<pre class="literal-block">
from typing import NewType, Protocol, Iterator

class Id(Protocol):
    code: int
    secrets: Iterator[bytes]

UserId = NewType('UserId', Id)  # Error, can't provide distinct type
</pre>
<p>In contrast, type aliases are fully supported, including generic type
aliases:</p>
<pre class="literal-block">
from typing import TypeVar, Reversible, Iterable, Sized

T = TypeVar('T')
class SizedIterable(Iterable[T], Sized, Protocol):
    pass
CompatReversible = Union[Reversible[T], SizedIterable[T]]
</pre>
</div>
<div class="section" id="runtime-decorator-and-narrowing-types-by-isinstance">
<span id="discussion"></span><h2><a class="toc-backref" href="#id34"><tt class="docutils literal">&#64;runtime</tt> decorator and narrowing types by <tt class="docutils literal">isinstance()</tt></a></h2>
<p>The default semantics is that <tt class="docutils literal">isinstance()</tt> and <tt class="docutils literal">issubclass()</tt> fail
for protocol types. This is in the spirit of duck typing -- protocols
basically would be used to model duck typing statically, not explicitly
at runtime.</p>
<p>However, it should be possible for protocol types to implement custom
instance and class checks when this makes sense, similar to how <tt class="docutils literal">Iterable</tt>
and other ABCs in <tt class="docutils literal">collections.abc</tt> and <tt class="docutils literal">typing</tt> already do it,
but this is limited to non-generic and unsubscripted generic protocols
(<tt class="docutils literal">Iterable</tt> is statically equivalent to <tt class="docutils literal"><span class="pre">Iterable[Any]`).</span>
The ``typing</tt> module will define a special <tt class="docutils literal">&#64;runtime</tt> class decorator
that provides the same semantics for class and instance checks as for
<tt class="docutils literal">collections.abc</tt> classes, essentially making them &quot;runtime protocols&quot;:</p>
<pre class="literal-block">
from typing import runtime, Protocol

&#64;runtime
class Closable(Protocol):
    def close(self):
        ...

assert isinstance(open('some/file'), Closable)
</pre>
<p>Static type checkers will understand <tt class="docutils literal">isinstance(x, Proto)</tt> and
<tt class="docutils literal">issubclass(C, Proto)</tt> for protocols defined with this decorator (as they
already do for <tt class="docutils literal">Iterable</tt> etc.). Static type checkers will narrow types
after such checks by the type erased <tt class="docutils literal">Proto</tt> (i.e. with all variables
having type <tt class="docutils literal">Any</tt> and all methods having type <tt class="docutils literal"><span class="pre">Callable[...,</span> Any]</tt>).
Note that <tt class="docutils literal">isinstance(x, Proto[int])</tt> etc. will always fail in agreement
with <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a>. Examples:</p>
<pre class="literal-block">
from typing import Iterable, Iterator, Sequence

def process(items: Iterable[int]) -&gt; None:
    if isinstance(items, Iterator):
        # 'items' has type 'Iterator[int]' here
    elif isinstance(items, Sequence[int]):
        # Error! Can't use 'isinstance()' with subscripted protocols
</pre>
<p>Note that instance checks are not 100% reliable statically, this is why
this behavior is opt-in, see section on <a class="reference internal" href="#rejected">rejected</a> ideas for examples.</p>
</div>
</div>
<div class="section" id="using-protocols-in-python-2-7-3-5">
<h1><a class="toc-backref" href="#id35">Using Protocols in Python 2.7 - 3.5</a></h1>
<p>Variable annotation syntax was added in Python 3.6, so that the syntax
for defining protocol variables proposed in <a class="reference internal" href="#specification">specification</a> section can't
be used if support for earlier versions is needed. To define these
in a manner compatible with older versions of Python one can use properties.
Properties can be settable and/or abstract if needed:</p>
<pre class="literal-block">
class Foo(Protocol):
    &#64;property
    def c(self) -&gt; int:
        return 42         # Default value can be provided for property...

    &#64;abstractproperty
    def d(self) -&gt; int:   # ... or it can be abstract
        return 0
</pre>
<p>Also function type comments can be used as per <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a> (for example
to provide compatibility with Python 2). The <tt class="docutils literal">typing</tt> module changes
proposed in this PEP will also be backported to earlier versions via the
backport currently available on PyPI.</p>
</div>
<div class="section" id="runtime-implementation-of-protocol-classes">
<h1><a class="toc-backref" href="#id36">Runtime Implementation of Protocol Classes</a></h1>
<div class="section" id="implementation-details">
<h2><a class="toc-backref" href="#id37">Implementation details</a></h2>
<p>The runtime implementation could be done in pure Python without any
effects on the core interpreter and standard library except in the
<tt class="docutils literal">typing</tt> module, and a minor update to <tt class="docutils literal">collections.abc</tt>:</p>
<ul class="simple">
<li>Define class <tt class="docutils literal">typing.Protocol</tt> similar to <tt class="docutils literal">typing.Generic</tt>.</li>
<li>Implement metaclass functionality to detect whether a class is
a protocol or not. Add a class attribute <tt class="docutils literal">_is_protocol = True</tt>
if that is the case. Verify that a protocol class only has protocol
base classes in the MRO (except for object).</li>
<li>Implement <tt class="docutils literal">&#64;runtime</tt> that allows <tt class="docutils literal">__subclasshook__()</tt> performing
structural instance and subclass checks as in <tt class="docutils literal">collections.abc</tt> classes.</li>
<li>All structural subtyping checks will be performed by static type checkers,
such as <tt class="docutils literal">mypy</tt> <a class="citation-reference" href="#mypy" id="id10">[mypy]</a>. No additional support for protocol validation will
be provided at runtime.</li>
<li>Classes <tt class="docutils literal">Mapping</tt>, <tt class="docutils literal">MutableMapping</tt>, <tt class="docutils literal">Sequence</tt>, and
<tt class="docutils literal">MutableSequence</tt> in <tt class="docutils literal">collections.abc</tt> module will support structural
instance and subclass checks (like e.g. <tt class="docutils literal">collections.abc.Iterable</tt>).</li>
</ul>
</div>
<div class="section" id="changes-in-the-typing-module">
<h2><a class="toc-backref" href="#id38">Changes in the typing module</a></h2>
<p>The following classes in <tt class="docutils literal">typing</tt> module will be protocols:</p>
<ul class="simple">
<li><tt class="docutils literal">Callable</tt></li>
<li><tt class="docutils literal">Awaitable</tt></li>
<li><tt class="docutils literal">Iterable</tt>, <tt class="docutils literal">Iterator</tt></li>
<li><tt class="docutils literal">AsyncIterable</tt>, <tt class="docutils literal">AsyncIterator</tt></li>
<li><tt class="docutils literal">Hashable</tt></li>
<li><tt class="docutils literal">Sized</tt></li>
<li><tt class="docutils literal">Container</tt></li>
<li><tt class="docutils literal">Collection</tt></li>
<li><tt class="docutils literal">Reversible</tt></li>
<li><tt class="docutils literal">Sequence</tt>, <tt class="docutils literal">MutableSequence</tt></li>
<li><tt class="docutils literal">Mapping</tt>, <tt class="docutils literal">MutableMapping</tt></li>
<li><tt class="docutils literal">ContextManager</tt>, <tt class="docutils literal">AsyncContextManager</tt></li>
<li><tt class="docutils literal">SupportsAbs</tt> (and other <tt class="docutils literal">Supports*</tt> classes)</li>
</ul>
<p>Most of these classes are small and conceptually simple. It is easy to see
what are the methods these protocols implement, and immediately recognize
the corresponding runtime protocol counterpart.
Practically, few changes will be needed in <tt class="docutils literal">typing</tt> since some of these
classes already behave the necessary way at runtime. Most of these will need
to be updated only in the corresponding <tt class="docutils literal">typeshed</tt> stubs <a class="citation-reference" href="#typeshed" id="id11">[typeshed]</a>.</p>
<p>All other concrete generic classes such as <tt class="docutils literal">List</tt>, <tt class="docutils literal">Set</tt>, <tt class="docutils literal">IO</tt>,
<tt class="docutils literal">Deque</tt>, etc are sufficiently complex that it makes sense to keep
them non-protocols (i.e. require code to be explicit about them). Also, it is
too easy to leave some methods unimplemented by accident, and explicitly
marking the subclass relationship allows type checkers to pinpoint the missing
implementations.</p>
</div>
<div class="section" id="introspection">
<h2><a class="toc-backref" href="#id39">Introspection</a></h2>
<p>The existing class introspection machinery (<tt class="docutils literal">dir</tt>, <tt class="docutils literal">__annotations__</tt> etc)
can be used with protocols. In addition, all introspection tools implemented
in the <tt class="docutils literal">typing</tt> module will support protocols. Since all attributes need
to be defined in the class body based on this proposal, protocol classes will
have even better perspective for introspection than regular classes where
attributes can be defined implicitly -- protocol attributes can't be
initialized in ways that are not visible to introspection
(using <tt class="docutils literal">setattr()</tt>, assignment via <tt class="docutils literal">self</tt>, etc.). Still, some things like
types of attributes will not be visible at runtime in Python 3.5 and earlier,
but this looks like a reasonable limitation.</p>
<p>There will be only limited support of <tt class="docutils literal">isinstance()</tt> and <tt class="docutils literal">issubclass()</tt>
as discussed above (these will <em>always</em> fail with <tt class="docutils literal">TypeError</tt> for
subscripted generic protocols, since a reliable answer could not be given
at runtime in this case). But together with other introspection tools this
give a reasonable perspective for runtime type checking tools.</p>
</div>
</div>
<div class="section" id="rejected-postponed-ideas">
<span id="rejected"></span><h1><a class="toc-backref" href="#id40">Rejected/Postponed Ideas</a></h1>
<p>The ideas in this section were previously discussed in <a class="citation-reference" href="#several" id="id12">[several]</a>
<a class="citation-reference" href="#discussions" id="id13">[discussions]</a> <a class="citation-reference" href="#elsewhere" id="id14">[elsewhere]</a>.</p>
<div class="section" id="make-every-class-a-protocol-by-default">
<h2><a class="toc-backref" href="#id41">Make every class a protocol by default</a></h2>
<p>Some languages such as Go make structural subtyping the only or the primary
form of subtyping. We could achieve a similar result by making all classes
protocols by default (or even always). However we believe that it is better
to require classes to be explicitly marked as protocols, for the following
reasons:</p>
<ul class="simple">
<li>Protocols don't have some properties of regular classes. In particular,
<tt class="docutils literal">isinstance()</tt>, as defined for normal classes, is based on the nominal
hierarchy. In order to make everything a protocol by default, and have
<tt class="docutils literal">isinstance()</tt> work would require changing its semantics,
which won't happen.</li>
<li>Protocol classes should generally not have many method implementations,
as they describe an interface, not an implementation.
Most classes have many method implementations, making them bad protocol
classes.</li>
<li>Experience suggests that many classes are not practical as protocols anyway,
mainly because their interfaces are too large, complex or
implementation-oriented (for example, they may include de facto
private attributes and methods without a <tt class="docutils literal">__</tt> prefix).</li>
<li>Most actually useful protocols in existing Python code seem to be implicit.
The ABCs in <tt class="docutils literal">typing</tt> and <tt class="docutils literal">collections.abc</tt> are rather an exception, but
even they are recent additions to Python and most programmers
do not use them yet.</li>
<li>Many built-in functions only accept concrete instances of <tt class="docutils literal">int</tt>
(and subclass instances), and similarly for other built-in classes. Making
<tt class="docutils literal">int</tt> a structural type wouldn't be safe without major changes to the
Python runtime, which won't happen.</li>
</ul>
</div>
<div class="section" id="protocols-subclassing-normal-classes">
<h2><a class="toc-backref" href="#id42">Protocols subclassing normal classes</a></h2>
<p>The main rationale to prohibit this is to preserve transitivity of subtyping,
consider this example:</p>
<pre class="literal-block">
from typing import Protocol

class Base:
    attr: str

class Proto(Base, Protocol):
    def meth(self) -&gt; int:
        ...

class C:
    attr: str
    def meth(self) -&gt; int:
        return 0
</pre>
<p>Now, <tt class="docutils literal">C</tt> is a subtype of <tt class="docutils literal">Proto</tt>, and <tt class="docutils literal">Proto</tt> is a subtype of <tt class="docutils literal">Base</tt>.
But <tt class="docutils literal">C</tt> cannot be a subtype of <tt class="docutils literal">Base</tt> (since the latter is not
a protocol). This situation would be really weird. In addition, there is
an ambiguity about whether attributes of <tt class="docutils literal">Base</tt> should become protocol
members of <tt class="docutils literal">Proto</tt>.</p>
</div>
<div class="section" id="support-optional-protocol-members">
<h2><a class="toc-backref" href="#id43">Support optional protocol members</a></h2>
<p>We can come up with examples where it would be handy to be able to say
that a method or data attribute does not need to be present in a class
implementing a protocol, but if it is present, it must conform to a specific
signature or type. One could use a <tt class="docutils literal">hasattr()</tt> check to determine whether
they can use the attribute on a particular instance.</p>
<p>Languages such as TypeScript have similar features and
apparently they are pretty commonly used. The current realistic potential
use cases for protocols in Python don't require these. In the interest
of simplicity, we propose to not support optional methods or attributes.
We can always revisit this later if there is an actual need.</p>
</div>
<div class="section" id="allow-only-protocol-methods-and-force-use-of-getters-and-setters">
<h2><a class="toc-backref" href="#id44">Allow only protocol methods and force use of getters and setters</a></h2>
<p>One could argue that protocols typically only define methods, but not
variables. However, using getters and setters in cases where only a
simple variable is needed would be quite unpythonic. Moreover, the widespread
use of properties (that often act as type validators) in large code bases
is partially due to previous absence of static type checkers for Python,
the problem that <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a> and this PEP are aiming to solve. For example:</p>
<pre class="literal-block">
# without static types

class MyClass:
    &#64;property
    def my_attr(self):
        return self._my_attr
    &#64;my_attr.setter
    def my_attr(self, value):
        if not isinstance(value, int):
            raise ValidationError(&quot;An integer expected for my_attr&quot;)
        self._my_attr = value

# with static types

class MyClass:
    my_attr: int
</pre>
</div>
<div class="section" id="support-non-protocol-members">
<h2><a class="toc-backref" href="#id45">Support non-protocol members</a></h2>
<p>There was an idea to make some methods &quot;non-protocol&quot; (i.e. not necessary
to implement, and inherited in explicit subclassing), but it was rejected,
since this complicates things. For example, consider this situation:</p>
<pre class="literal-block">
class Proto(Protocol):
    &#64;abstractmethod
    def first(self) -&gt; int:
        raise NotImplementedError
    def second(self) -&gt; int:
        return self.first() + 1

def fun(arg: Proto) -&gt; None:
    arg.second()
</pre>
<p>The question is should this be an error? We think most people would expect
this to be valid. Therefore, to be on the safe side, we need to require both
methods to be implemented in implicit subclasses. In addition, if one looks
at definitions in <tt class="docutils literal">collections.abc</tt>, there are very few methods that could
be considered &quot;non-protocol&quot;. Therefore, it was decided to not introduce
&quot;non-protocol&quot; methods.</p>
<p>There is only one downside to this: it will require some boilerplate for
implicit subtypes of <tt class="docutils literal">Mapping</tt> and few other &quot;large&quot; protocols. But, this
applies to few &quot;built-in&quot; protocols (like <tt class="docutils literal">Mapping</tt> and <tt class="docutils literal">Sequence</tt>) and
people are already subclassing them. Also, such style is discouraged for
user-defined protocols. It is recommended to create compact protocols and
combine them.</p>
</div>
<div class="section" id="make-protocols-interoperable-with-other-approaches">
<h2><a class="toc-backref" href="#id46">Make protocols interoperable with other approaches</a></h2>
<p>The protocols as described here are basically a minimal extension to
the existing concept of ABCs. We argue that this is the way they should
be understood, instead of as something that <em>replaces</em> Zope interfaces,
for example. Attempting such interoperabilities will significantly
complicate both the concept and the implementation.</p>
<p>On the other hand, Zope interfaces are conceptually a superset of protocols
defined here, but using an incompatible syntax to define them,
because before <a class="reference external" href="/dev/peps/pep-0526">PEP 526</a> there was no straightforward way to annotate attributes.
In the 3.6+ world, <tt class="docutils literal">zope.interface</tt> might potentially adopt the <tt class="docutils literal">Protocol</tt>
syntax. In this case, type checkers could be taught to recognize interfaces
as protocols and make simple structural checks with respect to them.</p>
</div>
<div class="section" id="use-assignments-to-check-explicitly-that-a-class-implements-a-protocol">
<h2><a class="toc-backref" href="#id47">Use assignments to check explicitly that a class implements a protocol</a></h2>
<p>In the Go language the explicit checks for implementation are performed
via dummy assignments <a class="citation-reference" href="#golang" id="id15">[golang]</a>. Such a way is also possible with the
current proposal. Example:</p>
<pre class="literal-block">
class A:
    def __len__(self) -&gt; float:
        return ...

_: Sized = A()  # Error: A.__len__ doesn't conform to 'Sized'
                # (Incompatible return type 'float')
</pre>
<p>This approach moves the check away from
the class definition and it almost requires a comment as otherwise
the code probably would not make any sense to an average reader
-- it looks like dead code. Besides, in the simplest form it requires one
to construct an instance of <tt class="docutils literal">A</tt>, which could be problematic if this requires
accessing or allocating some resources such as files or sockets.
We could work around the latter by using a cast, for example, but then
the code would be ugly. Therefore we discourage the use of this pattern.</p>
</div>
<div class="section" id="support-isinstance-checks-by-default">
<h2><a class="toc-backref" href="#id48">Support <tt class="docutils literal">isinstance()</tt> checks by default</a></h2>
<p>The problem with this is instance checks could be unreliable, except for
situations where there is a common signature convention such as <tt class="docutils literal">Iterable</tt>.
For example:</p>
<pre class="literal-block">
class P(Protocol):
    def common_method_name(self, x: int) -&gt; int: ...

class X:
    &lt;a bunch of methods&gt;
    def common_method_name(self) -&gt; None: ... # Note different signature

def do_stuff(o: Union[P, X]) -&gt; int:
    if isinstance(o, P):
        return o.common_method_name(1)  # oops, what if it's an X instance?
</pre>
<p>Another potentially problematic case is assignment of attributes
<em>after</em> instantiation:</p>
<pre class="literal-block">
class P(Protocol):
    x: int

class C:
    def initialize(self) -&gt; None:
        self.x = 0

c = C()
isinstance(c1, P)  # False
c.initialize()
isinstance(c, P)  # True

def f(x: Union[P, int]) -&gt; None:
    if isinstance(x, P):
        # static type of x is P here
        ...
    else:
        # type of x is &quot;int&quot; here?
        print(x + 1)

f(C())   # oops
</pre>
<p>We argue that requiring an explicit class decorator would be better, since
one can then attach warnings about problems like this in the documentation.
The user would be able to evaluate whether the benefits outweigh
the potential for confusion for each protocol and explicitly opt in -- but
the default behavior would be safer. Finally, it will be easy to make this
behavior default if necessary, while it might be problematic to make it opt-in
after being default.</p>
</div>
<div class="section" id="provide-a-special-intersection-type-construct">
<h2><a class="toc-backref" href="#id49">Provide a special intersection type construct</a></h2>
<p>There was an idea to allow <tt class="docutils literal">Proto = All[Proto1, Proto2, <span class="pre">...]</span></tt> as a shorthand
for:</p>
<pre class="literal-block">
class Proto(Proto1, Proto2, ..., Protocol):
    pass
</pre>
<p>However, it is not yet clear how popular/useful it will be and implementing
this in type checkers for non-protocol classes could be difficult. Finally, it
will be very easy to add this later if needed.</p>
</div>
<div class="section" id="prohibit-explicit-subclassing-of-protocols-by-non-protocols">
<h2><a class="toc-backref" href="#id50">Prohibit explicit subclassing of protocols by non-protocols</a></h2>
<p>This was rejected for the following reasons:</p>
<ul class="simple">
<li>Backward compatibility: People are already using ABCs, including generic
ABCs from <tt class="docutils literal">typing</tt> module. If we prohibit explicit subclassing of these
ABCs, then quite a lot of code will break.</li>
<li>Convenience: There are existing protocol-like ABCs (that will be turned
into protocols) that have many useful &quot;mix-in&quot; (non-abstract) methods.
For example in the case of <tt class="docutils literal">Sequence</tt> one only needs to implement
<tt class="docutils literal">__getitem__</tt> and <tt class="docutils literal">__len__</tt> in an explicit subclass, and one gets
<tt class="docutils literal">__iter__</tt>, <tt class="docutils literal">__contains__</tt>, <tt class="docutils literal">__reversed__</tt>, <tt class="docutils literal">index</tt>, and <tt class="docutils literal">count</tt>
for free.</li>
<li>Explicit subclassing makes it explicit that a class implements a particular
protocol, making subtyping relationships easier to see.</li>
<li>Type checkers can warn about missing protocol members or members with
incompatible types more easily, without having to use hacks like dummy
assignments discussed above in this section.</li>
<li>Explicit subclassing makes it possible to force a class to be considered
a subtype of a protocol (by using <tt class="docutils literal"># type: ignore</tt> together with an
explicit base class) when it is not strictly compatible, such as when
it has an unsafe override.</li>
</ul>
</div>
<div class="section" id="covariant-subtyping-of-mutable-attributes">
<h2><a class="toc-backref" href="#id51">Covariant subtyping of mutable attributes</a></h2>
<p>Rejected because covariant subtyping of mutable attributes is not safe.
Consider this example:</p>
<pre class="literal-block">
class P(Protocol):
    x: float

def f(arg: P) -&gt; None:
    arg.x = 0.42

class C:
    x: int

c = C()
f(c)  # Would typecheck if covariant subtyping
      # of mutable attributes were allowed
c.x &gt;&gt; 1  # But this fails at runtime
</pre>
<p>It was initially proposed to allow this for practical reasons, but it was
subsequently rejected, since this may mask some hard to spot bugs.</p>
</div>
<div class="section" id="overriding-inferred-variance-of-protocol-classes">
<h2><a class="toc-backref" href="#id52">Overriding inferred variance of protocol classes</a></h2>
<p>It was proposed to allow declaring protocols as invariant if they are actually
covariant or contravariant (as it is possible for nominal classes, see <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a>).
However, it was decided not to do this because of several downsides:</p>
<ul>
<li><p class="first">Declared protocol invariance breaks transitivity of sub-typing. Consider
this situation:</p>
<pre class="literal-block">
T = TypeVar('T')

class P(Protocol[T]):  # Declared as invariant
    def meth(self) -&gt; T:
        ...
class C:
    def meth(self) -&gt; float:
        ...
class D(C):
    def meth(self) -&gt; int:
        ...
</pre>
<p>Now we have that <tt class="docutils literal">D</tt> is a subtype of <tt class="docutils literal">C</tt>, and <tt class="docutils literal">C</tt> is a subtype of
<tt class="docutils literal">P[float]</tt>. But <tt class="docutils literal">D</tt> is <em>not</em> a subtype of <tt class="docutils literal">P[float]</tt> since <tt class="docutils literal">D</tt>
implements <tt class="docutils literal">P[int]</tt>, and <tt class="docutils literal">P</tt> is invariant. There is a possibility
to &quot;cure&quot; this by looking for protocol implementations in MROs but this
will be too complex in a general case, and this &quot;cure&quot; requires abandoning
simple idea of purely structural subtyping for protocols.</p>
</li>
<li><p class="first">Subtyping checks will always require type inference for protocols. In the
above example a user may complain: &quot;Why did you infer <tt class="docutils literal">P[int]</tt> for
my <tt class="docutils literal">D</tt>? It implements <tt class="docutils literal">P[float]</tt>!&quot;. Normally, inference can be overruled
by an explicit annotation, but here this will require explicit subclassing,
defeating the purpose of using protocols.</p>
</li>
<li><p class="first">Allowing overriding variance will make impossible more detailed error
messages in type checkers citing particular conflicts in member
type signatures.</p>
</li>
<li><p class="first">Finally, explicit is better than implicit in this case. Requiring user to
declare correct variance will simplify understanding the code and will avoid
unexpected errors at the point of use.</p>
</li>
</ul>
</div>
<div class="section" id="support-adapters-and-adaptation">
<h2><a class="toc-backref" href="#id53">Support adapters and adaptation</a></h2>
<p>Adaptation was proposed by <a class="reference external" href="/dev/peps/pep-0246">PEP 246</a> (rejected) and is supported by
<tt class="docutils literal">zope.interface</tt>, see <a class="reference external" href="https://docs.zope.org/zope.interface/adapter.html">https://docs.zope.org/zope.interface/adapter.html</a>.
Adapters is quite an advanced concept, and <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a> supports unions and
generic aliases that can be used instead of adapters. This can be illustrated
with an example of <tt class="docutils literal">Iterable</tt> protocol, there is another way of supporting
iteration by providing <tt class="docutils literal">__getitem__</tt> and <tt class="docutils literal">__len__</tt>. If a function
supports both this way and the now standard <tt class="docutils literal">__iter__</tt> method, then it could
be annotated by a union type:</p>
<pre class="literal-block">
class OldIterable(Sized, Protocol[T]):
    def __getitem__(self, item: int) -&gt; T: ...

CompatIterable = Union[Iterable[T], OldIterable[T]]

class A:
    def __iter__(self) -&gt; Iterator[str]: ...
class B:
    def __len__(self) -&gt; int: ...
    def __getitem__(self, item: int) -&gt; str: ...

def iterate(it: CompatIterable[str]) -&gt; None:
    ...

iterate(A())  # OK
iterate(B())  # OK
</pre>
<p>Since there is a reasonable alternative for such cases with existing tooling,
it is therefore proposed not to include adaptation in this PEP.</p>
</div>
<div class="section" id="call-structural-base-types-interfaces">
<h2><a class="toc-backref" href="#id54">Call structural base types &quot;interfaces&quot;</a></h2>
<p>&quot;Protocol&quot; is a term already widely used in Python to describe duck typing
contracts such as the iterator protocol (providing <tt class="docutils literal">__iter__</tt>
and <tt class="docutils literal">__next__</tt>), and the descriptor protocol (providing <tt class="docutils literal">__get__</tt>,
<tt class="docutils literal">__set__</tt>, and <tt class="docutils literal">__delete__</tt>). In addition to this and other reasons given
in <a class="reference internal" href="#specification">specification</a>, protocols are different from Java interfaces in several
aspects: protocols don't require explicit declaration of implementation
(they are mainly oriented on duck-typing), protocols can have
default implementations of members and store state.</p>
</div>
<div class="section" id="make-protocols-special-objects-at-runtime-rather-that-normal-abcs">
<h2><a class="toc-backref" href="#id55">Make protocols special objects at runtime rather that normal ABCs</a></h2>
<p>Making protocols non-ABCs will make the backwards compatibility problematic
if possible at all. For example, <tt class="docutils literal">collections.abc.Iterable</tt> is already
an ABC, and lots of existing code use patterns like
<tt class="docutils literal">isinstance(obj, collections.abc.Iterable)</tt> and similar checks with other
ABCs (also in a structural manner, i.e., via <tt class="docutils literal">__subclasshook__</tt>).
Disabling this behavior will cause breakages. If we keep this behavior
for ABCs in <tt class="docutils literal">collections.abc</tt> but will not provide a similar runtime
behavior for protocols in <tt class="docutils literal">typing</tt>, then a smooth transition to protocols
will be not possible. In addition, having two parallel hierarchies may cause
confusions.</p>
</div>
</div>
<div class="section" id="backwards-compatibility">
<h1><a class="toc-backref" href="#id56">Backwards Compatibility</a></h1>
<p>This PEP is almost fully backwards compatible. Few collection classes such as
<tt class="docutils literal">Sequence</tt> and <tt class="docutils literal">Mapping</tt> will be turned into runtime protocols, therefore
results of <tt class="docutils literal">isinstance()</tt> checks are going to change in some edge cases.
For example, a class that implements the <tt class="docutils literal">Sequence</tt> protocol but does not
explicitly inherit from <tt class="docutils literal">Sequence</tt> currently returns <tt class="docutils literal">False</tt> in
corresponding instance and class checks. With this PEP implemented, such
checks will return <tt class="docutils literal">True</tt>.</p>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id57">Implementation</a></h1>
<p>A working implementation of this PEP for <tt class="docutils literal">mypy</tt> type checker is found on
GitHub repo at <a class="reference external" href="https://github.com/ilevkivskyi/mypy/tree/protocols">https://github.com/ilevkivskyi/mypy/tree/protocols</a>,
corresponding <tt class="docutils literal">typeshed</tt> stubs for more flavor are found at
<a class="reference external" href="https://github.com/ilevkivskyi/typeshed/tree/protocols">https://github.com/ilevkivskyi/typeshed/tree/protocols</a>. Installation steps:</p>
<pre class="literal-block">
git clone --recurse-submodules https://github.com/ilevkivskyi/mypy/
cd mypy &amp;&amp; git checkout protocols &amp;&amp; cd typeshed
git remote add proto https://github.com/ilevkivskyi/typeshed
git fetch proto &amp;&amp; git checkout proto/protocols
cd .. &amp;&amp; git add typeshed &amp;&amp; sudo python3 -m pip install -U .
</pre>
<p>The runtime implementation of protocols in <tt class="docutils literal">typing</tt> module is
found at <a class="reference external" href="https://github.com/ilevkivskyi/typehinting/tree/protocols">https://github.com/ilevkivskyi/typehinting/tree/protocols</a>.
The version of <tt class="docutils literal">collections.abc</tt> with structural behavior for mappings and
sequences is found at <a class="reference external" href="https://github.com/ilevkivskyi/cpython/tree/protocols">https://github.com/ilevkivskyi/cpython/tree/protocols</a>.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id58">References</a></h1>
<table class="docutils citation" frame="void" id="typing" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[typing]</a></td><td><a class="reference external" href="https://docs.python.org/3/library/typing.html">https://docs.python.org/3/library/typing.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="wiki-structural" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[wiki-structural]</a></td><td><a class="reference external" href="https://en.wikipedia.org/wiki/Structural_type_system">https://en.wikipedia.org/wiki/Structural_type_system</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="zope-interfaces" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[zope-interfaces]</a></td><td><a class="reference external" href="https://zopeinterface.readthedocs.io/en/latest/">https://zopeinterface.readthedocs.io/en/latest/</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="abstract-classes" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[abstract-classes]</a></td><td><a class="reference external" href="https://docs.python.org/3/library/abc.html">https://docs.python.org/3/library/abc.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="collections-abc" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[collections-abc]</a></td><td><a class="reference external" href="https://docs.python.org/3/library/collections.abc.html">https://docs.python.org/3/library/collections.abc.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="typescript" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[typescript]</a></td><td><a class="reference external" href="https://www.typescriptlang.org/docs/handbook/interfaces.html">https://www.typescriptlang.org/docs/handbook/interfaces.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="golang" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[golang]</td><td><em>(<a class="fn-backref" href="#id7">1</a>, <a class="fn-backref" href="#id15">2</a>)</em> <a class="reference external" href="https://golang.org/doc/effective_go.html#interfaces_and_types">https://golang.org/doc/effective_go.html#interfaces_and_types</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="data-model" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[data-model]</a></td><td><a class="reference external" href="https://docs.python.org/3/reference/datamodel.html#special-method-names">https://docs.python.org/3/reference/datamodel.html#special-method-names</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="typeshed" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[typeshed]</a></td><td><a class="reference external" href="https://github.com/python/typeshed/">https://github.com/python/typeshed/</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="mypy" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[mypy]</a></td><td><a class="reference external" href="http://github.com/python/mypy/">http://github.com/python/mypy/</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="several" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[several]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2015-September/thread.html#35859">https://mail.python.org/pipermail/python-ideas/2015-September/thread.html#35859</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="discussions" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[discussions]</a></td><td><a class="reference external" href="https://github.com/python/typing/issues/11">https://github.com/python/typing/issues/11</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="elsewhere" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[elsewhere]</a></td><td><a class="reference external" href="https://github.com/python/peps/pull/224">https://github.com/python/peps/pull/224</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id59">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

