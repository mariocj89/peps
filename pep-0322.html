<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">322</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Reverse Iteration</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0322.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Raymond Hettinger &lt;python&#32;&#97;t&#32;rcn.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">24-Sep-2003</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.4</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">24-Sep-2003</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id2">Abstract</a></li>
<li><a class="reference internal" href="#motivation" id="id3">Motivation</a></li>
<li><a class="reference internal" href="#proposal" id="id4">Proposal</a></li>
<li><a class="reference internal" href="#bdfl-pronouncement" id="id5">BDFL Pronouncement</a></li>
<li><a class="reference internal" href="#alternative-method-names" id="id6">Alternative Method Names</a></li>
<li><a class="reference internal" href="#discussion" id="id7">Discussion</a></li>
<li><a class="reference internal" href="#real-world-use-cases" id="id8">Real World Use Cases</a></li>
<li><a class="reference internal" href="#rejected-alternatives" id="id9">Rejected Alternatives</a></li>
<li><a class="reference internal" href="#copyright" id="id10">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id2">Abstract</a></h1>
<p>This proposal is to add a builtin function to support reverse
iteration over sequences.</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id3">Motivation</a></h1>
<p>For indexable objects, current approaches for reverse iteration are
error prone, unnatural, and not especially readable:</p>
<pre class="literal-block">
for i in xrange(n-1, -1, -1):
    print seqn[i]
</pre>
<p>One other current approach involves reversing a list before iterating
over it.  That technique wastes computer cycles, memory, and lines of
code:</p>
<pre class="literal-block">
rseqn = list(seqn)
rseqn.reverse()
for value in rseqn:
    print value
</pre>
<p>Extended slicing is a third approach that minimizes the code overhead
but does nothing for memory efficiency, beauty, or clarity.</p>
<p>Reverse iteration is much less common than forward iteration, but it
does arise regularly in practice.  See <a class="reference internal" href="#real-world-use-cases">Real World Use Cases</a> below.</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id4">Proposal</a></h1>
<p>Add a builtin function called <em>reversed()</em> that makes a reverse
iterator over sequence objects that support __getitem__() and
__len__().</p>
<p>The above examples then simplify to:</p>
<pre class="literal-block">
for i in reversed(xrange(n)):
    print seqn[i]
</pre>
<pre class="literal-block">
for elem in reversed(seqn):
    print elem
</pre>
<p>The core idea is that the clearest, least error-prone way of specifying
reverse iteration is to specify it in a forward direction and then say
<em>reversed</em>.</p>
<p>The implementation could be as simple as:</p>
<pre class="literal-block">
def reversed(x):
    if hasattr(x, 'keys'):
        raise ValueError(&quot;mappings do not support reverse iteration&quot;)
    i = len(x)
    while i &gt; 0:
        i -= 1
        yield x[i]
</pre>
<p>No language syntax changes are needed.  The proposal is fully backwards
compatible.</p>
<p>A C implementation and unit tests are at:  <a class="reference external" href="http://www.python.org/sf/834422">http://www.python.org/sf/834422</a></p>
</div>
<div class="section" id="bdfl-pronouncement">
<h1><a class="toc-backref" href="#id5">BDFL Pronouncement</a></h1>
<p>This PEP has been conditionally accepted for Py2.4.  The condition means
that if the function is found to be useless, it can be removed before
Py2.4b1.</p>
</div>
<div class="section" id="alternative-method-names">
<h1><a class="toc-backref" href="#id6">Alternative Method Names</a></h1>
<ul class="simple">
<li><em>reviter</em>  -- Jeremy Fincher's suggestion matches use of iter()</li>
<li><em>ireverse</em> -- uses the itertools naming convention</li>
<li><em>inreverse</em> -- no one seems to like this one except me</li>
</ul>
<p>The name <em>reverse</em> is not a candidate because it duplicates the name
of the list.reverse() which mutates the underlying list.</p>
</div>
<div class="section" id="discussion">
<h1><a class="toc-backref" href="#id7">Discussion</a></h1>
<p>The case against adoption of the PEP is a desire to keep the number of
builtin functions small.  This needs to weighed against the simplicity
and convenience of having it as builtin instead of being tucked away in
some other namespace.</p>
</div>
<div class="section" id="real-world-use-cases">
<h1><a class="toc-backref" href="#id8">Real World Use Cases</a></h1>
<p>Here are some instances of reverse iteration taken from the standard
library and comments on why reverse iteration was necessary:</p>
<ul>
<li><p class="first">atexit.exit_handlers() uses:</p>
<pre class="literal-block">
while _exithandlers:
    func, targs, kargs = _exithandlers.pop()
        . . .
</pre>
<p>In this application popping is required, so the new function would
not help.</p>
</li>
<li><p class="first">heapq.heapify() uses <tt class="docutils literal">for i in <span class="pre">xrange(n//2</span> - 1, <span class="pre">-1,</span> <span class="pre">-1)</span></tt> because
higher-level orderings are more easily formed from pairs of
lower-level orderings.  A forward version of this algorithm is
possible; however, that would complicate the rest of the heap code
which iterates over the underlying list in the opposite direction.
The replacement code <tt class="docutils literal">for i in <span class="pre">reversed(xrange(n//2))</span></tt> makes
clear the range covered and how many iterations it takes.</p>
</li>
<li><p class="first">mhlib.test() uses:</p>
<pre class="literal-block">
testfolders.reverse();
for t in testfolders:
    do('mh.deletefolder(%s)' % `t`)
</pre>
<p>The need for reverse iteration arises because the tail of the
underlying list is altered during iteration.</p>
</li>
<li><p class="first">platform._dist_try_harder() uses
<tt class="docutils literal">for n in <span class="pre">range(len(verfiles)-1,-1,-1)</span></tt> because the loop deletes
selected elements from <em>verfiles</em> but needs to leave the rest of
the list intact for further iteration.</p>
</li>
<li><p class="first">random.shuffle() uses <tt class="docutils literal">for i in <span class="pre">xrange(len(x)-1,</span> 0, <span class="pre">-1)</span></tt> because
the algorithm is most easily understood as randomly selecting
elements from an ever diminishing pool.  In fact, the algorithm can
be run in a forward direction but is less intuitive and rarely
presented that way in literature.  The replacement code
<tt class="docutils literal">for i in reversed(xrange(1, <span class="pre">len(x)))</span></tt> is much easier
to verify visually.</p>
</li>
<li><p class="first">rfc822.Message.__delitem__() uses:</p>
<pre class="literal-block">
list.reverse()
for i in list:
    del self.headers[i]
</pre>
<p>The need for reverse iteration arises because the tail of the
underlying list is altered during iteration.</p>
</li>
</ul>
</div>
<div class="section" id="rejected-alternatives">
<h1><a class="toc-backref" href="#id9">Rejected Alternatives</a></h1>
<p>Several variants were submitted that attempted to apply <em>reversed()</em>
to all iterables by running the iterable to completion, saving the
results, and then returning a reverse iterator over the results.
While satisfying some notions of full generality, running the input
to the end is contrary to the purpose of using iterators
in the first place.  Also, a small disaster ensues if the underlying
iterator is infinite.</p>
<p>Putting the function in another module or attaching it to a type object
is not being considered.  Like its cousins, <em>zip()</em> and <em>enumerate()</em>,
the function needs to be directly accessible in daily programming.  Each
solves a basic looping problem:  lock-step iteration, loop counting, and
reverse iteration.  Requiring some form of dotted access would interfere
with their simplicity, daily utility, and accessibility.  They are core
looping constructs, independent of any one application domain.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id10">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>

