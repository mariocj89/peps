<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">3140</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">str(container) should call str(item), not repr(item)</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-3140.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Oleg Broytman &lt;phd&#32;&#97;t&#32;phdru.name&gt;,
Jim J. Jewett &lt;jimjjewett&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Discussions-To:</th><td class="field-body"><a class="reference external" href="mailto:python-3000&#64;python.org?subject=PEP%203140">python-3000&#32;&#97;t&#32;python.org</a></td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">27-May-2008</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">28-May-2008</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#rejection" id="id3">Rejection</a></li>
<li><a class="reference internal" href="#abstract" id="id4">Abstract</a></li>
<li><a class="reference internal" href="#motivation" id="id5">Motivation</a></li>
<li><a class="reference internal" href="#current-situation" id="id6">Current situation</a></li>
<li><a class="reference internal" href="#a-different-approach-call-str-item" id="id7">A different approach - call <tt class="docutils literal">str(item)</tt></a></li>
<li><a class="reference internal" href="#backward-compatibility" id="id8">Backward compatibility</a></li>
<li><a class="reference internal" href="#references" id="id9">References</a></li>
<li><a class="reference internal" href="#copyright" id="id10">Copyright</a></li>
</ul>
</div>
<div class="section" id="rejection">
<h1><a class="toc-backref" href="#id3">Rejection</a></h1>
<p>Guido said this would cause too much disturbance too close to beta. See <a class="footnote-reference" href="#id2" id="id1">[1]</a>.</p>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id4">Abstract</a></h1>
<p>This document discusses the advantages and disadvantages of the
current implementation of <tt class="docutils literal">str(container)</tt>.  It also discusses the
pros and cons of a different approach - to call <tt class="docutils literal">str(item)</tt> instead
of <tt class="docutils literal">repr(item)</tt>.</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id5">Motivation</a></h1>
<p>Currently <tt class="docutils literal">str(container)</tt> calls <tt class="docutils literal">repr</tt> on items.  Arguments for it:</p>
<ul class="simple">
<li>containers refuse to guess what the user wants to see on
<tt class="docutils literal">str(container)</tt> - surroundings, delimiters, and so on;</li>
<li><tt class="docutils literal">repr(item)</tt> usually displays type information - apostrophes
around strings, class names, etc.</li>
</ul>
<p>Arguments against:</p>
<ul class="simple">
<li>it's illogical; <tt class="docutils literal">str()</tt> is expected to call <tt class="docutils literal">__str__</tt> if it exists,
not <tt class="docutils literal">__repr__</tt>;</li>
<li>there is no standard way to print a container's content calling
items' <tt class="docutils literal">__str__</tt>, that's inconvenient in cases where <tt class="docutils literal">__str__</tt> and
<tt class="docutils literal">__repr__</tt> return different results;</li>
<li><tt class="docutils literal">repr(item)</tt> sometimes do wrong things (hex-escapes non-ASCII strings,
e.g.)</li>
</ul>
<p>This PEP proposes to change how <tt class="docutils literal">str(container)</tt> works.  It is
proposed to mimic how <tt class="docutils literal">repr(container)</tt> works except one detail - call
<tt class="docutils literal">str</tt> on items instead of <tt class="docutils literal">repr</tt>.  This allows a user to choose
what results she want to get - from <tt class="docutils literal">item.__repr__</tt> or <tt class="docutils literal">item.__str__</tt>.</p>
</div>
<div class="section" id="current-situation">
<h1><a class="toc-backref" href="#id6">Current situation</a></h1>
<p>Most container types (tuples, lists, dicts, sets, etc.) do not
implement <tt class="docutils literal">__str__</tt> method, so <tt class="docutils literal">str(container)</tt> calls
<tt class="docutils literal">container.__repr__</tt>, and <tt class="docutils literal">container.__repr__</tt>, once called, forgets
it is called from <tt class="docutils literal">str</tt> and always calls <tt class="docutils literal">repr</tt> on the container's
items.</p>
<p>This behaviour has advantages and disadvantages.  One advantage is
that most items are represented with type information - strings
are surrounded by apostrophes, instances may have both class name
and instance data:</p>
<pre class="literal-block">
&gt;&gt;&gt; print([42, '42'])
[42, '42']
&gt;&gt;&gt; print([Decimal('42'), datetime.now()])
[Decimal(&quot;42&quot;), datetime.datetime(2008, 5, 27, 19, 57, 43, 485028)]
</pre>
<p>The disadvantage is that <tt class="docutils literal">__repr__</tt> often returns technical data
(like '<tt class="docutils literal">&lt;object at address&gt;</tt>') or unreadable string (hex-encoded
string if the input is non-ASCII string):</p>
<pre class="literal-block">
&gt;&gt;&gt; print(['тест'])
['\xd4\xc5\xd3\xd4']
</pre>
<p>One of the motivations for <a class="reference external" href="/dev/peps/pep-3138">PEP 3138</a> is that neither <tt class="docutils literal">repr</tt> nor <tt class="docutils literal">str</tt>
will allow the sensible printing of dicts whose keys are non-ASCII
text strings.  Now that Unicode identifiers are allowed, it
includes Python's own attribute dicts.  This also includes JSON
serialization (and caused some hoops for the json lib).</p>
<p><a class="reference external" href="/dev/peps/pep-3138">PEP 3138</a> proposes to fix this by breaking the &quot;repr is safe ASCII&quot;
invariant, and changing the way <tt class="docutils literal">repr</tt> (which is used for
persistence) outputs some objects, with system-dependent failures.</p>
<p>Changing how <tt class="docutils literal">str(container)</tt> works would allow easy debugging in
the normal case, and retain the safety of ASCII-only for the
machine-readable  case.  The only downside is that <tt class="docutils literal">str(x)</tt> and
<tt class="docutils literal">repr(x)</tt> would more often be different -- but only in those cases
where the current almost-the-same version is insufficient.</p>
<p>It also seems illogical that <tt class="docutils literal">str(container)</tt> calls <tt class="docutils literal">repr</tt> on items
instead of <tt class="docutils literal">str</tt>.  It's only logical to expect following code:</p>
<pre class="literal-block">
class Test:
    def __str__(self):
        return &quot;STR&quot;

    def __repr__(self):
        return &quot;REPR&quot;


test = Test()
print(test)
print(repr(test))
print([test])
print(str([test]))
</pre>
<p>to print:</p>
<pre class="literal-block">
STR
REPR
[STR]
[STR]
</pre>
<p>where it actually prints:</p>
<pre class="literal-block">
STR
REPR
[REPR]
[REPR]
</pre>
<p>Especially it is illogical to see that print in Python 2 uses <tt class="docutils literal">str</tt>
if it is called on what seems to be a tuple:</p>
<pre class="literal-block">
&gt;&gt;&gt; print Decimal('42'), datetime.now()
42 2008-05-27 20:16:22.534285
</pre>
<p>where on an actual tuple it prints:</p>
<pre class="literal-block">
&gt;&gt;&gt; print((Decimal('42'), datetime.now()))
(Decimal(&quot;42&quot;), datetime.datetime(2008, 5, 27, 20, 16, 27, 937911))
</pre>
</div>
<div class="section" id="a-different-approach-call-str-item">
<h1><a class="toc-backref" href="#id7">A different approach - call <tt class="docutils literal">str(item)</tt></a></h1>
<p>For example, with numbers it is often only the value that people
care about.</p>
<pre class="literal-block">
&gt;&gt;&gt; print Decimal('3')
3
</pre>
<p>But putting the value in a list forces users to read the type
information, exactly as if <tt class="docutils literal">repr</tt> had been called for the benefit of
a machine:</p>
<pre class="literal-block">
&gt;&gt;&gt; print [Decimal('3')]
[Decimal(&quot;3&quot;)]
</pre>
<p>After this change, the type information would not clutter the <tt class="docutils literal">str</tt>
output:</p>
<pre class="literal-block">
&gt;&gt;&gt; print &quot;%s&quot;.format([Decimal('3')])
[3]
&gt;&gt;&gt; str([Decimal('3')])  # ==
[3]
</pre>
<p>But it would still be available if desired:</p>
<pre class="literal-block">
&gt;&gt;&gt; print &quot;%r&quot;.format([Decimal('3')])
[Decimal('3')]
&gt;&gt;&gt; repr([Decimal('3')])  # ==
[Decimal('3')]
</pre>
<p>There is a number of strategies to fix the problem.  The most
radical is to change <tt class="docutils literal">__repr__</tt> so it accepts a new parameter (flag)
&quot;called from <tt class="docutils literal">str</tt>, so call <tt class="docutils literal">str</tt> on items, not <tt class="docutils literal">repr</tt>&quot;.  The
drawback of the proposal is that every <tt class="docutils literal">__repr__</tt> implementation
must be changed.  Introspection could help a bit (inspect <tt class="docutils literal">__repr__</tt>
before calling if it accepts 2 or 3 parameters), but introspection
doesn't work on classes written in C, like all built-in containers.</p>
<p>Less radical proposal is to implement <tt class="docutils literal">__str__</tt> methods for built-in
container types.  The obvious drawback is a duplication of effort - all
those <tt class="docutils literal">__str__</tt> and <tt class="docutils literal">__repr__</tt> implementations are only differ
in one small detail - if they call <tt class="docutils literal">str</tt> or <tt class="docutils literal">repr</tt> on items.</p>
<p>The most conservative proposal is not to change str at all but
to allow developers to implement their own application- or
library-specific pretty-printers.  The drawback is again
a multiplication of effort and proliferation of many small
specific container-traversal algorithms.</p>
</div>
<div class="section" id="backward-compatibility">
<h1><a class="toc-backref" href="#id8">Backward compatibility</a></h1>
<p>In those cases where type information is more important than
usual, it will still be possible to get the current results by
calling <tt class="docutils literal">repr</tt> explicitly.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id9">References</a></h1>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Guido van Rossum, PEP: str(container) should call str(item), not
repr(item)
<a class="reference external" href="https://mail.python.org/pipermail/python-3000/2008-May/013876.html">https://mail.python.org/pipermail/python-3000/2008-May/013876.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id10">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

