<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">490</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Chain exceptions at C level</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0490.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Victor Stinner &lt;victor.stinner&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">25-March-2015</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.6</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id2">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id3">Rationale</a></li>
<li><a class="reference internal" href="#proposal" id="id4">Proposal</a><ul>
<li><a class="reference internal" href="#modify-pyerr-functions-to-chain-exceptions" id="id5">Modify PyErr_*() functions to chain exceptions</a></li>
<li><a class="reference internal" href="#modify-functions-to-not-chain-exceptions" id="id6">Modify functions to not chain exceptions</a></li>
<li><a class="reference internal" href="#modify-functions-to-chain-exceptions" id="id7">Modify functions to chain exceptions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backward-compatibility" id="id8">Backward compatibility</a></li>
<li><a class="reference internal" href="#alternatives" id="id9">Alternatives</a><ul>
<li><a class="reference internal" href="#no-change" id="id10">No change</a></li>
<li><a class="reference internal" href="#new-helpers-to-chain-exceptions" id="id11">New helpers to chain exceptions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#appendix" id="id12">Appendix</a><ul>
<li><a class="reference internal" href="#peps" id="id13">PEPs</a></li>
<li><a class="reference internal" href="#python-c-api" id="id14">Python C API</a></li>
<li><a class="reference internal" href="#python-issues" id="id15">Python Issues</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rejection" id="id16">Rejection</a></li>
<li><a class="reference internal" href="#copyright" id="id17">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id2">Abstract</a></h1>
<p>Chain exceptions at C level, as already done at Python level.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id3">Rationale</a></h1>
<p>Python 3 introduced a new killer feature: exceptions are chained by
default, <a class="reference external" href="/dev/peps/pep-3134">PEP 3134</a>.</p>
<p>Example:</p>
<pre class="literal-block">
try:
    raise TypeError(&quot;err1&quot;)
except TypeError:
    raise ValueError(&quot;err2&quot;)
</pre>
<p>Output:</p>
<pre class="literal-block">
Traceback (most recent call last):
  File &quot;test.py&quot;, line 2, in &lt;module&gt;
    raise TypeError(&quot;err1&quot;)
TypeError: err1

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File &quot;test.py&quot;, line 4, in &lt;module&gt;
    raise ValueError(&quot;err2&quot;)
ValueError: err2
</pre>
<p>Exceptions are chained by default in Python code, but not in
extensions written in C.</p>
<p>A new private <tt class="docutils literal">_PyErr_ChainExceptions()</tt> function was introduced in
Python 3.4.3 and 3.5 to chain exceptions. Currently, it must be called
explicitly to chain exceptions and its usage is not trivial.</p>
<p>Example of <tt class="docutils literal">_PyErr_ChainExceptions()</tt> usage from the <tt class="docutils literal">zipimport</tt>
module to chain the previous <tt class="docutils literal">OSError</tt> to a new <tt class="docutils literal">ZipImportError</tt>
exception:</p>
<pre class="literal-block">
PyObject *exc, *val, *tb;
PyErr_Fetch(&amp;exc, &amp;val, &amp;tb);
PyErr_Format(ZipImportError, &quot;can't open Zip file: %R&quot;, archive);
_PyErr_ChainExceptions(exc, val, tb);
</pre>
<p>This PEP proposes to also chain exceptions automatically at C level to
stay consistent and give more information on failures to help
debugging. The previous example becomes simply:</p>
<pre class="literal-block">
PyErr_Format(ZipImportError, &quot;can't open Zip file: %R&quot;, archive);
</pre>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id4">Proposal</a></h1>
<div class="section" id="modify-pyerr-functions-to-chain-exceptions">
<h2><a class="toc-backref" href="#id5">Modify PyErr_*() functions to chain exceptions</a></h2>
<p>Modify C functions raising exceptions of the Python C API to
automatically chain exceptions: modify <tt class="docutils literal">PyErr_SetString()</tt>,
<tt class="docutils literal">PyErr_Format()</tt>, <tt class="docutils literal">PyErr_SetNone()</tt>, etc.</p>
</div>
<div class="section" id="modify-functions-to-not-chain-exceptions">
<h2><a class="toc-backref" href="#id6">Modify functions to not chain exceptions</a></h2>
<p>Keeping the previous exception is not always interesting when the new
exception contains information of the previous exception or even more
information, especially when the two exceptions have the same type.</p>
<p>Example of an useless exception chain with <tt class="docutils literal">int(str)</tt>:</p>
<pre class="literal-block">
TypeError: a bytes-like object is required, not 'type'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: int() argument must be a string, a bytes-like object or a number, not 'type'
</pre>
<p>The new <tt class="docutils literal">TypeError</tt> exception contains more information than the
previous exception. The previous exception should be hidden.</p>
<p>The <tt class="docutils literal">PyErr_Clear()</tt> function can be called to clear the current
exception before raising a new exception, to not chain the current
exception with a new exception.</p>
</div>
<div class="section" id="modify-functions-to-chain-exceptions">
<h2><a class="toc-backref" href="#id7">Modify functions to chain exceptions</a></h2>
<p>Some functions save and then restore the current exception. If a new
exception is raised, the exception is currently displayed into
sys.stderr or ignored depending on the function.  Some of these
functions should be modified to chain exceptions instead.</p>
<p>Examples of function ignoring the new exception(s):</p>
<ul class="simple">
<li><tt class="docutils literal">ptrace_enter_call()</tt>: ignore exception</li>
<li><tt class="docutils literal">subprocess_fork_exec()</tt>: ignore exception raised by enable_gc()</li>
<li><tt class="docutils literal">t_bootstrap()</tt> of the <tt class="docutils literal">_thread</tt> module: ignore exception raised
by trying to display the bootstrap function to <tt class="docutils literal">sys.stderr</tt></li>
<li><tt class="docutils literal">PyDict_GetItem()</tt>, <tt class="docutils literal">_PyDict_GetItem_KnownHash()</tt>: ignore
exception raised by looking for a key in the dictionary</li>
<li><tt class="docutils literal">_PyErr_TrySetFromCause()</tt>: ignore exception</li>
<li><tt class="docutils literal">PyFrame_LocalsToFast()</tt>: ignore exception raised by
<tt class="docutils literal">dict_to_map()</tt></li>
<li><tt class="docutils literal">_PyObject_Dump()</tt>: ignore exception. <tt class="docutils literal">_PyObject_Dump()</tt> is used
to debug, to inspect a running process, it should not modify the
Python state.</li>
<li><tt class="docutils literal">Py_ReprLeave()</tt>: ignore exception &quot;because there is no way to
report them&quot;</li>
<li><tt class="docutils literal">type_dealloc()</tt>: ignore exception raised by
<tt class="docutils literal">remove_all_subclasses()</tt></li>
<li><tt class="docutils literal">PyObject_ClearWeakRefs()</tt>: ignore exception?</li>
<li><tt class="docutils literal">call_exc_trace()</tt>, <tt class="docutils literal">call_trace_protected()</tt>: ignore exception</li>
<li><tt class="docutils literal">remove_importlib_frames()</tt>: ignore exception</li>
<li><tt class="docutils literal">do_mktuple()</tt>, helper used by <tt class="docutils literal">Py_BuildValue()</tt> for example:
ignore exception?</li>
<li><tt class="docutils literal">flush_io()</tt>: ignore exception</li>
<li><tt class="docutils literal">sys_write()</tt>, <tt class="docutils literal">sys_format()</tt>: ignore exception</li>
<li><tt class="docutils literal">_PyTraceback_Add()</tt>: ignore exception</li>
<li><tt class="docutils literal">PyTraceBack_Print()</tt>: ignore exception</li>
</ul>
<p>Examples of function displaying the new exception to <tt class="docutils literal">sys.stderr</tt>:</p>
<ul class="simple">
<li><tt class="docutils literal">atexit_callfuncs()</tt>: display exceptions with
<tt class="docutils literal">PyErr_Display()</tt> and return the latest exception, the function
calls multiple callbacks and only returns the latest exception</li>
<li><tt class="docutils literal">sock_dealloc()</tt>: log the <tt class="docutils literal">ResourceWarning</tt> exception with
<tt class="docutils literal">PyErr_WriteUnraisable()</tt></li>
<li><tt class="docutils literal">slot_tp_del()</tt>: display exception with
<tt class="docutils literal">PyErr_WriteUnraisable()</tt></li>
<li><tt class="docutils literal">_PyGen_Finalize()</tt>: display <tt class="docutils literal">gen_close()</tt> exception with
<tt class="docutils literal">PyErr_WriteUnraisable()</tt></li>
<li><tt class="docutils literal">slot_tp_finalize()</tt>: display exception raised by the
<tt class="docutils literal">__del__()</tt> method with <tt class="docutils literal">PyErr_WriteUnraisable()</tt></li>
<li><tt class="docutils literal">PyErr_GivenExceptionMatches()</tt>: display exception raised by
<tt class="docutils literal">PyType_IsSubtype()</tt> with <tt class="docutils literal">PyErr_WriteUnraisable()</tt></li>
</ul>
</div>
</div>
<div class="section" id="backward-compatibility">
<h1><a class="toc-backref" href="#id8">Backward compatibility</a></h1>
<p>A side effect of chaining exceptions is that exceptions store
traceback objects which store frame objects which store local
variables.  Local variables are kept alive by exceptions. A common
issue is a reference cycle between local variables and exceptions: an
exception is stored in a local variable and the frame indirectly
stored in the exception. The cycle only impacts applications storing
exceptions.</p>
<p>The reference cycle can now be fixed with the new
<tt class="docutils literal">traceback.TracebackException</tt> object introduced in Python 3.5. It
stores informations required to format a full textual traceback without
storing local variables.</p>
<p>The <tt class="docutils literal">asyncio</tt> is impacted by the reference cycle issue. This module
is also maintained outside Python standard library to release a
version for Python 3.3.  <tt class="docutils literal">traceback.TracebackException</tt> will maybe
be backported in a private <tt class="docutils literal">asyncio</tt> module to fix reference cycle
issues.</p>
</div>
<div class="section" id="alternatives">
<h1><a class="toc-backref" href="#id9">Alternatives</a></h1>
<div class="section" id="no-change">
<h2><a class="toc-backref" href="#id10">No change</a></h2>
<p>A new private <tt class="docutils literal">_PyErr_ChainExceptions()</tt> function is enough to chain
manually exceptions.</p>
<p>Exceptions will only be chained explicitly where it makes sense.</p>
</div>
<div class="section" id="new-helpers-to-chain-exceptions">
<h2><a class="toc-backref" href="#id11">New helpers to chain exceptions</a></h2>
<p>Functions like <tt class="docutils literal">PyErr_SetString()</tt> don't chain automatically
exceptions. To make the usage of <tt class="docutils literal">_PyErr_ChainExceptions()</tt> easier,
new private functions are added:</p>
<ul class="simple">
<li><tt class="docutils literal">_PyErr_SetStringChain(exc_type, message)</tt></li>
<li><tt class="docutils literal">_PyErr_FormatChain(exc_type, format, <span class="pre">...)</span></tt></li>
<li><tt class="docutils literal">_PyErr_SetNoneChain(exc_type)</tt></li>
<li><tt class="docutils literal">_PyErr_SetObjectChain(exc_type, exc_value)</tt></li>
</ul>
<p>Helper functions to raise specific exceptions like
<tt class="docutils literal">_PyErr_SetKeyError(key)</tt> or <tt class="docutils literal">PyErr_SetImportError(message, name,
path)</tt> don't chain exceptions.  The generic
<tt class="docutils literal">_PyErr_ChainExceptions(exc_type, exc_value, exc_tb)</tt> should be used
to chain exceptions with these helper functions.</p>
</div>
</div>
<div class="section" id="appendix">
<h1><a class="toc-backref" href="#id12">Appendix</a></h1>
<div class="section" id="peps">
<h2><a class="toc-backref" href="#id13">PEPs</a></h2>
<ul class="simple">
<li><a class="reference external" href="https://www.python.org/dev/peps/pep-3134/">PEP 3134 -- Exception Chaining and Embedded Tracebacks</a> (Python 3.0):
new <tt class="docutils literal">__context__</tt> and <tt class="docutils literal">__cause__</tt> attributes for exceptions</li>
<li><a class="reference external" href="https://www.python.org/dev/peps/pep-0415/">PEP 415 - Implement context suppression with exception attributes</a> (Python 3.3):
<tt class="docutils literal">raise exc from None</tt></li>
<li><a class="reference external" href="https://www.python.org/dev/peps/pep-0409/">PEP 409 - Suppressing exception context</a>
(superseded by the <a class="reference external" href="/dev/peps/pep-0415">PEP 415</a>)</li>
</ul>
</div>
<div class="section" id="python-c-api">
<h2><a class="toc-backref" href="#id14">Python C API</a></h2>
<p>The header file <tt class="docutils literal">Include/pyerror.h</tt> declares functions related to
exceptions.</p>
<p>Functions raising exceptions:</p>
<ul class="simple">
<li><tt class="docutils literal">PyErr_SetNone(exc_type)</tt></li>
<li><tt class="docutils literal">PyErr_SetObject(exc_type, exc_value)</tt></li>
<li><tt class="docutils literal">PyErr_SetString(exc_type, message)</tt></li>
<li><tt class="docutils literal">PyErr_Format(exc, format, <span class="pre">...)</span></tt></li>
</ul>
<p>Helpers to raise specific exceptions:</p>
<ul class="simple">
<li><tt class="docutils literal">PyErr_BadArgument()</tt></li>
<li><tt class="docutils literal">PyErr_BadInternalCall()</tt></li>
<li><tt class="docutils literal">PyErr_NoMemory()</tt></li>
<li><tt class="docutils literal">PyErr_SetFromErrno(exc)</tt></li>
<li><tt class="docutils literal">PyErr_SetFromWindowsErr(err)</tt></li>
<li><tt class="docutils literal">PyErr_SetImportError(message, name, path)</tt></li>
<li><tt class="docutils literal">_PyErr_SetKeyError(key)</tt></li>
<li><tt class="docutils literal">_PyErr_TrySetFromCause(prefix_format, <span class="pre">...)</span></tt></li>
</ul>
<p>Manage the current exception:</p>
<ul class="simple">
<li><tt class="docutils literal">PyErr_Clear()</tt>: clear the current exception,
like <tt class="docutils literal">except: pass</tt></li>
<li><tt class="docutils literal">PyErr_Fetch(exc_type, exc_value, exc_tb)</tt></li>
<li><tt class="docutils literal">PyErr_Restore(exc_type, exc_value, exc_tb)</tt></li>
<li><tt class="docutils literal">PyErr_GetExcInfo(exc_type, exc_value, exc_tb)</tt></li>
<li><tt class="docutils literal">PyErr_SetExcInfo(exc_type, exc_value, exc_tb)</tt></li>
</ul>
<p>Others function to handle exceptions:</p>
<ul class="simple">
<li><tt class="docutils literal">PyErr_ExceptionMatches(exc)</tt>: check to implement
<tt class="docutils literal">except exc:&nbsp; ...</tt></li>
<li><tt class="docutils literal">PyErr_GivenExceptionMatches(exc1, exc2)</tt></li>
<li><tt class="docutils literal">PyErr_NormalizeException(exc_type, exc_value, exc_tb)</tt></li>
<li><tt class="docutils literal">_PyErr_ChainExceptions(exc_type, exc_value, exc_tb)</tt></li>
</ul>
</div>
<div class="section" id="python-issues">
<h2><a class="toc-backref" href="#id15">Python Issues</a></h2>
<p>Chain exceptions:</p>
<ul class="simple">
<li><a class="reference external" href="http://bugs.python.org/issue23763">Issue #23763: Chain exceptions in C</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue23696">Issue #23696: zipimport: chain ImportError to OSError</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue21715">Issue #21715: Chaining exceptions at C level</a>: added
<tt class="docutils literal">_PyErr_ChainExceptions()</tt></li>
<li><a class="reference external" href="http://bugs.python.org/issue18488">Issue #18488: sqlite: finalize() method of user function may be
called with an exception set if a call to step() method failed</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue23781">Issue #23781: Add private _PyErr_ReplaceException() in 2.7</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue23782">Issue #23782: Leak in _PyTraceback_Add</a></li>
</ul>
<p>Changes preventing to loose exceptions:</p>
<ul class="simple">
<li><a class="reference external" href="http://bugs.python.org/issue23571">Issue #23571: Raise SystemError if a function returns a result with an
exception set</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue18408">Issue #18408: Fixes crashes found by pyfailmalloc</a></li>
</ul>
</div>
</div>
<div class="section" id="rejection">
<h1><a class="toc-backref" href="#id16">Rejection</a></h1>
<p>The PEP was rejected on 2017-09-12 by Victor Stinner. It was decided in
the python-dev discussion to not chain C exceptions by default, but
instead chain them explicitly only where it makes sense.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id17">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

