<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">355</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Path - Object oriented filesystem paths</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0355.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Bj√∂rn Lindqvist &lt;bjourne&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">24-Jan-2006</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.5</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#rejection-notice" id="id14">Rejection Notice</a></li>
<li><a class="reference internal" href="#abstract" id="id15">Abstract</a></li>
<li><a class="reference internal" href="#background" id="id16">Background</a></li>
<li><a class="reference internal" href="#motivation" id="id17">Motivation</a></li>
<li><a class="reference internal" href="#rationale" id="id18">Rationale</a></li>
<li><a class="reference internal" href="#specification" id="id19">Specification</a></li>
<li><a class="reference internal" href="#replacing-older-functions-with-the-path-class" id="id20">Replacing older functions with the Path class</a></li>
<li><a class="reference internal" href="#deprecations" id="id21">Deprecations</a></li>
<li><a class="reference internal" href="#closed-issues" id="id22">Closed Issues</a></li>
<li><a class="reference internal" href="#open-issues" id="id23">Open Issues</a></li>
<li><a class="reference internal" href="#reference-implementation" id="id24">Reference Implementation</a></li>
<li><a class="reference internal" href="#examples" id="id25">Examples</a></li>
<li><a class="reference internal" href="#references-and-footnotes" id="id26">References and Footnotes</a></li>
<li><a class="reference internal" href="#copyright" id="id27">Copyright</a></li>
</ul>
</div>
<div class="section" id="rejection-notice">
<h1><a class="toc-backref" href="#id14">Rejection Notice</a></h1>
<p>This PEP has been rejected (in this form).  The proposed path class
is the ultimate kitchen sink; but the notion that it's better to
implement <strong>all</strong> functionality that uses a path as a method on a single
class is an anti-pattern.  (E.g. why not <tt class="docutils literal">open()</tt>?  Or <tt class="docutils literal">execfile()</tt>?)
Subclassing from str is a particularly bad idea; many string
operations make no sense when applied to a path.  This PEP has
lingered, and while the discussion flares up from time to time,
it's time to put this PEP out of its misery.  A less far-fetched
proposal might be more palatable.</p>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id15">Abstract</a></h1>
<p>This PEP describes a new class, <tt class="docutils literal">Path</tt>, to be added to the <tt class="docutils literal">os</tt>
module, for handling paths in an object oriented fashion.  The
&quot;weak&quot; deprecation of various related functions is also discussed
and recommended.</p>
</div>
<div class="section" id="background">
<h1><a class="toc-backref" href="#id16">Background</a></h1>
<p>The ideas expressed in this PEP are not recent, but have been
debated in the Python community for many years.  Many have felt
that the API for manipulating file paths as offered in the os.path
module is inadequate.  The first proposal for a <tt class="docutils literal">Path</tt> object was
raised by Just van Rossum on python-dev in 2001 <a class="footnote-reference" href="#id8" id="id1">[2]</a>.  In 2003,
Jason Orendorff released version 1.0 of the &quot;path module&quot; which
was the first public implementation that used objects to represent
paths <a class="footnote-reference" href="#id9" id="id2">[3]</a>.</p>
<p>The path module quickly became very popular and numerous attempts
were made to get the path module included in the Python standard
library; <a class="footnote-reference" href="#id10" id="id3">[4]</a>, <a class="footnote-reference" href="#id11" id="id4">[5]</a>, <a class="footnote-reference" href="#id12" id="id5">[6]</a>, <a class="footnote-reference" href="#id13" id="id6">[7]</a>.</p>
<p>This PEP summarizes the ideas and suggestions people have
expressed about the path module and proposes that a modified
version should be included in the standard library.</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id17">Motivation</a></h1>
<p>Dealing with filesystem paths is a common task in any programming
language, and very common in a high-level language like Python.
Good support for this task is needed, because:</p>
<ul class="simple">
<li>Almost every program uses paths to access files.  It makes sense
that a task, that is so often performed, should be as intuitive
and as easy to perform as possible.</li>
<li>It makes Python an even better replacement language for
over-complicated shell scripts.</li>
</ul>
<p>Currently, Python has a large number of different functions
scattered over half a dozen modules for handling paths.  This
makes it hard for newbies and experienced developers to choose
the right method.</p>
<p>The <tt class="docutils literal">Path</tt> class provides the following enhancements over the
current common practice:</p>
<ul>
<li><p class="first">One &quot;unified&quot; object provides all functionality from previous
functions.</p>
</li>
<li><p class="first">Subclassability - the <tt class="docutils literal">Path</tt> object can be extended to support
paths other than filesystem paths.  The programmer does not need
to learn a new API, but can reuse his or her knowledge of Path
to deal with the extended class.</p>
</li>
<li><p class="first">With all related functionality in one place, the right approach
is easier to learn as one does not have to hunt through many
different modules for the right functions.</p>
</li>
<li><p class="first">Python is an object oriented language.  Just like files,
datetimes and sockets are objects so are paths, they are not
merely strings to be passed to functions.  <tt class="docutils literal">Path</tt> objects is
inherently a pythonic idea.</p>
</li>
<li><p class="first"><tt class="docutils literal">Path</tt> takes advantage of properties.  Properties make for more
readable code:</p>
<pre class="literal-block">
if imgpath.ext == 'jpg':
    jpegdecode(imgpath)
</pre>
<p>Is better than:</p>
<pre class="literal-block">
if os.path.splitexit(imgpath)[1] == 'jpg':
    jpegdecode(imgpath)
</pre>
</li>
</ul>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id18">Rationale</a></h1>
<p>The following points summarize the design:</p>
<ul class="simple">
<li><tt class="docutils literal">Path</tt> extends from string, therefore all code which expects
string pathnames need not be modified and no existing code will
break.</li>
<li>A <tt class="docutils literal">Path</tt> object can be created either by using the classmethod
<tt class="docutils literal">Path.cwd</tt>, by instantiating the class with a string representing
a path or by using the default constructor which is equivalent
to <tt class="docutils literal"><span class="pre">Path(&quot;.&quot;)</span></tt>.</li>
<li><tt class="docutils literal">Path</tt> provides common pathname manipulation, pattern expansion,
pattern matching and other high-level file operations including
copying.  Basically <tt class="docutils literal">Path</tt> provides everything path-related except
the manipulation of file contents, for which file objects are
better suited.</li>
<li>Platform incompatibilities are dealt with by not instantiating
system specific methods.</li>
</ul>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id19">Specification</a></h1>
<p>This class defines the following public interface (docstrings have
been extracted from the reference implementation, and shortened
for brevity; see the reference implementation for more detail):</p>
<pre class="literal-block">
class Path(str):

    # Special Python methods:
    def __new__(cls, *args) =&gt; Path
        &quot;&quot;&quot;
        Creates a new path object concatenating the *args.  *args
        may only contain Path objects or strings.  If *args is
        empty, Path(os.curdir) is created.
        &quot;&quot;&quot;
    def __repr__(self): ...
    def __add__(self, more): ...
    def __radd__(self, other): ...

    # Alternative constructor.
    def cwd(cls): ...

    # Operations on path strings:
    def abspath(self) =&gt; Path
        &quot;&quot;&quot;Returns the absolute path of self as a new Path object.&quot;&quot;&quot;
    def normcase(self): ...
    def normpath(self): ...
    def realpath(self): ...
    def expanduser(self): ...
    def expandvars(self): ...
    def basename(self): ...
    def expand(self): ...
    def splitpath(self) =&gt; (Path, str)
        &quot;&quot;&quot;p.splitpath() -&gt; Return (p.parent, p.name).&quot;&quot;&quot;
    def stripext(self) =&gt; Path
        &quot;&quot;&quot;p.stripext() -&gt; Remove one file extension from the path.&quot;&quot;&quot;
    def splitunc(self): ...  [1]_
    def splitall(self): ...
    def relpath(self): ...
    def relpathto(self, dest): ...

    # Properties about the path:
    parent =&gt; Path
        &quot;&quot;&quot;This Path's parent directory as a new path object.&quot;&quot;&quot;
    name =&gt; str
        &quot;&quot;&quot;The name of this file or directory without the full path.&quot;&quot;&quot;
    ext =&gt; str
        &quot;&quot;&quot;
        The file extension or an empty string if Path refers to a
        file without an extension or a directory.
        &quot;&quot;&quot;
    drive =&gt; str
        &quot;&quot;&quot;
        The drive specifier.  Always empty on systems that don't
        use drive specifiers.
        &quot;&quot;&quot;
    namebase =&gt; str
        &quot;&quot;&quot;
        The same as path.name, but with one file extension
        stripped off.
        &quot;&quot;&quot;
    uncshare[1]

    # Operations that return lists of paths:
    def listdir(self, pattern = None): ...
    def dirs(self, pattern = None): ...
    def files(self, pattern = None): ...
    def walk(self, pattern = None): ...
    def walkdirs(self, pattern = None): ...
    def walkfiles(self, pattern = None): ...
    def match(self, pattern) =&gt; bool
        &quot;&quot;&quot;Returns True if self.name matches the given pattern.&quot;&quot;&quot;

    def matchcase(self, pattern) =&gt; bool
        &quot;&quot;&quot;
        Like match() but is guaranteed to be case sensitive even
        on platforms with case insensitive filesystems.
        &quot;&quot;&quot;
    def glob(self, pattern):

    # Methods for retrieving information about the filesystem
    # path:
    def exists(self): ...
    def isabs(self): ...
    def isdir(self): ...
    def isfile(self): ...
    def islink(self): ...
    def ismount(self): ...
    def samefile(self, other): ...  [1]_
    def atime(self): ...
        &quot;&quot;&quot;Last access time of the file.&quot;&quot;&quot;
    def mtime(self): ...
        &quot;&quot;&quot;Last-modified time of the file.&quot;&quot;&quot;
    def ctime(self): ...
        &quot;&quot;&quot;
        Return the system's ctime which, on some systems (like
        Unix) is the time of the last change, and, on others (like
        Windows), is the creation time for path.
        &quot;&quot;&quot;
    def size(self): ...
    def access(self, mode): ...  [1]_
    def stat(self): ...
    def lstat(self): ...
    def statvfs(self): ...  [1]_
    def pathconf(self, name): ...  [1]_

    # Methods for manipulating information about the filesystem
    # path.
    def utime(self, times) =&gt; None
    def chmod(self, mode) =&gt; None
    def chown(self, uid, gid) =&gt; None [1]_
    def rename(self, new) =&gt; None
    def renames(self, new) =&gt; None

    # Create/delete operations on directories
    def mkdir(self, mode = 0777): ...
    def makedirs(self, mode = 0777): ...
    def rmdir(self): ...
    def removedirs(self): ...

    # Modifying operations on files
    def touch(self): ...
    def remove(self): ...
    def unlink(self): ...

    # Modifying operations on links
    def link(self, newpath): ...
    def symlink(self, newlink): ...
    def readlink(self): ...
    def readlinkabs(self): ...

    # High-level functions from shutil
    def copyfile(self, dst): ...
    def copymode(self, dst): ...
    def copystat(self, dst): ...
    def copy(self, dst): ...
    def copy2(self, dst): ...
    def copytree(self, dst, symlinks = True): ...
    def move(self, dst): ...
    def rmtree(self, ignore_errors = False, onerror = None): ...

    # Special stuff from os
    def chroot(self): ...  [1]_
    def startfile(self): ...  [1]_
</pre>
</div>
<div class="section" id="replacing-older-functions-with-the-path-class">
<h1><a class="toc-backref" href="#id20">Replacing older functions with the Path class</a></h1>
<p>In this section, &quot;a ==&gt; b&quot; means that b can be used as a
replacement for a.</p>
<p>In the following examples, we assume that the <tt class="docutils literal">Path</tt> class is
imported with <tt class="docutils literal">from path import Path</tt>.</p>
<ul>
<li><p class="first">Replacing <tt class="docutils literal">os.path.join</tt>:</p>
<pre class="literal-block">
os.path.join(os.getcwd(), &quot;foobar&quot;)
==&gt;
Path(Path.cwd(), &quot;foobar&quot;)

os.path.join(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;)
==&gt;
Path(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;)
</pre>
</li>
<li><p class="first">Replacing <tt class="docutils literal">os.path.splitext</tt>:</p>
<pre class="literal-block">
fname = &quot;Python2.4.tar.gz&quot;
os.path.splitext(fname)[1]
==&gt;
fname = Path(&quot;Python2.4.tar.gz&quot;)
fname.ext
</pre>
<p>Or if you want both parts:</p>
<pre class="literal-block">
fname = &quot;Python2.4.tar.gz&quot;
base, ext = os.path.splitext(fname)
==&gt;
fname = Path(&quot;Python2.4.tar.gz&quot;)
base, ext = fname.namebase, fname.extx
</pre>
</li>
<li><p class="first">Replacing <tt class="docutils literal">glob.glob</tt>:</p>
<pre class="literal-block">
lib_dir = &quot;/lib&quot;
libs = glob.glob(os.path.join(lib_dir, &quot;*s.o&quot;))
==&gt;
lib_dir = Path(&quot;/lib&quot;)
libs = lib_dir.files(&quot;*.so&quot;)
</pre>
</li>
</ul>
</div>
<div class="section" id="deprecations">
<h1><a class="toc-backref" href="#id21">Deprecations</a></h1>
<p>Introducing this module to the standard library introduces a need
for the &quot;weak&quot; deprecation of a number of existing modules and
functions.  These modules and functions are so widely used that
they cannot be truly deprecated, as in generating
DeprecationWarning.  Here &quot;weak deprecation&quot; means notes in the
documentation only.</p>
<p>The table below lists the existing functionality that should be
deprecated.</p>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Path method/property</th>
<th class="head">Deprecates function</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>normcase()</td>
<td>os.path.normcase()</td>
</tr>
<tr><td>normpath()</td>
<td>os.path.normpath()</td>
</tr>
<tr><td>realpath()</td>
<td>os.path.realpath()</td>
</tr>
<tr><td>expanduser()</td>
<td>os.path.expanduser()</td>
</tr>
<tr><td>expandvars()</td>
<td>os.path.expandvars()</td>
</tr>
<tr><td>parent</td>
<td>os.path.dirname()</td>
</tr>
<tr><td>name</td>
<td>os.path.basename()</td>
</tr>
<tr><td>splitpath()</td>
<td>os.path.split()</td>
</tr>
<tr><td>drive</td>
<td>os.path.splitdrive()</td>
</tr>
<tr><td>ext</td>
<td>os.path.splitext()</td>
</tr>
<tr><td>splitunc()</td>
<td>os.path.splitunc()</td>
</tr>
<tr><td>__new__()</td>
<td>os.path.join(), os.curdir</td>
</tr>
<tr><td>listdir()</td>
<td>os.listdir() [fnmatch.filter()]</td>
</tr>
<tr><td>match()</td>
<td>fnmatch.fnmatch()</td>
</tr>
<tr><td>matchcase()</td>
<td>fnmatch.fnmatchcase()</td>
</tr>
<tr><td>glob()</td>
<td>glob.glob()</td>
</tr>
<tr><td>exists()</td>
<td>os.path.exists()</td>
</tr>
<tr><td>isabs()</td>
<td>os.path.isabs()</td>
</tr>
<tr><td>isdir()</td>
<td>os.path.isdir()</td>
</tr>
<tr><td>isfile()</td>
<td>os.path.isfile()</td>
</tr>
<tr><td>islink()</td>
<td>os.path.islink()</td>
</tr>
<tr><td>ismount()</td>
<td>os.path.ismount()</td>
</tr>
<tr><td>samefile()</td>
<td>os.path.samefile()</td>
</tr>
<tr><td>atime()</td>
<td>os.path.getatime()</td>
</tr>
<tr><td>ctime()</td>
<td>os.path.getctime()</td>
</tr>
<tr><td>mtime()</td>
<td>os.path.getmtime()</td>
</tr>
<tr><td>size()</td>
<td>os.path.getsize()</td>
</tr>
<tr><td>cwd()</td>
<td>os.getcwd()</td>
</tr>
<tr><td>access()</td>
<td>os.access()</td>
</tr>
<tr><td>stat()</td>
<td>os.stat()</td>
</tr>
<tr><td>lstat()</td>
<td>os.lstat()</td>
</tr>
<tr><td>statvfs()</td>
<td>os.statvfs()</td>
</tr>
<tr><td>pathconf()</td>
<td>os.pathconf()</td>
</tr>
<tr><td>utime()</td>
<td>os.utime()</td>
</tr>
<tr><td>chmod()</td>
<td>os.chmod()</td>
</tr>
<tr><td>chown()</td>
<td>os.chown()</td>
</tr>
<tr><td>rename()</td>
<td>os.rename()</td>
</tr>
<tr><td>renames()</td>
<td>os.renames()</td>
</tr>
<tr><td>mkdir()</td>
<td>os.mkdir()</td>
</tr>
<tr><td>makedirs()</td>
<td>os.makedirs()</td>
</tr>
<tr><td>rmdir()</td>
<td>os.rmdir()</td>
</tr>
<tr><td>removedirs()</td>
<td>os.removedirs()</td>
</tr>
<tr><td>remove()</td>
<td>os.remove()</td>
</tr>
<tr><td>unlink()</td>
<td>os.unlink()</td>
</tr>
<tr><td>link()</td>
<td>os.link()</td>
</tr>
<tr><td>symlink()</td>
<td>os.symlink()</td>
</tr>
<tr><td>readlink()</td>
<td>os.readlink()</td>
</tr>
<tr><td>chroot()</td>
<td>os.chroot()</td>
</tr>
<tr><td>startfile()</td>
<td>os.startfile()</td>
</tr>
<tr><td>copyfile()</td>
<td>shutil.copyfile()</td>
</tr>
<tr><td>copymode()</td>
<td>shutil.copymode()</td>
</tr>
<tr><td>copystat()</td>
<td>shutil.copystat()</td>
</tr>
<tr><td>copy()</td>
<td>shutil.copy()</td>
</tr>
<tr><td>copy2()</td>
<td>shutil.copy2()</td>
</tr>
<tr><td>copytree()</td>
<td>shutil.copytree()</td>
</tr>
<tr><td>move()</td>
<td>shutil.move()</td>
</tr>
<tr><td>rmtree()</td>
<td>shutil.rmtree()</td>
</tr>
</tbody>
</table>
<p>The <tt class="docutils literal">Path</tt> class deprecates the whole of <tt class="docutils literal">os.path</tt>, <tt class="docutils literal">shutil</tt>, <tt class="docutils literal">fnmatch</tt>
and <tt class="docutils literal">glob</tt>.  A big chunk of <tt class="docutils literal">os</tt> is also deprecated.</p>
</div>
<div class="section" id="closed-issues">
<h1><a class="toc-backref" href="#id22">Closed Issues</a></h1>
<p>A number contentious issues have been resolved since this PEP
first appeared on python-dev:</p>
<ul>
<li><p class="first">The <tt class="docutils literal">__div__()</tt> method was removed.  Overloading the / (division)
operator may be &quot;too much magic&quot; and make path concatenation
appear to be division.  The method can always be re-added later
if the BDFL so desires.  In its place, <tt class="docutils literal">__new__()</tt> got an <tt class="docutils literal">*args</tt>
argument that accepts both <tt class="docutils literal">Path</tt> and string objects.  The <tt class="docutils literal">*args</tt>
are concatenated with <tt class="docutils literal">os.path.join()</tt> which is used to construct
the <tt class="docutils literal">Path</tt> object.  These changes obsoleted the problematic
<tt class="docutils literal">joinpath()</tt> method which was removed.</p>
</li>
<li><p class="first">The methods and the properties <tt class="docutils literal"><span class="pre">getatime()/atime</span></tt>,
<tt class="docutils literal"><span class="pre">getctime()/ctime</span></tt>, <tt class="docutils literal"><span class="pre">getmtime()/mtime</span></tt> and <tt class="docutils literal"><span class="pre">getsize()/size</span></tt> duplicated
each other.  These methods and properties have been merged to
<tt class="docutils literal">atime()</tt>, <tt class="docutils literal">ctime()</tt>, <tt class="docutils literal">mtime()</tt> and <tt class="docutils literal">size()</tt>.  The reason they are not
properties instead, is because there is a possibility that they
may change unexpectedly.  The following example is not
guaranteed to always pass the assertion:</p>
<pre class="literal-block">
p = Path(&quot;foobar&quot;)
s = p.size()
assert p.size() == s
</pre>
</li>
</ul>
</div>
<div class="section" id="open-issues">
<h1><a class="toc-backref" href="#id23">Open Issues</a></h1>
<p>Some functionality of Jason Orendorff's path module have been
omitted:</p>
<ul>
<li><p class="first">Function for opening a path - better handled by the builtin
<tt class="docutils literal">open()</tt>.</p>
</li>
<li><p class="first">Functions for reading and writing whole files - better handled
by file objects' own <tt class="docutils literal">read()</tt> and <tt class="docutils literal">write()</tt> methods.</p>
</li>
<li><p class="first">A <tt class="docutils literal">chdir()</tt> function may be a worthy inclusion.</p>
</li>
<li><p class="first">A deprecation schedule needs to be set up.  How much
functionality should <tt class="docutils literal">Path</tt> implement?  How much of existing
functionality should it deprecate and when?</p>
</li>
<li><p class="first">The name obviously has to be either &quot;path&quot; or &quot;Path,&quot; but where
should it live?  In its own module or in <tt class="docutils literal">os</tt>?</p>
</li>
<li><p class="first">Due to <tt class="docutils literal">Path</tt> subclassing either <tt class="docutils literal">str</tt> or <tt class="docutils literal">unicode</tt>, the following
non-magic, public methods are available on <tt class="docutils literal">Path</tt> objects:</p>
<pre class="literal-block">
capitalize(), center(), count(), decode(), encode(),
endswith(), expandtabs(), find(), index(), isalnum(),
isalpha(), isdigit(), islower(), isspace(), istitle(),
isupper(), join(), ljust(), lower(), lstrip(), replace(),
rfind(), rindex(), rjust(), rsplit(), rstrip(), split(),
splitlines(), startswith(), strip(), swapcase(), title(),
translate(), upper(), zfill()
</pre>
<p>On python-dev it has been argued whether this inheritance is
sane or not.  Most persons debating said that most string
methods doesn't make sense in the context of filesystem paths --
they are just dead weight.  The other position, also argued on
python-dev, is that inheriting from string is very convenient
because it allows code to &quot;just work&quot; with <tt class="docutils literal">Path</tt> objects without
having to be adapted for them.</p>
<p>One of the problems is that at the Python level, there is no way
to make an object &quot;string-like enough,&quot; so that it can be passed
to the builtin function <tt class="docutils literal">open()</tt> (and other builtins expecting a
string or buffer), unless the object inherits from either <tt class="docutils literal">str</tt> or
<tt class="docutils literal">unicode</tt>.  Therefore, to not inherit from string requires changes
in CPython's core.</p>
</li>
</ul>
<p>The functions and modules that this new module is trying to
replace (<tt class="docutils literal">os.path</tt>, <tt class="docutils literal">shutil</tt>, <tt class="docutils literal">fnmatch</tt>, <tt class="docutils literal">glob</tt> and parts of <tt class="docutils literal">os</tt>) are
expected to be available in future Python versions for a long
time, to preserve backwards compatibility.</p>
</div>
<div class="section" id="reference-implementation">
<h1><a class="toc-backref" href="#id24">Reference Implementation</a></h1>
<p>Currently, the <tt class="docutils literal">Path</tt> class is implemented as a thin wrapper around
the standard library modules <tt class="docutils literal">fnmatch</tt>, <tt class="docutils literal">glob</tt>, <tt class="docutils literal">os</tt>, <tt class="docutils literal">os.path</tt> and
<tt class="docutils literal">shutil</tt>.  The intention of this PEP is to move functionality from
the aforementioned modules to <tt class="docutils literal">Path</tt> while they are being
deprecated.</p>
<p>For more detail and an implementation see:</p>
<blockquote>
<a class="reference external" href="http://wiki.python.org/moin/PathModule">http://wiki.python.org/moin/PathModule</a></blockquote>
</div>
<div class="section" id="examples">
<h1><a class="toc-backref" href="#id25">Examples</a></h1>
<p>In this section, &quot;a ==&gt; b&quot; means that b can be used as a
replacement for a.</p>
<ul>
<li><p class="first">Make all python files in the a directory executable:</p>
<pre class="literal-block">
DIR = '/usr/home/guido/bin'
for f in os.listdir(DIR):
    if f.endswith('.py'):
        path = os.path.join(DIR, f)
        os.chmod(path, 0755)
==&gt;
for f in Path('/usr/home/guido/bin').files(&quot;*.py&quot;):
    f.chmod(0755)
</pre>
</li>
<li><p class="first">Delete emacs backup files:</p>
<pre class="literal-block">
def delete_backups(arg, dirname, names):
    for name in names:
        if name.endswith('~'):
            os.remove(os.path.join(dirname, name))
os.path.walk(os.environ['HOME'], delete_backups, None)
==&gt;
d = Path(os.environ['HOME'])
for f in d.walkfiles('*~'):
    f.remove()
</pre>
</li>
<li><p class="first">Finding the relative path to a file:</p>
<pre class="literal-block">
b = Path('/users/peter/')
a = Path('/users/peter/synergy/tiki.txt')
a.relpathto(b)
</pre>
</li>
<li><p class="first">Splitting a path into directory and filename:</p>
<pre class="literal-block">
os.path.split(&quot;/path/to/foo/bar.txt&quot;)
==&gt;
Path(&quot;/path/to/foo/bar.txt&quot;).splitpath()
</pre>
</li>
<li><p class="first">List all Python scripts in the current directory tree:</p>
<pre class="literal-block">
list(Path().walkfiles(&quot;*.py&quot;))
</pre>
</li>
</ul>
</div>
<div class="section" id="references-and-footnotes">
<h1><a class="toc-backref" href="#id26">References and Footnotes</a></h1>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Method is not guaranteed to be available on all platforms.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[2]</a></td><td>&quot;(idea) subclassable string: path object?&quot;, van Rossum, 2001
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2001-August/016663.html">https://mail.python.org/pipermail/python-dev/2001-August/016663.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[3]</a></td><td>&quot;path module v1.0 released&quot;, Orendorff, 2003
<a class="reference external" href="https://mail.python.org/pipermail/python-announce-list/2003-January/001984.html">https://mail.python.org/pipermail/python-announce-list/2003-January/001984.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[4]</a></td><td>&quot;Some RFE for review&quot;, Birkenfeld, 2005
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2005-June/054438.html">https://mail.python.org/pipermail/python-dev/2005-June/054438.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[5]</a></td><td>&quot;path module&quot;, Orendorff, 2003
<a class="reference external" href="https://mail.python.org/pipermail/python-list/2003-July/174289.html">https://mail.python.org/pipermail/python-list/2003-July/174289.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[6]</a></td><td>&quot;PRE-PEP: new Path class&quot;, Roth, 2004
<a class="reference external" href="https://mail.python.org/pipermail/python-list/2004-January/201672.html">https://mail.python.org/pipermail/python-list/2004-January/201672.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[7]</a></td><td><a class="reference external" href="http://wiki.python.org/moin/PathClass">http://wiki.python.org/moin/PathClass</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id27">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

