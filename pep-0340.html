<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">340</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Anonymous Block Statements</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0340.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Guido van Rossum</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">27-Apr-2005</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id6">Introduction</a></li>
<li><a class="reference internal" href="#rejection-notice" id="id7">Rejection Notice</a></li>
<li><a class="reference internal" href="#motivation-and-summary" id="id8">Motivation and Summary</a></li>
<li><a class="reference internal" href="#use-cases" id="id9">Use Cases</a></li>
<li><a class="reference internal" href="#specification-the-exit-method" id="id10">Specification: the __exit__() Method</a></li>
<li><a class="reference internal" href="#specification-the-anonymous-block-statement" id="id11">Specification: the Anonymous Block Statement</a></li>
<li><a class="reference internal" href="#specification-generator-exit-handling" id="id12">Specification: Generator Exit Handling</a></li>
<li><a class="reference internal" href="#alternatives-considered-and-rejected" id="id13">Alternatives Considered and Rejected</a></li>
<li><a class="reference internal" href="#comparison-to-thunks" id="id14">Comparison to Thunks</a></li>
<li><a class="reference internal" href="#examples" id="id15">Examples</a></li>
<li><a class="reference internal" href="#acknowledgements" id="id16">Acknowledgements</a></li>
<li><a class="reference internal" href="#references" id="id17">References</a></li>
<li><a class="reference internal" href="#copyright" id="id18">Copyright</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id6">Introduction</a></h1>
<p>This PEP proposes a new type of compound statement which can be
used for resource management purposes.  The new statement type
is provisionally called the block-statement because the keyword
to be used has not yet been chosen.</p>
<p>This PEP competes with several other PEPs: <a class="reference external" href="/dev/peps/pep-0288">PEP 288</a> (Generators
Attributes and Exceptions; only the second part), <a class="reference external" href="/dev/peps/pep-0310">PEP 310</a>
(Reliable Acquisition/Release Pairs), and <a class="reference external" href="/dev/peps/pep-0325">PEP 325</a>
(Resource-Release Support for Generators).</p>
<p>I should clarify that using a generator to &quot;drive&quot; a block
statement is really a separable proposal; with just the definition
of the block statement from the PEP you could implement all the
examples using a class (similar to example 6, which is easily
turned into a template).  But the key idea is using a generator to
drive a block statement; the rest is elaboration, so I'd like to
keep these two parts together.</p>
<p>(<a class="reference external" href="/dev/peps/pep-0342">PEP 342</a>, Enhanced Iterators, was originally a part of this PEP;
but the two proposals are really independent and with Steven
Bethard's help I have moved it to a separate PEP.)</p>
</div>
<div class="section" id="rejection-notice">
<h1><a class="toc-backref" href="#id7">Rejection Notice</a></h1>
<p>I am rejecting this PEP in favor of <a class="reference external" href="/dev/peps/pep-0343">PEP 343</a>.  See the motivational
section in that PEP for the reasoning behind this rejection.  GvR.</p>
</div>
<div class="section" id="motivation-and-summary">
<h1><a class="toc-backref" href="#id8">Motivation and Summary</a></h1>
<p>(Thanks to Shane Hathaway -- Hi Shane!)</p>
<p>Good programmers move commonly used code into reusable functions.
Sometimes, however, patterns arise in the structure of the
functions rather than the actual sequence of statements.  For
example, many functions acquire a lock, execute some code specific
to that function, and unconditionally release the lock.  Repeating
the locking code in every function that uses it is error prone and
makes refactoring difficult.</p>
<p>Block statements provide a mechanism for encapsulating patterns of
structure.  Code inside the block statement runs under the control
of an object called a block iterator.  Simple block iterators
execute code before and after the code inside the block statement.
Block iterators also have the opportunity to execute the
controlled code more than once (or not at all), catch exceptions,
or receive data from the body of the block statement.</p>
<p>A convenient way to write block iterators is to write a generator
(<a class="reference external" href="/dev/peps/pep-0255">PEP 255</a>).  A generator looks a lot like a Python function, but
instead of returning a value immediately, generators pause their
execution at &quot;yield&quot; statements.  When a generator is used as a
block iterator, the yield statement tells the Python interpreter
to suspend the block iterator, execute the block statement body,
and resume the block iterator when the body has executed.</p>
<p>The Python interpreter behaves as follows when it encounters a
block statement based on a generator.  First, the interpreter
instantiates the generator and begins executing it.  The generator
does setup work appropriate to the pattern it encapsulates, such
as acquiring a lock, opening a file, starting a database
transaction, or starting a loop.  Then the generator yields
execution to the body of the block statement using a yield
statement.  When the block statement body completes, raises an
uncaught exception, or sends data back to the generator using a
continue statement, the generator resumes.  At this point, the
generator can either clean up and stop or yield again, causing the
block statement body to execute again.  When the generator
finishes, the interpreter leaves the block statement.</p>
</div>
<div class="section" id="use-cases">
<h1><a class="toc-backref" href="#id9">Use Cases</a></h1>
<p>See the Examples section near the end.</p>
</div>
<div class="section" id="specification-the-exit-method">
<h1><a class="toc-backref" href="#id10">Specification: the __exit__() Method</a></h1>
<p>An optional new method for iterators is proposed, called
<tt class="docutils literal">__exit__()</tt>.  It takes up to three arguments which correspond to
the three &quot;arguments&quot; to the raise-statement: type, value, and
traceback.  If all three arguments are <tt class="docutils literal">None</tt>, <tt class="docutils literal">sys.exc_info()</tt> may be
consulted to provide suitable default values.</p>
</div>
<div class="section" id="specification-the-anonymous-block-statement">
<h1><a class="toc-backref" href="#id11">Specification: the Anonymous Block Statement</a></h1>
<p>A new statement is proposed with the syntax:</p>
<pre class="literal-block">
block EXPR1 as VAR1:
    BLOCK1
</pre>
<p>Here, 'block' and 'as' are new keywords; <tt class="docutils literal">EXPR1</tt> is an arbitrary
expression (but not an expression-list) and <tt class="docutils literal">VAR1</tt> is an arbitrary
assignment target (which may be a comma-separated list).</p>
<p>The &quot;as VAR1&quot; part is optional; if omitted, the assignments to
VAR1 in the translation below are omitted (but the expressions
assigned are still evaluated!).</p>
<p>The choice of the 'block' keyword is contentious; many
alternatives have been proposed, including not to use a keyword at
all (which I actually like).  <a class="reference external" href="/dev/peps/pep-0310">PEP 310</a> uses 'with' for similar
semantics, but I would like to reserve that for a with-statement
similar to the one found in Pascal and VB.  (Though I just found
that the C# designers don't like 'with' <a class="footnote-reference" href="#id4" id="id1">[2]</a>, and I have to agree
with their reasoning.)  To sidestep this issue momentarily I'm
using 'block' until we can agree on the right keyword, if any.</p>
<p>Note that the 'as' keyword is not contentious (it will finally be
elevated to proper keyword status).</p>
<p>Note that it is up to the iterator to decide whether a
block-statement represents a loop with multiple iterations; in the
most common use case <tt class="docutils literal">BLOCK1</tt> is executed exactly once.  To the
parser, however, it is always a loop; break and continue return
transfer to the block's iterator (see below for details).</p>
<p>The translation is subtly different from a for-loop: <tt class="docutils literal">iter()</tt> is
not called, so <tt class="docutils literal">EXPR1</tt> should already be an iterator (not just an
iterable); and the iterator is guaranteed to be notified when
the block-statement is left, regardless if this is due to a
break, return or exception:</p>
<pre class="literal-block">
itr = EXPR1  # The iterator
ret = False  # True if a return statement is active
val = None   # Return value, if ret == True
exc = None   # sys.exc_info() tuple if an exception is active
while True:
    try:
        if exc:
            ext = getattr(itr, &quot;__exit__&quot;, None)
            if ext is not None:
                VAR1 = ext(*exc)   # May re-raise *exc
            else:
                raise exc[0], exc[1], exc[2]
        else:
            VAR1 = itr.next()  # May raise StopIteration
    except StopIteration:
        if ret:
            return val
        break
    try:
        ret = False
        val = exc = None
        BLOCK1
    except:
        exc = sys.exc_info()
</pre>
<p>(However, the variables 'itr' etc. are not user-visible and the
built-in names used cannot be overridden by the user.)</p>
<p>Inside <tt class="docutils literal">BLOCK1</tt>, the following special translations apply:</p>
<ul>
<li><p class="first">&quot;break&quot; is always legal; it is translated into:</p>
<pre class="literal-block">
exc = (StopIteration, None, None)
continue
</pre>
</li>
<li><p class="first">&quot;return EXPR3&quot; is only legal when the block-statement is
contained in a function definition; it is translated into:</p>
<pre class="literal-block">
exc = (StopIteration, None, None)
ret = True
val = EXPR3
continue
</pre>
</li>
</ul>
<p>The net effect is that break and return behave much the same as
if the block-statement were a for-loop, except that the iterator
gets a chance at resource cleanup before the block-statement is
left, through the optional <tt class="docutils literal">__exit__()</tt> method. The iterator also
gets a chance if the block-statement is left through raising an
exception.  If the iterator doesn't have an <tt class="docutils literal">__exit__()</tt> method,
there is no difference with a for-loop (except that a for-loop
calls <tt class="docutils literal">iter()</tt> on <tt class="docutils literal">EXPR1</tt>).</p>
<p>Note that a yield-statement in a block-statement is not treated
differently.  It suspends the function containing the block
<strong>without</strong> notifying the block's iterator.  The block's iterator is
entirely unaware of this yield, since the local control flow
doesn't actually leave the block.  In other words, it is <strong>not</strong>
like a break or return statement.  When the loop that was resumed
by the yield calls <tt class="docutils literal">next()</tt>, the block is resumed right after the
yield.  (See example 7 below.)  The generator finalization
semantics described below guarantee (within the limitations of all
finalization semantics) that the block will be resumed eventually.</p>
<p>Unlike the for-loop, the block-statement does not have an
else-clause.  I think it would be confusing, and emphasize the
&quot;loopiness&quot; of the block-statement, while I want to emphasize its
<strong>difference</strong> from a for-loop.  In addition, there are several
possible semantics for an else-clause, and only a very weak use
case.</p>
</div>
<div class="section" id="specification-generator-exit-handling">
<h1><a class="toc-backref" href="#id12">Specification: Generator Exit Handling</a></h1>
<p>Generators will implement the new <tt class="docutils literal">__exit__()</tt> method API.</p>
<p>Generators will be allowed to have a <tt class="docutils literal">yield</tt> statement inside a
try-finally statement.</p>
<p>The expression argument to the yield-statement will become
optional (defaulting to None).</p>
<p>When <tt class="docutils literal">__exit__()</tt> is called, the generator is resumed but at the
point of the yield-statement the exception represented by the
<tt class="docutils literal">__exit__</tt> argument(s) is raised.  The generator may re-raise this
exception, raise another exception, or yield another value,
except that if the exception passed in to <tt class="docutils literal">__exit__()</tt> was
StopIteration, it ought to raise StopIteration (otherwise the
effect would be that a break is turned into continue, which is
unexpected at least).  When the <strong>initial</strong> call resuming the
generator is an <tt class="docutils literal">__exit__()</tt> call instead of a <tt class="docutils literal">next()</tt> call, the
generator's execution is aborted and the exception is re-raised
without passing control to the generator's body.</p>
<p>When a generator that has not yet terminated is garbage-collected
(either through reference counting or by the cyclical garbage
collector), its <tt class="docutils literal">__exit__()</tt> method is called once with
StopIteration as its first argument.  Together with the
requirement that a generator ought to raise StopIteration when
<tt class="docutils literal">__exit__()</tt> is called with StopIteration, this guarantees the
eventual activation of any finally-clauses that were active when
the generator was last suspended.  Of course, under certain
circumstances the generator may never be garbage-collected.  This
is no different than the guarantees that are made about finalizers
(<tt class="docutils literal">__del__()</tt> methods) of other objects.</p>
</div>
<div class="section" id="alternatives-considered-and-rejected">
<h1><a class="toc-backref" href="#id13">Alternatives Considered and Rejected</a></h1>
<ul>
<li><p class="first">Many alternatives have been proposed for 'block'.  I haven't
seen a proposal for another keyword that I like better than
'block' yet.  Alas, 'block' is also not a good choice; it is a
rather popular name for variables, arguments and methods.
Perhaps 'with' is the best choice after all?</p>
</li>
<li><p class="first">Instead of trying to pick the ideal keyword, the block-statement
could simply have the form:</p>
<pre class="literal-block">
EXPR1 as VAR1:
    BLOCK1
</pre>
<p>This is at first attractive because, together with a good choice
of function names (like those in the Examples section below)
used in <tt class="docutils literal">EXPR1</tt>, it reads well, and feels like a &quot;user-defined
statement&quot;.  And yet, it makes me (and many others)
uncomfortable; without a keyword the syntax is very &quot;bland&quot;,
difficult to look up in a manual (remember that 'as' is
optional), and it makes the meaning of break and continue in the
block-statement even more confusing.</p>
</li>
<li><p class="first">Phillip Eby has proposed to have the block-statement use
an entirely different API than the for-loop, to differentiate
between the two.  A generator would have to be wrapped in a
decorator to make it support the block API.  IMO this adds more
complexity with very little benefit; and we can't relly deny
that the block-statement is conceptually a loop -- it supports
break and continue, after all.</p>
</li>
<li><p class="first">This keeps getting proposed: &quot;block VAR1 = EXPR1&quot; instead of
&quot;block EXPR1 as VAR1&quot;.  That would be very misleading, since
VAR1 does <strong>not</strong> get assigned the value of EXPR1; EXPR1 results
in a generator which is assigned to an internal variable, and
VAR1 is the value returned by successive calls to the <tt class="docutils literal">__next__()</tt>
method of that iterator.</p>
</li>
<li><p class="first">Why not change the translation to apply <tt class="docutils literal">iter(EXPR1)</tt>?  All the
examples would continue to work.  But this makes the
block-statement <strong>more</strong> like a for-loop, while the emphasis ought
to be on the <strong>difference</strong> between the two.  Not calling <tt class="docutils literal">iter()</tt>
catches a bunch of misunderstandings, like using a sequence as
<tt class="docutils literal">EXPR1</tt>.</p>
</li>
</ul>
</div>
<div class="section" id="comparison-to-thunks">
<h1><a class="toc-backref" href="#id14">Comparison to Thunks</a></h1>
<p>Alternative semantics proposed for the block-statement turn the
block into a thunk (an anonymous function that blends into the
containing scope).</p>
<p>The main advantage of thunks that I can see is that you can save
the thunk for later, like a callback for a button widget (the
thunk then becomes a closure).  You can't use a yield-based block
for that (except in Ruby, which uses yield syntax with a
thunk-based implementation).  But I have to say that I almost see
this as an advantage: I think I'd be slightly uncomfortable seeing
a block and not knowing whether it will be executed in the normal
control flow or later.  Defining an explicit nested function for
that purpose doesn't have this problem for me, because I already
know that the 'def' keyword means its body is executed later.</p>
<p>The other problem with thunks is that once we think of them as the
anonymous functions they are, we're pretty much forced to say that
a return statement in a thunk returns from the thunk rather than
from the containing function.  Doing it any other way would cause
major weirdness when the thunk were to survive its containing
function as a closure (perhaps continuations would help, but I'm
not about to go there :-).</p>
<p>But then an IMO important use case for the resource cleanup
template pattern is lost.  I routinely write code like this:</p>
<pre class="literal-block">
def findSomething(self, key, default=None):
    self.lock.acquire()
    try:
         for item in self.elements:
             if item.matches(key):
                 return item
         return default
    finally:
       self.lock.release()
</pre>
<p>and I'd be bummed if I couldn't write this as:</p>
<pre class="literal-block">
def findSomething(self, key, default=None):
    block locking(self.lock):
         for item in self.elements:
             if item.matches(key):
                 return item
         return default
</pre>
<p>This particular example can be rewritten using a break:</p>
<pre class="literal-block">
def findSomething(self, key, default=None):
    block locking(self.lock):
         for item in self.elements:
             if item.matches(key):
                 break
         else:
             item = default
     return item
</pre>
<p>but it looks forced and the transformation isn't always that easy;
you'd be forced to rewrite your code in a single-return style
which feels too restrictive.</p>
<p>Also note the semantic conundrum of a yield in a thunk -- the only
reasonable interpretation is that this turns the thunk into a
generator!</p>
<p>Greg Ewing believes that thunks &quot;would be a lot simpler, doing
just what is required without any jiggery pokery with exceptions
and break/continue/return statements.  It would be easy to explain
what it does and why it's useful.&quot;</p>
<p>But in order to obtain the required local variable sharing between
the thunk and the containing function, every local variable used
or set in the thunk would have to become a 'cell' (our mechanism
for sharing variables between nested scopes).  Cells slow down
access compared to regular local variables: access involves an
extra C function call (<tt class="docutils literal">PyCell_Get()</tt> or <tt class="docutils literal">PyCell_Set()</tt>).</p>
<p>Perhaps not entirely coincidentally, the last example above
(<tt class="docutils literal">findSomething()</tt> rewritten to avoid a return inside the block)
shows that, unlike for regular nested functions, we'll want
variables <strong>assigned to</strong> by the thunk also to be shared with the
containing function, even if they are not assigned to outside the
thunk.</p>
<p>Greg Ewing again: &quot;generators have turned out to be more powerful,
because you can have more than one of them on the go at once. Is
there a use for that capability here?&quot;</p>
<p>I believe there are definitely uses for this; several people have
already shown how to do asynchronous light-weight threads using
generators (e.g. David Mertz quoted in <a class="reference external" href="/dev/peps/pep-0288">PEP 288</a>, and Fredrik
Lundh <a class="footnote-reference" href="#id5" id="id2">[3]</a>).</p>
<p>And finally, Greg says: &quot;a thunk implementation has the potential
to easily handle multiple block arguments, if a suitable syntax
could ever be devised. It's hard to see how that could be done in
a general way with the generator implementation.&quot;</p>
<p>However, the use cases for multiple blocks seem elusive.</p>
<p>(Proposals have since been made to change the implementation of
thunks to remove most of these objections, but the resulting
semantics are fairly complex to explain and to implement, so IMO
that defeats the purpose of using thunks in the first place.)</p>
</div>
<div class="section" id="examples">
<h1><a class="toc-backref" href="#id15">Examples</a></h1>
<p>(Several of these examples contain &quot;yield None&quot;.  If <a class="reference external" href="/dev/peps/pep-0342">PEP 342</a> is
accepted, these can be changed to just &quot;yield&quot; of course.)</p>
<ol class="arabic">
<li><p class="first">A template for ensuring that a lock, acquired at the start of a
block, is released when the block is left:</p>
<pre class="literal-block">
def locking(lock):
    lock.acquire()
    try:
        yield None
    finally:
        lock.release()
</pre>
<p>Used as follows:</p>
<pre class="literal-block">
block locking(myLock):
    # Code here executes with myLock held.  The lock is
    # guaranteed to be released when the block is left (even
    # if via return or by an uncaught exception).
</pre>
</li>
<li><p class="first">A template for opening a file that ensures the file is closed
when the block is left:</p>
<pre class="literal-block">
def opening(filename, mode=&quot;r&quot;):
    f = open(filename, mode)
    try:
        yield f
    finally:
        f.close()
</pre>
<p>Used as follows:</p>
<pre class="literal-block">
block opening(&quot;/etc/passwd&quot;) as f:
    for line in f:
        print line.rstrip()
</pre>
</li>
<li><p class="first">A template for committing or rolling back a database
transaction:</p>
<pre class="literal-block">
def transactional(db):
    try:
        yield None
    except:
        db.rollback()
        raise
    else:
        db.commit()
</pre>
</li>
<li><p class="first">A template that tries something up to n times:</p>
<pre class="literal-block">
def auto_retry(n=3, exc=Exception):
    for i in range(n):
        try:
            yield None
            return
        except exc, err:
            # perhaps log exception here
            continue
    raise # re-raise the exception we caught earlier
</pre>
<p>Used as follows:</p>
<pre class="literal-block">
block auto_retry(3, IOError):
    f = urllib.urlopen(&quot;http://www.python.org/dev/peps/pep-0340/&quot;)
    print f.read()
</pre>
</li>
<li><p class="first">It is possible to nest blocks and combine templates:</p>
<pre class="literal-block">
def locking_opening(lock, filename, mode=&quot;r&quot;):
    block locking(lock):
        block opening(filename) as f:
            yield f
</pre>
<p>Used as follows:</p>
<pre class="literal-block">
block locking_opening(myLock, &quot;/etc/passwd&quot;) as f:
    for line in f:
        print line.rstrip()
</pre>
<p>(If this example confuses you, consider that it is equivalent
to using a for-loop with a yield in its body in a regular
generator which is invoking another iterator or generator
recursively; see for example the source code for <tt class="docutils literal">os.walk()</tt>.)</p>
</li>
<li><p class="first">It is possible to write a regular iterator with the
semantics of example 1:</p>
<pre class="literal-block">
class locking:
   def __init__(self, lock):
       self.lock = lock
       self.state = 0
   def __next__(self, arg=None):
       # ignores arg
       if self.state:
           assert self.state == 1
           self.lock.release()
           self.state += 1
           raise StopIteration
       else:
           self.lock.acquire()
           self.state += 1
           return None
   def __exit__(self, type, value=None, traceback=None):
       assert self.state in (0, 1, 2)
       if self.state == 1:
           self.lock.release()
       raise type, value, traceback
</pre>
<p>(This example is easily modified to implement the other
examples; it shows how much simpler generators are for the same
purpose.)</p>
</li>
<li><p class="first">Redirect stdout temporarily:</p>
<pre class="literal-block">
def redirecting_stdout(new_stdout):
    save_stdout = sys.stdout
    try:
        sys.stdout = new_stdout
        yield None
    finally:
        sys.stdout = save_stdout
</pre>
<p>Used as follows:</p>
<pre class="literal-block">
block opening(filename, &quot;w&quot;) as f:
    block redirecting_stdout(f):
        print &quot;Hello world&quot;
</pre>
</li>
<li><p class="first">A variant on <tt class="docutils literal">opening()</tt> that also returns an error condition:</p>
<pre class="literal-block">
def opening_w_error(filename, mode=&quot;r&quot;):
    try:
        f = open(filename, mode)
    except IOError, err:
        yield None, err
    else:
        try:
            yield f, None
        finally:
            f.close()
</pre>
<p>Used as follows:</p>
<pre class="literal-block">
block opening_w_error(&quot;/etc/passwd&quot;, &quot;a&quot;) as f, err:
    if err:
        print &quot;IOError:&quot;, err
    else:
        f.write(&quot;guido::0:0::/:/bin/sh\n&quot;)
</pre>
</li>
</ol>
</div>
<div class="section" id="acknowledgements">
<h1><a class="toc-backref" href="#id16">Acknowledgements</a></h1>
<p>In no useful order: Alex Martelli, Barry Warsaw, Bob Ippolito,
Brett Cannon, Brian Sabbey, Chris Ryland, Doug Landauer, Duncan
Booth, Fredrik Lundh, Greg Ewing, Holger Krekel, Jason Diamond,
Jim Jewett, Josiah Carlson, Ka-Ping Yee, Michael Chermside,
Michael Hudson, Neil Schemenauer, Nick Coghlan, Paul Moore,
Phillip Eby, Raymond Hettinger, Georg Brandl, Samuele
Pedroni, Shannon Behrens, Skip Montanaro, Steven Bethard, Terry
Reedy, Tim Delaney, Aahz, and others.  Thanks all for the valuable
contributions!</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id17">References</a></h1>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2005-April/052821.html">https://mail.python.org/pipermail/python-dev/2005-April/052821.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[2]</a></td><td><a class="reference external" href="http://msdn.microsoft.com/vcsharp/programming/language/ask/withstatement/">http://msdn.microsoft.com/vcsharp/programming/language/ask/withstatement/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[3]</a></td><td><a class="reference external" href="http://effbot.org/zone/asyncore-generators.htm">http://effbot.org/zone/asyncore-generators.htm</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id18">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
</div>

