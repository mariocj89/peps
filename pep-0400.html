<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">400</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Deprecate codecs.StreamReader and codecs.StreamWriter</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0400.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Victor Stinner &lt;victor.stinner&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Deferred</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">28-May-2011</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.3</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id5">Abstract</a></li>
<li><a class="reference internal" href="#pep-deferral" id="id6">PEP Deferral</a></li>
<li><a class="reference internal" href="#motivation" id="id7">Motivation</a></li>
<li><a class="reference internal" href="#rationale" id="id8">Rationale</a><ul>
<li><a class="reference internal" href="#streamreader-and-streamwriter-issues" id="id9">StreamReader and StreamWriter issues</a></li>
<li><a class="reference internal" href="#textiowrapper-features" id="id10">TextIOWrapper features</a></li>
<li><a class="reference internal" href="#textiowrapper-issues" id="id11">TextIOWrapper issues</a></li>
<li><a class="reference internal" href="#possible-improvements-of-streamreader-and-streamwriter" id="id12">Possible improvements of StreamReader and StreamWriter</a></li>
<li><a class="reference internal" href="#usage-of-streamreader-and-streamwriter" id="id13">Usage of StreamReader and StreamWriter</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility" id="id14">Backwards Compatibility</a><ul>
<li><a class="reference internal" href="#keep-the-public-api-codecs-open" id="id15">Keep the public API, codecs.open</a></li>
<li><a class="reference internal" href="#deprecate-streamreader-and-streamwriter" id="id16">Deprecate StreamReader and StreamWriter</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alternative-approach" id="id17">Alternative Approach</a></li>
<li><a class="reference internal" href="#appendix-a-issues-with-stateful-codecs" id="id18">Appendix A: Issues with stateful codecs</a><ul>
<li><a class="reference internal" href="#stateful-codecs" id="id19">Stateful codecs</a></li>
<li><a class="reference internal" href="#read-and-seek-0" id="id20">Read and seek(0)</a></li>
<li><a class="reference internal" href="#seek-n" id="id21">seek(n)</a></li>
<li><a class="reference internal" href="#append-mode" id="id22">Append mode</a></li>
</ul>
</li>
<li><a class="reference internal" href="#links" id="id23">Links</a></li>
<li><a class="reference internal" href="#copyright" id="id24">Copyright</a></li>
<li><a class="reference internal" href="#footnotes" id="id25">Footnotes</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id5">Abstract</a></h1>
<p>io.TextIOWrapper and codecs.StreamReaderWriter offer the same API
<a class="footnote-reference" href="#f1" id="id1">[1]</a>. TextIOWrapper has more features and is faster than
StreamReaderWriter. Duplicate code means that bugs should be fixed
twice and that we may have subtle differences between the two
implementations.</p>
<p>The codecs module was introduced in Python 2.0 (see the <a class="reference external" href="http://www.python.org/dev/peps/pep-0100/">PEP 100</a>). The io module was
introduced in Python 2.6 and 3.0 (see the <a class="reference external" href="http://www.python.org/dev/peps/pep-3116/">PEP 3116</a>), and reimplemented in C in
Python 2.7 and 3.1.</p>
</div>
<div class="section" id="pep-deferral">
<h1><a class="toc-backref" href="#id6">PEP Deferral</a></h1>
<p>Further exploration of the concepts covered in this PEP has been deferred
for lack of a current champion interested in promoting the goals of the PEP
and collecting and incorporating feedback, and with sufficient available
time to do so effectively.</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id7">Motivation</a></h1>
<p>When the Python I/O model was updated for 3.0, the concept of a
&quot;stream-with-known-encoding&quot; was introduced in the form of
io.TextIOWrapper. As this class is critical to the performance of
text-based I/O in Python 3, this module has an optimised C version
which is used by CPython by default. Many corner cases in handling
buffering, stateful codecs and universal newlines have been dealt with
since the release of Python 3.0.</p>
<p>This new interface overlaps heavily with the legacy
codecs.StreamReader, codecs.StreamWriter and codecs.StreamReaderWriter
interfaces that were part of the original codec interface design in
<a class="reference external" href="/dev/peps/pep-0100">PEP 100</a>. These interfaces are organised around the principle of an
encoding with an associated stream (i.e. the reverse of arrangement in
the io module), so the original <a class="reference external" href="/dev/peps/pep-0100">PEP 100</a> design required that codec
writers provide appropriate StreamReader and StreamWriter
implementations in addition to the core codec encode() and decode()
methods. This places a heavy burden on codec authors providing these
specialised implementations to correctly handle many of the corner
cases (see <a class="reference internal" href="#appendix-a">Appendix A</a>) that have now been dealt with by io.TextIOWrapper. While deeper
integration between the codec and the stream allows for additional
optimisations in theory, these optimisations have in practice either
not been carried out and else the associated code duplication means
that the corner cases that have been fixed in io.TextIOWrapper are
still not handled correctly in the various StreamReader and
StreamWriter implementations.</p>
<p>Accordingly, this PEP proposes that:</p>
<ul class="simple">
<li>codecs.open() be updated to delegate to the builtin open() in Python
3.3;</li>
<li>the legacy codecs.Stream* interfaces, including the streamreader and
streamwriter attributes of codecs.CodecInfo be deprecated in Python
3.3.</li>
</ul>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id8">Rationale</a></h1>
<div class="section" id="streamreader-and-streamwriter-issues">
<h2><a class="toc-backref" href="#id9">StreamReader and StreamWriter issues</a></h2>
<ul class="simple">
<li>StreamReader is unable to translate newlines.</li>
<li>StreamWriter doesn't support &quot;line buffering&quot; (flush if the input
text contains a newline).</li>
<li>StreamReader classes of the CJK encodings (e.g. GB18030) only
supports UNIX newlines ('\n').</li>
<li>StreamReader and StreamWriter are stateful codecs but don't expose
functions to control their state (getstate() or setstate()). Each
codec has to handle corner cases, see <a class="reference internal" href="#appendix-a">Appendix A</a>.</li>
<li>StreamReader and StreamWriter are very similar to IncrementalReader
and IncrementalEncoder, some code is duplicated for stateful codecs
(e.g. UTF-16).</li>
<li>Each codec has to reimplement its own StreamReader and StreamWriter
class, even if it's trivial (just call the encoder/decoder).</li>
<li>codecs.open(filename, &quot;r&quot;) creates an io.TextIOWrapper object.</li>
<li>No codec implements an optimized method in StreamReader or
StreamWriter based on the specificities of the codec.</li>
</ul>
<p>Issues in the bug tracker:</p>
<ul class="simple">
<li><a class="reference external" href="http://bugs.python.org/issue5445">Issue #5445</a> (2009-03-08):
codecs.StreamWriter.writelines problem when passed generator</li>
<li><a class="reference external" href="http://bugs.python.org/issue7262">Issue #7262:</a> (2009-11-04):
codecs.open() + eol (windows)</li>
<li><a class="reference external" href="http://bugs.python.org/issue8260">Issue #8260</a> (2010-03-29):
When I use codecs.open(...) and f.readline() follow up by f.read()
return bad result</li>
<li><a class="reference external" href="http://bugs.python.org/issue8630">Issue #8630</a> (2010-05-05):
Keepends param in codec readline(s)</li>
<li><a class="reference external" href="http://bugs.python.org/issue10344">Issue #10344</a> (2010-11-06):
codecs.readline doesn't care buffering</li>
<li><a class="reference external" href="http://bugs.python.org/issue11461">Issue #11461</a> (2011-03-10):
Reading UTF-16 with codecs.readline() breaks on surrogate pairs</li>
<li><a class="reference external" href="http://bugs.python.org/issue12446">Issue #12446</a> (2011-06-30):
StreamReader Readlines behavior odd</li>
<li><a class="reference external" href="http://bugs.python.org/issue12508">Issue #12508</a> (2011-07-06):
Codecs Anomaly</li>
<li><a class="reference external" href="http://bugs.python.org/issue12512">Issue #12512</a> (2011-07-07):
codecs: StreamWriter issues with stateful codecs after a seek or
with append mode</li>
<li><a class="reference external" href="http://bugs.python.org/issue12513">Issue #12513</a> (2011-07-07):
codec.StreamReaderWriter: issues with interlaced read-write</li>
</ul>
</div>
<div class="section" id="textiowrapper-features">
<h2><a class="toc-backref" href="#id10">TextIOWrapper features</a></h2>
<ul class="simple">
<li>TextIOWrapper supports any kind of newline, including translating
newlines (to UNIX newlines), to read and write.</li>
<li>TextIOWrapper reuses codecs incremental encoders and decoders (no
duplication of code).</li>
<li>The io module (TextIOWrapper) is faster than the codecs module
(StreamReader). It is implemented in C, whereas codecs is
implemented in Python.</li>
<li>TextIOWrapper has a readahead algorithm which speeds up small
reads: read character by character or line by line (io is 10x
through 25x faster than codecs on these operations).</li>
<li>TextIOWrapper has a write buffer.</li>
<li>TextIOWrapper.tell() is optimized.</li>
<li>TextIOWrapper supports random access (read+write) using a single
class which permit to optimize interlaced read-write (but no such
optimization is implemented).</li>
</ul>
</div>
<div class="section" id="textiowrapper-issues">
<h2><a class="toc-backref" href="#id11">TextIOWrapper issues</a></h2>
<ul class="simple">
<li><a class="reference external" href="http://bugs.python.org/issue12215">Issue #12215</a> (2011-05-30):
TextIOWrapper: issues with interlaced read-write</li>
</ul>
</div>
<div class="section" id="possible-improvements-of-streamreader-and-streamwriter">
<h2><a class="toc-backref" href="#id12">Possible improvements of StreamReader and StreamWriter</a></h2>
<p>By adding codec state read/write functions to the StreamReader and
StreamWriter classes, it will become possible to fix issues with
stateful codecs in a base class instead of in each stateful
StreamReader and StreamWriter classes.</p>
<p>It would be possible to change StreamReader and StreamWriter to make
them use IncrementalDecoder and IncrementalEncoder.</p>
<p>A codec can implement variants which are optimized for the specific
encoding or intercept certain stream methods to add functionality or
improve the encoding/decoding performance. TextIOWrapper cannot
implement such optimization, but TextIOWrapper uses incremental
encoders and decoders and uses read and write buffers, so the overhead
of incomplete inputs is low or nul.</p>
<p>A lot more could be done for other variable length encoding codecs,
e.g. UTF-8, since these often have problems near the end of a read due
to missing bytes. The UTF-32-BE/LE codecs could simply multiply the
character position by 4 to get the byte position.</p>
</div>
<div class="section" id="usage-of-streamreader-and-streamwriter">
<h2><a class="toc-backref" href="#id13">Usage of StreamReader and StreamWriter</a></h2>
<p>These classes are rarely used directly, but indirectly using
codecs.open(). They are not used in Python 3 standard library (except
in the codecs module).</p>
<p>Some projects implement their own codec with StreamReader and
StreamWriter, but don't use these classes.</p>
</div>
</div>
<div class="section" id="backwards-compatibility">
<h1><a class="toc-backref" href="#id14">Backwards Compatibility</a></h1>
<div class="section" id="keep-the-public-api-codecs-open">
<h2><a class="toc-backref" href="#id15">Keep the public API, codecs.open</a></h2>
<p>codecs.open() can be replaced by the builtin open() function. open()
has a similar API but has also more options. Both functions return
file-like objects (same API).</p>
<p>codecs.open() was the only way to open a text file in Unicode mode
until Python 2.6. Many Python 2 programs uses this function. Removing
codecs.open() implies more work to port programs from Python 2 to
Python 3, especially projets using the same code base for the two
Python versions (without using 2to3 program).</p>
<p>codecs.open() is kept for backward compatibility with Python 2.</p>
</div>
<div class="section" id="deprecate-streamreader-and-streamwriter">
<h2><a class="toc-backref" href="#id16">Deprecate StreamReader and StreamWriter</a></h2>
<p>Instanciating StreamReader or StreamWriter must emit a DeprecationWarning in
Python 3.3. Defining a subclass doesn't emit a DeprecationWarning.</p>
<p>codecs.open() will be changed to reuse the builtin open() function
(TextIOWrapper) to read-write text files.</p>
</div>
</div>
<div class="section" id="alternative-approach">
<span id="appendix-a"></span><h1><a class="toc-backref" href="#id17">Alternative Approach</a></h1>
<p>An alternative to the deprecation of the codecs.Stream* classes is to rename
codecs.open() to codecs.open_stream(), and to create a new codecs.open()
function reusing open() and so io.TextIOWrapper.</p>
</div>
<div class="section" id="appendix-a-issues-with-stateful-codecs">
<h1><a class="toc-backref" href="#id18">Appendix A: Issues with stateful codecs</a></h1>
<p>It is difficult to use correctly a stateful codec with a stream. Some
cases are supported by the codecs module, while io has no more known
bug related to stateful codecs. The main difference between the codecs
and the io module is that bugs have to be fixed in StreamReader and/or
StreamWriter classes of each codec for the codecs module, whereas bugs
can be fixed only once in io.TextIOWrapper. Here are some examples of
issues with stateful codecs.</p>
<div class="section" id="stateful-codecs">
<h2><a class="toc-backref" href="#id19">Stateful codecs</a></h2>
<p>Python supports the following stateful codecs:</p>
<ul class="simple">
<li>cp932</li>
<li>cp949</li>
<li>cp950</li>
<li>euc_jis_2004</li>
<li>euc_jisx2003</li>
<li>euc_jp</li>
<li>euc_kr</li>
<li>gb18030</li>
<li>gbk</li>
<li>hz</li>
<li>iso2022_jp</li>
<li>iso2022_jp_1</li>
<li>iso2022_jp_2</li>
<li>iso2022_jp_2004</li>
<li>iso2022_jp_3</li>
<li>iso2022_jp_ext</li>
<li>iso2022_kr</li>
<li>shift_jis</li>
<li>shift_jis_2004</li>
<li>shift_jisx0213</li>
<li>utf_8_sig</li>
<li>utf_16</li>
<li>utf_32</li>
</ul>
</div>
<div class="section" id="read-and-seek-0">
<h2><a class="toc-backref" href="#id20">Read and seek(0)</a></h2>
<pre class="literal-block">
with open(filename, 'w', encoding='utf-16') as f:
    f.write('abc')
    f.write('def')
    f.seek(0)
    assert f.read() == 'abcdef'
    f.seek(0)
    assert f.read() == 'abcdef'
</pre>
<p>The io and codecs modules support this usecase correctly.</p>
</div>
<div class="section" id="seek-n">
<h2><a class="toc-backref" href="#id21">seek(n)</a></h2>
<pre class="literal-block">
with open(filename, 'w', encoding='utf-16') as f:
    f.write('abc')
    pos = f.tell()
with open(filename, 'w', encoding='utf-16') as f:
    f.seek(pos)
    f.write('def')
    f.seek(0)
    f.write('###')
with open(filename, 'r', encoding='utf-16') as f:
    assert f.read() == '###def'
</pre>
<p>The io module supports this usecase, whereas codecs fails because it
writes a new BOM on the second write (<a class="reference external" href="http://bugs.python.org/issue12512">issue #12512</a>).</p>
</div>
<div class="section" id="append-mode">
<h2><a class="toc-backref" href="#id22">Append mode</a></h2>
<pre class="literal-block">
with open(filename, 'w', encoding='utf-16') as f:
    f.write('abc')
with open(filename, 'a', encoding='utf-16') as f:
    f.write('def')
with open(filename, 'r', encoding='utf-16') as f:
    assert f.read() == 'abcdef'
</pre>
<p>The io module supports this usecase, whereas codecs fails because it
writes a new BOM on the second write (<a class="reference external" href="http://bugs.python.org/issue12512">issue #12512</a>).</p>
</div>
</div>
<div class="section" id="links">
<h1><a class="toc-backref" href="#id23">Links</a></h1>
<ul class="simple">
<li><a class="reference external" href="http://www.python.org/dev/peps/pep-0100/">PEP 100: Python Unicode Integration</a></li>
<li><a class="reference external" href="http://www.python.org/dev/peps/pep-3116/">PEP 3116: New I/O</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue8796">Issue #8796: Deprecate codecs.open()</a></li>
<li><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2011-May/111591.html">[python-dev] Deprecate codecs.open() and StreamWriter/StreamReader</a></li>
</ul>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id24">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
</div>
<div class="section" id="footnotes">
<h1><a class="toc-backref" href="#id25">Footnotes</a></h1>
<table class="docutils footnote" frame="void" id="f1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>StreamReaderWriter has two more attributes than
TextIOWrapper, reader and writer.</td></tr>
</tbody>
</table>
</div>

