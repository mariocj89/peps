<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">467</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Minor API improvements for binary sequences</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0467.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Nick Coghlan &lt;ncoghlan&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Draft</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">2014-03-30</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.5</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">2014-03-30 2014-08-15 2014-08-16</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id6">Abstract</a></li>
<li><a class="reference internal" href="#proposals" id="id7">Proposals</a><ul>
<li><a class="reference internal" href="#deprecation-of-current-zero-initialised-sequence-behaviour" id="id8">Deprecation of current &quot;zero-initialised sequence&quot; behaviour</a></li>
<li><a class="reference internal" href="#addition-of-explicit-zero-initialised-sequence-constructors" id="id9">Addition of explicit &quot;zero-initialised sequence&quot; constructors</a></li>
<li><a class="reference internal" href="#addition-of-explicit-single-byte-constructors" id="id10">Addition of explicit &quot;single byte&quot; constructors</a></li>
<li><a class="reference internal" href="#addition-of-optimised-iterator-methods-that-produce-bytes-objects" id="id11">Addition of optimised iterator methods that produce <tt class="docutils literal">bytes</tt> objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#design-discussion" id="id12">Design discussion</a><ul>
<li><a class="reference internal" href="#why-not-rely-on-sequence-repetition-to-create-zero-initialised-sequences" id="id13">Why not rely on sequence repetition to create zero-initialised sequences?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references" id="id14">References</a></li>
<li><a class="reference internal" href="#copyright" id="id15">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id6">Abstract</a></h1>
<p>During the initial development of the Python 3 language specification, the
core <tt class="docutils literal">bytes</tt> type for arbitrary binary data started as the mutable type
that is now referred to as <tt class="docutils literal">bytearray</tt>. Other aspects of operating in
the binary domain in Python have also evolved over the course of the Python
3 series.</p>
<p>This PEP proposes four small adjustments to the APIs of the <tt class="docutils literal">bytes</tt>,
<tt class="docutils literal">bytearray</tt> and <tt class="docutils literal">memoryview</tt> types to make it easier to operate entirely
in the binary domain:</p>
<ul class="simple">
<li>Deprecate passing single integer values to <tt class="docutils literal">bytes</tt> and <tt class="docutils literal">bytearray</tt></li>
<li>Add <tt class="docutils literal">bytes.zeros</tt> and <tt class="docutils literal">bytearray.zeros</tt> alternative constructors</li>
<li>Add <tt class="docutils literal">bytes.byte</tt> and <tt class="docutils literal">bytearray.byte</tt> alternative constructors</li>
<li>Add <tt class="docutils literal">bytes.iterbytes</tt>, <tt class="docutils literal">bytearray.iterbytes</tt> and
<tt class="docutils literal">memoryview.iterbytes</tt> alternative iterators</li>
</ul>
</div>
<div class="section" id="proposals">
<h1><a class="toc-backref" href="#id7">Proposals</a></h1>
<div class="section" id="deprecation-of-current-zero-initialised-sequence-behaviour">
<h2><a class="toc-backref" href="#id8">Deprecation of current &quot;zero-initialised sequence&quot; behaviour</a></h2>
<p>Currently, the <tt class="docutils literal">bytes</tt> and <tt class="docutils literal">bytearray</tt> constructors accept an integer
argument and interpret it as meaning to create a zero-initialised sequence
of the given size:</p>
<pre class="literal-block">
&gt;&gt;&gt; bytes(3)
b'\x00\x00\x00'
&gt;&gt;&gt; bytearray(3)
bytearray(b'\x00\x00\x00')
</pre>
<p>This PEP proposes to deprecate that behaviour in Python 3.5, and remove it
entirely in Python 3.6.</p>
<p>No other changes are proposed to the existing constructors.</p>
</div>
<div class="section" id="addition-of-explicit-zero-initialised-sequence-constructors">
<h2><a class="toc-backref" href="#id9">Addition of explicit &quot;zero-initialised sequence&quot; constructors</a></h2>
<p>To replace the deprecated behaviour, this PEP proposes the addition of an
explicit <tt class="docutils literal">zeros</tt> alternative constructor as a class method on both
<tt class="docutils literal">bytes</tt> and <tt class="docutils literal">bytearray</tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; bytes.zeros(3)
b'\x00\x00\x00'
&gt;&gt;&gt; bytearray.zeros(3)
bytearray(b'\x00\x00\x00')
</pre>
<p>It will behave just as the current constructors behave when passed a single
integer.</p>
<p>The specific choice of <tt class="docutils literal">zeros</tt> as the alternative constructor name is taken
from the corresponding initialisation function in NumPy (although, as these
are 1-dimensional sequence types rather than N-dimensional matrices, the
constructors take a length as input rather than a shape tuple)</p>
</div>
<div class="section" id="addition-of-explicit-single-byte-constructors">
<h2><a class="toc-backref" href="#id10">Addition of explicit &quot;single byte&quot; constructors</a></h2>
<p>As binary counterparts to the text <tt class="docutils literal">chr</tt> function, this PEP proposes the
addition of an explicit <tt class="docutils literal">byte</tt> alternative constructor as a class method
on both <tt class="docutils literal">bytes</tt> and <tt class="docutils literal">bytearray</tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; bytes.byte(3)
b'\x03'
&gt;&gt;&gt; bytearray.byte(3)
bytearray(b'\x03')
</pre>
<p>These methods will only accept integers in the range 0 to 255 (inclusive):</p>
<pre class="literal-block">
&gt;&gt;&gt; bytes.byte(512)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ValueError: bytes must be in range(0, 256)

&gt;&gt;&gt; bytes.byte(1.0)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: 'float' object cannot be interpreted as an integer
</pre>
<p>The documentation of the <tt class="docutils literal">ord</tt> builtin will be updated to explicitly note
that <tt class="docutils literal">bytes.byte</tt> is the inverse operation for binary data, while <tt class="docutils literal">chr</tt>
is the inverse operation for text data.</p>
<p>Behaviourally, <tt class="docutils literal">bytes.byte(x)</tt> will be equivalent to the current
<tt class="docutils literal"><span class="pre">bytes([x])</span></tt> (and similarly for <tt class="docutils literal">bytearray</tt>). The new spelling is
expected to be easier to discover and easier to read (especially when used
in conjunction with indexing operations on binary sequence types).</p>
<p>As a separate method, the new spelling will also work better with higher
order functions like <tt class="docutils literal">map</tt>.</p>
</div>
<div class="section" id="addition-of-optimised-iterator-methods-that-produce-bytes-objects">
<h2><a class="toc-backref" href="#id11">Addition of optimised iterator methods that produce <tt class="docutils literal">bytes</tt> objects</a></h2>
<p>This PEP proposes that <tt class="docutils literal">bytes</tt>, <tt class="docutils literal">bytearray</tt> and <tt class="docutils literal">memoryview</tt> gain an
optimised <tt class="docutils literal">iterbytes</tt> method that produces length 1 <tt class="docutils literal">bytes</tt> objects
rather than integers:</p>
<pre class="literal-block">
for x in data.iterbytes():
    # x is a length 1 ``bytes`` object, rather than an integer
</pre>
<p>The method can be used with arbitrary buffer exporting objects by wrapping
them in a <tt class="docutils literal">memoryview</tt> instance first:</p>
<pre class="literal-block">
for x in memoryview(data).iterbytes():
    # x is a length 1 ``bytes`` object, rather than an integer
</pre>
<p>For <tt class="docutils literal">memoryview</tt>, the semantics of <tt class="docutils literal">iterbytes()</tt> are defined such that:</p>
<pre class="literal-block">
memview.tobytes() == b''.join(memview.iterbytes())
</pre>
<p>This allows the raw bytes of the memory view to be iterated over without
needing to make a copy, regardless of the defined shape and format.</p>
<p>The main advantage this method offers over the <tt class="docutils literal">map(bytes.byte, data)</tt>
approach is that it is guaranteed <em>not</em> to fail midstream with a
<tt class="docutils literal">ValueError</tt> or <tt class="docutils literal">TypeError</tt>. By contrast, when using the <tt class="docutils literal">map</tt> based
approach, the type and value of the individual items in the iterable are
only checked as they are retrieved and passed through the <tt class="docutils literal">bytes.byte</tt>
constructor.</p>
</div>
</div>
<div class="section" id="design-discussion">
<h1><a class="toc-backref" href="#id12">Design discussion</a></h1>
<div class="section" id="why-not-rely-on-sequence-repetition-to-create-zero-initialised-sequences">
<h2><a class="toc-backref" href="#id13">Why not rely on sequence repetition to create zero-initialised sequences?</a></h2>
<p>Zero-initialised sequences can be created via sequence repetition:</p>
<pre class="literal-block">
&gt;&gt;&gt; b'\x00' * 3
b'\x00\x00\x00'
&gt;&gt;&gt; bytearray(b'\x00') * 3
bytearray(b'\x00\x00\x00')
</pre>
<p>However, this was also the case when the <tt class="docutils literal">bytearray</tt> type was originally
designed, and the decision was made to add explicit support for it in the
type constructor. The immutable <tt class="docutils literal">bytes</tt> type then inherited that feature
when it was introduced in <a class="reference external" href="/dev/peps/pep-3137">PEP 3137</a>.</p>
<p>This PEP isn't revisiting that original design decision, just changing the
spelling as users sometimes find the current behaviour of the binary sequence
constructors surprising. In particular, there's a reasonable case to be made
that <tt class="docutils literal">bytes(x)</tt> (where <tt class="docutils literal">x</tt> is an integer) should behave like the
<tt class="docutils literal">bytes.byte(x)</tt> proposal in this PEP. Providing both behaviours as separate
class methods avoids that ambiguity.</p>
</div>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id14">References</a></h1>
<table class="docutils footnote" frame="void" id="id1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Initial March 2014 discussion thread on python-ideas
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2014-March/027295.html">https://mail.python.org/pipermail/python-ideas/2014-March/027295.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>Guido's initial feedback in that thread
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2014-March/027376.html">https://mail.python.org/pipermail/python-ideas/2014-March/027376.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>Issue proposing moving zero-initialised sequences to a dedicated API
(<a class="reference external" href="http://bugs.python.org/issue20895">http://bugs.python.org/issue20895</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td>Issue proposing to use calloc() for zero-initialised binary sequences
(<a class="reference external" href="http://bugs.python.org/issue21644">http://bugs.python.org/issue21644</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td>August 2014 discussion thread on python-dev
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2014-March/027295.html">https://mail.python.org/pipermail/python-ideas/2014-March/027295.html</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id15">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

