<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">100</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Python Unicode Integration</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0100.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">mal&#32;&#97;t&#32;lemburg.com (Marc-Andr√© Lemburg)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">10-Mar-2000</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.0</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#historical-note" id="id18">Historical Note</a></li>
<li><a class="reference internal" href="#introduction" id="id19">Introduction</a></li>
<li><a class="reference internal" href="#conventions" id="id20">Conventions</a></li>
<li><a class="reference internal" href="#general-remarks" id="id21">General Remarks</a></li>
<li><a class="reference internal" href="#unicode-default-encoding" id="id22">Unicode Default Encoding</a></li>
<li><a class="reference internal" href="#unicode-constructors" id="id23">Unicode Constructors</a></li>
<li><a class="reference internal" href="#unicode-type-object" id="id24">Unicode Type Object</a></li>
<li><a class="reference internal" href="#unicode-output" id="id25">Unicode Output</a></li>
<li><a class="reference internal" href="#unicode-ordinals" id="id26">Unicode Ordinals</a></li>
<li><a class="reference internal" href="#comparison-hash-value" id="id27">Comparison &amp; Hash Value</a></li>
<li><a class="reference internal" href="#coercion" id="id28">Coercion</a></li>
<li><a class="reference internal" href="#exceptions" id="id29">Exceptions</a></li>
<li><a class="reference internal" href="#codecs-coder-decoders-lookup" id="id30">Codecs (Coder/Decoders) Lookup</a></li>
<li><a class="reference internal" href="#standard-codecs" id="id31">Standard Codecs</a></li>
<li><a class="reference internal" href="#codecs-interface-definition" id="id32">Codecs Interface Definition</a></li>
<li><a class="reference internal" href="#whitespace" id="id33">Whitespace</a></li>
<li><a class="reference internal" href="#case-conversion" id="id34">Case Conversion</a></li>
<li><a class="reference internal" href="#line-breaks" id="id35">Line Breaks</a></li>
<li><a class="reference internal" href="#unicode-character-properties" id="id36">Unicode Character Properties</a></li>
<li><a class="reference internal" href="#private-code-point-areas" id="id37">Private Code Point Areas</a></li>
<li><a class="reference internal" href="#internal-format" id="id38">Internal Format</a></li>
<li><a class="reference internal" href="#buffer-interface" id="id39">Buffer Interface</a></li>
<li><a class="reference internal" href="#pickle-marshalling" id="id40">Pickle/Marshalling</a></li>
<li><a class="reference internal" href="#regular-expressions" id="id41">Regular Expressions</a></li>
<li><a class="reference internal" href="#formatting-markers" id="id42">Formatting Markers</a></li>
<li><a class="reference internal" href="#internal-argument-parsing" id="id43">Internal Argument Parsing</a></li>
<li><a class="reference internal" href="#file-stream-output" id="id44">File/Stream Output</a></li>
<li><a class="reference internal" href="#file-stream-input" id="id45">File/Stream Input</a></li>
<li><a class="reference internal" href="#unicode-methods-attributes" id="id46">Unicode Methods &amp; Attributes</a></li>
<li><a class="reference internal" href="#code-base" id="id47">Code Base</a></li>
<li><a class="reference internal" href="#test-cases" id="id48">Test Cases</a></li>
<li><a class="reference internal" href="#references" id="id49">References</a></li>
<li><a class="reference internal" href="#history-of-this-proposal" id="id50">History of this Proposal</a><ul>
<li><a class="reference internal" href="#id1" id="id51">1.7</a></li>
<li><a class="reference internal" href="#id2" id="id52">1.6</a></li>
<li><a class="reference internal" href="#id3" id="id53">1.5</a></li>
<li><a class="reference internal" href="#id4" id="id54">1.4</a></li>
<li><a class="reference internal" href="#id5" id="id55">1.3</a></li>
<li><a class="reference internal" href="#id6" id="id56">1.2</a></li>
<li><a class="reference internal" href="#id7" id="id57">1.1</a></li>
<li><a class="reference internal" href="#id8" id="id58">1.0</a></li>
<li><a class="reference internal" href="#id9" id="id59">0.9</a></li>
<li><a class="reference internal" href="#id10" id="id60">0.8</a></li>
<li><a class="reference internal" href="#id11" id="id61">0.7</a></li>
<li><a class="reference internal" href="#id12" id="id62">0.6</a></li>
<li><a class="reference internal" href="#id13" id="id63">0.5</a></li>
<li><a class="reference internal" href="#id14" id="id64">0.4</a></li>
<li><a class="reference internal" href="#id15" id="id65">0.3</a></li>
<li><a class="reference internal" href="#id16" id="id66">0.2</a></li>
<li><a class="reference internal" href="#id17" id="id67">0.1</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="historical-note">
<h1><a class="toc-backref" href="#id18">Historical Note</a></h1>
<p>This document was first written by Marc-Andre in the pre-PEP days,
and was originally distributed as Misc/unicode.txt in Python
distributions up to and included Python 2.1.  The last revision of
the proposal in that location was labeled version 1.7 (CVS
revision 3.10).  Because the document clearly serves the purpose
of an informational PEP in the post-PEP era, it has been moved
here and reformatted to comply with PEP guidelines.  Future
revisions will be made to this document, while Misc/unicode.txt
will contain a pointer to this PEP.</p>
<p>-Barry Warsaw, PEP editor</p>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id19">Introduction</a></h1>
<p>The idea of this proposal is to add native Unicode 3.0 support to
Python in a way that makes use of Unicode strings as simple as
possible without introducing too many pitfalls along the way.</p>
<p>Since this goal is not easy to achieve -- strings being one of the
most fundamental objects in Python -- we expect this proposal to
undergo some significant refinements.</p>
<p>Note that the current version of this proposal is still a bit
unsorted due to the many different aspects of the Unicode-Python
integration.</p>
<p>The latest version of this document is always available at:
<a class="reference external" href="http://starship.python.net/~lemburg/unicode-proposal.txt">http://starship.python.net/~lemburg/unicode-proposal.txt</a></p>
<p>Older versions are available as:
<a class="reference external" href="http://starship.python.net/~lemburg/unicode-proposal-X.X.txt">http://starship.python.net/~lemburg/unicode-proposal-X.X.txt</a></p>
<p>[ed. note: new revisions should be made to this PEP document,
while the historical record previous to version 1.7 should be
retrieved from MAL's url, or Misc/unicode.txt]</p>
</div>
<div class="section" id="conventions">
<h1><a class="toc-backref" href="#id20">Conventions</a></h1>
<ul class="simple">
<li>In examples we use u = Unicode object and s = Python string</li>
<li>'XXX' markings indicate points of discussion (PODs)</li>
</ul>
</div>
<div class="section" id="general-remarks">
<h1><a class="toc-backref" href="#id21">General Remarks</a></h1>
<ul class="simple">
<li>Unicode encoding names should be lower case on output and
case-insensitive on input (they will be converted to lower case
by all APIs taking an encoding name as input).</li>
<li>Encoding names should follow the name conventions as used by the
Unicode Consortium: spaces are converted to hyphens, e.g. 'utf
16' is written as 'utf-16'.</li>
<li>Codec modules should use the same names, but with hyphens
converted to underscores, e.g. <tt class="docutils literal">utf_8</tt>, <tt class="docutils literal">utf_16</tt>, <tt class="docutils literal">iso_8859_1</tt>.</li>
</ul>
</div>
<div class="section" id="unicode-default-encoding">
<h1><a class="toc-backref" href="#id22">Unicode Default Encoding</a></h1>
<p>The Unicode implementation has to make some assumption about the
encoding of 8-bit strings passed to it for coercion and about the
encoding to as default for conversion of Unicode to strings when
no specific encoding is given.  This encoding is called &lt;default
encoding&gt; throughout this text.</p>
<p>For this, the implementation maintains a global which can be set
in the site.py Python startup script.  Subsequent changes are not
possible.  The &lt;default encoding&gt; can be set and queried using the
two sys module APIs:</p>
<dl class="docutils">
<dt><tt class="docutils literal">sys.setdefaultencoding(encoding)</tt></dt>
<dd><p class="first">Sets the &lt;default encoding&gt; used by the Unicode implementation.
encoding has to be an encoding which is supported by the
Python installation, otherwise, a LookupError is raised.</p>
<p class="last">Note: This API is only available in site.py!  It is
removed from the sys module by site.py after usage.</p>
</dd>
<dt><tt class="docutils literal">sys.getdefaultencoding()</tt></dt>
<dd>Returns the current &lt;default encoding&gt;.</dd>
</dl>
<p>If not otherwise defined or set, the &lt;default encoding&gt; defaults
to 'ascii'.  This encoding is also the startup default of Python
(and in effect before site.py is executed).</p>
<p>Note that the default site.py startup module contains disabled
optional code which can set the &lt;default encoding&gt; according to
the encoding defined by the current locale.  The locale module is
used to extract the encoding from the locale default settings
defined by the OS environment (see locale.py).  If the encoding
cannot be determined, is unknown or unsupported, the code defaults
to setting the &lt;default encoding&gt; to 'ascii'.  To enable this
code, edit the site.py file or place the appropriate code into the
sitecustomize.py module of your Python installation.</p>
</div>
<div class="section" id="unicode-constructors">
<h1><a class="toc-backref" href="#id23">Unicode Constructors</a></h1>
<p>Python should provide a built-in constructor for Unicode strings
which is available through <tt class="docutils literal">__builtins__</tt>:</p>
<pre class="literal-block">
u = unicode(encoded_string[,encoding=&lt;default encoding&gt;][,errors=&quot;strict&quot;])

u = u'&lt;unicode-escape encoded Python string&gt;'

u = ur'&lt;raw-unicode-escape encoded Python string&gt;'
</pre>
<p>With the 'unicode-escape' encoding being defined as:</p>
<ul class="simple">
<li>all non-escape characters represent themselves as Unicode
ordinal (e.g. 'a' -&gt; U+0061).</li>
<li>all existing defined Python escape sequences are interpreted as
Unicode ordinals; note that <tt class="docutils literal">\xXXXX</tt> can represent all Unicode
ordinals, and <tt class="docutils literal">\OOO</tt> (octal) can represent Unicode ordinals up to
U+01FF.</li>
<li>a new escape sequence, <tt class="docutils literal">\uXXXX</tt>, represents U+XXXX; it is a syntax
error to have fewer than 4 digits after <tt class="docutils literal">\u</tt>.</li>
</ul>
<p>For an explanation of possible values for errors see the Codec
section below.</p>
<p>Examples:</p>
<pre class="literal-block">
u'abc'          -&gt; U+0061 U+0062 U+0063
u'\u1234'       -&gt; U+1234
u'abc\u1234\n'  -&gt; U+0061 U+0062 U+0063 U+1234 U+005c
</pre>
<p>The 'raw-unicode-escape' encoding is defined as follows:</p>
<ul class="simple">
<li><tt class="docutils literal">\uXXXX</tt> sequence represent the U+XXXX Unicode character if and
only if the number of leading backslashes is odd</li>
<li>all other characters represent themselves as Unicode ordinal
(e.g. 'b' -&gt; U+0062)</li>
</ul>
<p>Note that you should provide some hint to the encoding you used to
write your programs as pragma line in one the first few comment
lines of the source file (e.g. '# source file encoding: latin-1').
If you only use 7-bit ASCII then everything is fine and no such
notice is needed, but if you include Latin-1 characters not
defined in ASCII, it may well be worthwhile including a hint since
people in other countries will want to be able to read your source
strings too.</p>
</div>
<div class="section" id="unicode-type-object">
<h1><a class="toc-backref" href="#id24">Unicode Type Object</a></h1>
<p>Unicode objects should have the type UnicodeType with type name
'unicode', made available through the standard types module.</p>
</div>
<div class="section" id="unicode-output">
<h1><a class="toc-backref" href="#id25">Unicode Output</a></h1>
<p>Unicode objects have a method .encode([encoding=&lt;default encoding&gt;])
which returns a Python string encoding the Unicode string using the
given scheme (see Codecs).</p>
<pre class="literal-block">
print u := print u.encode()   # using the &lt;default encoding&gt;

str(u)  := u.encode()         # using the &lt;default encoding&gt;

repr(u) := &quot;u%s&quot; % repr(u.encode('unicode-escape'))
</pre>
<p>Also see Internal Argument Parsing and Buffer Interface for
details on how other APIs written in C will treat Unicode objects.</p>
</div>
<div class="section" id="unicode-ordinals">
<h1><a class="toc-backref" href="#id26">Unicode Ordinals</a></h1>
<p>Since Unicode 3.0 has a 32-bit ordinal character set, the
implementation should provide 32-bit aware ordinal conversion
APIs:</p>
<pre class="literal-block">
ord(u[:1]) (this is the standard ord() extended to work with Unicode
            objects)
  --&gt; Unicode ordinal number (32-bit)

unichr(i)
    --&gt; Unicode object for character i (provided it is 32-bit);
        ValueError otherwise
</pre>
<p>Both APIs should go into <tt class="docutils literal">__builtins__</tt> just like their string
counterparts <tt class="docutils literal">ord()</tt> and <tt class="docutils literal">chr()</tt>.</p>
<p>Note that Unicode provides space for private encodings.  Usage of
these can cause different output representations on different
machines.  This problem is not a Python or Unicode problem, but a
machine setup and maintenance one.</p>
</div>
<div class="section" id="comparison-hash-value">
<h1><a class="toc-backref" href="#id27">Comparison &amp; Hash Value</a></h1>
<p>Unicode objects should compare equal to other objects after these
other objects have been coerced to Unicode.  For strings this
means that they are interpreted as Unicode string using the
&lt;default encoding&gt;.</p>
<p>Unicode objects should return the same hash value as their ASCII
equivalent strings.  Unicode strings holding non-ASCII values are
not guaranteed to return the same hash values as the default
encoded equivalent string representation.</p>
<p>When compared using <tt class="docutils literal">cmp()</tt> (or <tt class="docutils literal">PyObject_Compare()</tt>) the
implementation should mask <tt class="docutils literal">TypeErrors</tt> raised during the conversion
to remain in synch with the string behavior.  All other errors
such as <tt class="docutils literal">ValueErrors</tt> raised during coercion of strings to Unicode
should not be masked and passed through to the user.</p>
<p>In containment tests ('a' in u'abc' and u'a' in 'abc') both sides
should be coerced to Unicode before applying the test.  Errors
occurring during coercion (e.g. None in u'abc') should not be
masked.</p>
</div>
<div class="section" id="coercion">
<h1><a class="toc-backref" href="#id28">Coercion</a></h1>
<p>Using Python strings and Unicode objects to form new objects
should always coerce to the more precise format, i.e. Unicode
objects.</p>
<pre class="literal-block">
u + s := u + unicode(s)

s + u := unicode(s) + u
</pre>
<p>All string methods should delegate the call to an equivalent
Unicode object method call by converting all involved strings to
Unicode and then applying the arguments to the Unicode method of
the same name, e.g.</p>
<pre class="literal-block">
string.join((s,u),sep) := (s + sep) + u

sep.join((s,u)) := (s + sep) + u
</pre>
<p>For a discussion of %-formatting w/r to Unicode objects, see
Formatting Markers.</p>
</div>
<div class="section" id="exceptions">
<h1><a class="toc-backref" href="#id29">Exceptions</a></h1>
<p><tt class="docutils literal">UnicodeError</tt> is defined in the exceptions module as a subclass of
<tt class="docutils literal">ValueError</tt>.  It is available at the C level via
<tt class="docutils literal">PyExc_UnicodeError</tt>.  All exceptions related to Unicode
encoding/decoding should be subclasses of <tt class="docutils literal">UnicodeError</tt>.</p>
</div>
<div class="section" id="codecs-coder-decoders-lookup">
<h1><a class="toc-backref" href="#id30">Codecs (Coder/Decoders) Lookup</a></h1>
<p>A Codec (see Codec Interface Definition) search registry should be
implemented by a module &quot;codecs&quot;:</p>
<pre class="literal-block">
codecs.register(search_function)
</pre>
<p>Search functions are expected to take one argument, the encoding
name in all lower case letters and with hyphens and spaces
converted to underscores, and return a tuple of functions
(encoder, decoder, stream_reader, stream_writer) taking the
following arguments:</p>
<dl class="docutils">
<dt>encoder and decoder</dt>
<dd>These must be functions or methods which have the same
interface as the <tt class="docutils literal">.encode</tt>/<tt class="docutils literal">.decode</tt> methods of Codec instances
(see Codec Interface). The functions/methods are expected to
work in a stateless mode.</dd>
<dt>stream_reader and stream_writer</dt>
<dd><p class="first">These need to be factory functions with the following
interface:</p>
<pre class="literal-block">
factory(stream,errors='strict')
</pre>
<p>The factory functions must return objects providing the
interfaces defined by <tt class="docutils literal">StreamWriter</tt>/<tt class="docutils literal">StreamReader</tt> resp.  (see
Codec Interface).  Stream codecs can maintain state.</p>
<p class="last">Possible values for errors are defined in the Codec section
below.</p>
</dd>
</dl>
<p>In case a search function cannot find a given encoding, it should
return None.</p>
<p>Aliasing support for encodings is left to the search functions to
implement.</p>
<p>The codecs module will maintain an encoding cache for performance
reasons.  Encodings are first looked up in the cache.  If not
found, the list of registered search functions is scanned.  If no
codecs tuple is found, a LookupError is raised.  Otherwise, the
codecs tuple is stored in the cache and returned to the caller.</p>
<p>To query the Codec instance the following API should be used:</p>
<pre class="literal-block">
codecs.lookup(encoding)
</pre>
<p>This will either return the found codecs tuple or raise a
<tt class="docutils literal">LookupError</tt>.</p>
</div>
<div class="section" id="standard-codecs">
<h1><a class="toc-backref" href="#id31">Standard Codecs</a></h1>
<p>Standard codecs should live inside an encodings/ package directory
in the Standard Python Code Library.  The <tt class="docutils literal">__init__.py</tt> file of that
directory should include a Codec Lookup compatible search function
implementing a lazy module based codec lookup.</p>
<p>Python should provide a few standard codecs for the most relevant
encodings, e.g.</p>
<pre class="literal-block">
'utf-8':              8-bit variable length encoding
'utf-16':             16-bit variable length encoding (little/big endian)
'utf-16-le':          utf-16 but explicitly little endian
'utf-16-be':          utf-16 but explicitly big endian
'ascii':              7-bit ASCII codepage
'iso-8859-1':         ISO 8859-1 (Latin 1) codepage
'unicode-escape':     See Unicode Constructors for a definition
'raw-unicode-escape': See Unicode Constructors for a definition
'native':             Dump of the Internal Format used by Python
</pre>
<p>Common aliases should also be provided per default, e.g.
'latin-1' for 'iso-8859-1'.</p>
<p>Note: 'utf-16' should be implemented by using and requiring byte
order marks (BOM) for file input/output.</p>
<p>All other encodings such as the CJK ones to support Asian scripts
should be implemented in separate packages which do not get
included in the core Python distribution and are not a part of
this proposal.</p>
</div>
<div class="section" id="codecs-interface-definition">
<h1><a class="toc-backref" href="#id32">Codecs Interface Definition</a></h1>
<p>The following base class should be defined in the module &quot;codecs&quot;.
They provide not only templates for use by encoding module
implementors, but also define the interface which is expected by
the Unicode implementation.</p>
<p>Note that the Codec Interface defined here is well suitable for a
larger range of applications.  The Unicode implementation expects
Unicode objects on input for <tt class="docutils literal">.encode()</tt> and <tt class="docutils literal">.write()</tt> and character
buffer compatible objects on input for <tt class="docutils literal">.decode()</tt>.  Output of
<tt class="docutils literal">.encode()</tt> and <tt class="docutils literal">.read()</tt> should be a Python string and <tt class="docutils literal">.decode()</tt> must
return an Unicode object.</p>
<p>First, we have the stateless encoders/decoders.  These do not work
in chunks as the stream codecs (see below) do, because all
components are expected to be available in memory.</p>
<pre class="literal-block">
class Codec:

    &quot;&quot;&quot;Defines the interface for stateless encoders/decoders.

       The .encode()/.decode() methods may implement different
       error handling schemes by providing the errors argument.
       These string values are defined:

         'strict'  - raise an error (or a subclass)
         'ignore'  - ignore the character and continue with the next
         'replace' - replace with a suitable replacement character;
                     Python will use the official U+FFFD
                     REPLACEMENT CHARACTER for the builtin Unicode
                     codecs.
    &quot;&quot;&quot;

    def encode(self,input,errors='strict'):

        &quot;&quot;&quot;Encodes the object input and returns a tuple (output
           object, length consumed).

           errors defines the error handling to apply.  It
           defaults to 'strict' handling.

           The method may not store state in the Codec instance.
           Use StreamCodec for codecs which have to keep state in
           order to make encoding/decoding efficient.
        &quot;&quot;&quot;

    def decode(self,input,errors='strict'):

        &quot;&quot;&quot;Decodes the object input and returns a tuple (output
           object, length consumed).

           input must be an object which provides the
           bf_getreadbuf buffer slot.  Python strings, buffer
           objects and memory mapped files are examples of objects
           providing this slot.

           errors defines the error handling to apply.  It
           defaults to 'strict' handling.

           The method may not store state in the Codec instance.
           Use StreamCodec for codecs which have to keep state in
           order to make encoding/decoding efficient.

        &quot;&quot;&quot;
</pre>
<p><tt class="docutils literal">StreamWriter</tt> and <tt class="docutils literal">StreamReader</tt> define the interface for stateful
encoders/decoders which work on streams.  These allow processing
of the data in chunks to efficiently use memory.  If you have
large strings in memory, you may want to wrap them with <tt class="docutils literal">cStringIO</tt>
objects and then use these codecs on them to be able to do chunk
processing as well, e.g. to provide progress information to the
user.</p>
<pre class="literal-block">
class StreamWriter(Codec):

    def __init__(self,stream,errors='strict'):

        &quot;&quot;&quot;Creates a StreamWriter instance.

           stream must be a file-like object open for writing
           (binary) data.

           The StreamWriter may implement different error handling
           schemes by providing the errors keyword argument.
           These parameters are defined:

             'strict' - raise a ValueError (or a subclass)
             'ignore' - ignore the character and continue with the next
             'replace'- replace with a suitable replacement character
        &quot;&quot;&quot;
        self.stream = stream
        self.errors = errors

    def write(self,object):

        &quot;&quot;&quot;Writes the object's contents encoded to self.stream.
        &quot;&quot;&quot;
        data, consumed = self.encode(object,self.errors)
        self.stream.write(data)

    def writelines(self, list):

        &quot;&quot;&quot;Writes the concatenated list of strings to the stream
           using .write().
        &quot;&quot;&quot;
        self.write(''.join(list))

    def reset(self):

        &quot;&quot;&quot;Flushes and resets the codec buffers used for keeping state.

           Calling this method should ensure that the data on the
           output is put into a clean state, that allows appending
           of new fresh data without having to rescan the whole
           stream to recover state.
        &quot;&quot;&quot;
        pass

    def __getattr__(self,name, getattr=getattr):

        &quot;&quot;&quot;Inherit all other methods from the underlying stream.
        &quot;&quot;&quot;
        return getattr(self.stream,name)


class StreamReader(Codec):

    def __init__(self,stream,errors='strict'):

        &quot;&quot;&quot;Creates a StreamReader instance.

           stream must be a file-like object open for reading
           (binary) data.

           The StreamReader may implement different error handling
           schemes by providing the errors keyword argument.
           These parameters are defined:

             'strict' - raise a ValueError (or a subclass)
             'ignore' - ignore the character and continue with the next
             'replace'- replace with a suitable replacement character;
        &quot;&quot;&quot;
        self.stream = stream
        self.errors = errors

    def read(self,size=-1):

        &quot;&quot;&quot;Decodes data from the stream self.stream and returns the
           resulting object.

           size indicates the approximate maximum number of bytes
           to read from the stream for decoding purposes.  The
           decoder can modify this setting as appropriate.  The
           default value -1 indicates to read and decode as much
           as possible.  size is intended to prevent having to
           decode huge files in one step.

           The method should use a greedy read strategy meaning
           that it should read as much data as is allowed within
           the definition of the encoding and the given size, e.g.
           if optional encoding endings or state markers are
           available on the stream, these should be read too.
        &quot;&quot;&quot;
        # Unsliced reading:
        if size &lt; 0:
            return self.decode(self.stream.read())[0]

        # Sliced reading:
        read = self.stream.read
        decode = self.decode
        data = read(size)
        i = 0
        while 1:
            try:
                object, decodedbytes = decode(data)
            except ValueError,why:
                # This method is slow but should work under pretty
                # much all conditions; at most 10 tries are made
                i = i + 1
                newdata = read(1)
                if not newdata or i &gt; 10:
                    raise
                data = data + newdata
            else:
                return object

    def readline(self, size=None):

        &quot;&quot;&quot;Read one line from the input stream and return the
           decoded data.

           Note: Unlike the .readlines() method, this method
           inherits the line breaking knowledge from the
           underlying stream's .readline() method -- there is
           currently no support for line breaking using the codec
           decoder due to lack of line buffering.  Subclasses
           should however, if possible, try to implement this
           method using their own knowledge of line breaking.

           size, if given, is passed as size argument to the
           stream's .readline() method.
        &quot;&quot;&quot;
        if size is None:
            line = self.stream.readline()
        else:
            line = self.stream.readline(size)
        return self.decode(line)[0]

    def readlines(self, sizehint=0):

        &quot;&quot;&quot;Read all lines available on the input stream
           and return them as list of lines.

           Line breaks are implemented using the codec's decoder
           method and are included in the list entries.

           sizehint, if given, is passed as size argument to the
           stream's .read() method.
        &quot;&quot;&quot;
        if sizehint is None:
            data = self.stream.read()
        else:
            data = self.stream.read(sizehint)
        return self.decode(data)[0].splitlines(1)

    def reset(self):

        &quot;&quot;&quot;Resets the codec buffers used for keeping state.

           Note that no stream repositioning should take place.
           This method is primarily intended to be able to recover
           from decoding errors.

        &quot;&quot;&quot;
        pass

    def __getattr__(self,name, getattr=getattr):

        &quot;&quot;&quot; Inherit all other methods from the underlying stream.
        &quot;&quot;&quot;
        return getattr(self.stream,name)
</pre>
<p>Stream codec implementors are free to combine the <tt class="docutils literal">StreamWriter</tt> and
<tt class="docutils literal">StreamReader</tt> interfaces into one class.  Even combining all these
with the Codec class should be possible.</p>
<p>Implementors are free to add additional methods to enhance the
codec functionality or provide extra state information needed for
them to work.  The internal codec implementation will only use the
above interfaces, though.</p>
<p>It is not required by the Unicode implementation to use these base
classes, only the interfaces must match; this allows writing
Codecs as extension types.</p>
<p>As guideline, large mapping tables should be implemented using
static C data in separate (shared) extension modules.  That way
multiple processes can share the same data.</p>
<p>A tool to auto-convert Unicode mapping files to mapping modules
should be provided to simplify support for additional mappings
(see References).</p>
</div>
<div class="section" id="whitespace">
<h1><a class="toc-backref" href="#id33">Whitespace</a></h1>
<p>The <tt class="docutils literal">.split()</tt> method will have to know about what is considered
whitespace in Unicode.</p>
</div>
<div class="section" id="case-conversion">
<h1><a class="toc-backref" href="#id34">Case Conversion</a></h1>
<p>Case conversion is rather complicated with Unicode data, since
there are many different conditions to respect.  See</p>
<blockquote>
<a class="reference external" href="http://www.unicode.org/unicode/reports/tr13/">http://www.unicode.org/unicode/reports/tr13/</a></blockquote>
<p>for some guidelines on implementing case conversion.</p>
<p>For Python, we should only implement the 1-1 conversions included
in Unicode.  Locale dependent and other special case conversions
(see the Unicode standard file SpecialCasing.txt) should be left
to user land routines and not go into the core interpreter.</p>
<p>The methods <tt class="docutils literal">.capitalize()</tt> and <tt class="docutils literal">.iscapitalized()</tt> should follow the
case mapping algorithm defined in the above technical report as
closely as possible.</p>
</div>
<div class="section" id="line-breaks">
<h1><a class="toc-backref" href="#id35">Line Breaks</a></h1>
<p>Line breaking should be done for all Unicode characters having the
B property as well as the combinations CRLF, CR, LF (interpreted
in that order) and other special line separators defined by the
standard.</p>
<p>The Unicode type should provide a <tt class="docutils literal">.splitlines()</tt> method which
returns a list of lines according to the above specification. See
Unicode Methods.</p>
</div>
<div class="section" id="unicode-character-properties">
<h1><a class="toc-backref" href="#id36">Unicode Character Properties</a></h1>
<p>A separate module &quot;unicodedata&quot; should provide a compact interface
to all Unicode character properties defined in the standard's
UnicodeData.txt file.</p>
<p>Among other things, these properties provide ways to recognize
numbers, digits, spaces, whitespace, etc.</p>
<p>Since this module will have to provide access to all Unicode
characters, it will eventually have to contain the data from
UnicodeData.txt which takes up around 600kB.  For this reason, the
data should be stored in static C data.  This enables compilation
as shared module which the underlying OS can shared between
processes (unlike normal Python code modules).</p>
<p>There should be a standard Python interface for accessing this
information so that other implementors can plug in their own
possibly enhanced versions, e.g. ones that do decompressing of the
data on-the-fly.</p>
</div>
<div class="section" id="private-code-point-areas">
<h1><a class="toc-backref" href="#id37">Private Code Point Areas</a></h1>
<p>Support for these is left to user land Codecs and not explicitly
integrated into the core.  Note that due to the Internal Format
being implemented, only the area between <tt class="docutils literal">\uE000</tt> and <tt class="docutils literal">\uF8FF</tt> is
usable for private encodings.</p>
</div>
<div class="section" id="internal-format">
<h1><a class="toc-backref" href="#id38">Internal Format</a></h1>
<p>The internal format for Unicode objects should use a Python
specific fixed format &lt;PythonUnicode&gt; implemented as 'unsigned
short' (or another unsigned numeric type having 16 bits).  Byte
order is platform dependent.</p>
<p>This format will hold UTF-16 encodings of the corresponding
Unicode ordinals.  The Python Unicode implementation will address
these values as if they were UCS-2 values. UCS-2 and UTF-16 are
the same for all currently defined Unicode character points.
UTF-16 without surrogates provides access to about 64k characters
and covers all characters in the Basic Multilingual Plane (BMP) of
Unicode.</p>
<p>It is the Codec's responsibility to ensure that the data they pass
to the Unicode object constructor respects this assumption.  The
constructor does not check the data for Unicode compliance or use
of surrogates.</p>
<p>Future implementations can extend the 32 bit restriction to the
full set of all UTF-16 addressable characters (around 1M
characters).</p>
<p>The Unicode API should provide interface routines from
&lt;PythonUnicode&gt; to the compiler's wchar_t which can be 16 or 32
bit depending on the compiler/libc/platform being used.</p>
<p>Unicode objects should have a pointer to a cached Python string
object &lt;defenc&gt; holding the object's value using the &lt;default
encoding&gt;.  This is needed for performance and internal parsing
(see Internal Argument Parsing) reasons.  The buffer is filled
when the first conversion request to the &lt;default encoding&gt; is
issued on the object.</p>
<p>Interning is not needed (for now), since Python identifiers are
defined as being ASCII only.</p>
<p><tt class="docutils literal">codecs.BOM</tt> should return the byte order mark (BOM) for the format
used internally.  The codecs module should provide the following
additional constants for convenience and reference (<tt class="docutils literal">codecs.BOM</tt>
will either be <tt class="docutils literal">BOM_BE</tt> or <tt class="docutils literal">BOM_LE</tt> depending on the platform):</p>
<pre class="literal-block">
BOM_BE: '\376\377'
  (corresponds to Unicode U+0000FEFF in UTF-16 on big endian
   platforms == ZERO WIDTH NO-BREAK SPACE)

BOM_LE: '\377\376'
  (corresponds to Unicode U+0000FFFE in UTF-16 on little endian
   platforms == defined as being an illegal Unicode character)

BOM4_BE: '\000\000\376\377'
  (corresponds to Unicode U+0000FEFF in UCS-4)

BOM4_LE: '\377\376\000\000'
  (corresponds to Unicode U+0000FFFE in UCS-4)
</pre>
<p>Note that Unicode sees big endian byte order as being &quot;correct&quot;.
The swapped order is taken to be an indicator for a &quot;wrong&quot;
format, hence the illegal character definition.</p>
<p>The configure script should provide aid in deciding whether Python
can use the native <tt class="docutils literal">wchar_t</tt> type or not (it has to be a 16-bit
unsigned type).</p>
</div>
<div class="section" id="buffer-interface">
<h1><a class="toc-backref" href="#id39">Buffer Interface</a></h1>
<p>Implement the buffer interface using the &lt;defenc&gt; Python string
object as basis for <tt class="docutils literal">bf_getcharbuf</tt> and the internal buffer for
<tt class="docutils literal">bf_getreadbuf</tt>.  If <tt class="docutils literal">bf_getcharbuf</tt> is requested and the &lt;defenc&gt;
object does not yet exist, it is created first.</p>
<p>Note that as special case, the parser marker &quot;s#&quot; will not return
raw Unicode UTF-16 data (which the <tt class="docutils literal">bf_getreadbuf</tt> returns), but
instead tries to encode the Unicode object using the default
encoding and then returns a pointer to the resulting string object
(or raises an exception in case the conversion fails).  This was
done in order to prevent accidentely writing binary data to an
output stream which the other end might not recognize.</p>
<p>This has the advantage of being able to write to output streams
(which typically use this interface) without additional
specification of the encoding to use.</p>
<p>If you need to access the read buffer interface of Unicode
objects, use the <tt class="docutils literal">PyObject_AsReadBuffer()</tt> interface.</p>
<p>The internal format can also be accessed using the
'unicode-internal' codec, e.g. via <tt class="docutils literal"><span class="pre">u.encode('unicode-internal')</span></tt>.</p>
</div>
<div class="section" id="pickle-marshalling">
<h1><a class="toc-backref" href="#id40">Pickle/Marshalling</a></h1>
<p>Should have native Unicode object support.  The objects should be
encoded using platform independent encodings.</p>
<p>Marshal should use UTF-8 and Pickle should either choose
Raw-Unicode-Escape (in text mode) or UTF-8 (in binary mode) as
encoding.  Using UTF-8 instead of UTF-16 has the advantage of
eliminating the need to store a BOM mark.</p>
</div>
<div class="section" id="regular-expressions">
<h1><a class="toc-backref" href="#id41">Regular Expressions</a></h1>
<p>Secret Labs AB is working on a Unicode-aware regular expression
machinery.  It works on plain 8-bit, UCS-2, and (optionally) UCS-4
internal character buffers.</p>
<p>Also see</p>
<blockquote>
<a class="reference external" href="http://www.unicode.org/unicode/reports/tr18/">http://www.unicode.org/unicode/reports/tr18/</a></blockquote>
<p>for some remarks on how to treat Unicode REs.</p>
</div>
<div class="section" id="formatting-markers">
<h1><a class="toc-backref" href="#id42">Formatting Markers</a></h1>
<p>Format markers are used in Python format strings.  If Python
strings are used as format strings, the following interpretations
should be in effect:</p>
<pre class="literal-block">
'%s': For Unicode objects this will cause coercion of the
      whole format string to Unicode.  Note that you should use
      a Unicode format string to start with for performance
      reasons.
</pre>
<p>In case the format string is an Unicode object, all parameters are
coerced to Unicode first and then put together and formatted
according to the format string.  Numbers are first converted to
strings and then to Unicode.</p>
<pre class="literal-block">
'%s': Python strings are interpreted as Unicode
      string using the &lt;default encoding&gt;.  Unicode objects are
      taken as is.
</pre>
<p>All other string formatters should work accordingly.</p>
<p>Example:</p>
<pre class="literal-block">
u&quot;%s %s&quot; % (u&quot;abc&quot;, &quot;abc&quot;)  ==  u&quot;abc abc&quot;
</pre>
</div>
<div class="section" id="internal-argument-parsing">
<h1><a class="toc-backref" href="#id43">Internal Argument Parsing</a></h1>
<p>These markers are used by the <tt class="docutils literal">PyArg_ParseTuple()</tt> APIs:</p>
<dl class="docutils">
<dt>&quot;U&quot;</dt>
<dd>Check for Unicode object and return a pointer to it</dd>
<dt>&quot;s&quot;</dt>
<dd>For Unicode objects: return a pointer to the object's
&lt;defenc&gt; buffer (which uses the &lt;default encoding&gt;).</dd>
<dt>&quot;s#&quot;</dt>
<dd>Access to the default encoded version of the Unicode object
(see Buffer Interface); note that the length relates to
the length of the default encoded string rather than the
Unicode object length.</dd>
<dt>&quot;t#&quot;</dt>
<dd>Same as &quot;s#&quot;.</dd>
<dt>&quot;es&quot;</dt>
<dd><p class="first">Takes two parameters: encoding (<tt class="docutils literal">const char *</tt>) and buffer
(<tt class="docutils literal">char **</tt>).</p>
<p>The input object is first coerced to Unicode in the usual
way and then encoded into a string using the given
encoding.</p>
<p class="last">On output, a buffer of the needed size is allocated and
returned through <tt class="docutils literal">*buffer</tt> as NULL-terminated string.  The
encoded may not contain embedded NULL characters.  The
caller is responsible for calling <tt class="docutils literal">PyMem_Free()</tt> to free the
allocated <tt class="docutils literal">*buffer</tt> after usage.</p>
</dd>
<dt>&quot;es#&quot;</dt>
<dd><p class="first">Takes three parameters: encoding (<tt class="docutils literal">const char *</tt>), buffer
(<tt class="docutils literal">char **</tt>) and buffer_len (<tt class="docutils literal">int *</tt>).</p>
<p>The input object is first coerced to Unicode in the usual
way and then encoded into a string using the given
encoding.</p>
<p>If <tt class="docutils literal">*buffer</tt> is non-NULL, <tt class="docutils literal">*buffer_len</tt> must be set to
<tt class="docutils literal">sizeof(buffer)</tt> on input. Output is then copied to <tt class="docutils literal">*buffer</tt>.</p>
<p>If <tt class="docutils literal">*buffer</tt> is NULL, a buffer of the needed size is
allocated and output copied into it.  <tt class="docutils literal">*buffer</tt> is then
updated to point to the allocated memory area.  The caller
is responsible for calling <tt class="docutils literal">PyMem_Free()</tt> to free the
allocated <tt class="docutils literal">*buffer</tt> after usage.</p>
<p class="last">In both cases <tt class="docutils literal">*buffer_len</tt> is updated to the number of
characters written (excluding the trailing NULL-byte).
The output buffer is assured to be NULL-terminated.</p>
</dd>
</dl>
<p>Examples:</p>
<p>Using &quot;es#&quot; with auto-allocation:</p>
<pre class="literal-block">
static PyObject *
test_parser(PyObject *self,
            PyObject *args)
{
    PyObject *str;
    const char *encoding = &quot;latin-1&quot;;
    char *buffer = NULL;
    int buffer_len = 0;

    if (!PyArg_ParseTuple(args, &quot;es#:test_parser&quot;,
                          encoding, &amp;buffer, &amp;buffer_len))
        return NULL;
    if (!buffer) {
        PyErr_SetString(PyExc_SystemError,
                        &quot;buffer is NULL&quot;);
        return NULL;
    }
    str = PyString_FromStringAndSize(buffer, buffer_len);
    PyMem_Free(buffer);
    return str;
}
</pre>
<p>Using &quot;es&quot; with auto-allocation returning a NULL-terminated string:</p>
<pre class="literal-block">
static PyObject *
test_parser(PyObject *self,
            PyObject *args)
{
    PyObject *str;
    const char *encoding = &quot;latin-1&quot;;
    char *buffer = NULL;

    if (!PyArg_ParseTuple(args, &quot;es:test_parser&quot;,
                          encoding, &amp;buffer))
        return NULL;
    if (!buffer) {
        PyErr_SetString(PyExc_SystemError,
                        &quot;buffer is NULL&quot;);
        return NULL;
    }
    str = PyString_FromString(buffer);
    PyMem_Free(buffer);
    return str;
}
</pre>
<p>Using &quot;es#&quot; with a pre-allocated buffer:</p>
<pre class="literal-block">
static PyObject *
test_parser(PyObject *self,
            PyObject *args)
{
    PyObject *str;
    const char *encoding = &quot;latin-1&quot;;
    char _buffer[10];
    char *buffer = _buffer;
    int buffer_len = sizeof(_buffer);

    if (!PyArg_ParseTuple(args, &quot;es#:test_parser&quot;,
                          encoding, &amp;buffer, &amp;buffer_len))
        return NULL;
    if (!buffer) {
        PyErr_SetString(PyExc_SystemError,
                        &quot;buffer is NULL&quot;);
        return NULL;
    }
    str = PyString_FromStringAndSize(buffer, buffer_len);
    return str;
}
</pre>
</div>
<div class="section" id="file-stream-output">
<h1><a class="toc-backref" href="#id44">File/Stream Output</a></h1>
<p>Since file.write(object) and most other stream writers use the
&quot;s#&quot; or &quot;t#&quot; argument parsing marker for querying the data to
write, the default encoded string version of the Unicode object
will be written to the streams (see Buffer Interface).</p>
<p>For explicit handling of files using Unicode, the standard stream
codecs as available through the codecs module should be used.</p>
<p>The codecs module should provide a short-cut
open(filename,mode,encoding) available which also assures that
mode contains the 'b' character when needed.</p>
</div>
<div class="section" id="file-stream-input">
<h1><a class="toc-backref" href="#id45">File/Stream Input</a></h1>
<p>Only the user knows what encoding the input data uses, so no
special magic is applied.  The user will have to explicitly
convert the string data to Unicode objects as needed or use the
file wrappers defined in the codecs module (see File/Stream
Output).</p>
</div>
<div class="section" id="unicode-methods-attributes">
<h1><a class="toc-backref" href="#id46">Unicode Methods &amp; Attributes</a></h1>
<p>All Python string methods, plus:</p>
<pre class="literal-block">
.encode([encoding=&lt;default encoding&gt;][,errors=&quot;strict&quot;])
   --&gt; see Unicode Output

.splitlines([include_breaks=0])
   --&gt; breaks the Unicode string into a list of (Unicode) lines;
       returns the lines with line breaks included, if
       include_breaks is true.  See Line Breaks for a
       specification of how line breaking is done.
</pre>
</div>
<div class="section" id="code-base">
<h1><a class="toc-backref" href="#id47">Code Base</a></h1>
<p>We should use Fredrik Lundh's Unicode object implementation as
basis. It already implements most of the string methods needed
and provides a well written code base which we can build upon.</p>
<p>The object sharing implemented in Fredrik's implementation should
be dropped.</p>
</div>
<div class="section" id="test-cases">
<h1><a class="toc-backref" href="#id48">Test Cases</a></h1>
<p>Test cases should follow those in Lib/test/test_string.py and
include additional checks for the Codec Registry and the Standard
Codecs.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id49">References</a></h1>
<ul class="simple">
<li>Unicode Consortium: <a class="reference external" href="http://www.unicode.org/">http://www.unicode.org/</a></li>
<li>Unicode FAQ: <a class="reference external" href="http://www.unicode.org/unicode/faq/">http://www.unicode.org/unicode/faq/</a></li>
<li>Unicode 3.0: <a class="reference external" href="http://www.unicode.org/unicode/standard/versions/Unicode3.0.html">http://www.unicode.org/unicode/standard/versions/Unicode3.0.html</a></li>
<li>Unicode-TechReports: <a class="reference external" href="http://www.unicode.org/unicode/reports/techreports.html">http://www.unicode.org/unicode/reports/techreports.html</a></li>
<li>Unicode-Mappings: <a class="reference external" href="ftp://ftp.unicode.org/Public/MAPPINGS/">ftp://ftp.unicode.org/Public/MAPPINGS/</a></li>
<li>Introduction to Unicode (a little outdated by still nice to read):
<a class="reference external" href="http://www.nada.kth.se/i18n/ucs/unicode-iso10646-oview.html">http://www.nada.kth.se/i18n/ucs/unicode-iso10646-oview.html</a></li>
<li>For comparison:
Introducing Unicode to ECMAScript (aka JavaScript) --
<a class="reference external" href="http://www-4.ibm.com/software/developer/library/internationalization-support.html">http://www-4.ibm.com/software/developer/library/internationalization-support.html</a></li>
<li>IANA Character Set Names:
<a class="reference external" href="ftp://ftp.isi.edu/in-notes/iana/assignments/character-sets">ftp://ftp.isi.edu/in-notes/iana/assignments/character-sets</a></li>
<li>Discussion of UTF-8 and Unicode support for POSIX and Linux:
<a class="reference external" href="http://www.cl.cam.ac.uk/~mgk25/unicode.html">http://www.cl.cam.ac.uk/~mgk25/unicode.html</a></li>
<li>Encodings:<ul>
<li>Overview: <a class="reference external" href="http://czyborra.com/utf/">http://czyborra.com/utf/</a></li>
<li>UCS-2: <a class="reference external" href="http://www.uazone.org/multiling/unicode/ucs2.html">http://www.uazone.org/multiling/unicode/ucs2.html</a></li>
<li>UTF-7: Defined in <a class="reference external" href="http://tools.ietf.org/html/rfc2152.html">RFC2152</a>, e.g.
<a class="reference external" href="http://www.uazone.org/multiling/ml-docs/rfc2152.txt">http://www.uazone.org/multiling/ml-docs/rfc2152.txt</a></li>
<li>UTF-8: Defined in <a class="reference external" href="http://tools.ietf.org/html/rfc2279.html">RFC2279</a>, e.g.
<a class="reference external" href="https://tools.ietf.org/html/rfc2279">https://tools.ietf.org/html/rfc2279</a></li>
<li>UTF-16: <a class="reference external" href="http://www.uazone.org/multiling/unicode/wg2n1035.html">http://www.uazone.org/multiling/unicode/wg2n1035.html</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="history-of-this-proposal">
<h1><a class="toc-backref" href="#id50">History of this Proposal</a></h1>
<p>[ed. note: revisions prior to 1.7 are available in the CVS history
of Misc/unicode.txt from the standard Python distribution.  All
subsequent history is available via the CVS revisions on this
file.]</p>
<div class="section" id="id1">
<h2><a class="toc-backref" href="#id51">1.7</a></h2>
<ul class="simple">
<li>Added note about the changed behaviour of &quot;s#&quot;.</li>
</ul>
</div>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id52">1.6</a></h2>
<ul class="simple">
<li>Changed &lt;defencstr&gt; to &lt;defenc&gt; since this is the name used in the
implementation.</li>
<li>Added notes about the usage of &lt;defenc&gt; in
the buffer protocol implementation.</li>
</ul>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id53">1.5</a></h2>
<ul class="simple">
<li>Added notes about setting the &lt;default encoding&gt;.</li>
<li>Fixed some typos (thanks to Andrew Kuchling).</li>
<li>Changed &lt;defencstr&gt; to &lt;utf8str&gt;.</li>
</ul>
</div>
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id54">1.4</a></h2>
<ul class="simple">
<li>Added note about mixed type comparisons and contains tests.</li>
<li>Changed treating of Unicode objects in format strings (if
used with <tt class="docutils literal">'%s' % u</tt> they will now cause the format string to
be coerced to Unicode, thus producing a Unicode object on
return).</li>
<li>Added link to IANA charset names (thanks to Lars
Marius Garshol).</li>
<li>Added new codec methods <tt class="docutils literal">.readline()</tt>,
<tt class="docutils literal">.readlines()</tt> and <tt class="docutils literal">.writelines()</tt>.</li>
</ul>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id55">1.3</a></h2>
<ul class="simple">
<li>Added new &quot;es&quot; and &quot;es#&quot; parser markers</li>
</ul>
</div>
<div class="section" id="id6">
<h2><a class="toc-backref" href="#id56">1.2</a></h2>
<ul class="simple">
<li>Removed POD about <tt class="docutils literal">codecs.open()</tt></li>
</ul>
</div>
<div class="section" id="id7">
<h2><a class="toc-backref" href="#id57">1.1</a></h2>
<ul class="simple">
<li>Added note about comparisons and hash values.</li>
<li>Added note about case mapping algorithms.</li>
<li>Changed stream codecs <tt class="docutils literal">.read()</tt> and <tt class="docutils literal">.write()</tt> method
to match the standard file-like object
methods (bytes consumed information is no longer returned by
the methods)</li>
</ul>
</div>
<div class="section" id="id8">
<h2><a class="toc-backref" href="#id58">1.0</a></h2>
<ul class="simple">
<li>changed encode Codec method to be symmetric to the decode method
(they both return (object, data consumed) now and thus become
interchangeable);</li>
<li>removed <tt class="docutils literal">__init__</tt> method of Codec class (the
methods are stateless) and moved the errors argument down to
the methods;</li>
<li>made the Codec design more generic w/r to type
of input and output objects;</li>
<li>changed <tt class="docutils literal">StreamWriter.flush</tt> to <tt class="docutils literal">StreamWriter.reset</tt> in order to
avoid overriding the stream's <tt class="docutils literal">.flush()</tt> method;</li>
<li>renamed <tt class="docutils literal">.breaklines()</tt> to <tt class="docutils literal">.splitlines()</tt>;</li>
<li>renamed the module unicodec to codecs;</li>
<li>modified the File I/O section to refer to the stream codecs.</li>
</ul>
</div>
<div class="section" id="id9">
<h2><a class="toc-backref" href="#id59">0.9</a></h2>
<ul class="simple">
<li>changed errors keyword argument definition;</li>
<li>added 'replace' error handling;</li>
<li>changed the codec APIs to accept buffer like
objects on input;</li>
<li>some minor typo fixes;</li>
<li>added Whitespace section and included references for Unicode characters that
have the whitespace and the line break characteristic;</li>
<li>added note that search functions can expect lower-case encoding names;</li>
<li>dropped slicing and offsets in the codec APIs</li>
</ul>
</div>
<div class="section" id="id10">
<h2><a class="toc-backref" href="#id60">0.8</a></h2>
<ul class="simple">
<li>added encodings package and raw unicode escape encoding;</li>
<li>untabified the proposal;</li>
<li>added notes on Unicode format strings;</li>
<li>added <tt class="docutils literal">.breaklines()</tt> method</li>
</ul>
</div>
<div class="section" id="id11">
<h2><a class="toc-backref" href="#id61">0.7</a></h2>
<ul class="simple">
<li>added a whole new set of codec APIs;</li>
<li>added a different encoder lookup scheme;</li>
<li>fixed some names</li>
</ul>
</div>
<div class="section" id="id12">
<h2><a class="toc-backref" href="#id62">0.6</a></h2>
<ul class="simple">
<li>changed &quot;s#&quot; to &quot;t#&quot;;</li>
<li>changed &lt;defencbuf&gt; to &lt;defencstr&gt; holding
a real Python string object;</li>
<li>changed Buffer Interface to
delegate requests to &lt;defencstr&gt;'s buffer interface;</li>
<li>removed the explicit reference to the unicodec.codecs dictionary (the
module can implement this in way fit for the purpose);</li>
<li>removed the settable default encoding;</li>
<li>move <tt class="docutils literal">UnicodeError</tt> from unicodec to exceptions;</li>
<li>&quot;s#&quot; not returns the internal data;</li>
<li>passed the UCS-2/UTF-16 checking from the Unicode constructor
to the Codecs</li>
</ul>
</div>
<div class="section" id="id13">
<h2><a class="toc-backref" href="#id63">0.5</a></h2>
<ul class="simple">
<li>moved <tt class="docutils literal">sys.bom</tt> to <tt class="docutils literal">unicodec.BOM</tt>;</li>
<li>added sections on case mapping,</li>
<li>private use encodings and Unicode character properties</li>
</ul>
</div>
<div class="section" id="id14">
<h2><a class="toc-backref" href="#id64">0.4</a></h2>
<ul class="simple">
<li>added Codec interface, notes on %-formatting,</li>
<li>changed some encoding details,</li>
<li>added comments on stream wrappers,</li>
<li>fixed some discussion points (most important: Internal Format),</li>
<li>clarified the 'unicode-escape' encoding, added encoding
references</li>
</ul>
</div>
<div class="section" id="id15">
<h2><a class="toc-backref" href="#id65">0.3</a></h2>
<ul class="simple">
<li>added references, comments on codec modules, the internal format,
bf_getcharbuffer and the RE engine;</li>
<li>added 'unicode-escape'
encoding proposed by Tim Peters and fixed repr(u) accordingly</li>
</ul>
</div>
<div class="section" id="id16">
<h2><a class="toc-backref" href="#id66">0.2</a></h2>
<ul class="simple">
<li>integrated Guido's suggestions, added stream codecs and file wrapping</li>
</ul>
</div>
<div class="section" id="id17">
<h2><a class="toc-backref" href="#id67">0.1</a></h2>
<ul class="simple">
<li>first version</li>
</ul>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>
</div>

