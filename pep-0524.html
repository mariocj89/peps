<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">524</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Make os.urandom() blocking on Linux</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0524.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Victor Stinner &lt;victor.stinner&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">20-June-2016</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.6</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id4">Abstract</a></li>
<li><a class="reference internal" href="#the-bug" id="id5">The bug</a><ul>
<li><a class="reference internal" href="#original-bug" id="id6">Original bug</a></li>
<li><a class="reference internal" href="#status-in-python-3-5-2" id="id7">Status in Python 3.5.2</a></li>
</ul>
</li>
<li><a class="reference internal" href="#use-cases" id="id8">Use Cases</a><ul>
<li><a class="reference internal" href="#use-case-1-init-script" id="id9">Use Case 1: init script</a><ul>
<li><a class="reference internal" href="#use-case-1-1-no-secret-needed" id="id10">Use case 1.1: No secret needed</a></li>
<li><a class="reference internal" href="#use-case-1-2-secure-secret-required" id="id11">Use case 1.2: Secure secret required</a></li>
</ul>
</li>
<li><a class="reference internal" href="#use-case-2-web-server" id="id12">Use Case 2: Web server</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fix-system-urandom" id="id13">Fix system urandom</a><ul>
<li><a class="reference internal" href="#load-entropy-from-disk-at-boot" id="id14">Load entropy from disk at boot</a></li>
<li><a class="reference internal" href="#virtual-machines" id="id15">Virtual machines</a></li>
<li><a class="reference internal" href="#embedded-devices" id="id16">Embedded devices</a></li>
</ul>
</li>
<li><a class="reference internal" href="#denial-of-service-when-reading-random" id="id17">Denial-of-service when reading random</a><ul>
<li><a class="reference internal" href="#don-t-use-dev-random-but-dev-urandom" id="id18">Don't use /dev/random but /dev/urandom</a></li>
<li><a class="reference internal" href="#getrandom-size-0-can-block-forever-on-linux" id="id19">getrandom(size, 0) can block forever on Linux</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rationale" id="id20">Rationale</a></li>
<li><a class="reference internal" href="#changes" id="id21">Changes</a><ul>
<li><a class="reference internal" href="#make-os-urandom-blocking-on-linux" id="id22">Make os.urandom() blocking on Linux</a></li>
<li><a class="reference internal" href="#add-a-new-os-getrandom-function" id="id23">Add a new os.getrandom() function</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples-using-os-getrandom" id="id24">Examples using os.getrandom()</a><ul>
<li><a class="reference internal" href="#best-effort-rng" id="id25">Best-effort RNG</a></li>
<li><a class="reference internal" href="#wait-for-system-rng" id="id26">wait_for_system_rng()</a></li>
<li><a class="reference internal" href="#create-a-best-effort-rng" id="id27">Create a best-effort RNG</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alternative" id="id28">Alternative</a><ul>
<li><a class="reference internal" href="#leave-os-urandom-unchanged-add-os-getrandom" id="id29">Leave os.urandom() unchanged, add os.getrandom()</a></li>
<li><a class="reference internal" href="#raise-blockingioerror-in-os-urandom" id="id30">Raise BlockingIOError in os.urandom()</a><ul>
<li><a class="reference internal" href="#proposition" id="id31">Proposition</a></li>
<li><a class="reference internal" href="#criticism" id="id32">Criticism</a></li>
</ul>
</li>
<li><a class="reference internal" href="#add-an-optional-block-parameter-to-os-urandom" id="id33">Add an optional block parameter to os.urandom()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#acceptance" id="id34">Acceptance</a></li>
<li><a class="reference internal" href="#annexes" id="id35">Annexes</a><ul>
<li><a class="reference internal" href="#operating-system-random-functions" id="id36">Operating system random functions</a></li>
<li><a class="reference internal" href="#why-using-os-urandom" id="id37">Why using os.urandom()?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#copyright" id="id38">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id4">Abstract</a></h1>
<p>Modify <tt class="docutils literal">os.urandom()</tt> to block on Linux 3.17 and newer until the OS
urandom is initialized to increase the security.</p>
<p>Add also a new <tt class="docutils literal">os.getrandom()</tt> function (for Linux and Solaris) to be
able to choose how to handle when <tt class="docutils literal">os.urandom()</tt> is going to block on
Linux.</p>
</div>
<div class="section" id="the-bug">
<h1><a class="toc-backref" href="#id5">The bug</a></h1>
<div class="section" id="original-bug">
<h2><a class="toc-backref" href="#id6">Original bug</a></h2>
<p>Python 3.5.0 was enhanced to use the new <tt class="docutils literal">getrandom()</tt> syscall
introduced in Linux 3.17 and Solaris 11.3. The problem is that users
started to complain that Python 3.5 blocks at startup on Linux in
virtual machines and embedded devices: see issues <a class="reference external" href="http://bugs.python.org/issue25420">#25420</a> and <a class="reference external" href="http://bugs.python.org/issue26839">#26839</a>.</p>
<p>On Linux, <tt class="docutils literal">getrandom(0)</tt> blocks until the kernel initialized urandom
with 128 bits of entropy. The issue #25420 describes a Linux build
platform blocking at <tt class="docutils literal">import random</tt>. The issue #26839 describes a
short Python script used to compute a MD5 hash, systemd-cron, script
called very early in the init process. The system initialization blocks
on this script which blocks on <tt class="docutils literal">getrandom(0)</tt> to initialize Python.</p>
<p>The Python initialization requires random bytes to implement a
counter-measure against the hash denial-of-service (hash DoS), see:</p>
<ul class="simple">
<li><a class="reference external" href="http://bugs.python.org/issue13703">Issue #13703: Hash collision security issue</a></li>
<li><a class="reference external" href="https://www.python.org/dev/peps/pep-0456/">PEP 456: Secure and interchangeable hash algorithm</a></li>
</ul>
<p>Importing the <tt class="docutils literal">random</tt> module creates an instance of
<tt class="docutils literal">random.Random</tt>: <tt class="docutils literal">random._inst</tt>. On Python 3.5, random.Random
constructor reads 2500 bytes from <tt class="docutils literal">os.urandom()</tt> to seed a Mersenne
Twister RNG (random number generator).</p>
<p>Other platforms may be affected by this bug, but in practice, only Linux
systems use Python scripts to initialize the system.</p>
</div>
<div class="section" id="status-in-python-3-5-2">
<h2><a class="toc-backref" href="#id7">Status in Python 3.5.2</a></h2>
<p>Python 3.5.2 behaves like Python 2.7 and Python 3.4. If the system
urandom is not initialized, the startup does not block, but
<tt class="docutils literal">os.urandom()</tt> can return low-quality entropy (even it is not easily
guessable).</p>
</div>
</div>
<div class="section" id="use-cases">
<h1><a class="toc-backref" href="#id8">Use Cases</a></h1>
<p>The following use cases are used to help to choose the right compromise
between security and practicability.</p>
<div class="section" id="use-case-1-init-script">
<h2><a class="toc-backref" href="#id9">Use Case 1: init script</a></h2>
<p>Use a Python 3 script to initialize the system, like systemd-cron. If
the script blocks, the system initialize is stuck too. The issue #26839
is a good example of this use case.</p>
<div class="section" id="use-case-1-1-no-secret-needed">
<h3><a class="toc-backref" href="#id10">Use case 1.1: No secret needed</a></h3>
<p>If the init script doesn't have to generate any secure secret, this use
case is already handled correctly in Python 3.5.2: Python startup
doesn't block on system urandom anymore.</p>
</div>
<div class="section" id="use-case-1-2-secure-secret-required">
<h3><a class="toc-backref" href="#id11">Use case 1.2: Secure secret required</a></h3>
<p>If the init script has to generate a secure secret, there is no safe
solution.</p>
<p>Falling back to weak entropy is not acceptable, it would
reduce the security of the program.</p>
<p>Python cannot produce itself secure entropy, it can only wait until
system urandom is initialized. But in this use case, the whole system
initialization is blocked by this script, so the system fails to boot.</p>
<p>The real answer is that the system initialization must not be blocked by
such script. It is ok to start the script very early at system
initialization, but the script may blocked a few seconds until it is
able to generate the secret.</p>
<p>Reminder: in some cases, the initialization of the system urandom never
occurs and so programs waiting for system urandom blocks forever.</p>
</div>
</div>
<div class="section" id="use-case-2-web-server">
<h2><a class="toc-backref" href="#id12">Use Case 2: Web server</a></h2>
<p>Run a Python 3 web server serving web pages using HTTP and HTTPS
protocols. The server is started as soon as possible.</p>
<p>The first target of the hash DoS attack was web server: it's important
that the hash secret cannot be easily guessed by an attacker.</p>
<p>If serving a web page needs a secret to create a cookie, create an
encryption key, ..., the secret must be created with good entropy:
again, it must be hard to guess the secret.</p>
<p>A web server requires security. If a choice must be made between
security and running the server with weak entropy, security is more
important. If there is no good entropy: the server must block or fail
with an error.</p>
<p>The question is if it makes sense to start a web server on a host before
system urandom is initialized.</p>
<p>The issues #25420 and #26839 are restricted to the Python startup, not
to generate a secret before the system urandom is initialized.</p>
</div>
</div>
<div class="section" id="fix-system-urandom">
<h1><a class="toc-backref" href="#id13">Fix system urandom</a></h1>
<div class="section" id="load-entropy-from-disk-at-boot">
<h2><a class="toc-backref" href="#id14">Load entropy from disk at boot</a></h2>
<p>Collecting entropy can take up to several minutes. To accelerate the
system initialization, operating systems store entropy on disk at
shutdown, and then reload entropy from disk at the boot.</p>
<p>If a system collects enough entropy at least once, the system urandom
will be initialized quickly, as soon as the entropy is reloaded from
disk.</p>
</div>
<div class="section" id="virtual-machines">
<h2><a class="toc-backref" href="#id15">Virtual machines</a></h2>
<p>Virtual machines don't have a direct access to the hardware and so have
less sources of entropy than bare metal. A solution is to add a
<a class="reference external" href="https://fedoraproject.org/wiki/Features/Virtio_RNG">virtio-rng device</a> to pass entropy
from the host to the virtual machine.</p>
</div>
<div class="section" id="embedded-devices">
<h2><a class="toc-backref" href="#id16">Embedded devices</a></h2>
<p>A solution for embedded devices is to plug an hardware RNG.</p>
<p>For example, Raspberry Pi have an hardware RNG but it's not used by
default. See: <a class="reference external" href="http://fios.sector16.net/hardware-rng-on-raspberry-pi/">Hardware RNG on Raspberry Pi</a>.</p>
</div>
</div>
<div class="section" id="denial-of-service-when-reading-random">
<h1><a class="toc-backref" href="#id17">Denial-of-service when reading random</a></h1>
<div class="section" id="don-t-use-dev-random-but-dev-urandom">
<h2><a class="toc-backref" href="#id18">Don't use /dev/random but /dev/urandom</a></h2>
<p>The <tt class="docutils literal">/dev/random</tt> device should only used for very specific use cases.
Reading from <tt class="docutils literal">/dev/random</tt> on Linux is likely to block. Users don't
like when an application blocks longer than 5 seconds to generate a
secret. It is only expected for specific cases like generating
explicitly an encryption key.</p>
<p>When the system has no available entropy, choosing between blocking
until entropy is available or falling back on lower quality entropy is a
matter of compromise between security and practicability. The choice
depends on the use case.</p>
<p>On Linux, <tt class="docutils literal">/dev/urandom</tt> is secure, it should be used instead of
<tt class="docutils literal">/dev/random</tt>. See <a class="reference external" href="http://www.2uo.de/myths-about-urandom/">Myths about /dev/urandom</a> by Thomas Hühn: &quot;Fact:
/dev/urandom is the preferred source of cryptographic randomness on
UNIX-like systems&quot;</p>
</div>
<div class="section" id="getrandom-size-0-can-block-forever-on-linux">
<h2><a class="toc-backref" href="#id19">getrandom(size, 0) can block forever on Linux</a></h2>
<p>The origin of the Python issue #26839 is the <a class="reference external" href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=822431">Debian bug
report #822431</a>: in fact,
<tt class="docutils literal">getrandom(size, 0)</tt> blocks forever on the virtual machine. The system
succeeded to boot because systemd killed the blocked process after 90
seconds.</p>
<p>Solutions like <a class="reference internal" href="#load-entropy-from-disk-at-boot">Load entropy from disk at boot</a> reduces the risk of
this bug.</p>
</div>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id20">Rationale</a></h1>
<p>On Linux, reading the <tt class="docutils literal">/dev/urandom</tt> can return &quot;weak&quot; entropy before
urandom is fully initialized, before the kernel collected 128 bits of
entropy. Linux 3.17 adds a new <tt class="docutils literal">getrandom()</tt> syscall which allows to
block until urandom is initialized.</p>
<p>On Python 3.5.2, os.urandom() uses the
<tt class="docutils literal">getrandom(size, GRND_NONBLOCK)</tt>, but falls back on reading the
non-blocking <tt class="docutils literal">/dev/urandom</tt> if <tt class="docutils literal">getrandom(size, GRND_NONBLOCK)</tt>
fails with <tt class="docutils literal">EAGAIN</tt>.</p>
<p>Security experts promotes <tt class="docutils literal">os.urandom()</tt> to genereate cryptographic
keys because it is implemented with a <a class="reference external" href="https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator">Cryptographically secure
pseudo-random number generator (CSPRNG)</a>.
By the way, <tt class="docutils literal">os.urandom()</tt> is preferred over <tt class="docutils literal">ssl.RAND_bytes()</tt> for
different reasons.</p>
<p>This PEP proposes to modify os.urandom() to use <tt class="docutils literal">getrandom()</tt> in
blocking mode to not return weak entropy, but also ensure that Python
will not block at startup.</p>
</div>
<div class="section" id="changes">
<h1><a class="toc-backref" href="#id21">Changes</a></h1>
<div class="section" id="make-os-urandom-blocking-on-linux">
<h2><a class="toc-backref" href="#id22">Make os.urandom() blocking on Linux</a></h2>
<p>All changes described in this section are specific to the Linux
platform.</p>
<p>Changes:</p>
<ul class="simple">
<li>Modify os.urandom() to block until system urandom is initialized:
<tt class="docutils literal">os.urandom()</tt> (C function <tt class="docutils literal">_PyOS_URandom()</tt>) is modified to
always call <tt class="docutils literal">getrandom(size, 0)</tt> (blocking mode) on Linux and
Solaris.</li>
<li>Add a new private <tt class="docutils literal">_PyOS_URandom_Nonblocking()</tt> function: try to
call <tt class="docutils literal">getrandom(size, GRND_NONBLOCK)</tt> on Linux and Solaris, but
falls back on reading <tt class="docutils literal">/dev/urandom</tt> if it fails with <tt class="docutils literal">EAGAIN</tt>.</li>
<li>Initialize hash secret from non-blocking system urandom:
<tt class="docutils literal">_PyRandom_Init()</tt> is modified to call
<tt class="docutils literal">_PyOS_URandom_Nonblocking()</tt>.</li>
<li><tt class="docutils literal">random.Random</tt> constructor now uses non-blocking system urandom: it
is modified to use internally the new <tt class="docutils literal">_PyOS_URandom_Nonblocking()</tt>
function to seed the RNG.</li>
</ul>
</div>
<div class="section" id="add-a-new-os-getrandom-function">
<h2><a class="toc-backref" href="#id23">Add a new os.getrandom() function</a></h2>
<p>A new <tt class="docutils literal">os.getrandom(size, flags=0)</tt> function is added: use
<tt class="docutils literal">getrandom()</tt> syscall on Linux and <tt class="docutils literal">getrandom()</tt> C function on
Solaris.</p>
<p>The function comes with 2 new flags:</p>
<ul class="simple">
<li><tt class="docutils literal">os.GRND_RANDOM</tt>: read bytes from <tt class="docutils literal">/dev/random</tt> rather than
reading <tt class="docutils literal">/dev/urandom</tt></li>
<li><tt class="docutils literal">os.GRND_NONBLOCK</tt>: raise a BlockingIOError if <tt class="docutils literal">os.getrandom()</tt>
would block</li>
</ul>
<p>The <tt class="docutils literal">os.getrandom()</tt> is a thin wrapper on the <tt class="docutils literal">getrandom()</tt>
syscall/C function and so inherit of its behaviour. For example, on
Linux, it can return less bytes than requested if the syscall is
interrupted by a signal.</p>
</div>
</div>
<div class="section" id="examples-using-os-getrandom">
<h1><a class="toc-backref" href="#id24">Examples using os.getrandom()</a></h1>
<div class="section" id="best-effort-rng">
<h2><a class="toc-backref" href="#id25">Best-effort RNG</a></h2>
<p>Example of a portable non-blocking RNG function: try to get random bytes
from the OS urandom, or fallback on the random module.</p>
<pre class="literal-block">
def best_effort_rng(size):
    # getrandom() is only available on Linux and Solaris
    if not hasattr(os, 'getrandom'):
        return os.urandom(size)

    result = bytearray()
    try:
        # need a loop because getrandom() can return less bytes than
        # requested for different reasons
        while size:
            data = os.getrandom(size, os.GRND_NONBLOCK)
            result += data
            size -= len(data)
    except BlockingIOError:
        # OS urandom is not initialized yet:
        # fallback on the Python random module
        data = bytes(random.randrange(256) for byte in range(size))
        result += data
    return bytes(result)
</pre>
<p>This function <em>can</em> block in theory on a platform where
<tt class="docutils literal">os.getrandom()</tt> is not available but <tt class="docutils literal">os.urandom()</tt> can block.</p>
</div>
<div class="section" id="wait-for-system-rng">
<h2><a class="toc-backref" href="#id26">wait_for_system_rng()</a></h2>
<p>Example of function waiting <em>timeout</em> seconds until the OS urandom is
initialized on Linux or Solaris:</p>
<pre class="literal-block">
def wait_for_system_rng(timeout, interval=1.0):
    if not hasattr(os, 'getrandom'):
        return

    deadline = time.monotonic() + timeout
    while True:
        try:
            os.getrandom(1, os.GRND_NONBLOCK)
        except BlockingIOError:
            pass
        else:
            return

        if time.monotonic() &gt; deadline:
            raise Exception('OS urandom not initialized after %s seconds'
                            % timeout)

        time.sleep(interval)
</pre>
<p>This function is <em>not</em> portable. For example, <tt class="docutils literal">os.urandom()</tt> can block
on FreeBSD in theory, at the early stage of the system initialization.</p>
</div>
<div class="section" id="create-a-best-effort-rng">
<h2><a class="toc-backref" href="#id27">Create a best-effort RNG</a></h2>
<p>Simpler example to create a non-blocking RNG on Linux: choose between
<tt class="docutils literal">Random.SystemRandom</tt> and <tt class="docutils literal">Random.Random</tt> depending if
<tt class="docutils literal">getrandom(size)</tt> would block.</p>
<pre class="literal-block">
def create_nonblocking_random():
    if not hasattr(os, 'getrandom'):
        return random.Random()

    try:
        os.getrandom(1, os.GRND_NONBLOCK)
    except BlockingIOError:
        return random.Random()
    else:
        return random.SystemRandom()
</pre>
<p>This function is <em>not</em> portable. For example, <tt class="docutils literal">random.SystemRandom</tt>
can block on FreeBSD in theory, at the early stage of the system
initialization.</p>
</div>
</div>
<div class="section" id="alternative">
<h1><a class="toc-backref" href="#id28">Alternative</a></h1>
<div class="section" id="leave-os-urandom-unchanged-add-os-getrandom">
<h2><a class="toc-backref" href="#id29">Leave os.urandom() unchanged, add os.getrandom()</a></h2>
<p>os.urandom() remains unchanged: never block, but it can return weak
entropy if system urandom is not initialized yet.</p>
<p>Only add the new <tt class="docutils literal">os.getrandom()</tt> function (wrapper to the
<tt class="docutils literal">getrandom()</tt> syscall/C function).</p>
<p>The <tt class="docutils literal">secrets.token_bytes()</tt> function should be used to write portable
code.</p>
<p>The problem with this change is that it expects that users understand
well security and know well each platforms. Python has the tradition of
hiding &quot;implementation details&quot;. For example, <tt class="docutils literal">os.urandom()</tt> is not a
thin wrapper to the <tt class="docutils literal">/dev/urandom</tt> device: it uses
<tt class="docutils literal">CryptGenRandom()</tt> on Windows, it uses <tt class="docutils literal">getentropy()</tt> on OpenBSD, it
tries <tt class="docutils literal">getrandom()</tt> on Linux and Solaris or falls back on reading
<tt class="docutils literal">/dev/urandom</tt>. Python already uses the best available system RNG
depending on the platform.</p>
<p>This PEP does not change the API:</p>
<ul class="simple">
<li><tt class="docutils literal">os.urandom()</tt>, <tt class="docutils literal">random.SystemRandom</tt> and <tt class="docutils literal">secrets</tt> for security</li>
<li><tt class="docutils literal">random</tt> module (except <tt class="docutils literal">random.SystemRandom</tt>) for all other usages</li>
</ul>
</div>
<div class="section" id="raise-blockingioerror-in-os-urandom">
<h2><a class="toc-backref" href="#id30">Raise BlockingIOError in os.urandom()</a></h2>
<div class="section" id="proposition">
<h3><a class="toc-backref" href="#id31">Proposition</a></h3>
<p><a class="reference external" href="https://www.python.org/dev/peps/pep-0522/">PEP 522: Allow BlockingIOError in security sensitive APIs on Linux</a>.</p>
<p>Python should not decide for the developer how to handle <a class="reference internal" href="#the-bug">The bug</a>:
raising immediatly a <tt class="docutils literal">BlockingIOError</tt> if <tt class="docutils literal">os.urandom()</tt> is going to
block allows developers to choose how to handle this case:</p>
<ul class="simple">
<li>catch the exception and falls back to a non-secure entropy source:
read <tt class="docutils literal">/dev/urandom</tt> on Linux, use the Python <tt class="docutils literal">random</tt> module
(which is not secure at all), use time, use process identifier, etc.</li>
<li>don't catch the error, the whole program fails with this fatal
exception</li>
</ul>
<p>More generally, the exception helps to notify when sometimes goes wrong.
The application can emit a warning when it starts to wait for
<tt class="docutils literal">os.urandom()</tt>.</p>
</div>
<div class="section" id="criticism">
<h3><a class="toc-backref" href="#id32">Criticism</a></h3>
<p>For the use case 2 (web server), falling back on non-secure entropy is
not acceptable. The application must handle <tt class="docutils literal">BlockingIOError</tt>: poll
<tt class="docutils literal">os.urandom()</tt> until it completes. Example:</p>
<pre class="literal-block">
def secret(n=16):
    try:
        return os.urandom(n)
    except BlockingIOError:
        pass

    print(&quot;Wait for system urandom initialiation: move your &quot;
          &quot;mouse, use your keyboard, use your disk, ...&quot;)
    while 1:
        # Avoid busy-loop: sleep 1 ms
        time.sleep(0.001)
        try:
            return os.urandom(n)
        except BlockingIOError:
            pass
</pre>
<p>For correctness, all applications which must generate a secure secret
must be modified to handle <tt class="docutils literal">BlockingIOError</tt> even if <a class="reference internal" href="#the-bug">The bug</a> is
unlikely.</p>
<p>The case of applications using <tt class="docutils literal">os.urandom()</tt> but don't really require
security is not well defined. Maybe these applications should not use
<tt class="docutils literal">os.urandom()</tt> at the first place, but always the non-blocking
<tt class="docutils literal">random</tt> module. If <tt class="docutils literal">os.urandom()</tt> is used for security, we are back
to the use case 2 described above: <a class="reference internal" href="#use-case-2-web-server">Use Case 2: Web server</a>. If a
developer doesn't want to drop <tt class="docutils literal">os.urandom()</tt>, the code should be
modified. Example:</p>
<pre class="literal-block">
def almost_secret(n=16):
    try:
        return os.urandom(n)
    except BlockingIOError:
        return bytes(random.randrange(256) for byte in range(n))
</pre>
<p>The question is if <a class="reference internal" href="#the-bug">The bug</a> is common enough to require that so many
applications have to be modified.</p>
<p>Another simpler choice is to refuse to start before the system urandom
is initialized:</p>
<pre class="literal-block">
def secret(n=16):
    try:
        return os.urandom(n)
    except BlockingIOError:
        print(&quot;Fatal error: the system urandom is not initialized&quot;)
        print(&quot;Wait a bit, and rerun the program later.&quot;)
        sys.exit(1)
</pre>
<p>Compared to Python 2.7, Python 3.4 and Python 3.5.2 where os.urandom()
never blocks nor raise an exception on Linux, such behaviour change can
be seen as a major regression.</p>
</div>
</div>
<div class="section" id="add-an-optional-block-parameter-to-os-urandom">
<h2><a class="toc-backref" href="#id33">Add an optional block parameter to os.urandom()</a></h2>
<p>See the <a class="reference external" href="http://bugs.python.org/issue27250">issue #27250: Add os.urandom_block()</a>.</p>
<p>Add an optional block parameter to os.urandom(). The default value may
be <tt class="docutils literal">True</tt> (block by default) or <tt class="docutils literal">False</tt> (non-blocking).</p>
<p>The first technical issue is to implement <tt class="docutils literal">os.urandom(block=False)</tt> on
all platforms. Only Linux 3.17 (and newer) and Solaris 11.3 (and newer)
have a well defined non-blocking API (<tt class="docutils literal">getrandom(size,
GRND_NONBLOCK)</tt>).</p>
<p>As <a class="reference internal" href="#raise-blockingioerror-in-os-urandom">Raise BlockingIOError in os.urandom()</a>, it doesn't seem worth it to
make the API more complex for a theorical (or at least very rare) use
case.</p>
<p>As <a class="reference internal" href="#leave-os-urandom-unchanged-add-os-getrandom">Leave os.urandom() unchanged, add os.getrandom()</a>, the problem is
that it makes the API more complex and so more error-prone.</p>
</div>
</div>
<div class="section" id="acceptance">
<h1><a class="toc-backref" href="#id34">Acceptance</a></h1>
<p>The PEP was <a class="reference external" href="https://mail.python.org/pipermail/security-sig/2016-August/000101.html">accepted on 2016-08-08 by Guido van Rossum</a>.</p>
</div>
<div class="section" id="annexes">
<h1><a class="toc-backref" href="#id35">Annexes</a></h1>
<div class="section" id="operating-system-random-functions">
<h2><a class="toc-backref" href="#id36">Operating system random functions</a></h2>
<p><tt class="docutils literal">os.urandom()</tt> uses the following functions:</p>
<ul class="simple">
<li><a class="reference external" href="http://man.openbsd.org/OpenBSD-current/man2/getentropy.2">OpenBSD: getentropy()</a>
(OpenBSD 5.6)</li>
<li><a class="reference external" href="http://man7.org/linux/man-pages/man2/getrandom.2.html">Linux: getrandom()</a> (Linux 3.17)
-- see also <a class="reference external" href="https://lwn.net/Articles/606141/">A system call for random numbers: getrandom()</a></li>
<li>Solaris: <a class="reference external" href="https://docs.oracle.com/cd/E53394_01/html/E54765/getentropy-2.html#scrolltoc">getentropy()</a>,
<a class="reference external" href="https://docs.oracle.com/cd/E53394_01/html/E54765/getrandom-2.html">getrandom()</a>
(both need Solaris 11.3)</li>
<li>UNIX, BSD: /dev/urandom, /dev/random</li>
<li>Windows: <a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa379942%28v=vs.85%29.aspx">CryptGenRandom()</a>
(Windows XP)</li>
</ul>
<p>On Linux, commands to get the status of <tt class="docutils literal">/dev/random</tt> (results are
number of bytes):</p>
<pre class="literal-block">
$ cat /proc/sys/kernel/random/entropy_avail
2850
$ cat /proc/sys/kernel/random/poolsize
4096
</pre>
</div>
<div class="section" id="why-using-os-urandom">
<h2><a class="toc-backref" href="#id37">Why using os.urandom()?</a></h2>
<p>Since <tt class="docutils literal">os.urandom()</tt> is implemented in the kernel, it doesn't have
issues of user-space RNG. For example, it is much harder to get its
state. It is usually built on a CSPRNG, so even if its state is
&quot;stolen&quot;, it is hard to compute previously generated numbers. The kernel
has a good knowledge of entropy sources and feed regulary the entropy
pool.</p>
<p>That's also why <tt class="docutils literal">os.urandom()</tt> is preferred over <tt class="docutils literal">ssl.RAND_bytes()</tt>.</p>
</div>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id38">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
</div>

