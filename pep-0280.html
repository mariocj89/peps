<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">280</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Optimizing access to globals</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0280.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">guido&#32;&#97;t&#32;python.org (Guido van Rossum)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Deferred</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">10-Feb-2002</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.3</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#deferral" id="id2">Deferral</a></li>
<li><a class="reference internal" href="#abstract" id="id3">Abstract</a></li>
<li><a class="reference internal" href="#description" id="id4">Description</a></li>
<li><a class="reference internal" href="#additional-ideas" id="id5">Additional Ideas</a></li>
<li><a class="reference internal" href="#faqs" id="id6">FAQs</a></li>
<li><a class="reference internal" href="#graphics" id="id7">Graphics</a></li>
<li><a class="reference internal" href="#comparison" id="id8">Comparison</a></li>
<li><a class="reference internal" href="#copyright" id="id9">Copyright</a></li>
</ul>
</div>
<div class="section" id="deferral">
<h1><a class="toc-backref" href="#id2">Deferral</a></h1>
<p>While this PEP is a nice idea, no-one has yet emerged to do the work of
hashing out the differences between this PEP, <a class="reference external" href="/dev/peps/pep-0266">PEP 266</a> and <a class="reference external" href="/dev/peps/pep-0267">PEP 267</a>.
Hence, it is being deferred.</p>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id3">Abstract</a></h1>
<p>This PEP describes yet another approach to optimizing access to
module globals, providing an alternative to <a class="reference external" href="/dev/peps/pep-0266">PEP 266</a> (Optimizing
Global Variable/Attribute Access by Skip Montanaro) and <a class="reference external" href="/dev/peps/pep-0267">PEP 267</a>
(Optimized Access to Module Namespaces by Jeremy Hylton).</p>
<p>The expectation is that eventually one approach will be picked and
implemented; possibly multiple approaches will be prototyped
first.</p>
</div>
<div class="section" id="description">
<h1><a class="toc-backref" href="#id4">Description</a></h1>
<p>(Note: Jason Orendorff writes: &quot;&quot;&quot;I implemented this once, long
ago, for Python 1.5-ish, I believe.  I got it to the point where
it was only 15% slower than ordinary Python, then abandoned it.
;) In my implementation, &quot;cells&quot; were real first-class objects,
and &quot;celldict&quot; was a copy-and-hack version of dictionary.  I
forget how the rest worked.&quot;&quot;&quot;  Reference:
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2002-February/019876.html">https://mail.python.org/pipermail/python-dev/2002-February/019876.html</a>)</p>
<p>Let a cell be a really simple Python object, containing a pointer
to a Python object and a pointer to a cell.  Both pointers may be
<tt class="docutils literal">NULL</tt>.  A Python implementation could be:</p>
<pre class="literal-block">
class cell(object):

    def __init__(self):
        self.objptr = NULL
        self.cellptr = NULL
</pre>
<p>The cellptr attribute is used for chaining cells together for
searching built-ins; this will be explained later.</p>
<p>Let a celldict be a mapping from strings (the names of a module's
globals) to objects (the values of those globals), implemented
using a dict of cells.  A Python implementation could be:</p>
<pre class="literal-block">
class celldict(object):

    def __init__(self):
        self.__dict = {} # dict of cells

    def getcell(self, key):
        c = self.__dict.get(key)
        if c is None:
            c = cell()
            self.__dict[key] = c
        return c

    def cellkeys(self):
        return self.__dict.keys()

    def __getitem__(self, key):
        c = self.__dict.get(key)
        if c is None:
            raise KeyError, key
        value = c.objptr
        if value is NULL:
            raise KeyError, key
        else:
            return value

    def __setitem__(self, key, value):
        c = self.__dict.get(key)
        if c is None:
            c = cell()
            self.__dict[key] = c
        c.objptr = value

    def __delitem__(self, key):
        c = self.__dict.get(key)
        if c is None or c.objptr is NULL:
            raise KeyError, key
        c.objptr = NULL

    def keys(self):
        return [k for k, c in self.__dict.iteritems()
                if c.objptr is not NULL]

    def items(self):
        return [k, c.objptr for k, c in self.__dict.iteritems()
                if c.objptr is not NULL]

    def values(self):
        preturn [c.objptr for c in self.__dict.itervalues()
                if c.objptr is not NULL]

    def clear(self):
        for c in self.__dict.values():
            c.objptr = NULL

    # Etc.
</pre>
<p>It is possible that a cell exists corresponding to a given key,
but the cell's objptr is <tt class="docutils literal">NULL</tt>; let's call such a cell empty.  When
the celldict is used as a mapping, it is as if empty cells don't
exist.  However, once added, a cell is never deleted from a
celldict, and it is possible to get at empty cells using the
<tt class="docutils literal">getcell()</tt> method.</p>
<p>The celldict implementation never uses the cellptr attribute of
cells.</p>
<p>We change the module implementation to use a celldict for its
<tt class="docutils literal">__dict__</tt>.  The module's getattr, setattr and delattr operations
now map to getitem, setitem and delitem on the celldict.  The type
of <tt class="docutils literal"><span class="pre">&lt;module&gt;.__dict__</span></tt> and <tt class="docutils literal">globals()</tt> is probably the only backwards
incompatibility.</p>
<p>When a module is initialized, its <tt class="docutils literal">__builtins__</tt> is initialized from
the <tt class="docutils literal">__builtin__</tt> module's <tt class="docutils literal">__dict__</tt>, which is itself a celldict.
For each cell in <tt class="docutils literal">__builtins__</tt>, the new module's <tt class="docutils literal">__dict__</tt> adds a
cell with a <tt class="docutils literal">NULL</tt> objptr, whose cellptr points to the corresponding
cell of <tt class="docutils literal">__builtins__</tt>.  Python pseudo-code (ignoring rexec):</p>
<pre class="literal-block">
import __builtin__

class module(object):

    def __init__(self):
        self.__dict__ = d = celldict()
        d['__builtins__'] = bd = __builtin__.__dict__
        for k in bd.cellkeys():
            c = self.__dict__.getcell(k)
            c.cellptr = bd.getcell(k)

    def __getattr__(self, k):
        try:
            return self.__dict__[k]
        except KeyError:
            raise IndexError, k

    def __setattr__(self, k, v):
        self.__dict__[k] = v

    def __delattr__(self, k):
        del self.__dict__[k]
</pre>
<p>The compiler generates <tt class="docutils literal">LOAD_GLOBAL_CELL &lt;i&gt;</tt> (and <tt class="docutils literal">STORE_GLOBAL_CELL
&lt;i&gt;</tt> etc.) opcodes for references to globals, where <tt class="docutils literal">&lt;i&gt;</tt> is a small
index with meaning only within one code object like the const
index in <tt class="docutils literal">LOAD_CONST</tt>.  The code object has a new tuple, <tt class="docutils literal">co_globals</tt>,
giving the names of the globals referenced by the code indexed by
<tt class="docutils literal">&lt;i&gt;</tt>.  No new analysis is required to be able to do this.</p>
<p>When a function object is created from a code object and a celldict,
the function object creates an array of cell pointers by asking the
celldict for cells corresponding to the names in the code object's
<tt class="docutils literal">co_globals</tt>.  If the celldict doesn't already have a cell for a
particular name, it creates and an empty one.  This array of cell
pointers is stored on the function object as <tt class="docutils literal">func_cells</tt>.  When a
function object is created from a regular dict instead of a
celldict, <tt class="docutils literal">func_cells</tt> is a <tt class="docutils literal">NULL</tt> pointer.</p>
<p>When the VM executes a <tt class="docutils literal">LOAD_GLOBAL_CELL &lt;i&gt;</tt> instruction, it gets
cell number <tt class="docutils literal">&lt;i&gt;</tt> from <tt class="docutils literal">func_cells</tt>.  It then looks in the cell's
<tt class="docutils literal">PyObject</tt> pointer, and if not <tt class="docutils literal">NULL</tt>, that's the global value.  If it
is <tt class="docutils literal">NULL</tt>, it follows the cell's cell pointer to the next cell, if it
is not <tt class="docutils literal">NULL</tt>, and looks in the <tt class="docutils literal">PyObject</tt> pointer in that cell.  If
that's also <tt class="docutils literal">NULL</tt>, or if there is no second cell, <tt class="docutils literal">NameError</tt> is
raised.  (It could follow the chain of cell pointers until a <tt class="docutils literal">NULL</tt>
cell pointer is found; but I have no use for this.)  Similar for
<tt class="docutils literal">STORE_GLOBAL_CELL &lt;i&gt;</tt>, except it doesn't follow the cell pointer
chain -- it always stores in the first cell.</p>
<p>There are fallbacks in the VM for the case where the function's
globals aren't a celldict, and hence <tt class="docutils literal">func_cells</tt> is <tt class="docutils literal">NULL</tt>.  In that
case, the code object's <tt class="docutils literal">co_globals</tt> is indexed with <tt class="docutils literal">&lt;i&gt;</tt> to find the
name of the corresponding global and this name is used to index the
function's globals dict.</p>
</div>
<div class="section" id="additional-ideas">
<h1><a class="toc-backref" href="#id5">Additional Ideas</a></h1>
<ul>
<li><p class="first">Never make <tt class="docutils literal">func_cell</tt> a <tt class="docutils literal">NULL</tt> pointer; instead, make up an array
of empty cells, so that <tt class="docutils literal">LOAD_GLOBAL_CELL</tt> can index <tt class="docutils literal">func_cells</tt>
without a <tt class="docutils literal">NULL</tt> check.</p>
</li>
<li><p class="first">Make <tt class="docutils literal">c.cellptr</tt> equal to c when a cell is created, so that
<tt class="docutils literal">LOAD_GLOBAL_CELL</tt> can always dereference <tt class="docutils literal">c.cellptr</tt> without a <tt class="docutils literal">NULL</tt>
check.</p>
<p>With these two additional ideas added, here's Python pseudo-code
for <tt class="docutils literal">LOAD_GLOBAL_CELL</tt>:</p>
<pre class="literal-block">
def LOAD_GLOBAL_CELL(self, i):
    # self is the frame
    c = self.func_cells[i]
    obj = c.objptr
    if obj is not NULL:
        return obj # Existing global
    return c.cellptr.objptr # Built-in or NULL
</pre>
</li>
<li><p class="first">Be more aggressive:  put the actual values of builtins into module
dicts, not just pointers to cells containing the actual values.</p>
<p>There are two points to this:  (1) Simplify and speed access, which
is the most common operation.  (2) Support faithful emulation of
extreme existing corner cases.</p>
<p>WRT  #2, the set of builtins in the scheme above is captured at the
time a module dict is first created.  Mutations to the set of builtin
names following that don't get reflected in the module dicts.  Example:
consider files <tt class="docutils literal">main.py</tt> and <tt class="docutils literal">cheater.py</tt>:</p>
<pre class="literal-block">
[main.py]
import cheater
def f():
    cheater.cheat()
    return pachinko()
print f()

[cheater.py]
def cheat():
    import __builtin__
    __builtin__.pachinko = lambda: 666
</pre>
<p>If <tt class="docutils literal">main.py</tt> is run under Python 2.2 (or before), 666 is printed.  But
under the proposal, <tt class="docutils literal">__builtin__.pachinko</tt> doesn't exist at the time
main's <tt class="docutils literal">__dict__</tt> is initialized.  When the function object for
f is created, <tt class="docutils literal">main.__dict__</tt> grows a pachinko cell mapping to two
<tt class="docutils literal">NULLs</tt>.  When <tt class="docutils literal">cheat()</tt> is called, <tt class="docutils literal">__builtin__.__dict__</tt> grows a pachinko
cell too, but <tt class="docutils literal">main.__dict__</tt> doesn't know-- and will never know --about
that.  When f's return stmt references pachinko, in will still find
the double-NULLs in <tt class="docutils literal">main.__dict__</tt>'s <tt class="docutils literal">pachinko</tt> cell, and so raise
<tt class="docutils literal">NameError</tt>.</p>
<p>A similar (in cause) break in compatibility can occur if a module
global foo is del'ed, but a builtin foo was created prior to that
but after the module dict was first created.  Then the builtin foo
becomes visible in the module under 2.2 and before, but remains
invisible under the proposal.</p>
<p>Mutating builtins is extremely rare (most programs never mutate the
builtins, and it's hard to imagine a plausible use for frequent
mutation of the builtins -- I've never seen or heard of one), so it
doesn't matter how expensive mutating the builtins becomes.  OTOH,
referencing globals and builtins is very common.  Combining those
observations suggests a more aggressive caching of builtins in module
globals, speeding access at the expense of making mutations of the
builtins (potentially much) more expensive to keep the caches in
synch.</p>
<p>Much of the scheme above remains the same, and most of the rest is
just a little different.  A cell changes to:</p>
<pre class="literal-block">
class cell(object):
    def __init__(self, obj=NULL, builtin=0):
        self.objptr = obj
        self.builtinflag = builtin
</pre>
<p>and a celldict maps strings to this version of cells.  <tt class="docutils literal">builtinflag</tt>
is true when and only when objptr contains a value obtained from
the builtins; in other words, it's true when and only when a cell
is acting as a cached value.  When <tt class="docutils literal">builtinflag</tt> is false, objptr is
the value of a module global (possibly <tt class="docutils literal">NULL</tt>).  celldict changes to:</p>
<pre class="literal-block">
class celldict(object):

    def __init__(self, builtindict=()):
        self.basedict = builtindict
        self.__dict = d = {}
        for k, v in builtindict.items():
            d[k] = cell(v, 1)

    def __getitem__(self, key):
        c = self.__dict.get(key)
        if c is None or c.objptr is NULL or c.builtinflag:
            raise KeyError, key
        return c.objptr

    def __setitem__(self, key, value):
        c = self.__dict.get(key)
        if c is None:
            c = cell()
            self.__dict[key] = c
        c.objptr = value
        c.builtinflag = 0

    def __delitem__(self, key):
        c = self.__dict.get(key)
        if c is None or c.objptr is NULL or c.builtinflag:
            raise KeyError, key
        c.objptr = NULL
        # We may have unmasked a builtin.  Note that because
        # we're checking the builtin dict for that *now*, this
        # still works if the builtin first came into existence
        # after we were constructed.  Note too that del on
        # namespace dicts is rare, so the expensse of this check
        # shouldn't matter.
        if key in self.basedict:
            c.objptr = self.basedict[key]
            assert c.objptr is not NULL # else &quot;in&quot; lied
            c.builtinflag = 1
        else:
            # There is no builtin with the same name.
            assert not c.builtinflag

    def keys(self):
        return [k for k, c in self.__dict.iteritems()
                if c.objptr is not NULL and not c.builtinflag]

    def items(self):
        return [k, c.objptr for k, c in self.__dict.iteritems()
                if c.objptr is not NULL and not c.builtinflag]

    def values(self):
        preturn [c.objptr for c in self.__dict.itervalues()
                if c.objptr is not NULL and not c.builtinflag]

    def clear(self):
        for c in self.__dict.values():
            if not c.builtinflag:
                c.objptr = NULL

    # Etc.
</pre>
<p>The speed benefit comes from simplifying <tt class="docutils literal">LOAD_GLOBAL_CELL</tt>, which
I expect is executed more frequently than all other namespace
operations combined:</p>
<pre class="literal-block">
def LOAD_GLOBAL_CELL(self, i):
    # self is the frame
    c = self.func_cells[i]
    return c.objptr   # may be NULL (also true before)
</pre>
<p>That is, accessing builtins and accessing module globals are equally
fast.  For module globals, a NULL-pointer test+branch is saved.  For
builtins, an additional pointer chase is also saved.</p>
<p>The other part needed to make this fly is expensive, propagating
mutations of builtins into the module dicts that were initialized
from the builtins.  This is much like, in 2.2, propagating changes
in new-style base classes to their descendants:  the builtins need to
maintain a list of weakrefs to the modules (or module dicts)
initialized from the builtin's dict.  Given a mutation to the builtin
dict (adding a new key, changing the value associated with an
existing key, or deleting a key), traverse the list of module dicts
and make corresponding mutations to them.  This is straightforward;
for example, if a key is deleted from builtins, execute
<tt class="docutils literal">reflect_bltin_del</tt> in each module:</p>
<pre class="literal-block">
def reflect_bltin_del(self, key):
    c = self.__dict.get(key)
    assert c is not None # else we were already out of synch
    if c.builtinflag:
        # Put us back in synch.
        c.objptr = NULL
        c.builtinflag = 0
    # Else we're shadowing the builtin, so don't care that
    # the builtin went away.
</pre>
<p>Note that <tt class="docutils literal">c.builtinflag</tt> protects from us erroneously deleting a
module global of the same name.  Adding a new (key, value) builtin
pair is similar:</p>
<pre class="literal-block">
def reflect_bltin_new(self, key, value):
    c = self.__dict.get(key)
    if c is None:
        # Never heard of it before:  cache the builtin value.
        self.__dict[key] = cell(value, 1)
    elif c.objptr is NULL:
        # This used to exist in the module or the builtins,
        # but doesn't anymore; rehabilitate it.
        assert not c.builtinflag
        c.objptr = value
        c.builtinflag = 1
    else:
        # We're shadowing it already.
        assert not c.builtinflag
</pre>
<p>Changing the value of an existing builtin:</p>
<pre class="literal-block">
def reflect_bltin_change(self, key, newvalue):
    c = self.__dict.get(key)
    assert c is not None # else we were already out of synch
    if c.builtinflag:
        # Put us back in synch.
        c.objptr = newvalue
    # Else we're shadowing the builtin, so don't care that
    # the builtin changed.
</pre>
</li>
</ul>
</div>
<div class="section" id="faqs">
<h1><a class="toc-backref" href="#id6">FAQs</a></h1>
<ul>
<li><p class="first">Q: Will it still be possible to:</p>
<p>a) install new builtins in the <tt class="docutils literal">__builtin__</tt> namespace and have
them available in all already loaded modules right away ?</p>
<p>b) override builtins (e.g. <tt class="docutils literal">open()</tt>) with my own copies
(e.g. to increase security) in a way that makes these new
copies override the previous ones in all modules ?</p>
<p>A: Yes, this is the whole point of this design.  In the original
approach, when <tt class="docutils literal">LOAD_GLOBAL_CELL</tt> finds a <tt class="docutils literal">NULL</tt> in the second
cell, it should go back to see if the <tt class="docutils literal">__builtins__</tt> dict has
been modified (the pseudo code doesn't have this yet).  Tim's
&quot;more aggressive&quot; alternative also takes care of this.</p>
</li>
<li><p class="first">Q: How does the new scheme get along with the restricted execution
model?</p>
<p>A: It is intended to support that fully.</p>
</li>
<li><p class="first">Q: What happens when a global is deleted?</p>
<p>A: The module's celldict would have a cell with a <tt class="docutils literal">NULL</tt> objptr for
that key.  This is true in both variations, but the &quot;aggressive&quot;
variation goes on to see whether this unmasks a builtin of the
same name, and if so copies its value (just a pointer-copy of the
ultimate <tt class="docutils literal">PyObject*</tt>) into the cell's objptr and sets the cell's
<tt class="docutils literal">builtinflag</tt> to true.</p>
</li>
<li><p class="first">Q: What would the C code for <tt class="docutils literal">LOAD_GLOBAL_CELL</tt> look like?</p>
<p>A: The first version, with the first two bullets under &quot;Additional
ideas&quot; incorporated, could look like this:</p>
<pre class="literal-block">
case LOAD_GLOBAL_CELL:
    cell = func_cells[oparg];
    x = cell-&gt;objptr;
    if (x == NULL) {
        x = cell-&gt;cellptr-&gt;objptr;
        if (x == NULL) {
            ... error recovery ...
            break;
        }
    }
    Py_INCREF(x);
    PUSH(x);
    continue;
</pre>
<p>We could even write it like this (idea courtesy of Ka-Ping Yee):</p>
<pre class="literal-block">
case LOAD_GLOBAL_CELL:
    cell = func_cells[oparg];
    x = cell-&gt;cellptr-&gt;objptr;
    if (x != NULL) {
        Py_INCREF(x);
        PUSH(x);
        continue;
    }
    ... error recovery ...
    break;
</pre>
<p>In modern CPU architectures, this reduces the number of
branches taken for built-ins, which might be a really good
thing, while any decent memory cache should realize that
<tt class="docutils literal"><span class="pre">cell-&gt;cellptr</span></tt> is the same as cell for regular globals and hence
this should be very fast in that case too.</p>
<p>For the aggressive variant:</p>
<pre class="literal-block">
case LOAD_GLOBAL_CELL:
    cell = func_cells[oparg];
    x = cell-&gt;objptr;
    if (x != NULL) {
        Py_INCREF(x);
        PUSH(x);
        continue;
    }
    ... error recovery ...
    break;
</pre>
</li>
<li><p class="first">Q: What happens in the module's top-level code where there is
presumably no <tt class="docutils literal">func_cells</tt> array?</p>
<p>A: We could do some code analysis and create a <tt class="docutils literal">func_cells</tt> array,
or we could use <tt class="docutils literal">LOAD_NAME</tt> which should use <tt class="docutils literal">PyMapping_GetItem</tt> on
the globals dict.</p>
</li>
</ul>
</div>
<div class="section" id="graphics">
<h1><a class="toc-backref" href="#id7">Graphics</a></h1>
<p>Ka-Ping Yee supplied a drawing of the state of things after
&quot;import spam&quot;, where <tt class="docutils literal">spam.py</tt> contains:</p>
<pre class="literal-block">
import eggs

i = -2
max = 3

def foo(n):
    y = abs(i) + max
    return eggs.ham(y + n)
</pre>
<p>The drawing is at <a class="reference external" href="http://web.lfw.org/repo/cells.gif">http://web.lfw.org/repo/cells.gif</a>; a larger
version is at <a class="reference external" href="http://lfw.org/repo/cells-big.gif">http://lfw.org/repo/cells-big.gif</a>; the source is at
<a class="reference external" href="http://lfw.org/repo/cells.ai">http://lfw.org/repo/cells.ai</a>.</p>
</div>
<div class="section" id="comparison">
<h1><a class="toc-backref" href="#id8">Comparison</a></h1>
<p>XXX Here, a comparison of the three approaches could be added.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id9">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

