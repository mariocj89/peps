<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">3130</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Access to Current Module/Class/Function</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-3130.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Jim J. Jewett &lt;jimjjewett&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">22-Apr-2007</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.0</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">22-Apr-2007</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#rejection-notice" id="id5">Rejection Notice</a></li>
<li><a class="reference internal" href="#abstract" id="id6">Abstract</a></li>
<li><a class="reference internal" href="#rationale-for-module" id="id7">Rationale for <tt class="docutils literal">__module__</tt></a></li>
<li><a class="reference internal" href="#rationale-for-class" id="id8">Rationale for <tt class="docutils literal">__class__</tt></a></li>
<li><a class="reference internal" href="#rationale-for-function" id="id9">Rationale for <tt class="docutils literal">__function__</tt></a></li>
<li><a class="reference internal" href="#backwards-compatibility" id="id10">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#implementation" id="id11">Implementation</a></li>
<li><a class="reference internal" href="#open-issues" id="id12">Open Issues</a></li>
<li><a class="reference internal" href="#references" id="id13">References</a></li>
<li><a class="reference internal" href="#copyright" id="id14">Copyright</a></li>
</ul>
</div>
<div class="section" id="rejection-notice">
<h1><a class="toc-backref" href="#id5">Rejection Notice</a></h1>
<p>This PEP is rejected.  It is not clear how it should be
implemented or what the precise semantics should be in edge cases,
and there aren't enough important use cases given.  response has
been lukewarm at best.</p>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id6">Abstract</a></h1>
<p>It is common to need a reference to the current module, class,
or function, but there is currently no entirely correct way to
do this.  This PEP proposes adding the keywords <tt class="docutils literal">__module__</tt>,
<tt class="docutils literal">__class__</tt>, and <tt class="docutils literal">__function__</tt>.</p>
</div>
<div class="section" id="rationale-for-module">
<h1><a class="toc-backref" href="#id7">Rationale for <tt class="docutils literal">__module__</tt></a></h1>
<p>Many modules export various functions, classes, and other objects,
but will perform additional activities (such as running unit
tests) when run as a script.  The current idiom is to test whether
the module's name has been set to magic value.</p>
<pre class="literal-block">
if __name__ == &quot;__main__&quot;: ...
</pre>
<p>More complicated introspection requires a module to (attempt to)
import itself.  If importing the expected name actually produces
a different module, there is no good workaround.</p>
<pre class="literal-block">
# __import__ lets you use a variable, but... it gets more
# complicated if the module is in a package.
__import__(__name__)

# So just go to sys modules... and hope that the module wasn't
# hidden/removed (perhaps for security), that __name__ wasn't
# changed, and definitely hope that no other module with the
# same name is now available.
class X(object):
    pass

import sys
mod = sys.modules[__name__]
mod = sys.modules[X.__class__.__module__]
</pre>
<p>Proposal:  Add a <tt class="docutils literal">__module__</tt> keyword which refers to the module
currently being defined (executed).  (But see open issues.)</p>
<pre class="literal-block">
# XXX sys.main is still changing as draft progresses.  May
# really need sys.modules[sys.main]
if __module__ is sys.main:    # assumes PEP (3122), Cannon
    ...
</pre>
</div>
<div class="section" id="rationale-for-class">
<h1><a class="toc-backref" href="#id8">Rationale for <tt class="docutils literal">__class__</tt></a></h1>
<p>Class methods are passed the current instance; from this they can
determine <tt class="docutils literal">self.__class__</tt> (or cls, for class methods).
Unfortunately, this reference is to the object's actual class,
which may be a subclass of the defining class.  The current
workaround is to repeat the name of the class, and assume that the
name will not be rebound.</p>
<pre class="literal-block">
class C(B):

    def meth(self):
        super(C, self).meth() # Hope C is never rebound.

class D(C):

    def meth(self):
        # ?!? issubclass(D,C), so it &quot;works&quot;:
        super(C, self).meth()
</pre>
<p>Proposal: Add a <tt class="docutils literal">__class__</tt> keyword which refers to the class
currently being defined (executed).  (But see open issues.)</p>
<pre class="literal-block">
class C(B):
    def meth(self):
        super(__class__, self).meth()
</pre>
<p>Note that super calls may be further simplified by the &quot;New Super&quot;
PEP (Spealman).  The <tt class="docutils literal">__class__</tt> (or <tt class="docutils literal">__this_class__</tt>) attribute came
up in attempts to simplify the explanation and/or implementation
of that PEP, but was separated out as an independent decision.</p>
<p>Note that <tt class="docutils literal">__class__</tt> (or <tt class="docutils literal">__this_class__</tt>) is not quite the same as
the <tt class="docutils literal">__thisclass__</tt> property on bound super objects.  The existing
<tt class="docutils literal">super.__thisclass__</tt> property refers to the class from which the
Method Resolution Order search begins.  In the above class D, it
would refer to (the current reference of name) C.</p>
</div>
<div class="section" id="rationale-for-function">
<h1><a class="toc-backref" href="#id9">Rationale for <tt class="docutils literal">__function__</tt></a></h1>
<p>Functions (including methods) often want access to themselves,
usually for a private storage location or true recursion.  While
there are several workarounds, all have their drawbacks.</p>
<pre class="literal-block">
def counter(_total=[0]):
    # _total shouldn't really appear in the
    # signature at all; the list wrapping and
    # [0] unwrapping obscure the code
    _total[0] += 1
    return _total[0]

&#64;annotate(total=0)
def counter():
    # Assume name counter is never rebound:
    counter.total += 1
    return counter.total

# class exists only to provide storage:
class _wrap(object):

    __total = 0

    def f(self):
        self.__total += 1
        return self.__total

# set module attribute to a bound method:
accum = _wrap().f

# This function calls &quot;factorial&quot;, which should be itself --
# but the same programming styles that use heavy recursion
# often have a greater willingness to rebind function names.
def factorial(n):
    return (n * factorial(n-1) if n else 1)
</pre>
<p>Proposal: Add a <tt class="docutils literal">__function__</tt> keyword which refers to the function
(or method) currently being defined (executed).  (But see open
issues.)</p>
<pre class="literal-block">
&#64;annotate(total=0)
def counter():
    # Always refers to this function obj:
    __function__.total += 1
    return __function__.total

def factorial(n):
    return (n * __function__(n-1) if n else 1)
</pre>
</div>
<div class="section" id="backwards-compatibility">
<h1><a class="toc-backref" href="#id10">Backwards Compatibility</a></h1>
<p>While a user could be using these names already, double-underscore
names ( <tt class="docutils literal">__anything__</tt> ) are explicitly reserved to the interpreter.
It is therefore acceptable to introduce special meaning to these
names within a single feature release.</p>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id11">Implementation</a></h1>
<p>Ideally, these names would be keywords treated specially by the
bytecode compiler.</p>
<p>Guido has suggested <a class="footnote-reference" href="#id3" id="id1">[1]</a> using a cell variable filled in by the
metaclass.</p>
<p>Michele Simionato has provided a prototype using bytecode hacks <a class="footnote-reference" href="#id4" id="id2">[2]</a>.
This does not require any new bytecode operators; it just
modifies the which specific sequence of existing operators gets
run.</p>
</div>
<div class="section" id="open-issues">
<h1><a class="toc-backref" href="#id12">Open Issues</a></h1>
<ul class="simple">
<li>Are <tt class="docutils literal">__module__</tt>, <tt class="docutils literal">__class__</tt>, and <tt class="docutils literal">__function__</tt> the right names?  In
particular, should the names include the word &quot;this&quot;, either as
<tt class="docutils literal">__this_module__</tt>, <tt class="docutils literal">__this_class__</tt>, and <tt class="docutils literal">__this_function__</tt>, (format
discussed on the python-3000 and python-ideas lists) or as
<tt class="docutils literal">__thismodule__</tt>, <tt class="docutils literal">__thisclass__</tt>, and <tt class="docutils literal">__thisfunction__</tt> (inspired
by, but conflicting with, current usage of super.``__thisclass__``).</li>
<li>Are all three keywords needed, or should this enhancement be
limited to a subset of the objects?  Should methods be treated
separately from other functions?</li>
</ul>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id13">References</a></h1>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Fixing super anyone?  Guido van Rossum
<a class="reference external" href="https://mail.python.org/pipermail/python-3000/2007-April/006671.html">https://mail.python.org/pipermail/python-3000/2007-April/006671.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Descriptor/Decorator challenge,  Michele Simionato
<a class="reference external" href="http://groups.google.com/group/comp.lang.python/browse_frm/thread/a6010c7494871bb1/62a2da68961caeb6?lnk=gst&amp;q=simionato+challenge&amp;rnum=1&amp;hl=en#62a2da68961caeb6">http://groups.google.com/group/comp.lang.python/browse_frm/thread/a6010c7494871bb1/62a2da68961caeb6?lnk=gst&amp;q=simionato+challenge&amp;rnum=1&amp;hl=en#62a2da68961caeb6</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id14">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

