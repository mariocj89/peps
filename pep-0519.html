<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">519</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Adding a file system path protocol</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0519.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Brett Cannon &lt;brett&#32;&#97;t&#32;python.org&gt;,
Koos Zevenhoven &lt;k7hoven&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">11-May-2016</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.6</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">11-May-2016,
12-May-2016,
13-May-2016</td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2016-May/144646.html">https://mail.python.org/pipermail/python-dev/2016-May/144646.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id14">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id15">Rationale</a></li>
<li><a class="reference internal" href="#proposal" id="id16">Proposal</a><ul>
<li><a class="reference internal" href="#protocol" id="id17">Protocol</a></li>
<li><a class="reference internal" href="#standard-library-changes" id="id18">Standard library changes</a><ul>
<li><a class="reference internal" href="#builtins" id="id19">builtins</a></li>
<li><a class="reference internal" href="#os" id="id20">os</a></li>
<li><a class="reference internal" href="#os-path" id="id21">os.path</a></li>
<li><a class="reference internal" href="#pathlib" id="id22">pathlib</a></li>
<li><a class="reference internal" href="#c-api" id="id23">C API</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility" id="id24">Backwards compatibility</a></li>
<li><a class="reference internal" href="#implementation" id="id25">Implementation</a></li>
<li><a class="reference internal" href="#rejected-ideas" id="id26">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#other-names-for-the-protocol-s-method" id="id27">Other names for the protocol's method</a></li>
<li><a class="reference internal" href="#separate-str-bytes-methods" id="id28">Separate str/bytes methods</a></li>
<li><a class="reference internal" href="#providing-a-path-attribute" id="id29">Providing a <tt class="docutils literal">path</tt> attribute</a></li>
<li><a class="reference internal" href="#have-fspath-only-return-strings" id="id30">Have <tt class="docutils literal">__fspath__()</tt> only return strings</a></li>
<li><a class="reference internal" href="#a-generic-string-encoding-mechanism" id="id31">A generic string encoding mechanism</a></li>
<li><a class="reference internal" href="#have-fspath-be-an-attribute" id="id32">Have __fspath__ be an attribute</a></li>
<li><a class="reference internal" href="#provide-specific-type-hinting-support" id="id33">Provide specific type hinting support</a></li>
<li><a class="reference internal" href="#provide-os-fspathb" id="id34">Provide <tt class="docutils literal">os.fspathb()</tt></a></li>
<li><a class="reference internal" href="#call-fspath-off-of-the-instance" id="id35">Call <tt class="docutils literal">__fspath__()</tt> off of the instance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#acknowledgements" id="id36">Acknowledgements</a></li>
<li><a class="reference internal" href="#references" id="id37">References</a></li>
<li><a class="reference internal" href="#copyright" id="id38">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id14">Abstract</a></h1>
<p>This PEP proposes a protocol for classes which represent a file system
path to be able to provide a <tt class="docutils literal">str</tt> or <tt class="docutils literal">bytes</tt> representation.
Changes to Python's standard library are also proposed to utilize this
protocol where appropriate to facilitate the use of path objects where
historically only <tt class="docutils literal">str</tt> and/or <tt class="docutils literal">bytes</tt> file system paths are
accepted. The goal is to facilitate the migration of users towards
rich path objects while providing an easy way to work with code
expecting <tt class="docutils literal">str</tt> or <tt class="docutils literal">bytes</tt>.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id15">Rationale</a></h1>
<p>Historically in Python, file system paths have been represented as
strings or bytes. This choice of representation has stemmed from C's
own decision to represent file system paths as
<tt class="docutils literal">const char *</tt> <a class="footnote-reference" href="#libc-open" id="id1">[3]</a>. While that is a totally serviceable
format to use for file system paths, it's not necessarily optimal. At
issue is the fact that while all file system paths can be represented
as strings or bytes, not all strings or bytes represent a file system
path. This can lead to issues where any e.g. string duck-types to a
file system path whether it actually represents a path or not.</p>
<p>To help elevate the representation of file system paths from their
representation as strings and bytes to a richer object representation,
the pathlib module <a class="footnote-reference" href="#id12" id="id2">[4]</a> was provisionally introduced in
Python 3.4 through <a class="reference external" href="/dev/peps/pep-0428">PEP 428</a>. While considered by some as an improvement
over strings and bytes for file system paths, it has suffered from a
lack of adoption. Typically the key issue listed for the low adoption
rate has been the lack of support in the standard library. This lack
of support required users of pathlib to manually convert path objects
to strings by calling <tt class="docutils literal">str(path)</tt> which many found error-prone.</p>
<p>One issue in converting path objects to strings comes from
the fact that the only generic way to get a string representation of
the path was to pass the object to <tt class="docutils literal">str()</tt>. This can pose a
problem when done blindly as nearly all Python objects have some
string representation whether they are a path or not, e.g.
<tt class="docutils literal">str(None)</tt> will give a result that
<tt class="docutils literal">builtins.open()</tt> <a class="footnote-reference" href="#builtins-open" id="id3">[5]</a> will happily use to create a new
file.</p>
<p>Exacerbating this whole situation is the
<tt class="docutils literal">DirEntry</tt> object <a class="footnote-reference" href="#os-direntry" id="id4">[8]</a>. While path objects have a
representation that can be extracted using <tt class="docutils literal">str()</tt>, <tt class="docutils literal">DirEntry</tt>
objects expose a <tt class="docutils literal">path</tt> attribute instead. Having no common
interface between path objects, <tt class="docutils literal">DirEntry</tt>, and any other
third-party path library has become an issue. A solution that allows
any path-representing object to declare that it is a path and a way
to extract a low-level representation that all path objects could
support is desired.</p>
<p>This PEP then proposes to introduce a new protocol to be followed by
objects which represent file system paths. Providing a protocol allows
for explicit signaling of what objects represent file system paths as
well as a way to extract a lower-level representation that can be used
with older APIs which only support strings or bytes.</p>
<p>Discussions regarding path objects that led to this PEP can be found
in multiple threads on the python-ideas mailing list archive
<a class="footnote-reference" href="#python-ideas-archive" id="id5">[1]</a> for the months of March and April 2016 and on
the python-dev mailing list archives <a class="footnote-reference" href="#python-dev-archive" id="id6">[2]</a> during
April 2016.</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id16">Proposal</a></h1>
<p>This proposal is split into two parts. One part is the proposal of a
protocol for objects to declare and provide support for exposing a
file system path representation. The other part deals with changes to
Python's standard library to support the new protocol. These changes
will also lead to the pathlib module dropping its provisional status.</p>
<div class="section" id="protocol">
<h2><a class="toc-backref" href="#id17">Protocol</a></h2>
<p>The following abstract base class defines the protocol for an object
to be considered a path object:</p>
<pre class="literal-block">
import abc
import typing as t


class PathLike(abc.ABC):

    &quot;&quot;&quot;Abstract base class for implementing the file system path protocol.&quot;&quot;&quot;

    &#64;abc.abstractmethod
    def __fspath__(self) -&gt; t.Union[str, bytes]:
        &quot;&quot;&quot;Return the file system path representation of the object.&quot;&quot;&quot;
        raise NotImplementedError
</pre>
<p>Objects representing file system paths will implement the
<tt class="docutils literal">__fspath__()</tt> method which will return the <tt class="docutils literal">str</tt> or <tt class="docutils literal">bytes</tt>
representation of the path. The <tt class="docutils literal">str</tt> representation is the
preferred low-level path representation as it is human-readable and
what people historically represent paths as.</p>
</div>
<div class="section" id="standard-library-changes">
<h2><a class="toc-backref" href="#id18">Standard library changes</a></h2>
<p>It is expected that most APIs in Python's standard library that
currently accept a file system path will be updated appropriately to
accept path objects (whether that requires code or simply an update
to documentation will vary). The modules mentioned below, though,
deserve specific details as they have either fundamental changes that
empower the ability to use path objects, or entail additions/removal
of APIs.</p>
<div class="section" id="builtins">
<h3><a class="toc-backref" href="#id19">builtins</a></h3>
<p><tt class="docutils literal">open()</tt> <a class="footnote-reference" href="#builtins-open" id="id7">[5]</a> will be updated to accept path objects as
well as continue to accept <tt class="docutils literal">str</tt> and <tt class="docutils literal">bytes</tt>.</p>
</div>
<div class="section" id="os">
<h3><a class="toc-backref" href="#id20">os</a></h3>
<p>The <tt class="docutils literal">fspath()</tt> function will be added with the following semantics:</p>
<pre class="literal-block">
import typing as t


def fspath(path: t.Union[PathLike, str, bytes]) -&gt; t.Union[str, bytes]:
    &quot;&quot;&quot;Return the string representation of the path.

    If str or bytes is passed in, it is returned unchanged. If __fspath__()
    returns something other than str or bytes then TypeError is raised. If
    this function is given something that is not str, bytes, or os.PathLike
    then TypeError is raised.
    &quot;&quot;&quot;
    if isinstance(path, (str, bytes)):
        return path

    # Work from the object's type to match method resolution of other magic
    # methods.
    path_type = type(path)
    try:
        path = path_type.__fspath__(path)
    except AttributeError:
        if hasattr(path_type, '__fspath__'):
            raise
    else:
        if isinstance(path, (str, bytes)):
            return path
        else:
            raise TypeError(&quot;expected __fspath__() to return str or bytes, &quot;
                            &quot;not &quot; + type(path).__name__)

    raise TypeError(&quot;expected str, bytes or os.PathLike object, not &quot;
                    + path_type.__name__)
</pre>
<p>The <tt class="docutils literal">os.fsencode()</tt> <a class="footnote-reference" href="#os-fsencode" id="id8">[6]</a> and
<tt class="docutils literal">os.fsdecode()</tt> <a class="footnote-reference" href="#os-fsdecode" id="id9">[7]</a> functions will be updated to accept
path objects. As both functions coerce their arguments to
<tt class="docutils literal">bytes</tt> and <tt class="docutils literal">str</tt>, respectively, they will be updated to call
<tt class="docutils literal">__fspath__()</tt> if present to convert the path object to a <tt class="docutils literal">str</tt> or
<tt class="docutils literal">bytes</tt> representation, and then perform their appropriate
coercion operations as if the return value from <tt class="docutils literal">__fspath__()</tt> had
been the original argument to the coercion function in question.</p>
<p>The addition of <tt class="docutils literal">os.fspath()</tt>, the updates to
<tt class="docutils literal">os.fsencode()</tt>/<tt class="docutils literal">os.fsdecode()</tt>, and the current semantics of
<tt class="docutils literal">pathlib.PurePath</tt> provide the semantics necessary to
get the path representation one prefers. For a path object,
<tt class="docutils literal">pathlib.PurePath</tt>/<tt class="docutils literal">Path</tt> can be used. To obtain the <tt class="docutils literal">str</tt> or
<tt class="docutils literal">bytes</tt> representation without any coersion, then <tt class="docutils literal">os.fspath()</tt>
can be used. If a <tt class="docutils literal">str</tt> is desired and the encoding of <tt class="docutils literal">bytes</tt>
should be assumed to be the default file system encoding, then
<tt class="docutils literal">os.fsdecode()</tt> should be used. If a <tt class="docutils literal">bytes</tt> representation is
desired and any strings should be encoded using the default file
system encoding, then <tt class="docutils literal">os.fsencode()</tt> is used. This PEP recommends
using path objects when possible and falling back to string paths as
necessary and using <tt class="docutils literal">bytes</tt> as a last resort.</p>
<p>Another way to view this is as a hierarchy of file system path
representations (highest- to lowest-level): path → str → bytes. The
functions and classes under discussion can all accept objects on the
same level of the hierarchy, but they vary in whether they promote or
demote objects to another level. The <tt class="docutils literal">pathlib.PurePath</tt> class can
promote a <tt class="docutils literal">str</tt> to a path object. The <tt class="docutils literal">os.fspath()</tt> function can
demote a path object to a <tt class="docutils literal">str</tt> or <tt class="docutils literal">bytes</tt> instance, depending
on what <tt class="docutils literal">__fspath__()</tt> returns.
The <tt class="docutils literal">os.fsdecode()</tt> function will demote a path object to
a string or promote a <tt class="docutils literal">bytes</tt> object to a <tt class="docutils literal">str</tt>. The
<tt class="docutils literal">os.fsencode()</tt> function will demote a path or string object to
<tt class="docutils literal">bytes</tt>. There is no function that provides a way to demote a path
object directly to <tt class="docutils literal">bytes</tt> while bypassing string demotion.</p>
<p>The <tt class="docutils literal">DirEntry</tt> object <a class="footnote-reference" href="#os-direntry" id="id10">[8]</a> will gain an <tt class="docutils literal">__fspath__()</tt>
method. It will return the same value as currently found on the
<tt class="docutils literal">path</tt> attribute of <tt class="docutils literal">DirEntry</tt> instances.</p>
<p>The <a class="reference internal" href="#protocol">Protocol</a> ABC will be added to the <tt class="docutils literal">os</tt> module under the name
<tt class="docutils literal">os.PathLike</tt>.</p>
</div>
<div class="section" id="os-path">
<h3><a class="toc-backref" href="#id21">os.path</a></h3>
<p>The various path-manipulation functions of <tt class="docutils literal">os.path</tt> <a class="footnote-reference" href="#id13" id="id11">[9]</a>
will be updated to accept path objects. For polymorphic functions that
accept both bytes and strings, they will be updated to simply use
<tt class="docutils literal">os.fspath()</tt>.</p>
<p>During the discussions leading up to this PEP it was suggested that
<tt class="docutils literal">os.path</tt> not be updated using an &quot;explicit is better than implicit&quot;
argument. The thinking was that since <tt class="docutils literal">__fspath__()</tt> is polymorphic
itself it may be better to have code working with <tt class="docutils literal">os.path</tt> extract
the path representation from path objects explicitly. There is also
the consideration that adding support this deep into the low-level OS
APIs will lead to code magically supporting path objects without
requiring any documentation updated, leading to potential complaints
when it doesn't work, unbeknownst to the project author.</p>
<p>But it is the view of this PEP that &quot;practicality beats purity&quot; in
this instance. To help facilitate the transition to supporting path
objects, it is better to make the transition as easy as possible than
to worry about unexpected/undocumented duck typing support for
path objects by projects.</p>
<p>There has also been the suggestion that <tt class="docutils literal">os.path</tt> functions could be
used in a tight loop and the overhead of checking or calling
<tt class="docutils literal">__fspath__()</tt> would be too costly. In this scenario only
path-consuming APIs would be directly updated and path-manipulating
APIs like the ones in <tt class="docutils literal">os.path</tt> would go unmodified. This would
require library authors to update their code to support path objects
if they performed any path manipulations, but if the library code
passed the path straight through then the library wouldn't need to be
updated. It is the view of this PEP and Guido, though, that this is an
unnecessary worry and that performance will still be acceptable.</p>
</div>
<div class="section" id="pathlib">
<h3><a class="toc-backref" href="#id22">pathlib</a></h3>
<p>The constructor for <tt class="docutils literal">pathlib.PurePath</tt> and <tt class="docutils literal">pathlib.Path</tt> will be
updated to accept <tt class="docutils literal">PathLike</tt> objects. Both <tt class="docutils literal">PurePath</tt> and <tt class="docutils literal">Path</tt>
will continue to not accept <tt class="docutils literal">bytes</tt> path representations, and so if
<tt class="docutils literal">__fspath__()</tt> returns <tt class="docutils literal">bytes</tt> it will raise an exception.</p>
<p>The <tt class="docutils literal">path</tt> attribute will be removed as this PEP makes it
redundant (it has not been included in any released version of Python
and so is not a backwards-compatibility concern).</p>
</div>
<div class="section" id="c-api">
<h3><a class="toc-backref" href="#id23">C API</a></h3>
<p>The C API will gain an equivalent function to <tt class="docutils literal">os.fspath()</tt>:</p>
<pre class="literal-block">
/*
    Return the file system path representation of the object.

    If the object is str or bytes, then allow it to pass through with
    an incremented refcount. If the object defines __fspath__(), then
    return the result of that method. All other types raise a TypeError.
*/
PyObject *
PyOS_FSPath(PyObject *path)
{
    _Py_IDENTIFIER(__fspath__);
    PyObject *func = NULL;
    PyObject *path_repr = NULL;

    if (PyUnicode_Check(path) || PyBytes_Check(path)) {
        Py_INCREF(path);
        return path;
    }

    func = _PyObject_LookupSpecial(path, &amp;PyId___fspath__);
    if (NULL == func) {
        return PyErr_Format(PyExc_TypeError,
                            &quot;expected str, bytes or os.PathLike object, &quot;
                            &quot;not %S&quot;,
                            path-&gt;ob_type);
    }

    path_repr = PyObject_CallFunctionObjArgs(func, NULL);
    Py_DECREF(func);
    if (!PyUnicode_Check(path_repr) &amp;&amp; !PyBytes_Check(path_repr)) {
        Py_DECREF(path_repr);
        return PyErr_Format(PyExc_TypeError,
                            &quot;expected __fspath__() to return str or bytes, &quot;
                            &quot;not %S&quot;,
                            path_repr-&gt;ob_type);
    }

    return path_repr;
}
</pre>
</div>
</div>
</div>
<div class="section" id="backwards-compatibility">
<h1><a class="toc-backref" href="#id24">Backwards compatibility</a></h1>
<p>There are no explicit backwards-compatibility concerns. Unless an
object incidentally already defines a <tt class="docutils literal">__fspath__()</tt> method there is
no reason to expect the pre-existing code to break or expect to have
its semantics implicitly changed.</p>
<p>Libraries wishing to support path objects and a version of Python
prior to Python 3.6 and the existence of <tt class="docutils literal">os.fspath()</tt> can use the
idiom of
<tt class="docutils literal">path.__fspath__() if hasattr(path, &quot;__fspath__&quot;) else path</tt>.</p>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id25">Implementation</a></h1>
<p>This is the task list for what this PEP proposes to be changed in
Python 3.6:</p>
<ol class="arabic simple">
<li>Remove the <tt class="docutils literal">path</tt> attribute from pathlib
(<a class="reference external" href="http://bugs.python.org/issue22570">done</a>)</li>
<li>Remove the provisional status of pathlib
(<a class="reference external" href="https://hg.python.org/lookup/a5a013ca5687">done</a>)</li>
<li>Add <tt class="docutils literal">os.PathLike</tt>
(<a class="reference external" href="https://hg.python.org/lookup/e672cf63d08a">code</a> and
<a class="reference external" href="http://hg.python.org/lookup/6239673d5e1d">docs</a> done)</li>
<li>Add <tt class="docutils literal">PyOS_FSPath()</tt>
(<a class="reference external" href="https://hg.python.org/lookup/780cbe18082e">code</a> and
<a class="reference external" href="http://hg.python.org/lookup/cec1f00c538d">docs</a> done)</li>
<li>Add <tt class="docutils literal">os.fspath()</tt>
(<a class="reference external" href="https://hg.python.org/lookup/780cbe18082e">done &lt;done</a>)</li>
<li>Update <tt class="docutils literal">os.fsencode()</tt>
(<a class="reference external" href="https://hg.python.org/lookup/00991aa5fdb5">done</a>)</li>
<li>Update <tt class="docutils literal">os.fsdecode()</tt>
(<a class="reference external" href="https://hg.python.org/lookup/00991aa5fdb5">done</a>)</li>
<li>Update <tt class="docutils literal">pathlib.PurePath</tt> and <tt class="docutils literal">pathlib.Path</tt>
(<a class="reference external" href="https://hg.python.org/lookup/a5a013ca5687">done</a>)<ol class="arabic">
<li>Add <tt class="docutils literal">__fspath__()</tt></li>
<li>Add <tt class="docutils literal">os.PathLike</tt> support to the constructors</li>
</ol>
</li>
<li>Add <tt class="docutils literal">__fspath__()</tt> to <tt class="docutils literal">DirEntry</tt>
(<a class="reference external" href="https://hg.python.org/lookup/5a62d682636e">done</a>)</li>
<li>Update <tt class="docutils literal">builtins.open()</tt>
(<a class="reference external" href="https://hg.python.org/lookup/254125a265d2">done</a>)</li>
<li>Update <tt class="docutils literal">os.path</tt>
(<a class="reference external" href="https://hg.python.org/cpython/rev/b64f83d6ff24">done</a>)</li>
<li>Add a <a class="reference external" href="https://docs.python.org/3.6/glossary.html">glossary</a> entry for &quot;path-like&quot;
(<a class="reference external" href="https://hg.python.org/lookup/9c57178f13dc">done</a>)</li>
<li>Update <a class="reference external" href="https://docs.python.org/3.6/whatsnew/3.6.html">&quot;What's New&quot;</a>
(<a class="reference external" href="https://hg.python.org/cpython/rev/95361959d451">done</a>)</li>
</ol>
</div>
<div class="section" id="rejected-ideas">
<h1><a class="toc-backref" href="#id26">Rejected Ideas</a></h1>
<div class="section" id="other-names-for-the-protocol-s-method">
<h2><a class="toc-backref" href="#id27">Other names for the protocol's method</a></h2>
<p>Various names were proposed during discussions leading to this PEP,
including <tt class="docutils literal">__path__</tt>, <tt class="docutils literal">__pathname__</tt>, and <tt class="docutils literal">__fspathname__</tt>. In
the end people seemed to gravitate towards <tt class="docutils literal">__fspath__</tt> for being
unambiguous without being unnecessarily long.</p>
</div>
<div class="section" id="separate-str-bytes-methods">
<h2><a class="toc-backref" href="#id28">Separate str/bytes methods</a></h2>
<p>At one point it was suggested that <tt class="docutils literal">__fspath__()</tt> only return
strings and another method named <tt class="docutils literal">__fspathb__()</tt> be introduced to
return bytes. The thinking is that by making <tt class="docutils literal">__fspath__()</tt> not be
polymorphic it could make dealing with the potential string or bytes
representations easier. But the general consensus was that returning
bytes will more than likely be rare and that the various functions in
the os module are the better abstraction to promote over direct
calls to <tt class="docutils literal">__fspath__()</tt>.</p>
</div>
<div class="section" id="providing-a-path-attribute">
<h2><a class="toc-backref" href="#id29">Providing a <tt class="docutils literal">path</tt> attribute</a></h2>
<p>To help deal with the issue of <tt class="docutils literal">pathlib.PurePath</tt> not inheriting
from <tt class="docutils literal">str</tt>, originally it was proposed to introduce a <tt class="docutils literal">path</tt>
attribute to mirror what <tt class="docutils literal">os.DirEntry</tt> provides. In the end,
though, it was determined that a protocol would provide the same
result while not directly exposing an API that most people will never
need to interact with directly.</p>
</div>
<div class="section" id="have-fspath-only-return-strings">
<h2><a class="toc-backref" href="#id30">Have <tt class="docutils literal">__fspath__()</tt> only return strings</a></h2>
<p>Much of the discussion that led to this PEP revolved around whether
<tt class="docutils literal">__fspath__()</tt> should be polymorphic and return <tt class="docutils literal">bytes</tt> as well as
<tt class="docutils literal">str</tt> or only return <tt class="docutils literal">str</tt>. The general sentiment for this view
was that <tt class="docutils literal">bytes</tt> are difficult to work with due to their
inherent lack of information about their encoding and <a class="reference external" href="/dev/peps/pep-0383">PEP 383</a> makes
it possible to represent all file system paths using <tt class="docutils literal">str</tt> with the
<tt class="docutils literal">surrogateescape</tt> handler. Thus, it would be better to forcibly
promote the use of <tt class="docutils literal">str</tt> as the low-level path representation for
high-level path objects.</p>
<p>In the end, it was decided that using <tt class="docutils literal">bytes</tt> to represent paths is
simply not going to go away and thus they should be supported to some
degree. The hope is that people will gravitate towards path objects
like pathlib and that will move people away from operating directly
with <tt class="docutils literal">bytes</tt>.</p>
</div>
<div class="section" id="a-generic-string-encoding-mechanism">
<h2><a class="toc-backref" href="#id31">A generic string encoding mechanism</a></h2>
<p>At one point there was a discussion of developing a generic mechanism
to extract a string representation of an object that had semantic
meaning (<tt class="docutils literal">__str__()</tt> does not necessarily return anything of
semantic significance beyond what may be helpful for debugging). In
the end, it was deemed to lack a motivating need beyond the one this
PEP is trying to solve in a specific fashion.</p>
</div>
<div class="section" id="have-fspath-be-an-attribute">
<h2><a class="toc-backref" href="#id32">Have __fspath__ be an attribute</a></h2>
<p>It was briefly considered to have <tt class="docutils literal">__fspath__</tt> be an attribute
instead of a method. This was rejected for two reasons. One,
historically protocols have been implemented as &quot;magic methods&quot; and
not &quot;magic methods and attributes&quot;. Two, there is no guarantee that
the lower-level representation of a path object will be pre-computed,
potentially misleading users that there was no expensive computation
behind the scenes in case the attribute was implemented as a property.</p>
<p>This also indirectly ties into the idea of introducing a <tt class="docutils literal">path</tt>
attribute to accomplish the same thing. This idea has an added issue,
though, of accidentally having any object with a <tt class="docutils literal">path</tt> attribute
meet the protocol's duck typing. Introducing a new magic method for
the protocol helpfully avoids any accidental opting into the protocol.</p>
</div>
<div class="section" id="provide-specific-type-hinting-support">
<h2><a class="toc-backref" href="#id33">Provide specific type hinting support</a></h2>
<p>There was some consideration to provdinga generic <tt class="docutils literal">typing.PathLike</tt>
class which would allow for e.g. <tt class="docutils literal">typing.PathLike[str]</tt> to specify
a type hint for a path object which returned a string representation.
While potentially beneficial, the usefulness was deemed too small to
bother adding the type hint class.</p>
<p>This also removed any desire to have a class in the <tt class="docutils literal">typing</tt> module
which represented the union of all acceptable path-representing types
as that can be represented with
<tt class="docutils literal">typing.Union[str, bytes, os.PathLike]</tt> easily enough and the hope
is users will slowly gravitate to path objects only.</p>
</div>
<div class="section" id="provide-os-fspathb">
<h2><a class="toc-backref" href="#id34">Provide <tt class="docutils literal">os.fspathb()</tt></a></h2>
<p>It was suggested that to mirror the structure of e.g.
<tt class="docutils literal">os.getcwd()</tt>/<tt class="docutils literal">os.getcwdb()</tt>, that <tt class="docutils literal">os.fspath()</tt> only return
<tt class="docutils literal">str</tt> and that another function named <tt class="docutils literal">os.fspathb()</tt> be
introduced that only returned <tt class="docutils literal">bytes</tt>. This was rejected as the
purposes of the <tt class="docutils literal">*b()</tt> functions are tied to querying the file
system where there is a need to get the raw bytes back. As this PEP
does not work directly with data on a file system (but which <em>may</em>
be), the view was taken this distinction is unnecessary. It's also
believed that the need for only bytes will not be common enough to
need to support in such a specific manner as <tt class="docutils literal">os.fsencode()</tt> will
provide similar functionality.</p>
</div>
<div class="section" id="call-fspath-off-of-the-instance">
<h2><a class="toc-backref" href="#id35">Call <tt class="docutils literal">__fspath__()</tt> off of the instance</a></h2>
<p>An earlier draft of this PEP had <tt class="docutils literal">os.fspath()</tt> calling
<tt class="docutils literal">path.__fspath__()</tt> instead of <tt class="docutils literal"><span class="pre">type(path).__fspath__(path)</span></tt>. The
changed to be consistent with how other magic methods in Python are
resolved.</p>
</div>
</div>
<div class="section" id="acknowledgements">
<h1><a class="toc-backref" href="#id36">Acknowledgements</a></h1>
<p>Thanks to everyone who participated in the various discussions related
to this PEP that spanned both python-ideas and python-dev. Special
thanks to Stephen Turnbull for direct feedback on early drafts of this
PEP. More special thanks to Koos Zevenhoven and Ethan Furman for not
only feedback on early drafts of this PEP but also helping to drive
the overall discussion on this topic across the two mailing lists.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id37">References</a></h1>
<table class="docutils footnote" frame="void" id="python-ideas-archive" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[1]</a></td><td>The python-ideas mailing list archive
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/">https://mail.python.org/pipermail/python-ideas/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="python-dev-archive" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[2]</a></td><td>The python-dev mailing list archive
(<a class="reference external" href="https://mail.python.org/pipermail/python-dev/">https://mail.python.org/pipermail/python-dev/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="libc-open" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[3]</a></td><td><tt class="docutils literal">open()</tt> documention for the C standard library
(<a class="reference external" href="http://www.gnu.org/software/libc/manual/html_node/Opening-and-Closing-Files.html">http://www.gnu.org/software/libc/manual/html_node/Opening-and-Closing-Files.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[4]</a></td><td>The <tt class="docutils literal">pathlib</tt> module
(<a class="reference external" href="https://docs.python.org/3/library/pathlib.html#module-pathlib">https://docs.python.org/3/library/pathlib.html#module-pathlib</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="builtins-open" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id7">2</a>)</em> The <tt class="docutils literal">builtins.open()</tt> function
(<a class="reference external" href="https://docs.python.org/3/library/functions.html#open">https://docs.python.org/3/library/functions.html#open</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="os-fsencode" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[6]</a></td><td>The <tt class="docutils literal">os.fsencode()</tt> function
(<a class="reference external" href="https://docs.python.org/3/library/os.html#os.fsencode">https://docs.python.org/3/library/os.html#os.fsencode</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="os-fsdecode" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[7]</a></td><td>The <tt class="docutils literal">os.fsdecode()</tt> function
(<a class="reference external" href="https://docs.python.org/3/library/os.html#os.fsdecode">https://docs.python.org/3/library/os.html#os.fsdecode</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="os-direntry" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[8]</td><td><em>(<a class="fn-backref" href="#id4">1</a>, <a class="fn-backref" href="#id10">2</a>)</em> The <tt class="docutils literal">os.DirEntry</tt> class
(<a class="reference external" href="https://docs.python.org/3/library/os.html#os.DirEntry">https://docs.python.org/3/library/os.html#os.DirEntry</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[9]</a></td><td>The <tt class="docutils literal">os.path</tt> module
(<a class="reference external" href="https://docs.python.org/3/library/os.path.html#module-os.path">https://docs.python.org/3/library/os.path.html#module-os.path</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id38">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

