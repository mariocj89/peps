<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">285</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Adding a bool type</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0285.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">guido&#32;&#97;t&#32;python.org (Guido van Rossum)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">8-Mar-2002</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.3</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">8-Mar-2002, 30-Mar-2002, 3-Apr-2002</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id2">Abstract</a></li>
<li><a class="reference internal" href="#review" id="id3">Review</a></li>
<li><a class="reference internal" href="#rationale" id="id4">Rationale</a></li>
<li><a class="reference internal" href="#specification" id="id5">Specification</a></li>
<li><a class="reference internal" href="#c-api" id="id6">C API</a></li>
<li><a class="reference internal" href="#clarification" id="id7">Clarification</a></li>
<li><a class="reference internal" href="#compatibility" id="id8">Compatibility</a></li>
<li><a class="reference internal" href="#resolved-issues" id="id9">Resolved Issues</a></li>
<li><a class="reference internal" href="#implementation" id="id10">Implementation</a></li>
<li><a class="reference internal" href="#copyright" id="id11">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id2">Abstract</a></h1>
<p>This PEP proposes the introduction of a new built-in type, bool,
with two constants, <tt class="docutils literal">False</tt> and <tt class="docutils literal">True</tt>.  The bool type would be a
straightforward subtype (in C) of the int type, and the values
<tt class="docutils literal">False</tt> and <tt class="docutils literal">True</tt> would behave like 0 and 1 in most respects (for
example, <tt class="docutils literal"><span class="pre">False==0</span></tt> and <tt class="docutils literal"><span class="pre">True==1</span></tt> would be true) except <tt class="docutils literal">repr()</tt> and
<tt class="docutils literal">str()</tt>.  All built-in operations that conceptually return a Boolean
result will be changed to return <tt class="docutils literal">False</tt> or <tt class="docutils literal">True</tt> instead of 0 or 1;
for example, comparisons, the &quot;not&quot; operator, and predicates like
<tt class="docutils literal">isinstance()</tt>.</p>
</div>
<div class="section" id="review">
<h1><a class="toc-backref" href="#id3">Review</a></h1>
<p>I've collected enough feedback to last me a lifetime, so I declare
the review period officially OVER.  I had Chinese food today; my
fortune cookie said &quot;Strong and bitter words indicate a weak
cause.&quot;  It reminded me of some of the posts against this
PEP... :-)</p>
<p>Anyway, here are my BDFL pronouncements.  (Executive summary: I'm
not changing a thing; all variants are rejected.)</p>
<ol class="arabic">
<li><p class="first">Should this PEP be accepted?</p>
<p>=&gt; Yes.</p>
<p>There have been many arguments against the PEP.  Many of them
were based on misunderstandings.  I've tried to clarify some of
the most common misunderstandings below in the main text of the
PEP.  The only issue that weighs at all for me is the tendency
of newbies to write &quot;if x == True&quot; where &quot;if x&quot; would suffice.
More about that below too.  I think this is not a sufficient
reason to reject the PEP.</p>
</li>
<li><p class="first">Should <tt class="docutils literal">str(True)</tt> return &quot;True&quot; or &quot;1&quot;?  &quot;1&quot; might reduce
backwards compatibility problems, but looks strange.
(<tt class="docutils literal">repr(True)</tt> would always return &quot;True&quot;.)</p>
<p>=&gt; &quot;True&quot;.</p>
<p>Almost all reviewers agree with this.</p>
</li>
<li><p class="first">Should the constants be called 'True' and 'False' (similar to
None) or 'true' and 'false' (as in C++, Java and C99)?</p>
<p>=&gt; True and False.</p>
<p>Most reviewers agree that consistency within Python is more
important than consistency with other languages.</p>
</li>
<li><p class="first">Should we strive to eliminate non-Boolean operations on bools
in the future, through suitable warnings, so that for example
True+1 would eventually (in Python 3000) be illegal?</p>
<p>=&gt; No.</p>
<p>There's a small but vocal minority that would prefer to see
&quot;textbook&quot; bools that don't support arithmetic operations at
all, but most reviewers agree with me that bools should always
allow arithmetic operations.</p>
</li>
<li><p class="first">Should <tt class="docutils literal">operator.truth(x)</tt> return an int or a bool?</p>
<p>=&gt; bool.</p>
<p>Tim Peters believes it should return an int, but almost all
other reviewers agree that it should return a bool.  My
rationale: <tt class="docutils literal">operator.truth()</tt> exists to force a Boolean context
on its argument (it calls the C API <tt class="docutils literal"><span class="pre">PyObject_IsTrue())</span></tt>.
Whether the outcome is reported as int or bool is secondary; if
bool exists there's no reason not to use it.  (Under the PEP,
<tt class="docutils literal">operator.truth()</tt> now becomes an alias for <tt class="docutils literal">bool()</tt>; that's fine.)</p>
</li>
<li><p class="first">Should bool inherit from int?</p>
<p>=&gt; Yes.</p>
<p>In an ideal world, bool might be better implemented as a
separate integer type that knows how to perform mixed-mode
arithmetic.  However, inheriting bool from int eases the
implementation enormously (in part since all C code that calls
<tt class="docutils literal">PyInt_Check()</tt> will continue to work -- this returns true for
subclasses of int).  Also, I believe this is right in terms of
substitutability: code that requires an int can be fed a bool
and it will behave the same as 0 or 1.  Code that requires a
bool may not work when it is given an int; for example, 3 &amp; 4
is 0, but both 3 and 4 are true when considered as truth
values.</p>
</li>
<li><p class="first">Should the name 'bool' be changed?</p>
<p>=&gt; No.</p>
<p>Some reviewers have argued for boolean instead of bool, because
this would be easier to understand (novices may have heard of
Boolean algebra but may not make the connection with bool) or
because they hate abbreviations.  My take: Python uses
abbreviations judiciously (like 'def', 'int', 'dict') and I
don't think these are a burden to understanding.  To a newbie,
it doesn't matter whether it's called a waffle or a bool; it's
a new word, and they learn quickly what it means.</p>
<p>One reviewer has argued to make the name 'truth'.  I find this
an unattractive name, and would actually prefer to reserve this
term (in documentation) for the more abstract concept of truth
values that already exists in Python.  For example: &quot;when a
container is interpreted as a truth value, an empty container
is considered false and a non-empty one is considered true.&quot;</p>
</li>
<li><p class="first">Should we strive to require that Boolean operations (like &quot;if&quot;,
&quot;and&quot;, &quot;not&quot;) have a bool as an argument in the future, so that
for example &quot;if []:&quot; would become illegal and would have to be
written as &quot;if bool([]):&quot; ???</p>
<p>=&gt; No!!!</p>
<p>Some people believe that this is how a language with a textbook
Boolean type should behave.  Because it was brought up, others
have worried that I might agree with this position.  Let me
make my position on this quite clear.  This is not part of the
PEP's motivation and I don't intend to make this change.  (See
also the section &quot;Clarification&quot; below.)</p>
</li>
</ol>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id4">Rationale</a></h1>
<p>Most languages eventually grow a Boolean type; even C99 (the new
and improved C standard, not yet widely adopted) has one.</p>
<p>Many programmers apparently feel the need for a Boolean type; most
Python documentation contains a bit of an apology for the absence
of a Boolean type.  I've seen lots of modules that defined
constants &quot;False=0&quot; and &quot;True=1&quot; (or similar) at the top and used
those.  The problem with this is that everybody does it
differently.  For example, should you use &quot;FALSE&quot;, &quot;false&quot;,
&quot;False&quot;, &quot;F&quot; or even &quot;f&quot;?  And should false be the value zero or
None, or perhaps a truth value of a different type that will print
as &quot;true&quot; or &quot;false&quot;?  Adding a standard bool type to the language
resolves those issues.</p>
<p>Some external libraries (like databases and RPC packages) need to
be able to distinguish between Boolean and integral values, and
while it's usually possible to craft a solution, it would be
easier if the language offered a standard Boolean type.  This also
applies to Jython: some Java classes have separately overloaded
methods or constructors for int and boolean arguments.  The bool
type can be used to select the boolean variant.  (The same is
apparently the case for some COM interfaces.)</p>
<p>The standard bool type can also serve as a way to force a value to
be interpreted as a Boolean, which can be used to normalize
Boolean values.  When a Boolean value needs to be normalized to
one of two values, <tt class="docutils literal">bool(x)</tt> is much clearer than &quot;not not x&quot; and
much more concise than</p>
<pre class="literal-block">
if x:
    return 1
else:
    return 0
</pre>
<p>Here are some arguments derived from teaching Python.  When
showing people comparison operators etc. in the interactive shell,
I think this is a bit ugly:</p>
<pre class="literal-block">
&gt;&gt;&gt; a = 13
&gt;&gt;&gt; b = 12
&gt;&gt;&gt; a &gt; b
1
&gt;&gt;&gt;
</pre>
<p>If this was:</p>
<pre class="literal-block">
&gt;&gt;&gt; a &gt; b
True
&gt;&gt;&gt;
</pre>
<p>it would require a millisecond less thinking each time a 0 or 1
was printed.</p>
<p>There's also the issue (which I've seen baffling even experienced
Pythonistas who had been away from the language for a while) that
if you see:</p>
<pre class="literal-block">
&gt;&gt;&gt; cmp(a, b)
1
&gt;&gt;&gt; cmp(a, a)
0
&gt;&gt;&gt;
</pre>
<p>you might be tempted to believe that <tt class="docutils literal">cmp()</tt> also returned a truth
value, whereas in reality it can return three different values
<tt class="docutils literal"><span class="pre">(-1,</span> 0, 1)</tt>.  If ints were not (normally) used to represent
Booleans results, this would stand out much more clearly as
something completely different.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id5">Specification</a></h1>
<p>The following Python code specifies most of the properties of the
new type:</p>
<pre class="literal-block">
class bool(int):

    def __new__(cls, val=0):
        # This constructor always returns an existing instance
        if val:
            return True
        else:
            return False

    def __repr__(self):
        if self:
            return &quot;True&quot;
        else:
            return &quot;False&quot;

    __str__ = __repr__

    def __and__(self, other):
        if isinstance(other, bool):
            return bool(int(self) &amp; int(other))
        else:
            return int.__and__(self, other)

    __rand__ = __and__

    def __or__(self, other):
        if isinstance(other, bool):
            return bool(int(self) | int(other))
        else:
            return int.__or__(self, other)

    __ror__ = __or__

    def __xor__(self, other):
        if isinstance(other, bool):
            return bool(int(self) ^ int(other))
        else:
            return int.__xor__(self, other)

    __rxor__ = __xor__

# Bootstrap truth values through sheer willpower
False = int.__new__(bool, 0)
True = int.__new__(bool, 1)
</pre>
<p>The values <tt class="docutils literal">False</tt> and <tt class="docutils literal">True</tt> will be singletons, like None.  Because
the type has two values, perhaps these should be called
&quot;doubletons&quot;?  The real implementation will not allow other
instances of bool to be created.</p>
<p><tt class="docutils literal">True</tt> and <tt class="docutils literal">False</tt> will properly round-trip through pickling and
marshalling; for example <tt class="docutils literal">pickle.loads(pickle.dumps(True))</tt> will
return <tt class="docutils literal">True</tt>, and so will <tt class="docutils literal">marshal.loads(marshal.dumps(True))</tt>.</p>
<p>All built-in operations that are defined to return a Boolean
result will be changed to return <tt class="docutils literal">False</tt> or <tt class="docutils literal">True</tt> instead of 0 or 1.
In particular, this affects comparisons (<tt class="docutils literal">&lt;</tt>, <tt class="docutils literal">&lt;=</tt>, <tt class="docutils literal">==</tt>, <tt class="docutils literal">!=</tt>,
<tt class="docutils literal">&gt;</tt>, <tt class="docutils literal">&gt;=</tt>, is, is not, in, not in), the unary operator 'not', the built-in
functions <tt class="docutils literal">callable()</tt>, <tt class="docutils literal">hasattr()</tt>, <tt class="docutils literal">isinstance()</tt> and <tt class="docutils literal">issubclass()</tt>,
the dict method <tt class="docutils literal">has_key()</tt>, the string and unicode methods
<tt class="docutils literal">endswith()</tt>, <tt class="docutils literal">isalnum()</tt>, <tt class="docutils literal">isalpha()</tt>, <tt class="docutils literal">isdigit()</tt>, <tt class="docutils literal">islower()</tt>, <tt class="docutils literal">isspace()</tt>,
<tt class="docutils literal">istitle()</tt>, <tt class="docutils literal">isupper()</tt>, and <tt class="docutils literal">startswith()</tt>, the unicode methods
<tt class="docutils literal">isdecimal()</tt> and <tt class="docutils literal">isnumeric()</tt>, and the 'closed' attribute of file
objects.  The predicates in the operator module are also changed
to return a bool, including <tt class="docutils literal">operator.truth()</tt>.</p>
<p>Because bool inherits from int, True+1 is valid and equals 2, and
so on.  This is important for backwards compatibility: because
comparisons and so on currently return integer values, there's no
way of telling what uses existing applications make of these
values.</p>
<p>It is expected that over time, the standard library will be
updated to use <tt class="docutils literal">False</tt> and <tt class="docutils literal">True</tt> when appropriate (but not to require
a bool argument type where previous an int was allowed).  This
change should not pose additional problems and is not specified in
detail by this PEP.</p>
</div>
<div class="section" id="c-api">
<h1><a class="toc-backref" href="#id6">C API</a></h1>
<p>The header file &quot;boolobject.h&quot; defines the C API for the bool
type.  It is included by &quot;Python.h&quot; so there is no need to include
it directly.</p>
<p>The existing names <tt class="docutils literal">Py_False</tt> and <tt class="docutils literal">Py_True</tt> reference the unique bool
objects <tt class="docutils literal">False</tt> and <tt class="docutils literal">True</tt> (previously these referenced static int
objects with values 0 and 1, which were not unique amongst int
values).</p>
<p>A new API, <tt class="docutils literal">PyObject *PyBool_FromLong(long)</tt>, takes a C long int
argument and returns a new reference to either <tt class="docutils literal">Py_False</tt> (when the
argument is zero) or <tt class="docutils literal">Py_True</tt> (when it is nonzero).</p>
<p>To check whether an object is a bool, the macro <tt class="docutils literal">PyBool_Check()</tt> can
be used.</p>
<p>The type of bool instances is <tt class="docutils literal">PyBoolObject *</tt>.</p>
<p>The bool type object is available as PyBool_Type.</p>
</div>
<div class="section" id="clarification">
<h1><a class="toc-backref" href="#id7">Clarification</a></h1>
<p>This PEP does <strong>not</strong> change the fact that almost all object types
can be used as truth values.  For example, when used in an if
statement, an empty list is false and a non-empty one is true;
this does not change and there is no plan to ever change this.</p>
<p>The only thing that changes is the preferred values to represent
truth values when returned or assigned explicitly.  Previously,
these preferred truth values were 0 and 1; the PEP changes the
preferred values to <tt class="docutils literal">False</tt> and <tt class="docutils literal">True</tt>, and changes built-in
operations to return these preferred values.</p>
</div>
<div class="section" id="compatibility">
<h1><a class="toc-backref" href="#id8">Compatibility</a></h1>
<p>Because of backwards compatibility, the bool type lacks many
properties that some would like to see.  For example, arithmetic
operations with one or two bool arguments is allowed, treating
<tt class="docutils literal">False</tt> as 0 and <tt class="docutils literal">True</tt> as 1.  Also, a bool may be used as a sequence
index.</p>
<p>I don't see this as a problem, and I don't want evolve the
language in this direction either.  I don't believe that a
stricter interpretation of &quot;Booleanness&quot; makes the language any
clearer.</p>
<p>Another consequence of the compatibility requirement is that the
expression &quot;True and 6&quot; has the value 6, and similarly the
expression &quot;False or None&quot; has the value None.  The &quot;and&quot; and &quot;or&quot;
operators are usefully defined to return the first argument that
determines the outcome, and this won't change; in particular, they
don't force the outcome to be a bool.  Of course, if both
arguments are bools, the outcome is always a bool.  It can also
easily be coerced into being a bool by writing for example &quot;bool(x
and y)&quot;.</p>
</div>
<div class="section" id="resolved-issues">
<h1><a class="toc-backref" href="#id9">Resolved Issues</a></h1>
<p>(See also the Review section above.)</p>
<ul>
<li><p class="first">Because the <tt class="docutils literal">repr()</tt> or <tt class="docutils literal">str()</tt> of a bool value is different from an
int value, some code (for example doctest-based unit tests, and
possibly database code that relies on things like &quot;%s&quot; % truth)
may fail.  It is easy to work around this (without explicitly
referencing the bool type), and it is expected that this only
affects a very small amount of code that can easily be fixed.</p>
</li>
<li><p class="first">Other languages (C99, C++, Java) name the constants &quot;false&quot; and
&quot;true&quot;, in all lowercase.  For Python, I prefer to stick with
the example set by the existing built-in constants, which all
use CapitalizedWords: <tt class="docutils literal">None</tt>, <tt class="docutils literal">Ellipsis</tt>, <tt class="docutils literal">NotImplemented</tt> (as well as
all built-in exceptions).  Python's built-in namespace uses all
lowercase for functions and types only.</p>
</li>
<li><p class="first">It has been suggested that, in order to satisfy user
expectations, for every x that is considered true in a Boolean
context, the expression <tt class="docutils literal">x == True</tt> should be true, and likewise
if x is considered false, <tt class="docutils literal">x == False</tt> should be true.  In
particular newbies who have only just learned about Boolean
variables are likely to write</p>
<pre class="literal-block">
if x == True: ...
</pre>
<p>instead of the correct form,</p>
<pre class="literal-block">
if x: ...
</pre>
<p>There seem to be strong psychological and linguistic reasons why
many people are at first uncomfortable with the latter form, but
I believe that the solution should be in education rather than
in crippling the language.  After all, == is general seen as a
transitive operator, meaning that from <tt class="docutils literal"><span class="pre">a==b</span></tt> and <tt class="docutils literal"><span class="pre">b==c</span></tt> we can
deduce <tt class="docutils literal"><span class="pre">a==c</span></tt>.  But if any comparison to <tt class="docutils literal">True</tt> were to report
equality when the other operand was a true value of any type,
atrocities like <tt class="docutils literal"><span class="pre">6==True==7</span></tt> would hold true, from which one could
infer the falsehood <tt class="docutils literal"><span class="pre">6==7</span></tt>.  That's unacceptable.  (In addition,
it would break backwards compatibility.  But even if it didn't,
I'd still be against this, for the stated reasons.)</p>
<p>Newbies should also be reminded that there's never a reason to
write</p>
<pre class="literal-block">
if bool(x): ...
</pre>
<p>since the bool is implicit in the &quot;if&quot;.  Explicit is <strong>not</strong>
better than implicit here, since the added verbiage impairs
redability and there's no other interpretation possible.  There
is, however, sometimes a reason to write</p>
<pre class="literal-block">
b = bool(x)
</pre>
<p>This is useful when it is unattractive to keep a reference to an
arbitrary object x, or when normalization is required for some
other reason.  It is also sometimes appropriate to write</p>
<pre class="literal-block">
i = int(bool(x))
</pre>
<p>which converts the bool to an int with the value 0 or 1.  This
conveys the intention to henceforth use the value as an int.</p>
</li>
</ul>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id10">Implementation</a></h1>
<p>A complete implementation in C has been uploaded to the
SourceForge patch manager: <a class="reference external" href="http://python.org/sf/528022">http://python.org/sf/528022</a></p>
<p>This will soon be checked into CVS for python 2.3a0.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id11">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
fill-column: 70
End: -->
</div>

