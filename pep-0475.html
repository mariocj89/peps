<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">475</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Retry system calls failing with EINTR</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0475.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Charles-Fran√ßois Natali &lt;cf.natali&#32;&#97;t&#32;gmail.com&gt;, Victor Stinner &lt;victor.stinner&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">BDFL-Delegate:</th><td class="field-body">Antoine Pitrou &lt;solipsis&#32;&#97;t&#32;pitrou.net&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">29-July-2014</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.5</td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2015-February/138018.html">https://mail.python.org/pipermail/python-dev/2015-February/138018.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id3">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id4">Rationale</a><ul>
<li><a class="reference internal" href="#interrupted-system-calls" id="id5">Interrupted system calls</a></li>
<li><a class="reference internal" href="#status-in-python-3-4" id="id6">Status in Python 3.4</a></li>
<li><a class="reference internal" href="#use-case-1-don-t-bother-with-signals" id="id7">Use Case 1: Don't Bother With Signals</a></li>
<li><a class="reference internal" href="#use-case-2-be-notified-of-signals-as-soon-as-possible" id="id8">Use Case 2: Be notified of signals as soon as possible</a></li>
</ul>
</li>
<li><a class="reference internal" href="#proposal" id="id9">Proposal</a><ul>
<li><a class="reference internal" href="#modified-functions" id="id10">Modified functions</a></li>
<li><a class="reference internal" href="#interruptederror-handling" id="id11">InterruptedError handling</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backward-compatibility" id="id12">Backward compatibility</a></li>
<li><a class="reference internal" href="#appendix" id="id13">Appendix</a><ul>
<li><a class="reference internal" href="#wakeup-file-descriptor" id="id14">Wakeup file descriptor</a></li>
<li><a class="reference internal" href="#multithreading" id="id15">Multithreading</a></li>
<li><a class="reference internal" href="#signals-on-windows" id="id16">Signals on Windows</a><ul>
<li><a class="reference internal" href="#control-events" id="id17">Control events</a></li>
<li><a class="reference internal" href="#signals" id="id18">Signals</a></li>
<li><a class="reference internal" href="#sigint" id="id19">SIGINT</a></li>
</ul>
</li>
<li><a class="reference internal" href="#links" id="id20">Links</a><ul>
<li><a class="reference internal" href="#misc" id="id21">Misc</a></li>
<li><a class="reference internal" href="#python-issues-related-to-eintr" id="id22">Python issues related to EINTR</a></li>
<li><a class="reference internal" href="#python-issues-related-to-signals" id="id23">Python issues related to signals</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#implementation" id="id24">Implementation</a></li>
<li><a class="reference internal" href="#copyright" id="id25">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id3">Abstract</a></h1>
<p>System call wrappers provided in the standard library should be retried
automatically when they fail with <tt class="docutils literal">EINTR</tt>, to relieve application code
from the burden of doing so.</p>
<p>By system calls, we mean the functions exposed by the standard C library
pertaining to I/O or handling of other system resources.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id4">Rationale</a></h1>
<div class="section" id="interrupted-system-calls">
<h2><a class="toc-backref" href="#id5">Interrupted system calls</a></h2>
<p>On POSIX systems, signals are common.  Code calling system calls must be
prepared to handle them.  Examples of signals:</p>
<ul class="simple">
<li>The most common signal is <tt class="docutils literal">SIGINT</tt>, the signal sent when CTRL+c is
pressed. By default, Python raises a <tt class="docutils literal">KeyboardInterrupt</tt> exception
when this signal is received.</li>
<li>When running subprocesses, the <tt class="docutils literal">SIGCHLD</tt> signal is sent when a
child process exits.</li>
<li>Resizing the terminal sends the <tt class="docutils literal">SIGWINCH</tt> signal to the
applications running in the terminal.</li>
<li>Putting the application in background (ex: press CTRL-z and then
type the <tt class="docutils literal">bg</tt> command) sends the <tt class="docutils literal">SIGCONT</tt> signal.</li>
</ul>
<p>Writing a C signal handler is difficult: only &quot;async-signal-safe&quot;
functions can be called (for example, <tt class="docutils literal">printf()</tt> and <tt class="docutils literal">malloc()</tt>
are not async-signal safe), and there are issues with reentrancy.
Therefore, when a signal is received by a process during the execution
of a system call, the system call can fail with the <tt class="docutils literal">EINTR</tt> error to
give the program an opportunity to handle the signal without the
restriction on signal-safe functions.</p>
<p>This behaviour is system-dependent: on certain systems, using the
<tt class="docutils literal">SA_RESTART</tt> flag, some system calls are retried automatically instead
of failing with <tt class="docutils literal">EINTR</tt>.  Regardless, Python's <tt class="docutils literal">signal.signal()</tt>
function clears the <tt class="docutils literal">SA_RESTART</tt> flag when setting the signal handler:
all system calls will probably fail with <tt class="docutils literal">EINTR</tt> in Python.</p>
<p>Since receiving a signal is a non-exceptional occurrence, robust POSIX code
must be prepared to handle <tt class="docutils literal">EINTR</tt> (which, in most cases, means
retry in a loop in the hope that the call eventually succeeds).
Without special support from Python, this can make application code
much more verbose than it needs to be.</p>
</div>
<div class="section" id="status-in-python-3-4">
<h2><a class="toc-backref" href="#id6">Status in Python 3.4</a></h2>
<p>In Python 3.4, handling the <tt class="docutils literal">InterruptedError</tt> exception (<tt class="docutils literal">EINTR</tt>'s
dedicated exception class) is duplicated at every call site on a case by
case basis.  Only a few Python modules actually handle this exception,
and fixes usually took several years to cover a whole module.  Example of
code retrying <tt class="docutils literal">file.read()</tt> on <tt class="docutils literal">InterruptedError</tt>:</p>
<pre class="literal-block">
while True:
    try:
        data = file.read(size)
        break
    except InterruptedError:
        continue
</pre>
<p>List of Python modules in the standard library which handle
<tt class="docutils literal">InterruptedError</tt>:</p>
<ul class="simple">
<li><tt class="docutils literal">asyncio</tt></li>
<li><tt class="docutils literal">asyncore</tt></li>
<li><tt class="docutils literal">io</tt>, <tt class="docutils literal">_pyio</tt></li>
<li><tt class="docutils literal">multiprocessing</tt></li>
<li><tt class="docutils literal">selectors</tt></li>
<li><tt class="docutils literal">socket</tt></li>
<li><tt class="docutils literal">socketserver</tt></li>
<li><tt class="docutils literal">subprocess</tt></li>
</ul>
<p>Other programming languages like Perl, Java and Go retry system calls
failing with <tt class="docutils literal">EINTR</tt> at a lower level, so that libraries and applications
needn't bother.</p>
</div>
<div class="section" id="use-case-1-don-t-bother-with-signals">
<h2><a class="toc-backref" href="#id7">Use Case 1: Don't Bother With Signals</a></h2>
<p>In most cases, you don't want to be interrupted by signals and you
don't expect to get <tt class="docutils literal">InterruptedError</tt> exceptions.  For example, do
you really want to write such complex code for a &quot;Hello World&quot;
example?</p>
<pre class="literal-block">
while True:
    try:
        print(&quot;Hello World&quot;)
        break
    except InterruptedError:
        continue
</pre>
<p><tt class="docutils literal">InterruptedError</tt> can happen in unexpected places. For example,
<tt class="docutils literal">os.close()</tt> and <tt class="docutils literal">FileIO.close()</tt> may raise <tt class="docutils literal">InterruptedError</tt>:
see the article <a class="reference external" href="http://alobbs.com/post/54503240599/close-and-eintr">close() and EINTR</a>.</p>
<p>The <a class="reference internal" href="#python-issues-related-to-eintr">Python issues related to EINTR</a> section below gives examples of
bugs caused by <tt class="docutils literal">EINTR</tt>.</p>
<p>The expectation in this use case is that Python hides the
<tt class="docutils literal">InterruptedError</tt> and retries system calls automatically.</p>
</div>
<div class="section" id="use-case-2-be-notified-of-signals-as-soon-as-possible">
<h2><a class="toc-backref" href="#id8">Use Case 2: Be notified of signals as soon as possible</a></h2>
<p>Sometimes yet, you expect some signals and you want to handle them as
soon as possible.  For example, you may want to immediately quit a
program using the <tt class="docutils literal">CTRL+c</tt> keyboard shortcut.</p>
<p>Besides, some signals are not interesting and should not disrupt the
application.  There are two options to interrupt an application on
only <em>some</em> signals:</p>
<ul class="simple">
<li>Set up a custom signal handler which raises an exception, such as
<tt class="docutils literal">KeyboardInterrupt</tt> for <tt class="docutils literal">SIGINT</tt>.</li>
<li>Use a I/O multiplexing function like <tt class="docutils literal">select()</tt> together with Python's
signal wakeup file descriptor: see the function <tt class="docutils literal">signal.set_wakeup_fd()</tt>.</li>
</ul>
<p>The expectation in this use case is for the Python signal handler to be
executed timely, and the system call to fail if the handler raised an
exception -- otherwise restart.</p>
</div>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id9">Proposal</a></h1>
<p>This PEP proposes to handle EINTR and retries at the lowest level, i.e.
in the wrappers provided by the stdlib (as opposed to higher-level
libraries and applications).</p>
<p>Specifically, when a system call fails with <tt class="docutils literal">EINTR</tt>, its Python wrapper
must call the given signal handler (using <tt class="docutils literal">PyErr_CheckSignals()</tt>).
If the signal handler raises an exception, the Python wrapper bails out
and fails with the exception.</p>
<p>If the signal handler returns successfully, the Python wrapper retries the
system call automatically.  If the system call involves a timeout parameter,
the timeout is recomputed.</p>
<div class="section" id="modified-functions">
<h2><a class="toc-backref" href="#id10">Modified functions</a></h2>
<p>Example of standard library functions that need to be modified to comply
with this PEP:</p>
<ul class="simple">
<li><tt class="docutils literal">open()</tt>, <tt class="docutils literal">os.open()</tt>, <tt class="docutils literal">io.open()</tt></li>
<li>functions of the <tt class="docutils literal">faulthandler</tt> module</li>
<li><tt class="docutils literal">os</tt> functions:<ul>
<li><tt class="docutils literal">os.fchdir()</tt></li>
<li><tt class="docutils literal">os.fchmod()</tt></li>
<li><tt class="docutils literal">os.fchown()</tt></li>
<li><tt class="docutils literal">os.fdatasync()</tt></li>
<li><tt class="docutils literal">os.fstat()</tt></li>
<li><tt class="docutils literal">os.fstatvfs()</tt></li>
<li><tt class="docutils literal">os.fsync()</tt></li>
<li><tt class="docutils literal">os.ftruncate()</tt></li>
<li><tt class="docutils literal">os.mkfifo()</tt></li>
<li><tt class="docutils literal">os.mknod()</tt></li>
<li><tt class="docutils literal">os.posix_fadvise()</tt></li>
<li><tt class="docutils literal">os.posix_fallocate()</tt></li>
<li><tt class="docutils literal">os.pread()</tt></li>
<li><tt class="docutils literal">os.pwrite()</tt></li>
<li><tt class="docutils literal">os.read()</tt></li>
<li><tt class="docutils literal">os.readv()</tt></li>
<li><tt class="docutils literal">os.sendfile()</tt></li>
<li><tt class="docutils literal">os.wait3()</tt></li>
<li><tt class="docutils literal">os.wait4()</tt></li>
<li><tt class="docutils literal">os.wait()</tt></li>
<li><tt class="docutils literal">os.waitid()</tt></li>
<li><tt class="docutils literal">os.waitpid()</tt></li>
<li><tt class="docutils literal">os.write()</tt></li>
<li><tt class="docutils literal">os.writev()</tt></li>
<li>special cases: <tt class="docutils literal">os.close()</tt> and <tt class="docutils literal">os.dup2()</tt> now ignore <tt class="docutils literal">EINTR</tt> error,
the syscall is not retried</li>
</ul>
</li>
<li><tt class="docutils literal">select.select()</tt>, <tt class="docutils literal">select.poll.poll()</tt>, <tt class="docutils literal">select.epoll.poll()</tt>,
<tt class="docutils literal">select.kqueue.control()</tt>, <tt class="docutils literal">select.devpoll.poll()</tt></li>
<li><tt class="docutils literal">socket.socket()</tt> methods:<ul>
<li><tt class="docutils literal">accept()</tt></li>
<li><tt class="docutils literal">connect()</tt> (except for non-blocking sockets)</li>
<li><tt class="docutils literal">recv()</tt></li>
<li><tt class="docutils literal">recvfrom()</tt></li>
<li><tt class="docutils literal">recvmsg()</tt></li>
<li><tt class="docutils literal">send()</tt></li>
<li><tt class="docutils literal">sendall()</tt></li>
<li><tt class="docutils literal">sendmsg()</tt></li>
<li><tt class="docutils literal">sendto()</tt></li>
</ul>
</li>
<li><tt class="docutils literal">signal.sigtimedwait()</tt>, <tt class="docutils literal">signal.sigwaitinfo()</tt></li>
<li><tt class="docutils literal">time.sleep()</tt></li>
</ul>
<p>(Note: the <tt class="docutils literal">selector</tt> module already retries on <tt class="docutils literal">InterruptedError</tt>, but it
doesn't recompute the timeout yet)</p>
<p><tt class="docutils literal">os.close</tt>, <tt class="docutils literal">close()</tt> methods and <tt class="docutils literal">os.dup2()</tt> are a special case: they
will ignore <tt class="docutils literal">EINTR</tt> instead of retrying.  The reason is complex but involves
behaviour under Linux and the fact that the file descriptor may really be
closed even if EINTR is returned. See articles:</p>
<ul class="simple">
<li><a class="reference external" href="http://lwn.net/Articles/576478/">Returning EINTR from close()</a></li>
<li><a class="reference external" href="http://linux.derkeiler.com/Mailing-Lists/Kernel/2005-09/3000.html">(LKML) Re: [patch 7/7] uml: retry host close() on EINTR</a></li>
<li><a class="reference external" href="http://alobbs.com/post/54503240599/close-and-eintr">close() and EINTR</a></li>
</ul>
<p>The <tt class="docutils literal">socket.socket.connect()</tt> method does not retry <tt class="docutils literal">connect()</tt> for
non-blocking sockets if it is interrupted by a signal (fails with <tt class="docutils literal">EINTR</tt>).
The connection runs asynchronously in background. The caller is responsible
to wait until the socket becomes writable (ex: using <tt class="docutils literal">select.select()</tt>)
and then call <tt class="docutils literal">socket.socket.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)</tt>
to check if the connection succeeded (<tt class="docutils literal">getsockopt()</tt> returns <tt class="docutils literal">0</tt>) or failed.</p>
</div>
<div class="section" id="interruptederror-handling">
<h2><a class="toc-backref" href="#id11">InterruptedError handling</a></h2>
<p>Since interrupted system calls are automatically retried, the
<tt class="docutils literal">InterruptedError</tt> exception should not occur anymore when calling those
system calls.  Therefore, manual handling of <tt class="docutils literal">InterruptedError</tt> as
described in <a class="reference internal" href="#status-in-python-3-4">Status in Python 3.4</a> can be removed, which will simplify
standard library code.</p>
</div>
</div>
<div class="section" id="backward-compatibility">
<h1><a class="toc-backref" href="#id12">Backward compatibility</a></h1>
<p>Applications relying on the fact that system calls are interrupted
with <tt class="docutils literal">InterruptedError</tt> will hang.  The authors of this PEP don't
think that such applications exist, since they would be exposed to
other issues such as race conditions (there is an opportunity for deadlock
if the signal comes before the system call).  Besides, such code would
be non-portable.</p>
<p>In any case, those applications must be fixed to handle signals differently,
to have a reliable behaviour on all platforms and all Python versions.
A possible strategy is to set up a signal handler raising a well-defined
exception, or use a wakeup file descriptor.</p>
<p>For applications using event loops, <tt class="docutils literal">signal.set_wakeup_fd()</tt> is the
recommended option to handle signals.  Python's low-level signal handler
will write signal numbers into the file descriptor and the event loop
will be awaken to read them.  The event loop can handle those signals
without the restriction of signal handlers (for example, the loop can
be woken up in any thread, not just the main thread).</p>
</div>
<div class="section" id="appendix">
<h1><a class="toc-backref" href="#id13">Appendix</a></h1>
<div class="section" id="wakeup-file-descriptor">
<h2><a class="toc-backref" href="#id14">Wakeup file descriptor</a></h2>
<p>Since Python 3.3, <tt class="docutils literal">signal.set_wakeup_fd()</tt> writes the signal number
into the file descriptor, whereas it only wrote a null byte before.
It becomes possible to distinguish between signals using the wakeup file
descriptor.</p>
<p>Linux has a <tt class="docutils literal">signalfd()</tt> system call which provides more information on
each signal.  For example, it's possible to know the pid and uid who sent
the signal.  This function is not exposed in Python yet (see
<a class="reference external" href="http://bugs.python.org/issue12304">issue 12304</a>).</p>
<p>On Unix, the <tt class="docutils literal">asyncio</tt> module uses the wakeup file descriptor to
wake up its event loop.</p>
</div>
<div class="section" id="multithreading">
<h2><a class="toc-backref" href="#id15">Multithreading</a></h2>
<p>A C signal handler can be called from any thread, but Python
signal handlers will always be called in the main Python thread.</p>
<p>Python's C API provides the <tt class="docutils literal">PyErr_SetInterrupt()</tt> function which calls
the <tt class="docutils literal">SIGINT</tt> signal handler in order to interrupt the main Python thread.</p>
</div>
<div class="section" id="signals-on-windows">
<h2><a class="toc-backref" href="#id16">Signals on Windows</a></h2>
<div class="section" id="control-events">
<h3><a class="toc-backref" href="#id17">Control events</a></h3>
<p>Windows uses &quot;control events&quot;:</p>
<ul class="simple">
<li><tt class="docutils literal">CTRL_BREAK_EVENT</tt>: Break (<tt class="docutils literal">SIGBREAK</tt>)</li>
<li><tt class="docutils literal">CTRL_CLOSE_EVENT</tt>: Close event</li>
<li><tt class="docutils literal">CTRL_C_EVENT</tt>: CTRL+C (<tt class="docutils literal">SIGINT</tt>)</li>
<li><tt class="docutils literal">CTRL_LOGOFF_EVENT</tt>: Logoff</li>
<li><tt class="docutils literal">CTRL_SHUTDOWN_EVENT</tt>: Shutdown</li>
</ul>
<p>The <a class="reference external" href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms686016%28v=vs.85%29.aspx">SetConsoleCtrlHandler() function</a>
can be used to install a control handler.</p>
<p>The <tt class="docutils literal">CTRL_C_EVENT</tt> and <tt class="docutils literal">CTRL_BREAK_EVENT</tt> events can be sent to a
process using the <a class="reference external" href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms683155%28v=vs.85%29.aspx">GenerateConsoleCtrlEvent() function</a>.
This function is exposed in Python as <tt class="docutils literal">os.kill()</tt>.</p>
</div>
<div class="section" id="signals">
<h3><a class="toc-backref" href="#id18">Signals</a></h3>
<p>The following signals are supported on Windows:</p>
<ul class="simple">
<li><tt class="docutils literal">SIGABRT</tt></li>
<li><tt class="docutils literal">SIGBREAK</tt> (<tt class="docutils literal">CTRL_BREAK_EVENT</tt>): signal only available on Windows</li>
<li><tt class="docutils literal">SIGFPE</tt></li>
<li><tt class="docutils literal">SIGILL</tt></li>
<li><tt class="docutils literal">SIGINT</tt> (<tt class="docutils literal">CTRL_C_EVENT</tt>)</li>
<li><tt class="docutils literal">SIGSEGV</tt></li>
<li><tt class="docutils literal">SIGTERM</tt></li>
</ul>
</div>
<div class="section" id="sigint">
<h3><a class="toc-backref" href="#id19">SIGINT</a></h3>
<p>The default Python signal handler for <tt class="docutils literal">SIGINT</tt> sets a Windows event
object: <tt class="docutils literal">sigint_event</tt>.</p>
<p><tt class="docutils literal">time.sleep()</tt> is implemented with <tt class="docutils literal">WaitForSingleObjectEx()</tt>, it
waits for the <tt class="docutils literal">sigint_event</tt> object using <tt class="docutils literal">time.sleep()</tt> parameter
as the timeout.  So the sleep can be interrupted by <tt class="docutils literal">SIGINT</tt>.</p>
<p><tt class="docutils literal">_winapi.WaitForMultipleObjects()</tt> automatically adds
<tt class="docutils literal">sigint_event</tt> to the list of watched handles, so it can also be
interrupted.</p>
<p><tt class="docutils literal">PyOS_StdioReadline()</tt> also used <tt class="docutils literal">sigint_event</tt> when <tt class="docutils literal">fgets()</tt>
failed to check if Ctrl-C or Ctrl-Z was pressed.</p>
</div>
</div>
<div class="section" id="links">
<h2><a class="toc-backref" href="#id20">Links</a></h2>
<div class="section" id="misc">
<h3><a class="toc-backref" href="#id21">Misc</a></h3>
<ul class="simple">
<li><a class="reference external" href="http://www.gnu.org/software/libc/manual/html_node/Interrupted-Primitives.html">glibc manual: Primitives Interrupted by Signals</a></li>
<li><a class="reference external" href="https://rt.perl.org/Public/Bug/Display.html?id=119097">Bug #119097 for perl5: print returning EINTR in 5.14</a>.</li>
</ul>
</div>
<div class="section" id="python-issues-related-to-eintr">
<h3><a class="toc-backref" href="#id22">Python issues related to EINTR</a></h3>
<p>The main issue is: <a class="reference external" href="http://bugs.python.org/issue18885">handle EINTR in the stdlib</a>.</p>
<p>Open issues:</p>
<ul class="simple">
<li><a class="reference external" href="http://bugs.python.org/issue22018">Add a new signal.set_wakeup_socket() function</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue22042">signal.set_wakeup_fd(fd): set the fd to non-blocking mode</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue22043">Use a monotonic clock to compute timeouts</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue22007">sys.stdout.write on OS X is not EINTR safe</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue21772">platform.uname() not EINTR safe</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue11266">asyncore does not handle EINTR in recv, send, connect, accept,</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue20611">socket.create_connection() doesn't handle EINTR properly</a></li>
</ul>
<p>Closed issues:</p>
<ul class="simple">
<li><a class="reference external" href="http://bugs.python.org/issue9867">Interrupted system calls are not retried</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue1049450">Solaris: EINTR exception in select/socket calls in telnetlib</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue12493">subprocess: Popen.communicate() doesn't handle EINTR in some cases</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue12338">multiprocessing.util._eintr_retry doen't recalculate timeouts</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue12268">file readline, readlines &amp; readall methods can lose data on EINTR</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue17097">multiprocessing BaseManager serve_client() does not check EINTR on recv</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue19849">selectors behaviour on EINTR undocumented</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue19850">asyncio: limit EINTR occurrences with SA_RESTART</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue21602">smtplib.py socket.create_connection() also doesn't handle EINTR properly</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue11650">Faulty RESTART/EINTR handling in Parser/myreadline.c</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue3771">test_httpservers intermittent failure, test_post and EINTR</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue686667">os.spawnv(P_WAIT, ...) on Linux doesn't handle EINTR</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue517554">asyncore fails when EINTR happens in pol</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue10956">file.write and file.read don't handle EINTR</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue1628205">socket.readline() interface doesn't handle EINTR properly</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue1068268">subprocess is not EINTR-safe</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue7978">SocketServer doesn't handle syscall interruption</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue17367">subprocess deadlock when read() is interrupted</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue12462">time.sleep(1): call PyErr_CheckSignals() if the sleep was interrupted</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue8354">siginterrupt with flag=False is reset when signal received</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue1089358">need siginterrupt()  on Linux - impossible to do timeouts</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue581232">[Windows] Can not interrupt time.sleep()</a></li>
</ul>
</div>
<div class="section" id="python-issues-related-to-signals">
<h3><a class="toc-backref" href="#id23">Python issues related to signals</a></h3>
<p>Open issues:</p>
<ul class="simple">
<li><a class="reference external" href="http://bugs.python.org/issue17182">signal.default_int_handler should set signal number on the raised
exception</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue12304">expose signalfd(2) in the signal module</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue14484">missing return in win32_kill?</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue3180">Interrupts are lost during readline PyOS_InputHook processing</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue1687125">cannot catch KeyboardInterrupt when using curses getkey()</a></li>
<li><a class="reference external" href="http://bugs.python.org/issue16151">Deferred KeyboardInterrupt in interactive mode</a></li>
</ul>
<p>Closed issues:</p>
<ul class="simple">
<li><a class="reference external" href="http://bugs.python.org/issue753733">sys.interrupt_main()</a></li>
</ul>
</div>
</div>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id24">Implementation</a></h1>
<p>The implementation is tracked in <a class="reference external" href="http://bugs.python.org/issue23285">issue 23285</a>. It was committed on
February 07, 2015.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id25">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

