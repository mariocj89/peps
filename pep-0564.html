<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">564</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Add new time functions with nanosecond resolution</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0564.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Victor Stinner &lt;victor.stinner&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">16-October-2017</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.7</td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2017-October/150046.html">https://mail.python.org/pipermail/python-dev/2017-October/150046.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id2">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id3">Rationale</a><ul>
<li><a class="reference internal" href="#float-type-limited-to-104-days" id="id4">Float type limited to 104 days</a></li>
<li><a class="reference internal" href="#previous-rejected-pep" id="id5">Previous rejected PEP</a></li>
<li><a class="reference internal" href="#issues-caused-by-precision-loss" id="id6">Issues caused by precision loss</a><ul>
<li><a class="reference internal" href="#example-1-measure-time-delta-in-long-running-process" id="id7">Example 1: measure time delta in long-running process</a></li>
<li><a class="reference internal" href="#example-2-compare-times-with-different-resolution" id="id8">Example 2: compare times with different resolution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cpython-enhancements-of-the-last-5-years" id="id9">CPython enhancements of the last 5 years</a></li>
<li><a class="reference internal" href="#existing-python-apis-using-nanoseconds-as-int" id="id10">Existing Python APIs using nanoseconds as int</a></li>
</ul>
</li>
<li><a class="reference internal" href="#changes" id="id11">Changes</a><ul>
<li><a class="reference internal" href="#new-functions" id="id12">New functions</a></li>
<li><a class="reference internal" href="#unchanged-functions" id="id13">Unchanged functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alternatives-and-discussion" id="id14">Alternatives and discussion</a><ul>
<li><a class="reference internal" href="#sub-nanosecond-resolution" id="id15">Sub-nanosecond resolution</a></li>
<li><a class="reference internal" href="#modifying-time-time-result-type" id="id16">Modifying time.time() result type</a></li>
<li><a class="reference internal" href="#different-types" id="id17">Different types</a></li>
<li><a class="reference internal" href="#different-api" id="id18">Different API</a></li>
<li><a class="reference internal" href="#a-new-module" id="id19">A new module</a></li>
</ul>
</li>
<li><a class="reference internal" href="#annex-clocks-resolution-in-python" id="id20">Annex: Clocks Resolution in Python</a><ul>
<li><a class="reference internal" href="#script" id="id21">Script</a></li>
<li><a class="reference internal" href="#linux" id="id22">Linux</a></li>
<li><a class="reference internal" href="#windows" id="id23">Windows</a></li>
<li><a class="reference internal" href="#analysis" id="id24">Analysis</a></li>
</ul>
</li>
<li><a class="reference internal" href="#links" id="id25">Links</a></li>
<li><a class="reference internal" href="#copyright" id="id26">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id2">Abstract</a></h1>
<p>Add six new &quot;nanosecond&quot; variants of existing functions to the <tt class="docutils literal">time</tt>
module: <tt class="docutils literal">clock_gettime_ns()</tt>, <tt class="docutils literal">clock_settime_ns()</tt>,
<tt class="docutils literal">monotonic_ns()</tt>, <tt class="docutils literal">perf_counter_ns()</tt>, <tt class="docutils literal">process_time_ns()</tt> and
<tt class="docutils literal">time_ns()</tt>.  While similar to the existing functions without the
<tt class="docutils literal">_ns</tt> suffix, they provide nanosecond resolution: they return a number of
nanoseconds as a Python <tt class="docutils literal">int</tt>.</p>
<p>The <tt class="docutils literal">time.time_ns()</tt> resolution is 3 times better than the <tt class="docutils literal">time.time()</tt>
resolution on Linux and Windows.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id3">Rationale</a></h1>
<div class="section" id="float-type-limited-to-104-days">
<h2><a class="toc-backref" href="#id4">Float type limited to 104 days</a></h2>
<p>The clocks resolution of desktop and laptop computers is getting closer
to nanosecond resolution.  More and more clocks have a frequency in MHz,
up to GHz for the CPU TSC clock.</p>
<p>The Python <tt class="docutils literal">time.time()</tt> function returns the current time as a
floating-point number which is usually a 64-bit binary floating-point
number (in the IEEE 754 format).</p>
<p>The problem is that the <tt class="docutils literal">float</tt> type starts to lose nanoseconds after 104
days.  Converting from nanoseconds (<tt class="docutils literal">int</tt>) to seconds (<tt class="docutils literal">float</tt>) and
then back to nanoseconds (<tt class="docutils literal">int</tt>) to check if conversions lose
precision:</p>
<pre class="literal-block">
# no precision loss
&gt;&gt;&gt; x = 2 ** 52 + 1; int(float(x * 1e-9) * 1e9) - x
0
# precision loss! (1 nanosecond)
&gt;&gt;&gt; x = 2 ** 53 + 1; int(float(x * 1e-9) * 1e9) - x
-1
&gt;&gt;&gt; print(datetime.timedelta(seconds=2 ** 53 / 1e9))
104 days, 5:59:59.254741
</pre>
<p><tt class="docutils literal">time.time()</tt> returns seconds elapsed since the UNIX epoch: January
1st, 1970.  This function hasn't had nanosecond precision since May 1970
(47 years ago):</p>
<pre class="literal-block">
&gt;&gt;&gt; import datetime
&gt;&gt;&gt; unix_epoch = datetime.datetime(1970, 1, 1)
&gt;&gt;&gt; print(unix_epoch + datetime.timedelta(seconds=2**53 / 1e9))
1970-04-15 05:59:59.254741
</pre>
</div>
<div class="section" id="previous-rejected-pep">
<h2><a class="toc-backref" href="#id5">Previous rejected PEP</a></h2>
<p>Five years ago, the <a class="reference external" href="/dev/peps/pep-0410">PEP 410</a> proposed a large and complex change in all
Python functions returning time to support nanosecond resolution using
the <tt class="docutils literal">decimal.Decimal</tt> type.</p>
<p>The PEP was rejected for different reasons:</p>
<ul class="simple">
<li>The idea of adding a new optional parameter to change the result type
was rejected. It's an uncommon (and bad?) programming practice in
Python.</li>
<li>It was not clear if hardware clocks really had a resolution of 1
nanosecond, or if that made sense at the Python level.</li>
<li>The <tt class="docutils literal">decimal.Decimal</tt> type is uncommon in Python and so requires
to adapt code to handle it.</li>
</ul>
</div>
<div class="section" id="issues-caused-by-precision-loss">
<h2><a class="toc-backref" href="#id6">Issues caused by precision loss</a></h2>
<div class="section" id="example-1-measure-time-delta-in-long-running-process">
<h3><a class="toc-backref" href="#id7">Example 1: measure time delta in long-running process</a></h3>
<p>A server is running for longer than 104 days.  A clock is read before and
after running a function to measure its performance to detect
performance issues at runtime.  Such benchmark only loses precision
because of the float type used by clocks, not because of the clock
resolution.</p>
<p>On Python microbenchmarks, it is common to see function calls taking
less than 100 ns.  A difference of a few nanoseconds might become
significant.</p>
</div>
<div class="section" id="example-2-compare-times-with-different-resolution">
<h3><a class="toc-backref" href="#id8">Example 2: compare times with different resolution</a></h3>
<p>Two programs &quot;A&quot; and &quot;B&quot; are running on the same system and use the system
clock.  The program A reads the system clock with nanosecond resolution
and writes a timestamp with nanosecond resolution.  The program B reads
the timestamp with nanosecond resolution, but compares it to the system
clock read with a worse resolution.  To simplify the example, let's say
that B reads the clock with second resolution.  If that case, there is a
window of 1 second while the program B can see the timestamp written by A
as &quot;in the future&quot;.</p>
<p>Nowadays, more and more databases and filesystems support storing times
with nanosecond resolution.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This issue was already fixed for file modification time by adding the
<tt class="docutils literal">st_mtime_ns</tt> field to the <tt class="docutils literal">os.stat()</tt> result, and by accepting
nanoseconds in <tt class="docutils literal">os.utime()</tt>. This PEP proposes to generalize the
fix.</p>
</div>
</div>
</div>
<div class="section" id="cpython-enhancements-of-the-last-5-years">
<h2><a class="toc-backref" href="#id9">CPython enhancements of the last 5 years</a></h2>
<p>Since the <a class="reference external" href="/dev/peps/pep-0410">PEP 410</a> was rejected:</p>
<ul class="simple">
<li>The <tt class="docutils literal">os.stat_result</tt> structure got 3 new fields for timestamps as
nanoseconds (Python <tt class="docutils literal">int</tt>): <tt class="docutils literal">st_atime_ns</tt>, <tt class="docutils literal">st_ctime_ns</tt>
and <tt class="docutils literal">st_mtime_ns</tt>.</li>
<li>The <a class="reference external" href="/dev/peps/pep-0418">PEP 418</a> was accepted, Python 3.3 got 3 new clocks:
<tt class="docutils literal">time.monotonic()</tt>, <tt class="docutils literal">time.perf_counter()</tt> and
<tt class="docutils literal">time.process_time()</tt>.</li>
<li>The CPython private &quot;pytime&quot; C API handling time now uses a new
<tt class="docutils literal">_PyTime_t</tt> type: simple 64-bit signed integer (C <tt class="docutils literal">int64_t</tt>).
The <tt class="docutils literal">_PyTime_t</tt> unit is an implementation detail and not part of the
API. The unit is currently <tt class="docutils literal">1 nanosecond</tt>.</li>
</ul>
</div>
<div class="section" id="existing-python-apis-using-nanoseconds-as-int">
<h2><a class="toc-backref" href="#id10">Existing Python APIs using nanoseconds as int</a></h2>
<p>The <tt class="docutils literal">os.stat_result</tt> structure has 3 fields for timestamps as
nanoseconds (<tt class="docutils literal">int</tt>): <tt class="docutils literal">st_atime_ns</tt>, <tt class="docutils literal">st_ctime_ns</tt> and
<tt class="docutils literal">st_mtime_ns</tt>.</p>
<p>The <tt class="docutils literal">ns</tt> parameter of the <tt class="docutils literal">os.utime()</tt> function accepts a
<tt class="docutils literal">(atime_ns: int, mtime_ns: int)</tt> tuple: nanoseconds.</p>
</div>
</div>
<div class="section" id="changes">
<h1><a class="toc-backref" href="#id11">Changes</a></h1>
<div class="section" id="new-functions">
<h2><a class="toc-backref" href="#id12">New functions</a></h2>
<p>This PEP adds six new functions to the <tt class="docutils literal">time</tt> module:</p>
<ul class="simple">
<li><tt class="docutils literal">time.clock_gettime_ns(clock_id)</tt></li>
<li><tt class="docutils literal">time.clock_settime_ns(clock_id, time: int)</tt></li>
<li><tt class="docutils literal">time.monotonic_ns()</tt></li>
<li><tt class="docutils literal">time.perf_counter_ns()</tt></li>
<li><tt class="docutils literal">time.process_time_ns()</tt></li>
<li><tt class="docutils literal">time.time_ns()</tt></li>
</ul>
<p>These functions are similar to the version without the <tt class="docutils literal">_ns</tt> suffix,
but return a number of nanoseconds as a Python <tt class="docutils literal">int</tt>.</p>
<p>For example, <tt class="docutils literal">time.monotonic_ns() == int(time.monotonic() * 1e9)</tt> if
<tt class="docutils literal">monotonic()</tt> value is small enough to not lose precision.</p>
<p>These functions are needed because they may return &quot;large&quot; timestamps,
like <tt class="docutils literal">time.time()</tt> which uses the UNIX epoch as reference, and so their
<tt class="docutils literal">float</tt>-returning variants are likely to lose precision at the nanosecond
resolution.</p>
</div>
<div class="section" id="unchanged-functions">
<h2><a class="toc-backref" href="#id13">Unchanged functions</a></h2>
<p>Since the <tt class="docutils literal">time.clock()</tt> function was deprecated in Python 3.3, no
<tt class="docutils literal">time.clock_ns()</tt> is added.</p>
<p>Python has other time-returning functions.  No nanosecond variant is
proposed for these other functions, either because their internal
resolution is greater or equal to 1 us, or because their maximum value
is small enough to not lose precision.  For example, the maximum value of
<tt class="docutils literal">time.clock_getres()</tt> should be 1 second.</p>
<p>Examples of unchanged functions:</p>
<ul class="simple">
<li><tt class="docutils literal">os</tt> module: <tt class="docutils literal">sched_rr_get_interval()</tt>, <tt class="docutils literal">times()</tt>, <tt class="docutils literal">wait3()</tt>
and <tt class="docutils literal">wait4()</tt></li>
<li><tt class="docutils literal">resource</tt> module: <tt class="docutils literal">ru_utime</tt> and <tt class="docutils literal">ru_stime</tt> fields of
<tt class="docutils literal">getrusage()</tt></li>
<li><tt class="docutils literal">signal</tt> module: <tt class="docutils literal">getitimer()</tt>, <tt class="docutils literal">setitimer()</tt></li>
<li><tt class="docutils literal">time</tt> module: <tt class="docutils literal">clock_getres()</tt></li>
</ul>
<p>See also the <a class="reference internal" href="#annex-clocks-resolution-in-python">Annex: Clocks Resolution in Python</a>.</p>
<p>A new nanosecond-returning flavor of these functions may be added later
if an operating system exposes new functions providing better resolution.</p>
</div>
</div>
<div class="section" id="alternatives-and-discussion">
<h1><a class="toc-backref" href="#id14">Alternatives and discussion</a></h1>
<div class="section" id="sub-nanosecond-resolution">
<h2><a class="toc-backref" href="#id15">Sub-nanosecond resolution</a></h2>
<p><tt class="docutils literal">time.time_ns()</tt> API is not theoretically future-proof: if clock
resolutions continue to increase below the nanosecond level, new Python
functions may be needed.</p>
<p>In practice, the 1 nanosecond resolution is currently enough for all
structures returned by all common operating systems functions.</p>
<p>Hardware clocks with a resolution better than 1 nanosecond already
exist.  For example, the frequency of a CPU TSC clock is the CPU base
frequency: the resolution is around 0.3 ns for a CPU running at 3
GHz.  Users who have access to such hardware and really need
sub-nanosecond resolution can however extend Python for their needs.
Such a rare use case doesn't justify to design the Python standard library
to support sub-nanosecond resolution.</p>
<p>For the CPython implementation, nanosecond resolution is convenient: the
standard and well supported <tt class="docutils literal">int64_t</tt> type can be used to store a
nanosecond-precise timestamp.  It supports a timespan of -292 years
to +292 years.  Using the UNIX epoch as reference, it therefore supports
representing times since year 1677 to year 2262:</p>
<pre class="literal-block">
&gt;&gt;&gt; 1970 - 2 ** 63 / (10 ** 9 * 3600 * 24 * 365.25)
1677.728976954687
&gt;&gt;&gt; 1970 + 2 ** 63 / (10 ** 9 * 3600 * 24 * 365.25)
2262.271023045313
</pre>
</div>
<div class="section" id="modifying-time-time-result-type">
<h2><a class="toc-backref" href="#id16">Modifying time.time() result type</a></h2>
<p>It was proposed to modify <tt class="docutils literal">time.time()</tt> to return a different number
type with better precision.</p>
<p>The <a class="reference external" href="/dev/peps/pep-0410">PEP 410</a> proposed to return <tt class="docutils literal">decimal.Decimal</tt> which already exists and
supports arbitrary precision, but it was rejected.  Apart from
<tt class="docutils literal">decimal.Decimal</tt>, no portable real number type with better precision
is currently available in Python.</p>
<p>Changing the built-in Python <tt class="docutils literal">float</tt> type is out of the scope of this
PEP.</p>
<p>Moreover, changing existing functions to return a new type introduces a
risk of breaking the backward compatibility even if the new type is
designed carefully.</p>
</div>
<div class="section" id="different-types">
<h2><a class="toc-backref" href="#id17">Different types</a></h2>
<p>Many ideas of new types were proposed to support larger or arbitrary
precision: fractions, structures or 2-tuple using integers,
fixed-point number, etc.</p>
<p>See also the <a class="reference external" href="/dev/peps/pep-0410">PEP 410</a> for a previous long discussion on other types.</p>
<p>Adding a new type requires more effort to support it, than reusing
the existing <tt class="docutils literal">int</tt> type.  The standard library, third party code and
applications would have to be modified to support it.</p>
<p>The Python <tt class="docutils literal">int</tt> type is well known, well supported, easy to
manipulate, and supports all arithmetic operations such as
<tt class="docutils literal">dt = t2 - t1</tt>.</p>
<p>Moreover, taking/returning an integer number of nanoseconds is not a
new concept in Python, as witnessed by <tt class="docutils literal">os.stat_result</tt> and
<tt class="docutils literal"><span class="pre">os.utime(ns=(atime_ns,</span> mtime_ns))</tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the Python <tt class="docutils literal">float</tt> type becomes larger (e.g. decimal128 or
float128), the <tt class="docutils literal">time.time()</tt> precision will increase as well.</p>
</div>
</div>
<div class="section" id="different-api">
<h2><a class="toc-backref" href="#id18">Different API</a></h2>
<p>The <tt class="docutils literal">time.time(ns=False)</tt> API was proposed to avoid adding new
functions. It's an uncommon (and bad?) programming practice in Python to
change the result type depending on a parameter.</p>
<p>Different options were proposed to allow the user to choose the time
resolution. If each Python module uses a different resolution, it can
become difficult to handle different resolutions, instead of just
seconds (<tt class="docutils literal">time.time()</tt> returning <tt class="docutils literal">float</tt>) and nanoseconds
(<tt class="docutils literal">time.time_ns()</tt> returning <tt class="docutils literal">int</tt>). Moreover, as written above,
there is no need for resolution better than 1 nanosecond in practice in
the Python standard library.</p>
</div>
<div class="section" id="a-new-module">
<h2><a class="toc-backref" href="#id19">A new module</a></h2>
<p>It was proposed to add a new <tt class="docutils literal">time_ns</tt> module containing the following
functions:</p>
<ul class="simple">
<li><tt class="docutils literal">time_ns.clock_gettime(clock_id)</tt></li>
<li><tt class="docutils literal">time_ns.clock_settime(clock_id, time: int)</tt></li>
<li><tt class="docutils literal">time_ns.monotonic()</tt></li>
<li><tt class="docutils literal">time_ns.perf_counter()</tt></li>
<li><tt class="docutils literal">time_ns.process_time()</tt></li>
<li><tt class="docutils literal">time_ns.time()</tt></li>
</ul>
<p>The first question is whether the <tt class="docutils literal">time_ns</tt> module should expose exactly
the same API (constants, functions, etc.) as the <tt class="docutils literal">time</tt> module. It can be
painful to maintain two flavors of the <tt class="docutils literal">time</tt> module. How are users use
supposed to make a choice between these two modules?</p>
<p>If tomorrow, other nanosecond variants are needed in the <tt class="docutils literal">os</tt> module,
will we have to add a new <tt class="docutils literal">os_ns</tt> module as well? There are functions
related to time in many modules: <tt class="docutils literal">time</tt>, <tt class="docutils literal">os</tt>, <tt class="docutils literal">signal</tt>,
<tt class="docutils literal">resource</tt>, <tt class="docutils literal">select</tt>, etc.</p>
<p>Another idea is to add a <tt class="docutils literal">time.ns</tt> submodule or a nested-namespace to
get the <tt class="docutils literal">time.ns.time()</tt> syntax, but it suffers from the same issues.</p>
</div>
</div>
<div class="section" id="annex-clocks-resolution-in-python">
<h1><a class="toc-backref" href="#id20">Annex: Clocks Resolution in Python</a></h1>
<p>This annex contains the resolution of clocks as measured in Python, and
not the resolution announced by the operating system or the resolution of
the internal structure used by the operating system.</p>
<div class="section" id="script">
<h2><a class="toc-backref" href="#id21">Script</a></h2>
<p>Example of script to measure the smallest difference between two
<tt class="docutils literal">time.time()</tt> and <tt class="docutils literal">time.time_ns()</tt> reads ignoring differences of zero:</p>
<pre class="literal-block">
import math
import time

LOOPS = 10 ** 6

print(&quot;time.time_ns(): %s&quot; % time.time_ns())
print(&quot;time.time(): %s&quot; % time.time())

min_dt = [abs(time.time_ns() - time.time_ns())
          for _ in range(LOOPS)]
min_dt = min(filter(bool, min_dt))
print(&quot;min time_ns() delta: %s ns&quot; % min_dt)

min_dt = [abs(time.time() - time.time())
          for _ in range(LOOPS)]
min_dt = min(filter(bool, min_dt))
print(&quot;min time() delta: %s ns&quot; % math.ceil(min_dt * 1e9))
</pre>
</div>
<div class="section" id="linux">
<h2><a class="toc-backref" href="#id22">Linux</a></h2>
<p>Clocks resolution measured in Python on Fedora 26 (kernel 4.12):</p>
<table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Function</th>
<th class="head">Resolution</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>clock()</td>
<td>1 us</td>
</tr>
<tr><td>monotonic()</td>
<td>81 ns</td>
</tr>
<tr><td>monotonic_ns()</td>
<td>84 ns</td>
</tr>
<tr><td>perf_counter()</td>
<td>82 ns</td>
</tr>
<tr><td>perf_counter_ns()</td>
<td>84 ns</td>
</tr>
<tr><td>process_time()</td>
<td>2 ns</td>
</tr>
<tr><td>process_time_ns()</td>
<td>1 ns</td>
</tr>
<tr><td>resource.getrusage()</td>
<td>1 us</td>
</tr>
<tr><td>time()</td>
<td><strong>239 ns</strong></td>
</tr>
<tr><td>time_ns()</td>
<td><strong>84 ns</strong></td>
</tr>
<tr><td>times().elapsed</td>
<td>10 ms</td>
</tr>
<tr><td>times().user</td>
<td>10 ms</td>
</tr>
</tbody>
</table>
<p>Notes on resolutions:</p>
<ul class="simple">
<li><tt class="docutils literal">clock()</tt> frequency is <tt class="docutils literal">CLOCKS_PER_SECOND</tt> which is 1,000,000 Hz
(1 MHz): resolution of 1 us.</li>
<li><tt class="docutils literal">times()</tt> frequency is <tt class="docutils literal"><span class="pre">os.sysconf(&quot;SC_CLK_TCK&quot;)</span></tt> (or the <tt class="docutils literal">HZ</tt>
constant) which is equal to 100 Hz: resolution of 10 ms.</li>
<li><tt class="docutils literal">resource.getrusage()</tt>, <tt class="docutils literal">os.wait3()</tt> and <tt class="docutils literal">os.wait4()</tt> use the
<tt class="docutils literal">ru_usage</tt> structure. The type of the <tt class="docutils literal">ru_usage.ru_utime</tt> and
<tt class="docutils literal">ru_usage.ru_stime</tt> fields is the <tt class="docutils literal">timeval</tt> structure which has a
resolution of 1 us.</li>
</ul>
</div>
<div class="section" id="windows">
<h2><a class="toc-backref" href="#id23">Windows</a></h2>
<p>Clocks resolution measured in Python on Windows 8.1:</p>
<table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="43%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Function</th>
<th class="head">Resolution</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>monotonic()</td>
<td>15 ms</td>
</tr>
<tr><td>monotonic_ns()</td>
<td>15 ms</td>
</tr>
<tr><td>perf_counter()</td>
<td>100 ns</td>
</tr>
<tr><td>perf_counter_ns()</td>
<td>100 ns</td>
</tr>
<tr><td>process_time()</td>
<td>15.6 ms</td>
</tr>
<tr><td>process_time_ns()</td>
<td>15.6 ms</td>
</tr>
<tr><td>time()</td>
<td><strong>894.1 us</strong></td>
</tr>
<tr><td>time_ns()</td>
<td><strong>318 us</strong></td>
</tr>
</tbody>
</table>
<p>The frequency of <tt class="docutils literal">perf_counter()</tt> and <tt class="docutils literal">perf_counter_ns()</tt> comes from
<tt class="docutils literal">QueryPerformanceFrequency()</tt>. The frequency is usually 10 MHz: resolution of
100 ns. In old Windows versions, the frequency was sometimes 3,579,545 Hz (3.6
MHz): resolution of 279 ns.</p>
</div>
<div class="section" id="analysis">
<h2><a class="toc-backref" href="#id24">Analysis</a></h2>
<p>The resolution of <tt class="docutils literal">time.time_ns()</tt> is much better than
<tt class="docutils literal">time.time()</tt>: <strong>84 ns (2.8x better) vs 239 ns on Linux and 318 us
(2.8x better) vs 894 us on Windows</strong>. The <tt class="docutils literal">time.time()</tt> resolution will
only become larger (worse) as years pass since every day adds
86,400,000,000,000 nanoseconds to the system clock, which increases the
precision loss.</p>
<p>The difference between <tt class="docutils literal">time.perf_counter()</tt>, <tt class="docutils literal">time.monotonic()</tt>,
<tt class="docutils literal">time.process_time()</tt> and their respective nanosecond variants is
not visible in this quick script since the script runs for less than 1
minute, and the uptime of the computer used to run the script was
smaller than 1 week.  A significant difference may be seen if uptime
reaches 104 days or more.</p>
<p><tt class="docutils literal">resource.getrusage()</tt> and <tt class="docutils literal">times()</tt> have a resolution greater or
equal to 1 microsecond, and so don't need a variant with nanosecond
resolution.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Internally, Python starts <tt class="docutils literal">monotonic()</tt> and <tt class="docutils literal">perf_counter()</tt>
clocks at zero on some platforms which indirectly reduce the
precision loss.</p>
</div>
</div>
</div>
<div class="section" id="links">
<h1><a class="toc-backref" href="#id25">Links</a></h1>
<ul class="simple">
<li><a class="reference external" href="https://bugs.python.org/issue31784">bpo-31784: Implementation of the PEP 564</a></li>
</ul>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id26">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
</div>

