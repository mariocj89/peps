<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">236</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Back to the __future__</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0236.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Tim Peters &lt;tim.peters&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">26-Feb-2001</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.1</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">26-Feb-2001</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#motivation" id="id14">Motivation</a></li>
<li><a class="reference internal" href="#intent" id="id15">Intent</a></li>
<li><a class="reference internal" href="#syntax" id="id16">Syntax</a></li>
<li><a class="reference internal" href="#semantics" id="id17">Semantics</a></li>
<li><a class="reference internal" href="#example" id="id18">Example</a></li>
<li><a class="reference internal" href="#standard-module-future-py" id="id19">Standard Module __future__.py</a></li>
<li><a class="reference internal" href="#resolved-problem-runtime-compilation" id="id20">Resolved Problem:  Runtime Compilation</a></li>
<li><a class="reference internal" href="#resolved-problem-native-interactive-shells" id="id21">Resolved Problem:  Native Interactive Shells</a></li>
<li><a class="reference internal" href="#resolved-problem-simulated-interactive-shells" id="id22">Resolved Problem:  Simulated Interactive Shells</a></li>
<li><a class="reference internal" href="#questions-and-answers" id="id23">Questions and Answers</a><ul>
<li><a class="reference internal" href="#what-about-a-from-past-version-to-get-back-old-behavior" id="id24">What about a &quot;from __past__&quot; version, to get back <em>old</em> behavior?</a></li>
<li><a class="reference internal" href="#what-about-incompatibilities-due-to-changes-in-the-python-virtual-machine" id="id25">What about incompatibilities due to changes in the Python virtual machine?</a></li>
<li><a class="reference internal" href="#what-about-incompatibilities-due-to-changes-in-python-s-c-api" id="id26">What about incompatibilities due to changes in Python's C API?</a></li>
<li><a class="reference internal" href="#i-want-to-wrap-future-statements-in-try-except-blocks-so-i-can-use-different-code-depending-on-which-version-of-python-i-m-running-why-can-t-i" id="id27">I want to wrap future_statements in try/except blocks, so I can use different code depending on which version of Python I'm running. Why can't I?</a></li>
<li><a class="reference internal" href="#going-back-to-the-nested-scopes-example-what-if-release-2-2-comes-along-and-i-still-haven-t-changed-my-code-how-can-i-keep-the-2-1-behavior-then" id="id28">Going back to the nested_scopes example, what if release 2.2 comes along and I still haven't changed my code?  How can I keep the 2.1 behavior then?</a></li>
<li><a class="reference internal" href="#overloading-import-sucks-why-not-introduce-a-new-statement-for-this" id="id29">Overloading <tt class="docutils literal">import</tt> sucks.  Why not introduce a new statement for this?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#copyright" id="id30">Copyright</a></li>
<li><a class="reference internal" href="#references-and-footnotes" id="id31">References and Footnotes</a></li>
</ul>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id14">Motivation</a></h1>
<p>From time to time, Python makes an incompatible change to the advertised
semantics of core language constructs, or changes their accidental
(implementation-dependent) behavior in some way.  While this is never done
capriciously, and is always done with the aim of improving the language over
the long term, over the short term it's contentious and disrupting.</p>
<p><a class="reference external" href="/dev/peps/pep-0005">PEP 5</a>, Guidelines for Language Evolution <a class="footnote-reference" href="#id9" id="id1">[1]</a> suggests ways to ease the pain,
and this PEP introduces some machinery in support of that.</p>
<p><a class="reference external" href="/dev/peps/pep-0227">PEP 227</a>, Statically Nested Scopes <a class="footnote-reference" href="#id10" id="id2">[2]</a> is the first application, and will be
used as an example here.</p>
</div>
<div class="section" id="intent">
<h1><a class="toc-backref" href="#id15">Intent</a></h1>
<p>[Note:  This is policy, and so should eventually move into <a class="reference external" href="/dev/peps/pep-0005">PEP 5</a> <a class="footnote-reference" href="#id9" id="id3">[1]</a>]</p>
<p>When an incompatible change to core language syntax or semantics is being
made:</p>
<ol class="arabic simple">
<li>The release C that introduces the change does not change the syntax or
semantics by default.</li>
<li>A future release R is identified in which the new syntax or semantics will
be enforced.</li>
<li>The mechanisms described in <a class="reference external" href="/dev/peps/pep-0003">PEP 3</a>, Warning Framework <a class="footnote-reference" href="#id11" id="id4">[3]</a> are used to
generate warnings, whenever possible, about constructs or operations whose
meaning may <a class="footnote-reference" href="#id12" id="id5">[4]</a> change in release R.</li>
<li>The new future_statement (see below) can be explicitly included in a module
M to request that the code in module M use the new syntax or semantics in
the current release C.</li>
</ol>
<p>So old code continues to work by default, for at least one release, although
it may start to generate new warning messages.  Migration to the new syntax or
semantics can proceed during that time, using the future_statement to make
modules containing it act as if the new syntax or semantics were already being
enforced.</p>
<p>Note that there is no need to involve the future_statement machinery in new
features unless they can break existing code; fully backward- compatible
additions can-- and should --be introduced without a corresponding
future_statement.</p>
</div>
<div class="section" id="syntax">
<h1><a class="toc-backref" href="#id16">Syntax</a></h1>
<p>A future_statement is simply a from/import statement using the reserved module
name <tt class="docutils literal">__future__</tt>:</p>
<pre class="literal-block">
future_statement: &quot;from&quot; &quot;__future__&quot; &quot;import&quot; feature [&quot;as&quot; name]
                  (&quot;,&quot;feature [&quot;as&quot; name])*

feature: identifier
name: identifier
</pre>
<p>In addition, all future_statments must appear near the top of the module.  The
only lines that can appear before a future_statement are:</p>
<ul class="simple">
<li>The module docstring (if any).</li>
<li>Comments.</li>
<li>Blank lines.</li>
<li>Other future_statements.</li>
</ul>
<p>Example:</p>
<pre class="literal-block">
&quot;&quot;&quot;This is a module docstring.&quot;&quot;&quot;

# This is a comment, preceded by a blank line and followed by
# a future_statement.
from __future__ import nested_scopes

from math import sin
from __future__ import alabaster_weenoblobs  # compile-time error!
# That was an error because preceded by a non-future_statement.
</pre>
</div>
<div class="section" id="semantics">
<h1><a class="toc-backref" href="#id17">Semantics</a></h1>
<p>A future_statement is recognized and treated specially at compile time:
changes to the semantics of core constructs are often implemented by
generating different code.  It may even be the case that a new feature
introduces new incompatible syntax (such as a new reserved word), in which
case the compiler may need to parse the module differently.  Such decisions
cannot be pushed off until runtime.</p>
<p>For any given release, the compiler knows which feature names have been
defined, and raises a compile-time error if a future_statement contains a
feature not known to it <a class="footnote-reference" href="#id13" id="id6">[5]</a>.</p>
<p>The direct runtime semantics are the same as for any <tt class="docutils literal">import</tt> statement:
there is a standard module <tt class="docutils literal">__future__.py</tt>, described later, and it will be
imported in the usual way at the time the future_statement is executed.</p>
<p>The <em>interesting</em> runtime semantics depend on the specific feature(s)
&quot;imported&quot; by the future_statement(s) appearing in the module.</p>
<p>Note that there is nothing special about the statement:</p>
<pre class="literal-block">
import __future__ [as name]
</pre>
<p>That is not a future_statement; it's an ordinary import statement, with no
special semantics or syntax restrictions.</p>
</div>
<div class="section" id="example">
<h1><a class="toc-backref" href="#id18">Example</a></h1>
<p>Consider this code, in file scope.py:</p>
<pre class="literal-block">
x = 42
def f():
    x = 666
    def g():
        print &quot;x is&quot;, x
    g()
f()
</pre>
<p>Under 2.0, it prints:</p>
<pre class="literal-block">
x is 42
</pre>
<p>Nested scopes <a class="footnote-reference" href="#id10" id="id7">[2]</a> are being introduced in 2.1.  But under 2.1, it still
prints:</p>
<pre class="literal-block">
x is 42
</pre>
<p>and also generates a warning.</p>
<p>In 2.2, and also in 2.1 <em>if</em> <tt class="docutils literal">from __future__ import nested_scopes</tt> is
included at the top of <tt class="docutils literal">scope.py</tt>, it prints:</p>
<pre class="literal-block">
x is 666
</pre>
</div>
<div class="section" id="standard-module-future-py">
<h1><a class="toc-backref" href="#id19">Standard Module __future__.py</a></h1>
<p><tt class="docutils literal">Lib/__future__.py</tt> is a real module, and serves three purposes:</p>
<ol class="arabic simple">
<li>To avoid confusing existing tools that analyze import statements and expect
to find the modules they're importing.</li>
<li>To ensure that future_statements run under releases prior to 2.1 at least
yield runtime exceptions (the import of <tt class="docutils literal">__future__</tt> will fail, because
there was no module of that name prior to 2.1).</li>
<li>To document when incompatible changes were introduced, and when they will
be-- or were --made mandatory.  This is a form of executable documentation,
and can be inspected programatically via importing <tt class="docutils literal">__future__</tt> and
examining its contents.</li>
</ol>
<p>Each statement in <tt class="docutils literal">__future__.py</tt> is of the form:</p>
<pre class="literal-block">
FeatureName = &quot;_Feature(&quot; OptionalRelease &quot;,&quot; MandatoryRelease &quot;)&quot;
</pre>
<p>where, normally, <em>OptionalRelease</em> &lt;  <em>MandatoryRelease</em>, and both are
5-tuples of the same form as <tt class="docutils literal">sys.version_info</tt>:</p>
<pre class="literal-block">
(PY_MAJOR_VERSION, # the 2 in 2.1.0a3; an int
 PY_MINOR_VERSION, # the 1; an int
 PY_MICRO_VERSION, # the 0; an int
 PY_RELEASE_LEVEL, # &quot;alpha&quot;, &quot;beta&quot;, &quot;candidate&quot; or &quot;final&quot;; string
 PY_RELEASE_SERIAL # the 3; an int )
</pre>
<p><em>OptionalRelease</em> records the first release in which:</p>
<pre class="literal-block">
from __future__ import FeatureName
</pre>
<p>was accepted.</p>
<p>In the case of <em>MandatoryReleases</em> that have not yet occurred,
<em>MandatoryRelease</em> predicts the release in which the feature will become part
of the language.</p>
<p>Else <em>MandatoryRelease</em> records when the feature became part of the language;
in releases at or after that, modules no longer need:</p>
<pre class="literal-block">
from __future__ import FeatureName
</pre>
<p>to use the feature in question, but may continue to use such imports.</p>
<p><em>MandatoryRelease</em> may also be <tt class="docutils literal">None</tt>, meaning that a planned feature got
dropped.</p>
<p>Instances of <tt class="docutils literal">class _Feature</tt> have two corresponding methods,
<tt class="docutils literal">.getOptionalRelease()</tt> and <tt class="docutils literal">.getMandatoryRelease()</tt>.</p>
<p>No feature line will ever be deleted from <tt class="docutils literal">__future__.py</tt>.</p>
<p>Example line:</p>
<pre class="literal-block">
nested_scopes = _Feature((2, 1, 0, &quot;beta&quot;, 1), (2, 2, 0, &quot;final&quot;, 0))
</pre>
<p>This means that:</p>
<pre class="literal-block">
from __future__ import nested_scopes
</pre>
<p>will work in all releases at or after 2.1b1, and that nested_scopes are
intended to be enforced starting in release 2.2.</p>
</div>
<div class="section" id="resolved-problem-runtime-compilation">
<h1><a class="toc-backref" href="#id20">Resolved Problem:  Runtime Compilation</a></h1>
<p>Several Python features can compile code during a module's runtime:</p>
<ol class="arabic simple">
<li>The <tt class="docutils literal">exec</tt> statement.</li>
<li>The <tt class="docutils literal">execfile()</tt> function.</li>
<li>The <tt class="docutils literal">compile()</tt> function.</li>
<li>The <tt class="docutils literal">eval()</tt> function.</li>
<li>The <tt class="docutils literal">input()</tt> function.</li>
</ol>
<p>Since a module M containing a future_statement naming feature F explicitly
requests that the current release act like a future release with respect to F,
any code compiled dynamically from text passed to one of these from within M
should probably also use the new syntax or semantics associated with F.  The
2.1 release does behave this way.</p>
<p>This isn't always desired, though.  For example, <tt class="docutils literal">doctest.testmod(M)</tt>
compiles examples taken from strings in M, and those examples should use M's
choices, not necessarily the doctest module's choices.  In the 2.1 release,
this isn't possible, and no scheme has yet been suggested for working around
this.  NOTE: <a class="reference external" href="/dev/peps/pep-0264">PEP 264</a> later addressed this in a flexible way, by adding
optional arguments to <tt class="docutils literal">compile()</tt>.</p>
<p>In any case, a future_statement appearing &quot;near the top&quot; (see Syntax above) of
text compiled dynamically by an <tt class="docutils literal">exec</tt>, <tt class="docutils literal">execfile()</tt> or <tt class="docutils literal">compile()</tt>
applies to the code block generated, but has no further effect on the module
that executes such an <tt class="docutils literal">exec</tt>, <tt class="docutils literal">execfile()</tt> or <tt class="docutils literal">compile()</tt>.  This can't
be used to affect <tt class="docutils literal">eval()</tt> or <tt class="docutils literal">input()</tt>, however, because they only allow
expression input, and a future_statement is not an expression.</p>
</div>
<div class="section" id="resolved-problem-native-interactive-shells">
<h1><a class="toc-backref" href="#id21">Resolved Problem:  Native Interactive Shells</a></h1>
<p>There are two ways to get an interactive shell:</p>
<ol class="arabic simple">
<li>By invoking Python from a command line without a script argument.</li>
<li>By invoking Python from a command line with the <tt class="docutils literal"><span class="pre">-i</span></tt> switch and with a
script argument.</li>
</ol>
<p>An interactive shell can be seen as an extreme case of runtime compilation
(see above):  in effect, each statement typed at an interactive shell prompt
runs a new instance of <tt class="docutils literal">exec</tt>, <tt class="docutils literal">compile()</tt> or <tt class="docutils literal">execfile()</tt>.  A
future_statement typed at an interactive shell applies to the rest of the
shell session's life, as if the future_statement had appeared at the top of a
module.</p>
</div>
<div class="section" id="resolved-problem-simulated-interactive-shells">
<h1><a class="toc-backref" href="#id22">Resolved Problem:  Simulated Interactive Shells</a></h1>
<p>Interactive shells &quot;built by hand&quot; (by tools such as IDLE and the Emacs
Python-mode) should behave like native interactive shells (see above).
However, the machinery used internally by native interactive shells has not
been exposed, and there isn't a clear way for tools building their own
interactive shells to achieve the desired behavior.</p>
<p>NOTE:  <a class="reference external" href="/dev/peps/pep-0264">PEP 264</a> later addressed this, by adding intelligence to the standard
<tt class="docutils literal">codeop.py</tt>.  Simulated shells that don't use the standard library shell
helpers can get a similar effect by exploiting the new optional arguments to
<tt class="docutils literal">compile()</tt> added by <a class="reference external" href="/dev/peps/pep-0264">PEP 264</a>.</p>
</div>
<div class="section" id="questions-and-answers">
<h1><a class="toc-backref" href="#id23">Questions and Answers</a></h1>
<div class="section" id="what-about-a-from-past-version-to-get-back-old-behavior">
<h2><a class="toc-backref" href="#id24">What about a &quot;from __past__&quot; version, to get back <em>old</em> behavior?</a></h2>
<p>Outside the scope of this PEP.  Seems unlikely to the author, though.  Write a
PEP if you want to pursue it.</p>
</div>
<div class="section" id="what-about-incompatibilities-due-to-changes-in-the-python-virtual-machine">
<h2><a class="toc-backref" href="#id25">What about incompatibilities due to changes in the Python virtual machine?</a></h2>
<p>Outside the scope of this PEP, although <a class="reference external" href="/dev/peps/pep-0005">PEP 5</a> <a class="footnote-reference" href="#id9" id="id8">[1]</a> suggests a grace period
there too, and the future_statement may also have a role to play there.</p>
</div>
<div class="section" id="what-about-incompatibilities-due-to-changes-in-python-s-c-api">
<h2><a class="toc-backref" href="#id26">What about incompatibilities due to changes in Python's C API?</a></h2>
<p>Outside the scope of this PEP.</p>
</div>
<div class="section" id="i-want-to-wrap-future-statements-in-try-except-blocks-so-i-can-use-different-code-depending-on-which-version-of-python-i-m-running-why-can-t-i">
<h2><a class="toc-backref" href="#id27">I want to wrap future_statements in try/except blocks, so I can use different code depending on which version of Python I'm running. Why can't I?</a></h2>
<p>Sorry!  <tt class="docutils literal">try/except</tt> is a runtime feature; future_statements are primarily
compile-time gimmicks, and your <tt class="docutils literal">try/except</tt> happens long after the compiler
is done.  That is, by the time you do <tt class="docutils literal">try/except</tt>, the semantics in effect
for the module are already a done deal.  Since the <tt class="docutils literal">try/except</tt> wouldn't
accomplish what it <em>looks</em> like it should accomplish, it's simply not allowed.
We also want to keep these special statements very easy to find and to
recognize.</p>
<p>Note that you <em>can</em> import <tt class="docutils literal">__future__</tt> directly, and use the information in
it, along with <tt class="docutils literal">sys.version_info</tt>, to figure out where the release you're
running under stands in relation to a given feature's status.</p>
</div>
<div class="section" id="going-back-to-the-nested-scopes-example-what-if-release-2-2-comes-along-and-i-still-haven-t-changed-my-code-how-can-i-keep-the-2-1-behavior-then">
<h2><a class="toc-backref" href="#id28">Going back to the nested_scopes example, what if release 2.2 comes along and I still haven't changed my code?  How can I keep the 2.1 behavior then?</a></h2>
<p>By continuing to use 2.1, and not moving to 2.2 until you do change your
code.  The purpose of future_statement is to make life easier for people who
keep current with the latest release in a timely fashion.  We don't hate you
if you don't, but your problems are much harder to solve, and somebody with
those problems will need to write a PEP addressing them.  future_statement is
aimed at a different audience.</p>
</div>
<div class="section" id="overloading-import-sucks-why-not-introduce-a-new-statement-for-this">
<h2><a class="toc-backref" href="#id29">Overloading <tt class="docutils literal">import</tt> sucks.  Why not introduce a new statement for this?</a></h2>
<p>Like maybe <tt class="docutils literal">lambda lambda nested_scopes</tt>?  That is, unless we introduce a
new keyword, we can't introduce an entirely new statement.  But if we
introduce a new keyword, that in itself would break old code.  That would be
too ironic to bear.  Yes, overloading <tt class="docutils literal">import</tt> does suck, but not as
energetically as the alternatives -- as is, future_statements are 100%
backward compatible.</p>
</div>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id30">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
</div>
<div class="section" id="references-and-footnotes">
<h1><a class="toc-backref" href="#id31">References and Footnotes</a></h1>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id3">2</a>, <a class="fn-backref" href="#id8">3</a>)</em> <a class="reference external" href="/dev/peps/pep-0005">PEP 5</a>, Guidelines for Language Evolution, Prescod
<a class="reference external" href="http://www.python.org/dev/peps/pep-0005/">http://www.python.org/dev/peps/pep-0005/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id7">2</a>)</em> <a class="reference external" href="/dev/peps/pep-0227">PEP 227</a>, Statically Nested Scopes, Hylton
<a class="reference external" href="http://www.python.org/dev/peps/pep-0227/">http://www.python.org/dev/peps/pep-0227/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td><a class="reference external" href="/dev/peps/pep-0230">PEP 230</a>, Warning Framework, Van Rossum
<a class="reference external" href="http://www.python.org/dev/peps/pep-0230/">http://www.python.org/dev/peps/pep-0230/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[4]</a></td><td>Note that this is <em>may</em> and not <em>will</em>:  better safe than sorry.  Of course
spurious warnings won't be generated when avoidable with reasonable cost.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[5]</a></td><td>This ensures that a future_statement run under a release prior to the
first one in which a given feature is known (but &gt;= 2.1) will raise a
compile-time error rather than silently do a wrong thing. If transported
to a release prior to 2.1, a runtime error will be raised because of the
failure to import <tt class="docutils literal">__future__</tt> (no such module existed in the standard
distribution before the 2.1 release, and the double underscores make it a
reserved name).</td></tr>
</tbody>
</table>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

