<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">245</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Python Interface Syntax</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0245.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Michel Pelletier &lt;michel&#32;&#97;t&#32;users.sourceforge.net&gt;</td>
</tr>
<tr class="field"><th class="field-name">Discussions-To:</th><td class="field-body"><a class="reference external" href="http://www.zope.org/Wikis/Interfaces">http://www.zope.org/Wikis/Interfaces</a></td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">11-Jan-2001</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.2</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">21-Mar-2001</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#rejection-notice" id="id17">Rejection Notice</a></li>
<li><a class="reference internal" href="#introduction" id="id18">Introduction</a></li>
<li><a class="reference internal" href="#overview" id="id19">Overview</a></li>
<li><a class="reference internal" href="#the-problem" id="id20">The Problem</a></li>
<li><a class="reference internal" href="#overview-of-the-interface-syntax" id="id21">Overview of the Interface Syntax</a></li>
<li><a class="reference internal" href="#interface-assertion" id="id22">Interface Assertion</a></li>
<li><a class="reference internal" href="#formal-interface-syntax" id="id23">Formal Interface Syntax</a></li>
<li><a class="reference internal" href="#classes-and-interfaces" id="id24">Classes and Interfaces</a></li>
<li><a class="reference internal" href="#interface-aware-built-ins" id="id25">Interface-aware built-ins</a></li>
<li><a class="reference internal" href="#backward-compatibility" id="id26">Backward Compatibility</a></li>
<li><a class="reference internal" href="#summary-of-proposed-changes-to-python" id="id27">Summary of Proposed Changes to Python</a></li>
<li><a class="reference internal" href="#risks" id="id28">Risks</a></li>
<li><a class="reference internal" href="#open-issues" id="id29">Open Issues</a><ul>
<li><a class="reference internal" href="#goals" id="id30">Goals</a></li>
<li><a class="reference internal" href="#syntax" id="id31">Syntax</a></li>
<li><a class="reference internal" href="#architecture" id="id32">Architecture</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dissenting-opinion" id="id33">Dissenting Opinion</a></li>
<li><a class="reference internal" href="#references" id="id34">References</a></li>
<li><a class="reference internal" href="#copyright" id="id35">Copyright</a></li>
</ul>
</div>
<div class="section" id="rejection-notice">
<h1><a class="toc-backref" href="#id17">Rejection Notice</a></h1>
<p>I'm rejecting this PEP.  It's been five years now.  While at some
point I expect that Python will have interfaces, it would be naive
to expect it to resemble the syntax in this PEP.  Also, <a class="reference external" href="/dev/peps/pep-0246">PEP 246</a> is
being rejected in favor of something completely different; interfaces
won't play a role in adaptation or whatever will replace it.  GvR.</p>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id18">Introduction</a></h1>
<p>This PEP describes a proposed syntax for creating interface
objects in Python.</p>
</div>
<div class="section" id="overview">
<h1><a class="toc-backref" href="#id19">Overview</a></h1>
<p>In addition to thinking about adding a static type system to
Python, the Types-SIG was also charged to devise an interface
system for Python.  In December of 1998, Jim Fulton released a
prototype interfaces system based on discussions from the SIG.
Many of the issues and background information on this discussion
and prototype can be found in the SIG archives <a class="footnote-reference" href="#id9" id="id1">[1]</a>.</p>
<p>Around the end of 2000, Digital Creations began thinking about
better component model designs for Zope <a class="footnote-reference" href="#id10" id="id2">[2]</a>.  Zope's future
component model relies heavily on interface objects.  This led to
further development of Jim's &quot;Scarecrow&quot; interfaces prototype.
Starting with version 2.3, Zope comes with an Interface package as
standard software.  Zope's Interface package is used as the
reference implementation for this PEP.</p>
<p>The syntax proposed by this PEP relies on syntax enhancements
describe in <a class="reference external" href="/dev/peps/pep-0232">PEP 232</a> <a class="footnote-reference" href="#id11" id="id3">[3]</a> and describes an underlying framework
which <a class="reference external" href="/dev/peps/pep-0233">PEP 233</a> <a class="footnote-reference" href="#id12" id="id4">[4]</a> could be based upon.  There is some work being
done with regard to interface objects and Proxy objects, so for
those optional parts of this PEP you may want to see <a class="footnote-reference" href="#id13" id="id5">[5]</a>.</p>
</div>
<div class="section" id="the-problem">
<h1><a class="toc-backref" href="#id20">The Problem</a></h1>
<p>Interfaces are important because they solve a number of problems
that arise while developing software:</p>
<ul class="simple">
<li>There are many implied interfaces in Python, commonly referred
to as &quot;protocols&quot;.  Currently determining those protocols is
based on implementation introspection, but often that also
fails.  For example, defining <tt class="docutils literal">__getitem__</tt> implies both a
sequence and a mapping (the former with sequential, integer
keys).  There is no way for the developer to be explicit about
which protocols the object intends to implement.</li>
<li>Python is limited, from the developer's point of view, by the
split between types and classes.  When types are expected, the
consumer uses code like 'type(foo) == type(&quot;&quot;)' to determine if
'foo' is a string.  When instances of classes are expected, the
consumer uses 'isinstance(foo, MyString)' to determine if 'foo'
is an instance of the 'MyString' class.  There is no unified
model for determining if an object can be used in a certain,
valid way.</li>
<li>Python's dynamic typing is very flexible and powerful, but it
does not have the advantage of static typed languages that
provide type checking.  Static typed languages provide you with
much more type safety, but are often overly verbose because
objects can only be generalized by common subclassing and used
specifically with casting (for example, in Java).</li>
</ul>
<p>There are also a number of documentation problems that interfaces
try to solve.</p>
<ul class="simple">
<li>Developers waste a lot of time looking at the source code of
your system to figure out how objects work.</li>
<li>Developers who are new to your system may misunderstand how your
objects work, causing, and possibly propagating, usage errors.</li>
<li>Because a lack of interfaces means usage is inferred from the
source, developers may end up using methods and attributes that
are meant for &quot;internal use only&quot;.</li>
<li>Code inspection can be hard, and very discouraging to novice
programmers trying to properly understand code written by gurus.</li>
<li>A lot of time is wasted when many people try very hard to
understand obscurity (like undocumented software).  Effort spend
up front documenting interfaces will save much of this time in
the end.</li>
</ul>
<p>Interfaces try to solve these problems by providing a way for you
to specify a contractual obligation for your object, documentation
on how to use an object, and a built-in mechanism for discovering
the contract and the documentation.</p>
<p>Python has very useful introspection features.  It is well known
that this makes exploring concepts in the interactive interpreter
easier, because Python gives you the ability to look at all kinds
of information about the objects: the type, doc strings, instance
dictionaries, base classes, unbound methods and more.</p>
<p>Many of these features are oriented toward introspecting, using
and changing the implementation of software, and one of them (&quot;doc
strings&quot;) is oriented toward providing documentation.  This
proposal describes an extension to this natural introspection
framework that describes an object's interface.</p>
</div>
<div class="section" id="overview-of-the-interface-syntax">
<h1><a class="toc-backref" href="#id21">Overview of the Interface Syntax</a></h1>
<p>For the most part, the syntax of interfaces is very much like the
syntax of classes, but future needs, or needs brought up in
discussion, may define new possibilities for interface syntax.</p>
<p>A formal BNF description of the syntax is givena later in the PEP,
for the purposes of illustration, here is an example of two
different interfaces created with the proposed syntax:</p>
<pre class="literal-block">
interface CountFishInterface:
    &quot;Fish counting interface&quot;

    def oneFish():
        &quot;Increments the fish count by one&quot;

    def twoFish():
        &quot;Increments the fish count by two&quot;

    def getFishCount():
        &quot;Returns the fish count&quot;

interface ColorFishInterface:
    &quot;Fish coloring interface&quot;

    def redFish():
        &quot;Sets the current fish color to red&quot;

    def blueFish():
        &quot;Sets the current fish color to blue&quot;

    def getFishColor():
        &quot;This returns the current fish color&quot;
</pre>
<p>This code, when evaluated, will create two interfaces called
<tt class="docutils literal">CountFishInterface</tt> and <tt class="docutils literal">ColorFishInterface</tt>. These interfaces
are defined by the <tt class="docutils literal">interface</tt> statement.</p>
<p>The prose documentation for the interfaces and their methods come
from doc strings.  The method signature information comes from the
signatures of the <tt class="docutils literal">def</tt> statements.  Notice how there is no body
for the def statements.  The interface does not implement a
service to anything; it merely describes one.  Documentation
strings on interfaces and interface methods are mandatory, a
'pass' statement cannot be provided.  The interface equivalent of
a pass statement is an empty doc string.</p>
<p>You can also create interfaces that &quot;extend&quot; other interfaces.
Here, you can see a new type of Interface that extends the
CountFishInterface and ColorFishInterface:</p>
<pre class="literal-block">
interface FishMarketInterface(CountFishInterface, ColorFishInterface):
    &quot;This is the documentation for the FishMarketInterface&quot;

    def getFishMonger():
        &quot;Returns the fish monger you can interact with&quot;

    def hireNewFishMonger(name):
        &quot;Hire a new fish monger&quot;

    def buySomeFish(quantity=1):
        &quot;Buy some fish at the market&quot;
</pre>
<p>The FishMarketInteface extends upon the CountFishInterface and
ColorfishInterface.</p>
</div>
<div class="section" id="interface-assertion">
<h1><a class="toc-backref" href="#id22">Interface Assertion</a></h1>
<p>The next step is to put classes and interfaces together by
creating a concrete Python class that asserts that it implements
an interface.  Here is an example FishMarket component that might
do this:</p>
<pre class="literal-block">
class FishError(Error):
    pass

class FishMarket implements FishMarketInterface:
    number = 0
    color = None
    monger_name = 'Crusty Barnacles'

    def __init__(self, number, color):
        self.number = number
        self.color = color

    def oneFish(self):
        self.number += 1

    def twoFish(self):
        self.number += 2

    def redFish(self):
        self.color = 'red'

    def blueFish(self):
        self.color = 'blue'

    def getFishCount(self):
        return self.number

    def getFishColor(self):
        return self.color

    def getFishMonger(self):
        return self.monger_name

    def hireNewFishMonger(self, name):
        self.monger_name = name

    def buySomeFish(self, quantity=1):
        if quantity &gt; self.count:
            raise FishError(&quot;There's not enough fish&quot;)
        self.count -= quantity
        return quantity
</pre>
<p>This new class, FishMarket defines a concrete class which
implements the FishMarketInterface.  The object following the
<tt class="docutils literal">implements</tt> statement is called an &quot;interface assertion&quot;.  An
interface assertion can be either an interface object, or tuple of
interface assertions.</p>
<p>The interface assertion provided in a <tt class="docutils literal">class</tt> statement like this
is stored in the class's <tt class="docutils literal">__implements__</tt> class attribute.  After
interpreting the above example, you would have a class statement
that can be examined like this with an 'implements' built-in
function:</p>
<pre class="literal-block">
&gt;&gt;&gt; FishMarket
&lt;class FishMarket at 8140f50&gt;
&gt;&gt;&gt; FishMarket.__implements__
(&lt;Interface FishMarketInterface at 81006f0&gt;,)
&gt;&gt;&gt; f = FishMarket(6, 'red')
&gt;&gt;&gt; implements(f, FishMarketInterface)
1
&gt;&gt;&gt;
</pre>
<p>A class can realize more than one interface.  For example, say you
had an interface called <tt class="docutils literal">ItemInterface</tt> that described how an
object worked as an item in a container object.  If you wanted to
assert that FishMarket instances realized the ItemInterface
interface as well as the FishMarketInterface, you can provide an
interface assertion that contained a tuple of interface objects to
the FishMarket class:</p>
<pre class="literal-block">
class FishMarket implements FishMarketInterface, ItemInterface:
    # ...
</pre>
<p>Interface assertions can also be used if you want to assert that
one class implements an interface, and all of the interfaces that
another class implements:</p>
<pre class="literal-block">
class MyFishMarket implements FishMarketInterface, ItemInterface:
    # ...

class YourFishMarket implements FooInterface, MyFishMarket.__implements__:
    # ...
</pre>
<p>This new class YourFishMarket, asserts that it implements the
FooInterface, as well as the interfaces implemented by the
MyFishMarket class.</p>
<p>It's worth going into a little bit more detail about interface
assertions.  An interface assertion is either an interface object,
or a tuple of interface assertions.  For example:</p>
<pre class="literal-block">
FooInterface

FooInterface, (BarInteface, BobInterface)

FooInterface, (BarInterface, (BobInterface, MyClass.__implements__))
</pre>
<p>Are all valid interface assertions.  When two interfaces define
the same attributes, the order in which information is preferred
in the assertion is from top-to-bottom, left-to-right.</p>
<p>There are other interface proposals that, in the need for
simplicity, have combined the notion of class and interface to
provide simple interface enforcement.  Interface objects have a
<tt class="docutils literal">deferred</tt> method that returns a deferred class that implements
this behavior:</p>
<pre class="literal-block">
&gt;&gt;&gt; FM = FishMarketInterface.deferred()
&gt;&gt;&gt; class MyFM(FM): pass

&gt;&gt;&gt; f = MyFM()
&gt;&gt;&gt; f.getFishMonger()
Traceback (innermost last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
Interface.Exceptions.BrokenImplementation:
An object has failed to implement interface FishMarketInterface

        The getFishMonger attribute was not provided.
&gt;&gt;&gt;
</pre>
<p>This provides for a bit of passive interface enforcement by
telling you what you forgot to do to implement that interface.</p>
</div>
<div class="section" id="formal-interface-syntax">
<h1><a class="toc-backref" href="#id23">Formal Interface Syntax</a></h1>
<p>Python syntax is defined in a modified BNF grammar notation
described in the Python Reference Manual <a class="footnote-reference" href="#id16" id="id6">[8]</a>.  This section
describes the proposed interface syntax using this grammar:</p>
<pre class="literal-block">
interfacedef:   &quot;interface&quot; interfacename [extends] &quot;:&quot; suite
extends:        &quot;(&quot; [expression_list] &quot;)&quot;
interfacename:  identifier
</pre>
<p>An interface definition is an executable statement.  It first
evaluates the extends list, if present.  Each item in the extends
list should evaluate to an interface object.</p>
<p>The interface's suite is then executed in a new execution frame
(see the Python Reference Manual, section 4.1), using a newly
created local namespace and the original global namespace.  When
the interface's suite finishes execution, its execution frame is
discarded but its local namespace is saved as interface elements.
An interface object is then created using the extends list for the
base interfaces and the saved interface elements.  The interface
name is bound to this interface object in the original local
namespace.</p>
<p>This PEP also proposes an extension to Python's 'class' statement:</p>
<pre class="literal-block">
classdef:    &quot;class&quot; classname [inheritance] [implements] &quot;:&quot; suite
implements:  &quot;implements&quot; implist
implist:     expression-list

classname,
inheritance,
suite,
expression-list:  see the Python Reference Manual
</pre>
<p>Before a class' suite is executed, the 'inheritance' and
'implements' statements are evaluated, if present.  The
'inheritance' behavior is unchanged as defined in Section 7.6 of
the Language Reference.</p>
<p>The 'implements', if present, is evaluated after inheritance.
This must evaluate to an interface specification, which is either
an interface, or a tuple of interface specifications.  If a valid
interface specification is present, the assertion is assigned to
the class object's '__implements__' attribute, as a tuple.</p>
<p>This PEP does not propose any changes to the syntax of function
definitions or assignments.</p>
</div>
<div class="section" id="classes-and-interfaces">
<h1><a class="toc-backref" href="#id24">Classes and Interfaces</a></h1>
<p>The example interfaces above do not describe any kind of behavior
for their methods, they just describe an interface that a typical
FishMarket object would realize.</p>
<p>You may notice a similarity between interfaces extending from
other interfaces and classes sub-classing from other classes.
This is a similar concept.  However it is important to note that
interfaces extend interfaces and classes subclass classes.  You
cannot extend a class or subclass an interface.  Classes and
interfaces are separate.</p>
<p>The purpose of a class is to share the implementation of how an
object works.  The purpose of an interface is to document how to
work with an object, not how the object is implemented.  It is
possible to have several different classes with very different
implementations realize the same interface.</p>
<p>It's also possible to implement one interface with many classes
that mix in pieces the functionality of the interface or,
conversely, it's possible to have one class implement many
interfaces.  Because of this, interfaces and classes should not be
confused or intermingled.</p>
</div>
<div class="section" id="interface-aware-built-ins">
<h1><a class="toc-backref" href="#id25">Interface-aware built-ins</a></h1>
<p>A useful extension to Python's list of built-in functions in the
light of interface objects would be <tt class="docutils literal">implements()</tt>.  This builtin
would expect two arguments, an object and an interface, and return
a true value if the object implements the interface, false
otherwise.  For example:</p>
<pre class="literal-block">
&gt;&gt;&gt; interface FooInterface: pass
&gt;&gt;&gt; class Foo implements FooInterface: pass
&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; implements(f, FooInterface)
1
</pre>
<p>Currently, this functionality exists in the reference
implementation as functions in the <tt class="docutils literal">Interface</tt> package, requiring
an &quot;import Interface&quot; to use it.  Its existence as a built-in
would be purely for a convenience, and not necessary for using
interfaces, and analogous to <tt class="docutils literal">isinstance()</tt> for classes.</p>
</div>
<div class="section" id="backward-compatibility">
<h1><a class="toc-backref" href="#id26">Backward Compatibility</a></h1>
<p>The proposed interface model does not introduce any backward
compatibility issues in Python.  The proposed syntax, however,
does.</p>
<p>Any existing code that uses <tt class="docutils literal">interface</tt> as an identifier will
break.  There may be other kinds of backwards incompatibility that
defining <tt class="docutils literal">interface</tt> as a new keyword will introduce.  This
extension to Python's syntax does not change any existing syntax
in any backward incompatible way.</p>
<p>The new <tt class="docutils literal">from __future__</tt> Python syntax <a class="footnote-reference" href="#id14" id="id7">[6]</a>, and the new warning
framework <a class="footnote-reference" href="#id15" id="id8">[7]</a> is ideal for resolving this backward
incompatibility.  To use interface syntax now, a developer could
use the statement:</p>
<pre class="literal-block">
from __future__ import interfaces
</pre>
<p>In addition, any code that uses the keyword <tt class="docutils literal">interface</tt> as an
identifier will be issued a warning from Python.  After the
appropriate period of time, the interface syntax would become
standard, the above import statement would do nothing, and any
identifiers named <tt class="docutils literal">interface</tt> would raise an exception.  This
period of time is proposed to be 24 months.</p>
</div>
<div class="section" id="summary-of-proposed-changes-to-python">
<h1><a class="toc-backref" href="#id27">Summary of Proposed Changes to Python</a></h1>
<p>Adding new <tt class="docutils literal">interface</tt> keyword and extending class syntax with
<tt class="docutils literal">implements</tt>.</p>
<p>Extending class interface to include <tt class="docutils literal">__implements__</tt>.</p>
<p>Add 'implements(obj, interface)' built-in.</p>
</div>
<div class="section" id="risks">
<h1><a class="toc-backref" href="#id28">Risks</a></h1>
<p>This PEP proposes adding one new keyword to the Python language,
<tt class="docutils literal">interface</tt>.  This will break code.</p>
</div>
<div class="section" id="open-issues">
<h1><a class="toc-backref" href="#id29">Open Issues</a></h1>
<div class="section" id="goals">
<h2><a class="toc-backref" href="#id30">Goals</a></h2>
</div>
<div class="section" id="syntax">
<h2><a class="toc-backref" href="#id31">Syntax</a></h2>
</div>
<div class="section" id="architecture">
<h2><a class="toc-backref" href="#id32">Architecture</a></h2>
</div>
</div>
<div class="section" id="dissenting-opinion">
<h1><a class="toc-backref" href="#id33">Dissenting Opinion</a></h1>
<p>This PEP has not yet been discussed on python-dev.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id34">References</a></h1>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/types-sig/1998-December/date.html">https://mail.python.org/pipermail/types-sig/1998-December/date.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="http://www.zope.org">http://www.zope.org</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="/dev/peps/pep-0232">PEP 232</a>, Function Attributes, Warsaw
<a class="reference external" href="http://www.python.org/dev/peps/pep-0232/">http://www.python.org/dev/peps/pep-0232/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td><a class="reference external" href="/dev/peps/pep-0233">PEP 233</a>, Python Online Help, Prescod
<a class="reference external" href="http://www.python.org/dev/peps/pep-0233/">http://www.python.org/dev/peps/pep-0233/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td><a class="reference external" href="http://www.lemburg.com/files/python/mxProxy.html">http://www.lemburg.com/files/python/mxProxy.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[6]</a></td><td><a class="reference external" href="/dev/peps/pep-0236">PEP 236</a>, Back to the __future__, Peters
<a class="reference external" href="http://www.python.org/dev/peps/pep-0236/">http://www.python.org/dev/peps/pep-0236/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[7]</a></td><td><a class="reference external" href="/dev/peps/pep-0230">PEP 230</a>, Warning Framework, van Rossum
<a class="reference external" href="http://www.python.org/dev/peps/pep-0236/">http://www.python.org/dev/peps/pep-0236/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[8]</a></td><td>Python Reference Manual
<a class="reference external" href="http://docs.python.org/reference/">http://docs.python.org/reference/</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id35">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

