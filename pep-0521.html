<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">521</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Managing global context via 'with' blocks in generators and coroutines</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0521.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Nathaniel J. Smith &lt;njs&#32;&#97;t&#32;pobox.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Deferred</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">27-Apr-2015</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.6</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">29-Apr-2015</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id3">Abstract</a></li>
<li><a class="reference internal" href="#specification" id="id4">Specification</a><ul>
<li><a class="reference internal" href="#nested-blocks" id="id5">Nested blocks</a></li>
<li><a class="reference internal" href="#other-changes" id="id6">Other changes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rationale" id="id7">Rationale</a><ul>
<li><a class="reference internal" href="#alternative-approaches" id="id8">Alternative approaches</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility" id="id9">Backwards compatibility</a></li>
<li><a class="reference internal" href="#interaction-with-pep-492" id="id10">Interaction with PEP 492</a></li>
<li><a class="reference internal" href="#references" id="id11">References</a></li>
<li><a class="reference internal" href="#copyright" id="id12">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id3">Abstract</a></h1>
<p>While we generally try to avoid global state when possible, there
nonetheless exist a number of situations where it is agreed to be the
best approach.  In Python, a standard pattern for handling such cases
is to store the global state in global or thread-local storage, and
then use <tt class="docutils literal">with</tt> blocks to limit modifications of this global state
to a single dynamic scope. Examples where this pattern is used include
the standard library's <tt class="docutils literal">warnings.catch_warnings</tt> and
<tt class="docutils literal">decimal.localcontext</tt>, NumPy's <tt class="docutils literal">numpy.errstate</tt> (which exposes
the error-handling settings provided by the IEEE 754 floating point
standard), and the handling of logging context or HTTP request context
in many server application frameworks.</p>
<p>However, there is currently no ergonomic way to manage such local
changes to global state when writing a generator or coroutine. For
example, this code:</p>
<pre class="literal-block">
def f():
    with warnings.catch_warnings():
        for x in g():
            yield x
</pre>
<p>may or may not successfully catch warnings raised by <tt class="docutils literal">g()</tt>, and may
or may not inadverdantly swallow warnings triggered elsewhere in the
code.  The context manager, which was intended to apply only to <tt class="docutils literal">f</tt>
and its callees, ends up having a dynamic scope that encompasses
arbitrary and unpredictable parts of its call<strong>ers</strong>. This problem
becomes particularly acute when writing asynchronous code, where
essentially all functions become coroutines.</p>
<p>Here, we propose to solve this problem by notifying context managers
whenever execution is suspended or resumed within their scope,
allowing them to restrict their effects appropriately.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id4">Specification</a></h1>
<p>Two new, optional, methods are added to the context manager protocol:
<tt class="docutils literal">__suspend__</tt> and <tt class="docutils literal">__resume__</tt>.  If present, these methods will be
called whenever a frame's execution is suspended or resumed from
within the context of the <tt class="docutils literal">with</tt> block.</p>
<p>More formally, consider the following code:</p>
<pre class="literal-block">
with EXPR as VAR:
    PARTIAL-BLOCK-1
    f((yield foo))
    PARTIAL-BLOCK-2
</pre>
<p>Currently this is equivalent to the following code (copied from <a class="reference external" href="/dev/peps/pep-0343">PEP 343</a>):</p>
<pre class="literal-block">
mgr = (EXPR)
exit = type(mgr).__exit__  # Not calling it yet
value = type(mgr).__enter__(mgr)
exc = True
try:
    try:
        VAR = value  # Only if &quot;as VAR&quot; is present
        PARTIAL-BLOCK-1
        f((yield foo))
        PARTIAL-BLOCK-2
    except:
        exc = False
        if not exit(mgr, *sys.exc_info()):
            raise
finally:
    if exc:
        exit(mgr, None, None, None)
</pre>
<p>This PEP proposes to modify <tt class="docutils literal">with</tt> block handling to instead become:</p>
<pre class="literal-block">
mgr = (EXPR)
exit = type(mgr).__exit__  # Not calling it yet
### --- NEW STUFF ---
if the_block_contains_yield_points:  # known statically at compile time
    suspend = getattr(type(mgr), &quot;__suspend__&quot;, lambda: None)
    resume = getattr(type(mgr), &quot;__resume__&quot;, lambda: None)
### --- END OF NEW STUFF ---
value = type(mgr).__enter__(mgr)
exc = True
try:
    try:
        VAR = value  # Only if &quot;as VAR&quot; is present
        PARTIAL-BLOCK-1
        ### --- NEW STUFF ---
        suspend(mgr)
        tmp = yield foo
        resume(mgr)
        f(tmp)
        ### --- END OF NEW STUFF ---
        PARTIAL-BLOCK-2
    except:
        exc = False
        if not exit(mgr, *sys.exc_info()):
            raise
finally:
    if exc:
        exit(mgr, None, None, None)
</pre>
<p>Analogous suspend/resume calls are also wrapped around the <tt class="docutils literal">yield</tt>
points embedded inside the <tt class="docutils literal">yield from</tt>, <tt class="docutils literal">await</tt>, <tt class="docutils literal">async with</tt>,
and <tt class="docutils literal">async for</tt> constructs.</p>
<div class="section" id="nested-blocks">
<h2><a class="toc-backref" href="#id5">Nested blocks</a></h2>
<p>Given this code:</p>
<pre class="literal-block">
def f():
    with OUTER:
        with INNER:
            yield VALUE
</pre>
<p>then we perform the following operations in the following sequence:</p>
<pre class="literal-block">
INNER.__suspend__()
OUTER.__suspend__()
yield VALUE
OUTER.__resume__()
INNER.__resume__()
</pre>
<p>Note that this ensures that the following is a valid refactoring:</p>
<pre class="literal-block">
def f():
    with OUTER:
        yield from g()

def g():
    with INNER
        yield VALUE
</pre>
<p>Similarly, <tt class="docutils literal">with</tt> statements with multiple context managers suspend
from right to left, and resume from left to right.</p>
</div>
<div class="section" id="other-changes">
<h2><a class="toc-backref" href="#id6">Other changes</a></h2>
<p>Appropriate <tt class="docutils literal">__suspend__</tt> and <tt class="docutils literal">__resume__</tt> methods are added to
<tt class="docutils literal">warnings.catch_warnings</tt> and <tt class="docutils literal">decimal.localcontext</tt>.</p>
</div>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id7">Rationale</a></h1>
<p>In the abstract, we gave an example of plausible but incorrect code:</p>
<pre class="literal-block">
def f():
    with warnings.catch_warnings():
        for x in g():
            yield x
</pre>
<p>To make this correct in current Python, we need to instead write
something like:</p>
<pre class="literal-block">
def f():
    with warnings.catch_warnings():
        it = iter(g())
    while True:
        with warnings.catch_warnings():
            try:
                x = next(it)
            except StopIteration:
                break
        yield x
</pre>
<p>OTOH, if this PEP is accepted then the original code will become
correct as-is.  Or if this isn't convincing, then here's another
example of broken code; fixing it requires even greater gyrations, and
these are left as an exercise for the reader:</p>
<pre class="literal-block">
async def test_foo_emits_warning():
    with warnings.catch_warnings(record=True) as w:
        await foo()
    assert len(w) == 1
    assert &quot;xyzzy&quot; in w[0].message
</pre>
<p>And notice that this last example isn't artificial at all -- this is
exactly how you write a test that an async/await-using coroutine
correctly raises a warning.  Similar issues arise for pretty much any
use of <tt class="docutils literal">warnings.catch_warnings</tt>, <tt class="docutils literal">decimal.localcontext</tt>, or
<tt class="docutils literal">numpy.errstate</tt> in async/await-using code.  So there's clearly a
real problem to solve here, and the growing prominence of async code
makes it increasingly urgent.</p>
<div class="section" id="alternative-approaches">
<h2><a class="toc-backref" href="#id8">Alternative approaches</a></h2>
<p>The main alternative that has been proposed is to create some kind of
&quot;task-local storage&quot;, analogous to &quot;thread-local storage&quot;
<a class="footnote-reference" href="#yury-task-local-proposal" id="id1">[1]</a>. In essence, the idea would be that the
event loop would take care to allocate a new &quot;task namespace&quot; for each
task it schedules, and provide an API to at any given time fetch the
namespace corresponding to the currently executing task.  While there
are many details to be worked out <a class="footnote-reference" href="#task-local-challenges" id="id2">[2]</a>, the basic
idea seems doable, and it is an especially natural way to handle the
kind of global context that arises at the top-level of async
application frameworks (e.g., setting up context objects in a web
framework).  But it also has a number of flaws:</p>
<ul>
<li><p class="first">It only solves the problem of managing global state for coroutines
that <tt class="docutils literal">yield</tt> back to an asynchronous event loop.  But there
actually isn't anything about this problem that's specific to
asyncio -- as shown in the examples above, simple generators run
into exactly the same issue.</p>
</li>
<li><p class="first">It creates an unnecessary coupling between event loops and code that
needs to manage global state. Obviously an async web framework needs
to interact with some event loop API anyway, so it's not a big deal
in that case. But it's weird that <tt class="docutils literal">warnings</tt> or <tt class="docutils literal">decimal</tt> or
NumPy should have to call into an async library's API to access
their internal state when they themselves involve no async code.
Worse, since there are multiple event loop APIs in common use, it
isn't clear how to choose which to integrate with.  (This could be
somewhat mitigated by CPython providing a standard API for creating
and switching &quot;task-local domains&quot; that asyncio, Twisted, tornado,
etc. could then work with.)</p>
</li>
<li><p class="first">It's not at all clear that this can be made acceptably fast.  NumPy
has to check the floating point error settings on every single
arithmetic operation.  Checking a piece of data in thread-local
storage is absurdly quick, because modern platforms have put massive
resources into optimizing this case (e.g. dedicating a CPU register
for this purpose); calling a method on an event loop to fetch a
handle to a namespace and then doing lookup in that namespace is
much slower.</p>
<p>More importantly, this extra cost would be paid on <em>every</em> access to
the global data, even for programs which are not otherwise using an
event loop at all.  This PEP's proposal, by contrast, only affects
code that actually mixes <tt class="docutils literal">with</tt> blocks and <tt class="docutils literal">yield</tt> statements,
meaning that the users who experience the costs are the same users
who also reap the benefits.</p>
</li>
</ul>
<p>On the other hand, such tight integration between task context and the
event loop does potentially allow other features that are beyond the
scope of the current proposal.  For example, an event loop could note
which task namespace was in effect when a task called <tt class="docutils literal">call_soon</tt>,
and arrange that the callback when run would have access to the same
task namespace.  Whether this is useful, or even well-defined in the
case of cross-thread calls (what does it mean to have task-local
storage accessed from two threads simultaneously?), is left as a
puzzle for event loop implementors to ponder -- nothing in this
proposal rules out such enhancements as well.  It does seem though
that such features would be useful primarily for state that already
has a tight integration with the event loop -- while we might want a
request id to be preserved across <tt class="docutils literal">call_soon</tt>, most people would not
expect:</p>
<pre class="literal-block">
with warnings.catch_warnings():
    loop.call_soon(f)
</pre>
<p>to result in <tt class="docutils literal">f</tt> being run with warnings disabled, which would be
the result if <tt class="docutils literal">call_soon</tt> preserved global context in general. It's
also unclear how this would even work given that the warnings context
manager <tt class="docutils literal">__exit__</tt> would be called before <tt class="docutils literal">f</tt>.</p>
<p>So this PEP takes the position that <tt class="docutils literal">__suspend__</tt>/<tt class="docutils literal">__resume__</tt>
and &quot;task-local storage&quot; are two complementary tools that are both
useful in different circumstances.</p>
</div>
</div>
<div class="section" id="backwards-compatibility">
<h1><a class="toc-backref" href="#id9">Backwards compatibility</a></h1>
<p>Because <tt class="docutils literal">__suspend__</tt> and <tt class="docutils literal">__resume__</tt> are optional and default to
no-ops, all existing context managers continue to work exactly as
before.</p>
<p>Speed-wise, this proposal adds additional overhead when entering a
<tt class="docutils literal">with</tt> block (where we must now check for the additional methods;
failed attribute lookup in CPython is rather slow, since it involves
allocating an <tt class="docutils literal">AttributeError</tt>), and additional overhead at
suspension points.  Since the position of <tt class="docutils literal">with</tt> blocks and
suspension points is known statically, the compiler can
straightforwardly optimize away this overhead in all cases except
where one actually has a <tt class="docutils literal">yield</tt> inside a <tt class="docutils literal">with</tt>. Furthermore,
because we only do attribute checks for <tt class="docutils literal">__suspend__</tt> and
<tt class="docutils literal">__resume__</tt> once at the start of a <tt class="docutils literal">with</tt> block, when these
attributes are undefined then the per-yield overhead can be optimized
down to a single C-level <tt class="docutils literal">if <span class="pre">(frame-&gt;needs_suspend_resume_calls)</span> {
... }</tt>. Therefore, we expect the overall overhead to be negligible.</p>
</div>
<div class="section" id="interaction-with-pep-492">
<h1>Interaction with <a class="reference external" href="/dev/peps/pep-0492">PEP 492</a></h1>
<p><a class="reference external" href="/dev/peps/pep-0492">PEP 492</a> added new asynchronous context managers, which are like
regular context managers, but instead of having regular methods
<tt class="docutils literal">__enter__</tt> and <tt class="docutils literal">__exit__</tt> they have coroutine methods
<tt class="docutils literal">__aenter__</tt> and <tt class="docutils literal">__aexit__</tt>.</p>
<p>Following this pattern, one might expect this proposal to add
<tt class="docutils literal">__asuspend__</tt> and <tt class="docutils literal">__aresume__</tt> coroutine methods. But this
doesn't make much sense, since the whole point is that <tt class="docutils literal">__suspend__</tt>
should be called before yielding our thread of execution and allowing
other code to run. The only thing we accomplish by making
<tt class="docutils literal">__asuspend__</tt> a coroutine is to make it possible for
<tt class="docutils literal">__asuspend__</tt> itself to yield. So either we need to recursively
call <tt class="docutils literal">__asuspend__</tt> from inside <tt class="docutils literal">__asuspend__</tt>, or else we need to
give up and allow these yields to happen without calling the suspend
callback; either way it defeats the whole point.</p>
<p>Well, with one exception: one possible pattern for coroutine code is
to call <tt class="docutils literal">yield</tt> in order to communicate with the coroutine runner,
but without actually suspending their execution (i.e., the coroutine
might know that the coroutine runner will resume them immediately
after processing the <tt class="docutils literal">yield</tt>ed message). An example of this is the
<tt class="docutils literal">curio.timeout_after</tt> async context manager, which yields a special
<tt class="docutils literal">set_timeout</tt> message to the curio kernel, and then the kernel
immediately (synchronously) resumes the coroutine which sent the
message. And from the user point of view, this timeout value acts just
like the kinds of global variables that motivated this PEP. But, there
is a crucal difference: this kind of async context manager is, by
definition, tightly integrated with the coroutine runner. So, the
coroutine runner can take over responsibility for keeping track of
which timeouts apply to which coroutines without any need for this PEP
at all (and this is indeed how curio.timeout_after works).</p>
<p>That leaves two reasonable approaches to handling async context managers:</p>
<ol class="arabic simple">
<li>Add plain <tt class="docutils literal">__suspend__</tt> and <tt class="docutils literal">__resume__</tt> methods.</li>
<li>Leave async context managers alone for now until we have more
experience with them.</li>
</ol>
<p>Either seems plausible, so out of laziness / <a class="reference external" href="http://martinfowler.com/bliki/Yagni.html">YAGNI</a> this PEP tentatively
proposes to stick with option (2).</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id11">References</a></h1>
<table class="docutils footnote" frame="void" id="yury-task-local-proposal" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="https://groups.google.com/forum/#!topic/python-tulip/zix5HQxtElg">https://groups.google.com/forum/#!topic/python-tulip/zix5HQxtElg</a>
<a class="reference external" href="https://github.com/python/asyncio/issues/165">https://github.com/python/asyncio/issues/165</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="task-local-challenges" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>For example, we would have to decide
whether there is a single task-local namespace shared by all users
(in which case we need a way for multiple third-party libraries to
adjudicate access to this namespace), or else if there are multiple
task-local namespaces, then we need some mechanism for each library
to arrange for their task-local namespaces to be created and
destroyed at appropriate moments.  The preliminary patch linked
from the github issue above doesn't seem to provide any mechanism
for such lifecycle management.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id12">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

