<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">237</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Unifying Long Integers and Integers</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0237.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Moshe Zadka, Guido van Rossum</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">11-Mar-2001</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.2</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">16-Mar-2001, 14-Aug-2001, 23-Aug-2001</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id3">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id4">Rationale</a></li>
<li><a class="reference internal" href="#implementation" id="id5">Implementation</a></li>
<li><a class="reference internal" href="#incompatibilities" id="id6">Incompatibilities</a></li>
<li><a class="reference internal" href="#literals" id="id7">Literals</a></li>
<li><a class="reference internal" href="#built-in-functions" id="id8">Built-in Functions</a></li>
<li><a class="reference internal" href="#c-api" id="id9">C API</a></li>
<li><a class="reference internal" href="#transition" id="id10">Transition</a></li>
<li><a class="reference internal" href="#overflowwarning" id="id11">OverflowWarning</a></li>
<li><a class="reference internal" href="#example" id="id12">Example</a></li>
<li><a class="reference internal" href="#resolved-issues" id="id13">Resolved Issues</a></li>
<li><a class="reference internal" href="#id1" id="id14">Implementation</a></li>
<li><a class="reference internal" href="#copyright" id="id15">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id3">Abstract</a></h1>
<p>Python currently distinguishes between two kinds of integers (ints): regular
or short ints, limited by the size of a C long (typically 32 or 64 bits), and
long ints, which are limited only by available memory.  When operations on
short ints yield results that don't fit in a C long, they raise an error.
There are some other distinctions too.  This PEP proposes to do away with most
of the differences in semantics, unifying the two types from the perspective
of the Python user.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id4">Rationale</a></h1>
<p>Many programs find a need to deal with larger numbers after the fact, and
changing the algorithms later is bothersome.  It can hinder performance in the
normal case, when all arithmetic is performed using long ints whether or not
they are needed.</p>
<p>Having the machine word size exposed to the language hinders portability.  For
examples Python source files and .pyc's are not portable between 32-bit and
64-bit machines because of this.</p>
<p>There is also the general desire to hide unnecessary details from the Python
user when they are irrelevant for most applications. An example is memory
allocation, which is explicit in C but automatic in Python, giving us the
convenience of unlimited sizes on strings, lists, etc.  It makes sense to
extend this convenience to numbers.</p>
<p>It will give new Python programmers (whether they are new to programming in
general or not) one less thing to learn before they can start using the
language.</p>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id5">Implementation</a></h1>
<p>Initially, two alternative implementations were proposed (one by each author):</p>
<ol class="arabic">
<li><p class="first">The <tt class="docutils literal">PyInt</tt> type's slot for a C long will be turned into a:</p>
<pre class="literal-block">
union {
    long i;
    struct {
        unsigned long length;
        digit digits[1];
    } bignum;
};
</pre>
<p>Only the <tt class="docutils literal"><span class="pre">n-1</span></tt> lower bits of the <tt class="docutils literal">long</tt> have any meaning; the top bit
is always set.  This distinguishes the <tt class="docutils literal">union</tt>.  All <tt class="docutils literal">PyInt</tt> functions
will check this bit before deciding which types of operations to use.</p>
</li>
<li><p class="first">The existing short and long int types remain, but operations return
a long int instead of raising <tt class="docutils literal">OverflowError</tt> when a result cannot be
represented as a short int.  A new type, <tt class="docutils literal">integer</tt>, may be introduced
that is an abstract base type of which both the <tt class="docutils literal">int</tt> and <tt class="docutils literal">long</tt>
implementation types are subclassed.  This is useful so that programs can
check integer-ness with a single test:</p>
<pre class="literal-block">
if isinstance(i, integer): ...
</pre>
</li>
</ol>
<p>After some consideration, the second implementation plan was selected, since
it is far easier to implement, is backwards compatible at the C API level, and
in addition can be implemented partially as a transitional measure.</p>
</div>
<div class="section" id="incompatibilities">
<h1><a class="toc-backref" href="#id6">Incompatibilities</a></h1>
<p>The following operations have (usually subtly) different semantics for short
and for long integers, and one or the other will have to be changed somehow.
This is intended to be an exhaustive list. If you know of any other operation
that differ in outcome depending on whether a short or a long int with the same
value is passed, please write the second author.</p>
<ul class="simple">
<li>Currently, all arithmetic operators on short ints except <tt class="docutils literal">&lt;&lt;</tt> raise
<tt class="docutils literal">OverflowError</tt> if the result cannot be represented as a short int.  This
will be changed to return a long int instead. The following operators can
currently raise <tt class="docutils literal">OverflowError</tt>: <tt class="docutils literal">x+y</tt>, <tt class="docutils literal"><span class="pre">x-y</span></tt>, <tt class="docutils literal">x*y</tt>, <tt class="docutils literal"><span class="pre">x**y</span></tt>,
<tt class="docutils literal">divmod(x, y)</tt>, <tt class="docutils literal">x/y</tt>, <tt class="docutils literal">x%y</tt>, and <tt class="docutils literal"><span class="pre">-x</span></tt>.  (The last four can only
overflow when the value <tt class="docutils literal"><span class="pre">-sys.maxint-1</span></tt> is involved.)</li>
<li>Currently, <tt class="docutils literal"><span class="pre">x&lt;&lt;n</span></tt> can lose bits for short ints.  This will be changed to
return a long int containing all the shifted-out bits, if returning a short
int would lose bits (where changing sign is considered a special case of
losing bits).</li>
<li>Currently, hex and oct literals for short ints may specify negative values;
for example <tt class="docutils literal">0xffffffff == <span class="pre">-1</span></tt> on a 32-bit machine.  This will be changed
to equal <tt class="docutils literal">0xffffffffL</tt> (<tt class="docutils literal"><span class="pre">2**32-1</span></tt>).</li>
<li>Currently, the <tt class="docutils literal">%u</tt>, <tt class="docutils literal">%x</tt>, <tt class="docutils literal">%X</tt> and <tt class="docutils literal">%o</tt> string formatting operators
and the <tt class="docutils literal">hex()</tt> and <tt class="docutils literal">oct()</tt> built-in functions behave differently for
negative numbers: negative short ints are formatted as unsigned C long,
while negative long ints are formatted with a minus sign.  This will be
changed to use the long int semantics in all cases (but without the trailing
<em>L</em> that currently distinguishes the output of <tt class="docutils literal">hex()</tt> and <tt class="docutils literal">oct()</tt> for
long ints).  Note that this means that <tt class="docutils literal">%u</tt> becomes an alias for <tt class="docutils literal">%d</tt>.
It will eventually be removed.</li>
<li>Currently, <tt class="docutils literal">repr()</tt> of a long int returns a string ending in <em>L</em> while
<tt class="docutils literal">repr()</tt> of a short int doesn't.  The <em>L</em> will be dropped; but not before
Python 3.0.</li>
<li>Currently, an operation with long operands will never return a short int.
This <em>may</em> change, since it allows some optimization.  (No changes have been
made in this area yet, and none are planned.)</li>
<li>The expression <tt class="docutils literal"><span class="pre">type(x).__name__</span></tt> depends on whether <em>x</em> is a short or a
long int.  Since implementation alternative 2 is chosen, this difference
will remain.  (In Python 3.0, we <em>may</em> be able to deploy a trick to hide the
difference, because it <em>is</em> annoying to reveal the difference to user code,
and more so as the difference between the two types is less visible.)</li>
<li>Long and short ints are handled different by the <tt class="docutils literal">marshal</tt> module, and by
the <tt class="docutils literal">pickle</tt> and <tt class="docutils literal">cPickle</tt> modules.  This difference will remain (at
least until Python 3.0).</li>
<li>Short ints with small values (typically between -1 and 99 inclusive) are
<em>interned</em> -- whenever a result has such a value, an existing short int with
the same value is returned.  This is not done for long ints with the same
values.  This difference will remain.  (Since there is no guarantee of this
interning, it is debatable whether this is a semantic difference -- but code
may exist that uses <tt class="docutils literal">is</tt> for comparisons of short ints and happens to work
because of this interning.  Such code may fail if used with long ints.)</li>
</ul>
</div>
<div class="section" id="literals">
<h1><a class="toc-backref" href="#id7">Literals</a></h1>
<p>A trailing <em>L</em> at the end of an integer literal will stop having any
meaning, and will be eventually become illegal.  The compiler will choose the
appropriate type solely based on the value. (Until Python 3.0, it will force
the literal to be a long; but literals without a trailing <em>L</em> may also be
long, if they are not representable as short ints.)</p>
</div>
<div class="section" id="built-in-functions">
<h1><a class="toc-backref" href="#id8">Built-in Functions</a></h1>
<p>The function <tt class="docutils literal">int()</tt> will return a short or a long int depending on the
argument value.  In Python 3.0, the function <tt class="docutils literal">long()</tt> will call the function
<tt class="docutils literal">int()</tt>; before then, it will continue to force the result to be a long int,
but otherwise work the same way as <tt class="docutils literal">int()</tt>. The built-in name <tt class="docutils literal">long</tt> will
remain in the language to represent the long implementation type (unless it is
completely eradicated in Python 3.0), but using the <tt class="docutils literal">int()</tt> function is
still recommended, since it will automatically return a long when needed.</p>
</div>
<div class="section" id="c-api">
<h1><a class="toc-backref" href="#id9">C API</a></h1>
<p>The C API remains unchanged; C code will still need to be aware of the
difference between short and long ints.  (The Python 3.0 C API will probably
be completely incompatible.)</p>
<p>The <tt class="docutils literal"><span class="pre">PyArg_Parse*()</span></tt> APIs already accept long ints, as long as they are
within the range representable by C ints or longs, so that functions taking C
int or long argument won't have to worry about dealing with Python longs.</p>
</div>
<div class="section" id="transition">
<h1><a class="toc-backref" href="#id10">Transition</a></h1>
<p>There are three major phases to the transition:</p>
<ol class="arabic simple">
<li>Short int operations that currently raise <tt class="docutils literal">OverflowError</tt> return a long
int value instead.  This is the only change in this phase.  Literals will
still distinguish between short and long ints.  The other semantic
differences listed above (including the behavior of <tt class="docutils literal">&lt;&lt;</tt>) will remain.
Because this phase only changes situations that currently raise
<tt class="docutils literal">OverflowError</tt>, it is assumed that this won't break existing code.
(Code that depends on this exception would have to be too convoluted to be
concerned about it.)  For those concerned about extreme backwards
compatibility, a command line option (or a call to the warnings module)
will allow a warning or an error to be issued at this point, but this is
off by default.</li>
<li>The remaining semantic differences are addressed.  In all cases the long
int semantics will prevail.  Since this will introduce backwards
incompatibilities which will break some old code, this phase may require a
future statement and/or warnings, and a prolonged transition phase.  The
trailing <em>L</em> will continue to be used for longs as input and by
<tt class="docutils literal">repr()</tt>.<ol class="upperalpha">
<li>Warnings are enabled about operations that will change their numeric
outcome in stage 2B, in particular <tt class="docutils literal">hex()</tt> and <tt class="docutils literal">oct()</tt>, <tt class="docutils literal">%u</tt>,
<tt class="docutils literal">%x</tt>, <tt class="docutils literal">%X</tt> and <tt class="docutils literal">%o</tt>, <tt class="docutils literal">hex</tt> and <tt class="docutils literal">oct</tt> literals in the
(inclusive) range <tt class="docutils literal">[sys.maxint+1, sys.maxint*2+1]</tt>, and left shifts
losing bits.</li>
<li>The new semantic for these operations are implemented. Operations that
give different results than before will <em>not</em> issue a warning.</li>
</ol>
</li>
<li>The trailing <em>L</em> is dropped from <tt class="docutils literal">repr()</tt>, and made illegal on input.
(If possible, the <tt class="docutils literal">long</tt> type completely disappears.) The trailing <em>L</em>
is also dropped from <tt class="docutils literal">hex()</tt> and <tt class="docutils literal">oct()</tt>.</li>
</ol>
<p>Phase 1 will be implemented in Python 2.2.</p>
<p>Phase 2 will be implemented gradually, with 2A in Python 2.3 and 2B in
Python 2.4.</p>
<p>Phase 3 will be implemented in Python 3.0 (at least two years after Python 2.4
is released).</p>
</div>
<div class="section" id="overflowwarning">
<h1><a class="toc-backref" href="#id11">OverflowWarning</a></h1>
<p>Here are the rules that guide warnings generated in situations that currently
raise <tt class="docutils literal">OverflowError</tt>.  This applies to transition phase 1.  Historical
note: despite that phase 1 was completed in Python 2.2, and phase 2A in Python
2.3, nobody noticed that OverflowWarning was still generated in Python 2.3.
It was finally disabled in Python 2.4.  The Python builtin
<tt class="docutils literal">OverflowWarning</tt>, and the corresponding C API <tt class="docutils literal">PyExc_OverflowWarning</tt>,
are no longer generated or used in Python 2.4, but will remain for the
(unlikely) case of user code until Python 2.5.</p>
<ul>
<li><p class="first">A new warning category is introduced, <tt class="docutils literal">OverflowWarning</tt>.  This is a
built-in name.</p>
</li>
<li><p class="first">If an int result overflows, an <tt class="docutils literal">OverflowWarning</tt> warning is issued, with a
message argument indicating the operation, e.g. &quot;integer addition&quot;.  This
may or may not cause a warning message to be displayed on <tt class="docutils literal">sys.stderr</tt>, or
may cause an exception to be raised, all under control of the <tt class="docutils literal"><span class="pre">-W</span></tt> command
line and the warnings module.</p>
</li>
<li><p class="first">The <tt class="docutils literal">OverflowWarning</tt> warning is ignored by default.</p>
</li>
<li><p class="first">The <tt class="docutils literal">OverflowWarning</tt> warning can be controlled like all warnings, via the
<tt class="docutils literal"><span class="pre">-W</span></tt> command line option or via the <tt class="docutils literal">warnings.filterwarnings()</tt> call.
For example:</p>
<pre class="literal-block">
python -Wdefault::OverflowWarning
</pre>
<p>cause the <tt class="docutils literal">OverflowWarning</tt> to be displayed the first time it occurs at a
particular source line, and:</p>
<pre class="literal-block">
python -Werror::OverflowWarning
</pre>
<p>cause the <tt class="docutils literal">OverflowWarning</tt> to be turned into an exception whenever it
happens.  The following code enables the warning from inside the program:</p>
<pre class="literal-block">
import warnings
warnings.filterwarnings(&quot;default&quot;, &quot;&quot;, OverflowWarning)
</pre>
<p>See the python <tt class="docutils literal">man</tt> page for the <tt class="docutils literal"><span class="pre">-W</span></tt> option and the <tt class="docutils literal">warnings</tt>
module documentation for <tt class="docutils literal">filterwarnings()</tt>.</p>
</li>
<li><p class="first">If the <tt class="docutils literal">OverflowWarning</tt> warning is turned into an error,
<tt class="docutils literal">OverflowError</tt> is substituted.  This is needed for backwards
compatibility.</p>
</li>
<li><p class="first">Unless the warning is turned into an exceptions, the result of the operation
(e.g., <tt class="docutils literal">x+y</tt>) is recomputed after converting the arguments to long ints.</p>
</li>
</ul>
</div>
<div class="section" id="example">
<h1><a class="toc-backref" href="#id12">Example</a></h1>
<p>If you pass a long int to a C function or built-in operation that takes an
integer, it will be treated the same as a short int as long as the value fits
(by virtue of how <tt class="docutils literal">PyArg_ParseTuple()</tt> is implemented).  If the long value
doesn't fit, it will still raise an <tt class="docutils literal">OverflowError</tt>.  For example:</p>
<pre class="literal-block">
def fact(n):
    if n &lt;= 1:
    return 1
return n*fact(n-1)

A = &quot;ABCDEFGHIJKLMNOPQ&quot;
n = input(&quot;Gimme an int: &quot;)
print A[fact(n)%17]
</pre>
<p>For <tt class="docutils literal">n &gt;= 13</tt>, this currently raises <tt class="docutils literal">OverflowError</tt> (unless the user
enters a trailing <em>L</em> as part of their input), even though the calculated
index would always be in <tt class="docutils literal">range(17)</tt>.  With the new approach this code will
do the right thing: the index will be calculated as a long int, but its value
will be in range.</p>
</div>
<div class="section" id="resolved-issues">
<h1><a class="toc-backref" href="#id13">Resolved Issues</a></h1>
<p>These issues, previously open, have been resolved.</p>
<ul>
<li><p class="first"><tt class="docutils literal">hex()</tt> and <tt class="docutils literal">oct()</tt> applied to longs will continue to produce a trailing
<em>L</em> until Python 3000.  The original text above wasn't clear about this,
but since it didn't happen in Python 2.4 it was thought better to leave it
alone.  BDFL pronouncement here:</p>
<p><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2006-June/065918.html">https://mail.python.org/pipermail/python-dev/2006-June/065918.html</a></p>
</li>
<li><p class="first">What to do about <tt class="docutils literal">sys.maxint</tt>?  Leave it in, since it is still relevant
whenever the distinction between short and long ints is still relevant (e.g.
when inspecting the type of a value).</p>
</li>
<li><p class="first">Should we remove <tt class="docutils literal">%u</tt> completely?  Remove it.</p>
</li>
<li><p class="first">Should we warn about <tt class="docutils literal">&lt;&lt;</tt> not truncating integers?  Yes.</p>
</li>
<li><p class="first">Should the overflow warning be on a portable maximum size?  No.</p>
</li>
</ul>
</div>
<div class="section" id="id1">
<h1><a class="toc-backref" href="#id14">Implementation</a></h1>
<p>The implementation work for the Python 2.x line is completed; phase 1 was
released with Python 2.2, phase 2A with Python 2.3, and phase 2B will be
released with Python 2.4 (and is already in CVS).</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id15">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

