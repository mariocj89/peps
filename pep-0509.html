<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">509</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Add a private version to dict</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0509.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Victor Stinner &lt;victor.stinner&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">4-January-2016</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.6</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id6">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id7">Rationale</a></li>
<li><a class="reference internal" href="#guard-example" id="id8">Guard example</a></li>
<li><a class="reference internal" href="#usage-of-the-dict-version" id="id9">Usage of the dict version</a><ul>
<li><a class="reference internal" href="#speedup-method-calls" id="id10">Speedup method calls</a></li>
<li><a class="reference internal" href="#specialized-functions-using-guards" id="id11">Specialized functions using guards</a></li>
<li><a class="reference internal" href="#pyjion" id="id12">Pyjion</a></li>
<li><a class="reference internal" href="#cython" id="id13">Cython</a></li>
<li><a class="reference internal" href="#unladen-swallow" id="id14">Unladen Swallow</a></li>
</ul>
</li>
<li><a class="reference internal" href="#changes" id="id15">Changes</a></li>
<li><a class="reference internal" href="#backwards-compatibility" id="id16">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#implementation-and-performance" id="id17">Implementation and Performance</a></li>
<li><a class="reference internal" href="#integer-overflow" id="id18">Integer overflow</a></li>
<li><a class="reference internal" href="#alternatives" id="id19">Alternatives</a><ul>
<li><a class="reference internal" href="#expose-the-version-at-python-level-as-a-read-only-version-property" id="id20">Expose the version at Python level as a read-only __version__ property</a></li>
<li><a class="reference internal" href="#add-a-version-to-each-dict-entry" id="id21">Add a version to each dict entry</a></li>
<li><a class="reference internal" href="#add-a-new-dict-subtype" id="id22">Add a new dict subtype</a></li>
</ul>
</li>
<li><a class="reference internal" href="#prior-art" id="id23">Prior Art</a><ul>
<li><a class="reference internal" href="#method-cache-and-type-version-tag" id="id24">Method cache and type version tag</a></li>
<li><a class="reference internal" href="#globals-builtins-cache" id="id25">Globals / builtins cache</a></li>
<li><a class="reference internal" href="#cached-globals-builtins-lookup" id="id26">Cached globals+builtins lookup</a></li>
<li><a class="reference internal" href="#guard-against-changing-dict-during-iteration" id="id27">Guard against changing dict during iteration</a></li>
<li><a class="reference internal" href="#pysizer" id="id28">PySizer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#discussion" id="id29">Discussion</a></li>
<li><a class="reference internal" href="#acceptance" id="id30">Acceptance</a></li>
<li><a class="reference internal" href="#copyright" id="id31">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id6">Abstract</a></h1>
<p>Add a new private version to the builtin <tt class="docutils literal">dict</tt> type, incremented at
each dictionary creation and at each dictionary change, to implement
fast guards on namespaces.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id7">Rationale</a></h1>
<p>In Python, the builtin <tt class="docutils literal">dict</tt> type is used by many instructions. For
example, the <tt class="docutils literal">LOAD_GLOBAL</tt> instruction looks up a variable in the
global namespace, or in the builtins namespace (two dict lookups).
Python uses <tt class="docutils literal">dict</tt> for the builtins namespace, globals namespace, type
namespaces, instance namespaces, etc. The local namespace (function
namespace) is usually optimized to an array, but it can be a dict too.</p>
<p>Python is hard to optimize because almost everything is mutable: builtin
functions, function code, global variables, local variables, ... can be
modified at runtime. Implementing optimizations respecting the Python
semantics requires to detect when &quot;something changes&quot;: we will call
these checks &quot;guards&quot;.</p>
<p>The speedup of optimizations depends on the speed of guard checks. This
PEP proposes to add a private version to dictionaries to implement fast
guards on namespaces.</p>
<p>Dictionary lookups can be skipped if the version does not change, which
is the common case for most namespaces. The version is globally unique,
so checking the version is also enough to verify that the namespace
dictionary was not replaced with a new dictionary.</p>
<p>When the dictionary version does not change, the performance of a guard
does not depend on the number of watched dictionary entries: the
complexity is O(1).</p>
<p>Example of optimization: copy the value of a global variable to function
constants.  This optimization requires a guard on the global variable to
check if it was modified after it was copied. If the global variable is
not modified, the function uses the cached copy. If the global variable
is modified, the function uses a regular lookup, and maybe also
deoptimizes the function (to remove the overhead of the guard check for
next function calls).</p>
<p>See the <a class="reference external" href="https://www.python.org/dev/peps/pep-0510/">PEP 510 -- Specialized functions with guards</a> for concrete usage of
guards to specialize functions and for a more general rationale on
Python static optimizers.</p>
</div>
<div class="section" id="guard-example">
<h1><a class="toc-backref" href="#id8">Guard example</a></h1>
<p>Pseudo-code of a fast guard to check if a dictionary entry was modified
(created, updated or deleted) using a hypothetical
<tt class="docutils literal">dict_get_version(dict)</tt> function:</p>
<pre class="literal-block">
UNSET = object()

class GuardDictKey:
    def __init__(self, dict, key):
        self.dict = dict
        self.key = key
        self.value = dict.get(key, UNSET)
        self.version = dict_get_version(dict)

    def check(self):
        &quot;&quot;&quot;Return True if the dictionary entry did not change
        and the dictionary was not replaced.&quot;&quot;&quot;

        # read the version of the dictionary
        version = dict_get_version(self.dict)
        if version == self.version:
            # Fast-path: dictionary lookup avoided
            return True

        # lookup in the dictionary
        value = self.dict.get(self.key, UNSET)
        if value is self.value:
            # another key was modified:
            # cache the new dictionary version
            self.version = version
            return True

        # the key was modified
        return False
</pre>
</div>
<div class="section" id="usage-of-the-dict-version">
<h1><a class="toc-backref" href="#id9">Usage of the dict version</a></h1>
<div class="section" id="speedup-method-calls">
<h2><a class="toc-backref" href="#id10">Speedup method calls</a></h2>
<p>Yury Selivanov wrote a <a class="reference external" href="https://bugs.python.org/issue26110">patch to optimize method calls</a>. The patch depends on the
<a class="reference external" href="https://bugs.python.org/issue26219">&quot;implement per-opcode cache in ceval&quot;</a> patch which requires dictionary
versions to invalidate the cache if the globals dictionary or the
builtins dictionary has been modified.</p>
<p>The cache also requires that the dictionary version is globally unique.
It is possible to define a function in a namespace and call it in a
different namespace, using <tt class="docutils literal">exec()</tt> with the <em>globals</em> parameter for
example. In this case, the globals dictionary was replaced and the cache
must also be invalidated.</p>
</div>
<div class="section" id="specialized-functions-using-guards">
<h2><a class="toc-backref" href="#id11">Specialized functions using guards</a></h2>
<p>The <a class="reference external" href="https://www.python.org/dev/peps/pep-0510/">PEP 510 -- Specialized functions with guards</a> proposes an API to support
specialized functions with guards. It allows to implement static
optimizers for Python without breaking the Python semantics.</p>
<p>The <a class="reference external" href="http://fatoptimizer.readthedocs.org/">fatoptimizer</a> of the <a class="reference external" href="http://faster-cpython.readthedocs.org/fat_python.html">FAT
Python</a> project
is an example of a static Python optimizer. It implements many
optimizations which require guards on namespaces:</p>
<ul class="simple">
<li>Call pure builtins: to replace <tt class="docutils literal"><span class="pre">len(&quot;abc&quot;)</span></tt> with <tt class="docutils literal">3</tt>, guards on
<tt class="docutils literal"><span class="pre">builtins.__dict__['len']</span></tt> and <tt class="docutils literal"><span class="pre">globals()['len']</span></tt> are required</li>
<li>Loop unrolling: to unroll the loop <tt class="docutils literal">for i in <span class="pre">range(...):</span> ...</tt>,
guards on <tt class="docutils literal"><span class="pre">builtins.__dict__['range']</span></tt> and <tt class="docutils literal"><span class="pre">globals()['range']</span></tt>
are required</li>
<li>etc.</li>
</ul>
</div>
<div class="section" id="pyjion">
<h2><a class="toc-backref" href="#id12">Pyjion</a></h2>
<p>According of Brett Cannon, one of the two main developers of Pyjion,
Pyjion can benefit from dictionary version to implement optimizations.</p>
<p><a class="reference external" href="https://github.com/Microsoft/Pyjion">Pyjion</a> is a JIT compiler for
Python based upon CoreCLR (Microsoft .NET Core runtime).</p>
</div>
<div class="section" id="cython">
<h2><a class="toc-backref" href="#id13">Cython</a></h2>
<p>Cython can benefit from dictionary version to implement optimizations.</p>
<p><a class="reference external" href="http://cython.org/">Cython</a> is an optimising static compiler for both
the Python programming language and the extended Cython programming
language.</p>
</div>
<div class="section" id="unladen-swallow">
<h2><a class="toc-backref" href="#id14">Unladen Swallow</a></h2>
<p>Even if dictionary version was not explicitly mentioned, optimizing
globals and builtins lookup was part of the Unladen Swallow plan:
&quot;Implement one of the several proposed schemes for speeding lookups of
globals and builtins.&quot; (source: <a class="reference external" href="https://code.google.com/p/unladen-swallow/wiki/ProjectPlan">Unladen Swallow ProjectPlan</a>).</p>
<p>Unladen Swallow is a fork of CPython 2.6.1 adding a JIT compiler
implemented with LLVM. The project stopped in 2011: <a class="reference external" href="http://qinsb.blogspot.com.au/2011/03/unladen-swallow-retrospective.html">Unladen Swallow
Retrospective</a>.</p>
</div>
</div>
<div class="section" id="changes">
<h1><a class="toc-backref" href="#id15">Changes</a></h1>
<p>Add a <tt class="docutils literal">ma_version_tag</tt> field to the <tt class="docutils literal">PyDictObject</tt> structure with
the C type <tt class="docutils literal">PY_UINT64_T</tt>, 64-bit unsigned integer. Add also a global
dictionary version.</p>
<p>Each time a dictionary is created, the global version is incremented and
the dictionary version is initialized to the global version.</p>
<p>Each time the dictionary content is modified, the global version must be
incremented and copied to the dictionary version. Dictionary methods
which can modify its content:</p>
<ul class="simple">
<li><tt class="docutils literal">clear()</tt></li>
<li><tt class="docutils literal">pop(key)</tt></li>
<li><tt class="docutils literal">popitem()</tt></li>
<li><tt class="docutils literal">setdefault(key, value)</tt></li>
<li><tt class="docutils literal">__delitem__(key)</tt></li>
<li><tt class="docutils literal">__setitem__(key, value)</tt></li>
<li><tt class="docutils literal"><span class="pre">update(...)</span></tt></li>
</ul>
<p>The choice of increasing or not the version when a dictionary method
does not change its content is left to the Python implementation. A
Python implementation can decide to not increase the version to avoid
dictionary lookups in guards. Examples of cases when dictionary methods
don't modify its content:</p>
<ul class="simple">
<li><tt class="docutils literal">clear()</tt> if the dict is already empty</li>
<li><tt class="docutils literal">pop(key)</tt> if the key does not exist</li>
<li><tt class="docutils literal">popitem()</tt> if the dict is empty</li>
<li><tt class="docutils literal">setdefault(key, value)</tt> if the key already exists</li>
<li><tt class="docutils literal">__delitem__(key)</tt> if the key does not exist</li>
<li><tt class="docutils literal">__setitem__(key, value)</tt> if the new value is identical to the
current value</li>
<li><tt class="docutils literal">update()</tt> if called without argument or if new values are identical
to current values</li>
</ul>
<p>Setting a key to a new value equals to the old value is also considered
as an operation modifying the dictionary content.</p>
<p>Two different empty dictionaries must have a different version to be
able to identify a dictionary just by its version. It allows to verify
in a guard that a namespace was not replaced without storing a strong
reference to the dictionary. Using a borrowed reference does not work:
if the old dictionary is destroyed, it is possible that a new dictionary
is allocated at the same memory address. By the way, dictionaries don't
support weak references.</p>
<p>The version increase must be atomic. In CPython, the Global Interpreter
Lock (GIL) already protects <tt class="docutils literal">dict</tt> methods to make changes atomic.</p>
<p>Example using a hypothetical <tt class="docutils literal">dict_get_version(dict)</tt> function:</p>
<pre class="literal-block">
&gt;&gt;&gt; d = {}
&gt;&gt;&gt; dict_get_version(d)
100
&gt;&gt;&gt; d['key'] = 'value'
&gt;&gt;&gt; dict_get_version(d)
101
&gt;&gt;&gt; d['key'] = 'new value'
&gt;&gt;&gt; dict_get_version(d)
102
&gt;&gt;&gt; del d['key']
&gt;&gt;&gt; dict_get_version(d)
103
</pre>
<p>The field is called <tt class="docutils literal">ma_version_tag</tt>, rather than <tt class="docutils literal">ma_version</tt>, to
suggest to compare it using <tt class="docutils literal">version_tag == old_version_tag</tt>, rather
than <tt class="docutils literal">version &lt;= old_version</tt> which becomes wrong after an integer
overflow.</p>
</div>
<div class="section" id="backwards-compatibility">
<h1><a class="toc-backref" href="#id16">Backwards Compatibility</a></h1>
<p>Since the <tt class="docutils literal">PyDictObject</tt> structure is not part of the stable ABI and
the new dictionary version not exposed at the Python scope, changes are
backward compatible.</p>
</div>
<div class="section" id="implementation-and-performance">
<h1><a class="toc-backref" href="#id17">Implementation and Performance</a></h1>
<p>The <a class="reference external" href="https://bugs.python.org/issue26058">issue #26058: PEP 509: Add ma_version_tag to PyDictObject</a> contains a patch implementing
this PEP.</p>
<p>On pybench and timeit microbenchmarks, the patch does not seem to add
any overhead on dictionary operations. For example, the following timeit
micro-benchmarks takes 318 nanoseconds before and after the change:</p>
<pre class="literal-block">
python3.6 -m timeit 'd={1: 0}; d[2]=0; d[3]=0; d[4]=0; del d[1]; del d[2]; d.clear()'
</pre>
<p>When the version does not change, <tt class="docutils literal">PyDict_GetItem()</tt> takes 14.8 ns for
a dictionary lookup, whereas a guard check only takes 3.8 ns. Moreover,
a guard can watch for multiple keys. For example, for an optimization
using 10 global variables in a function, 10 dictionary lookups costs 148
ns, whereas the guard still only costs 3.8 ns when the version does not
change (39x as fast).</p>
<p>The <a class="reference external" href="http://fatoptimizer.readthedocs.org/en/latest/fat.html">fat module</a> implements
such guards: <tt class="docutils literal">fat.GuardDict</tt> is based on the dictionary version.</p>
</div>
<div class="section" id="integer-overflow">
<h1><a class="toc-backref" href="#id18">Integer overflow</a></h1>
<p>The implementation uses the C type <tt class="docutils literal">PY_UINT64_T</tt> to store the version:
a 64 bits unsigned integer. The C code uses <tt class="docutils literal">version++</tt>. On integer
overflow, the version is wrapped to <tt class="docutils literal">0</tt> (and then continues to be
incremented) according to the C standard.</p>
<p>After an integer overflow, a guard can succeed whereas the watched
dictionary key was modified. The bug only occurs at a guard check if
there are exaclty <tt class="docutils literal">2 ** 64</tt> dictionary creations or modifications
since the previous guard check.</p>
<p>If a dictionary is modified every nanosecond, <tt class="docutils literal">2 ** 64</tt> modifications
takes longer than 584 years. Using a 32-bit version, it only takes 4
seconds. That's why a 64-bit unsigned type is also used on 32-bit
systems. A dictionary lookup at the C level takes 14.8 ns.</p>
<p>A risk of a bug every 584 years is acceptable.</p>
</div>
<div class="section" id="alternatives">
<h1><a class="toc-backref" href="#id19">Alternatives</a></h1>
<div class="section" id="expose-the-version-at-python-level-as-a-read-only-version-property">
<h2><a class="toc-backref" href="#id20">Expose the version at Python level as a read-only __version__ property</a></h2>
<p>The first version of the PEP proposed to expose the dictionary version
as a read-only <tt class="docutils literal">__version__</tt> property at Python level, and also to add
the property to <tt class="docutils literal">collections.UserDict</tt> (since this type must mimick
the <tt class="docutils literal">dict</tt> API).</p>
<p>There are multiple issues:</p>
<ul>
<li><p class="first">To be consistent and avoid bad surprises, the version must be added to
all mapping types. Implementing a new mapping type would require extra
work for no benefit, since the version is only required on the
<tt class="docutils literal">dict</tt> type in practice.</p>
</li>
<li><p class="first">All Python implementations would have to implement this new property,
it gives more work to other implementations, whereas they may not use
the dictionary version at all.</p>
</li>
<li><p class="first">Exposing the dictionary version at the Python level can lead the
false assumption on performances. Checking <tt class="docutils literal">dict.__version__</tt> at
the Python level is not faster than a dictionary lookup. A dictionary
lookup in Python has a cost of 48.7 ns and checking the version has a
cost of 47.5 ns, the difference is only 1.2 ns (3%):</p>
<pre class="literal-block">
$ python3.6 -m timeit -s 'd = {str(i):i for i in range(100)}' 'd[&quot;33&quot;] == 33'
10000000 loops, best of 3: 0.0487 usec per loop
$ python3.6 -m timeit -s 'd = {str(i):i for i in range(100)}' 'd.__version__ == 100'
10000000 loops, best of 3: 0.0475 usec per loop
</pre>
</li>
<li><p class="first">The <tt class="docutils literal">__version__</tt> can be wrapped on integer overflow. It is error
prone: using <tt class="docutils literal">dict.__version__ &lt;= guard_version</tt> is wrong,
<tt class="docutils literal">dict.__version__ == guard_version</tt> must be used instead to reduce
the risk of bug on integer overflow (even if the integer overflow is
unlikely in practice).</p>
</li>
</ul>
<p>Mandatory bikeshedding on the property name:</p>
<ul class="simple">
<li><tt class="docutils literal">__cache_token__</tt>: name proposed by Nick Coghlan, name coming from
<a class="reference external" href="https://docs.python.org/3/library/abc.html#abc.get_cache_token">abc.get_cache_token()</a>.</li>
<li><tt class="docutils literal">__version__</tt></li>
<li><tt class="docutils literal">__version_tag__</tt></li>
<li><tt class="docutils literal">__timestamp__</tt></li>
</ul>
</div>
<div class="section" id="add-a-version-to-each-dict-entry">
<h2><a class="toc-backref" href="#id21">Add a version to each dict entry</a></h2>
<p>A single version per dictionary requires to keep a strong reference to
the value which can keep the value alive longer than expected. If we add
also a version per dictionary entry, the guard can only store the entry
version (a simple integer) to avoid the strong reference to the value:
only strong references to the dictionary and to the key are needed.</p>
<p>Changes: add a <tt class="docutils literal">me_version_tag</tt> field to the <tt class="docutils literal">PyDictKeyEntry</tt>
structure, the field has the C type <tt class="docutils literal">PY_UINT64_T</tt>. When a key is
created or modified, the entry version is set to the dictionary version
which is incremented at any change (create, modify, delete).</p>
<p>Pseudo-code of a fast guard to check if a dictionary key was modified
using hypothetical <tt class="docutils literal">dict_get_version(dict)</tt> and
<tt class="docutils literal">dict_get_entry_version(dict)</tt> functions:</p>
<pre class="literal-block">
UNSET = object()

class GuardDictKey:
    def __init__(self, dict, key):
        self.dict = dict
        self.key = key
        self.dict_version = dict_get_version(dict)
        self.entry_version = dict_get_entry_version(dict, key)

    def check(self):
        &quot;&quot;&quot;Return True if the dictionary entry did not change
        and the dictionary was not replaced.&quot;&quot;&quot;

        # read the version of the dictionary
        dict_version = dict_get_version(self.dict)
        if dict_version == self.version:
            # Fast-path: dictionary lookup avoided
            return True

        # lookup in the dictionary to read the entry version
        entry_version = get_dict_key_version(dict, key)
        if entry_version == self.entry_version:
            # another key was modified:
            # cache the new dictionary version
            self.dict_version = dict_version
            self.entry_version = entry_version
            return True

        # the key was modified
        return False
</pre>
<p>The main drawback of this option is the impact on the memory footprint.
It increases the size of each dictionary entry, so the overhead depends
on the number of buckets (dictionary entries, used or not used). For
example, it increases the size of each dictionary entry by 8 bytes on
64-bit system.</p>
<p>In Python, the memory footprint matters and the trend is to reduce it.
Examples:</p>
<ul class="simple">
<li><a class="reference external" href="https://www.python.org/dev/peps/pep-0393/">PEP 393 -- Flexible String Representation</a></li>
<li><a class="reference external" href="https://www.python.org/dev/peps/pep-0412/">PEP 412 -- Key-Sharing Dictionary</a></li>
</ul>
</div>
<div class="section" id="add-a-new-dict-subtype">
<h2><a class="toc-backref" href="#id22">Add a new dict subtype</a></h2>
<p>Add a new <tt class="docutils literal">verdict</tt> type, subtype of <tt class="docutils literal">dict</tt>. When guards are needed,
use the <tt class="docutils literal">verdict</tt> for namespaces (module namespace, type namespace,
instance namespace, etc.) instead of <tt class="docutils literal">dict</tt>.</p>
<p>Leave the <tt class="docutils literal">dict</tt> type unchanged to not add any overhead (CPU, memory
footprint) when guards are not used.</p>
<p>Technical issue: a lot of C code in the wild, including CPython core,
expecting the exact <tt class="docutils literal">dict</tt> type. Issues:</p>
<ul class="simple">
<li><tt class="docutils literal">exec()</tt> requires a <tt class="docutils literal">dict</tt> for globals and locals. A lot of code
use <tt class="docutils literal"><span class="pre">globals={}</span></tt>. It is not possible to cast the <tt class="docutils literal">dict</tt> to a
<tt class="docutils literal">dict</tt> subtype because the caller expects the <tt class="docutils literal">globals</tt> parameter
to be modified (<tt class="docutils literal">dict</tt> is mutable).</li>
<li>C functions call directly <tt class="docutils literal">PyDict_xxx()</tt> functions, instead of calling
<tt class="docutils literal">PyObject_xxx()</tt> if the object is a <tt class="docutils literal">dict</tt> subtype</li>
<li><tt class="docutils literal">PyDict_CheckExact()</tt> check fails on <tt class="docutils literal">dict</tt> subtype, whereas some
functions require the exact <tt class="docutils literal">dict</tt> type.</li>
<li><tt class="docutils literal">Python/ceval.c</tt> does not completely supports dict subtypes for
namespaces</li>
</ul>
<p>The <tt class="docutils literal">exec()</tt> issue is a blocker issue.</p>
<p>Other issues:</p>
<ul class="simple">
<li>The garbage collector has a special code to &quot;untrack&quot; <tt class="docutils literal">dict</tt>
instances. If a <tt class="docutils literal">dict</tt> subtype is used for namespaces, the garbage
collector can be unable to break some reference cycles.</li>
<li>Some functions have a fast-path for <tt class="docutils literal">dict</tt> which would not be taken
for <tt class="docutils literal">dict</tt> subtypes, and so it would make Python a little bit
slower.</li>
</ul>
</div>
</div>
<div class="section" id="prior-art">
<h1><a class="toc-backref" href="#id23">Prior Art</a></h1>
<div class="section" id="method-cache-and-type-version-tag">
<h2><a class="toc-backref" href="#id24">Method cache and type version tag</a></h2>
<p>In 2007, Armin Rigo wrote a patch to implement a cache of methods. It
was merged into Python 2.6.  The patch adds a &quot;type attribute cache
version tag&quot; (<tt class="docutils literal">tp_version_tag</tt>) and a &quot;valid version tag&quot; flag to
types (the <tt class="docutils literal">PyTypeObject</tt> structure).</p>
<p>The type version tag is not exposed at the Python level.</p>
<p>The version tag has the C type <tt class="docutils literal">unsigned int</tt>. The cache is a global
hash table of 4096 entries, shared by all types. The cache is global to
&quot;make it fast, have a deterministic and low memory footprint, and be
easy to invalidate&quot;. Each cache entry has a version tag. A global
version tag is used to create the next version tag, it also has the C
type <tt class="docutils literal">unsigned int</tt>.</p>
<p>By default, a type has its &quot;valid version tag&quot; flag cleared to indicate
that the version tag is invalid. When the first method of the type is
cached, the version tag and the &quot;valid version tag&quot; flag are set. When a
type is modified, the &quot;valid version tag&quot; flag of the type and its
subclasses is cleared. Later, when a cache entry of these types is used,
the entry is removed because its version tag is outdated.</p>
<p>On integer overflow, the whole cache is cleared and the global version
tag is reset to <tt class="docutils literal">0</tt>.</p>
<p>See <a class="reference external" href="https://bugs.python.org/issue1685986">Method cache (issue #1685986)</a> and <a class="reference external" href="https://bugs.python.org/issue1700288">Armin's method cache
optimization updated for Python 2.6 (issue #1700288)</a>.</p>
</div>
<div class="section" id="globals-builtins-cache">
<h2><a class="toc-backref" href="#id25">Globals / builtins cache</a></h2>
<p>In 2010, Antoine Pitrou proposed a <a class="reference external" href="http://bugs.python.org/issue10401">Globals / builtins cache (issue
#10401)</a> which adds a private
<tt class="docutils literal">ma_version</tt> field to the <tt class="docutils literal">PyDictObject</tt> structure (<tt class="docutils literal">dict</tt> type),
the field has the C type <tt class="docutils literal">Py_ssize_t</tt>.</p>
<p>The patch adds a &quot;global and builtin cache&quot; to functions and frames, and
changes <tt class="docutils literal">LOAD_GLOBAL</tt> and <tt class="docutils literal">STORE_GLOBAL</tt> instructions to use the
cache.</p>
<p>The change on the <tt class="docutils literal">PyDictObject</tt> structure is very similar to this
PEP.</p>
</div>
<div class="section" id="cached-globals-builtins-lookup">
<h2><a class="toc-backref" href="#id26">Cached globals+builtins lookup</a></h2>
<p>In 2006, Andrea Griffini proposed a patch implementing a <a class="reference external" href="https://bugs.python.org/issue1616125">Cached
globals+builtins lookup optimization</a>.  The patch adds a private
<tt class="docutils literal">timestamp</tt> field to the <tt class="docutils literal">PyDictObject</tt> structure (<tt class="docutils literal">dict</tt> type),
the field has the C type <tt class="docutils literal">size_t</tt>.</p>
<p>Thread on python-dev: <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2006-December/070348.html">About dictionary lookup caching</a>
(December 2006).</p>
</div>
<div class="section" id="guard-against-changing-dict-during-iteration">
<h2><a class="toc-backref" href="#id27">Guard against changing dict during iteration</a></h2>
<p>In 2013, Serhiy Storchaka proposed <a class="reference external" href="https://bugs.python.org/issue19332">Guard against changing dict during
iteration (issue #19332)</a> which
adds a <tt class="docutils literal">ma_count</tt> field to the <tt class="docutils literal">PyDictObject</tt> structure (<tt class="docutils literal">dict</tt>
type), the field has the C type <tt class="docutils literal">size_t</tt>.  This field is incremented
when the dictionary is modified.</p>
</div>
<div class="section" id="pysizer">
<h2><a class="toc-backref" href="#id28">PySizer</a></h2>
<p><a class="reference external" href="http://pysizer.8325.org/">PySizer</a>: a memory profiler for Python,
Google Summer of Code 2005 project by Nick Smallbone.</p>
<p>This project has a patch for CPython 2.4 which adds <tt class="docutils literal">key_time</tt> and
<tt class="docutils literal">value_time</tt> fields to dictionary entries. It uses a global
process-wide counter for dictionaries, incremented each time that a
dictionary is modified. The times are used to decide when child objects
first appeared in their parent objects.</p>
</div>
</div>
<div class="section" id="discussion">
<h1><a class="toc-backref" href="#id29">Discussion</a></h1>
<p>Thread on the mailing lists:</p>
<ul class="simple">
<li>python-dev: <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2016-April/144250.html">Updated PEP 509</a></li>
<li>python-dev: <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2016-April/144137.html">RFC: PEP 509: Add a private version to dict</a></li>
<li>python-dev: <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2016-January/142685.html">PEP 509: Add a private version to dict</a>
(january 2016)</li>
<li>python-ideas: <a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2016-January/037702.html">RFC: PEP: Add dict.__version__</a>
(january 2016)</li>
</ul>
</div>
<div class="section" id="acceptance">
<h1><a class="toc-backref" href="#id30">Acceptance</a></h1>
<p>The PEP was <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2016-September/146298.html">accepted on 2016-09-07 by Guido van Rossum</a>.
The PEP implementation has since been committed to the repository.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id31">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
</div>

