<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">323</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Copyable Iterators</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0323.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Alex Martelli &lt;aleaxit&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Deferred</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">25-Oct-2003</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.5</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">29-Oct-2003</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#deferral" id="id5">Deferral</a></li>
<li><a class="reference internal" href="#abstract" id="id6">Abstract</a></li>
<li><a class="reference internal" href="#update-and-comments" id="id7">Update and Comments</a></li>
<li><a class="reference internal" href="#motivation" id="id8">Motivation</a></li>
<li><a class="reference internal" href="#specification" id="id9">Specification</a></li>
<li><a class="reference internal" href="#details" id="id10">Details</a></li>
<li><a class="reference internal" href="#rationale" id="id11">Rationale</a></li>
<li><a class="reference internal" href="#references" id="id12">References</a></li>
<li><a class="reference internal" href="#copyright" id="id13">Copyright</a></li>
</ul>
</div>
<div class="section" id="deferral">
<h1><a class="toc-backref" href="#id5">Deferral</a></h1>
<p>This PEP has been deferred. Copyable iterators are a nice idea, but after
four years, no implementation or widespread interest has emerged.</p>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id6">Abstract</a></h1>
<p>This PEP suggests that some iterator types should support shallow
copies of their instances by exposing a <tt class="docutils literal">__copy__</tt> method which meets
some specific requirements, and indicates how code using an iterator
might exploit such a <tt class="docutils literal">__copy__</tt> method when present.</p>
</div>
<div class="section" id="update-and-comments">
<h1><a class="toc-backref" href="#id7">Update and Comments</a></h1>
<p>Support for <tt class="docutils literal">__copy__</tt> was included in Py2.4's <tt class="docutils literal">itertools.tee()</tt>.</p>
<p>Adding <tt class="docutils literal">__copy__</tt> methods to existing iterators will change the
behavior under <tt class="docutils literal">tee()</tt>.  Currently, the copied iterators remain
tied to the original iterator.  If the original advances, then
so do all of the copies.  Good practice is to overwrite the
original so that anamolies don't result:  <tt class="docutils literal">a,b=tee(a)</tt>.
Code that doesn't follow that practice may observe a semantic
change if a <tt class="docutils literal">__copy__</tt> method is added to an iterator.</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id8">Motivation</a></h1>
<p>In Python up to 2.3, most built-in iterator types don't let the user
copy their instances.  User-coded iterators that do let their clients
call copy.copy on their instances may, or may not, happen to return,
as a result of the copy, a separate iterator object that may be
iterated upon independently from the original.</p>
<p>Currently, &quot;support&quot; for copy.copy in a user-coded iterator type is
almost invariably &quot;accidental&quot; -- i.e., the standard machinery of the
copy method in Python's standard library's copy module does build and
return a copy.  However, the copy will be independently iterable with
respect to the original only if calling <tt class="docutils literal">.next()</tt> on an instance of that
class happens to change instance state solely by rebinding some
attributes to new values, and not by mutating some attributes'
existing values.</p>
<p>For example, an iterator whose &quot;index&quot; state is held as an integer
attribute will probably give usable copies, since (integers being
immutable) <tt class="docutils literal">.next()</tt> presumably just rebinds that attribute.  On the
other hand, another iterator whose &quot;index&quot; state is held as a list
attribute will probably mutate the same list object when <tt class="docutils literal">.next()</tt>
executes, and therefore copies of such an iterator will not be
iterable separately and independently from the original.</p>
<p>Given this existing situation, <tt class="docutils literal">copy.copy(it)</tt> on some iterator object
isn't very useful, nor, therefore, is it at all widely used.  However,
there are many cases in which being able to get a &quot;snapshot&quot; of an
iterator, as a &quot;bookmark&quot;, so as to be able to keep iterating along
the sequence but later iterate again on the same sequence from the
bookmark onwards, is useful.  To support such &quot;bookmarking&quot;, module
itertools, in 2.4, has grown a 'tee' function, to be used as:</p>
<pre class="literal-block">
it, bookmark = itertools.tee(it)
</pre>
<p>The previous value of 'it' must not be used again, which is why this
typical usage idiom rebinds the name.  After this call, 'it' and
'bookmark' are independently-iterable iterators on the same underlying
sequence as the original value of 'it': this satisfies application
needs for &quot;iterator copying&quot;.</p>
<p>However, when itertools.tee can make no hypotheses about the nature of
the iterator it is passed as an argument, it must save in memory all
items through which one of the two 'teed' iterators, but not yet both,
have stepped.  This can be quite costly in terms of memory, if the two
iterators get very far from each other in their stepping; indeed, in
some cases it may be preferable to make a list from the iterator so as
to be able to step repeatedly through the subsequence, or, if that is
too costy in terms of memory, save items to disk, again in order to be
able to iterate through them repeatedly.</p>
<p>This PEP proposes another idea that will, in some important cases,
allow <tt class="docutils literal">itertools.tee</tt> to do its job with minimal cost in terms of
memory; user code may also occasionally be able to exploit the idea in
order to decide whether to copy an iterator, make a list from it, or
use an auxiliary disk file.</p>
<p>The key consideration is that some important iterators, such as those
which built-in function iter builds over sequences, would be
intrinsically easy to copy: just get another reference to the same
sequence, and a copy of the integer index.  However, in Python 2.3,
those iterators don't expose the state, and don't support <tt class="docutils literal">copy.copy</tt>.</p>
<p>The purpose of this PEP, therefore, is to have those iterator types
expose a suitable <tt class="docutils literal">__copy__</tt> method.  Similarly, user-coded iterator
types that can provide copies of their instances, suitable for
separate and independent iteration, with limited costs in time and
space, should also expose a suitable <tt class="docutils literal">__copy__</tt> method.  While
copy.copy also supports other ways to let a type control the way
its instances are copied, it is suggested, for simplicity, that
iterator types that support copying always do so by exposing a
<tt class="docutils literal">__copy__</tt> method, and not in the other ways <tt class="docutils literal">copy.copy</tt> supports.</p>
<p>Having iterators expose a suitable <tt class="docutils literal">__copy__</tt> when feasible will afford
easy optimization of itertools.tee and similar user code, as in:</p>
<pre class="literal-block">
def tee(it):
    it = iter(it)
    try: copier = it.__copy__
    except AttributeError:
        # non-copyable iterator, do all the needed hard work
        # [snipped!]
    else:
        return it, copier()
</pre>
<p>Note that this function does NOT call &quot;copy.copy(it)&quot;, which (even
after this PEP is implemented) might well still &quot;just happen to
succeed&quot;. for some iterator type that is implemented as a user-coded
class. without really supplying an adequate &quot;independently iterable&quot;
copy object as its result.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id9">Specification</a></h1>
<p>Any iterator type X may expose a method <tt class="docutils literal">__copy__</tt> that is callable
without arguments on any instance x of X.  The method should be
exposed if and only if the iterator type can provide copyability with
reasonably little computational and memory effort.  Furthermore, the
new object y returned by method <tt class="docutils literal">__copy__</tt> should be a new instance
of X that is iterable independently and separately from x, stepping
along the same &quot;underlying sequence&quot; of items.</p>
<p>For example, suppose a class Iter essentially duplicated the
functionality of the iter builtin for iterating on a sequence:</p>
<pre class="literal-block">
class Iter(object):

    def __init__(self, sequence):
        self.sequence = sequence
        self.index = 0

    def __iter__(self):
        return self

    def next(self):
        try: result = self.sequence[self.index]
        except IndexError: raise StopIteration
        self.index += 1
        return result
</pre>
<p>To make this Iter class compliant with this PEP, the following
addition to the body of class Iter would suffice:</p>
<pre class="literal-block">
def __copy__(self):
    result = self.__class__(self.sequence)
    result.index = self.index
    return result
</pre>
<p>Note that <tt class="docutils literal">__copy__</tt>, in this case, does not even try to copy the
sequence; if the sequence is altered while either or both of the
original and copied iterators are still stepping on it, the iteration
behavior is quite likely to go awry anyway -- it is not <tt class="docutils literal">__copy__</tt>'s
responsibility to change this normal Python behavior for iterators
which iterate on mutable sequences (that might, perhaps, be the
specification for a <tt class="docutils literal">__deepcopy__</tt> method of iterators, which, however,
this PEP does not deal with).</p>
<p>Consider also a &quot;random iterator&quot;, which provides a nonterminating
sequence of results from some method of a random instance, called
with given arguments:</p>
<pre class="literal-block">
class RandomIterator(object):

    def __init__(self, bound_method, *args):
        self.call = bound_method
        self.args = args

    def __iter__(self):
        return self

    def next(self):
        return self.call(*self.args)

    def __copy__(self):
        import copy, new
        im_self = copy.copy(self.call.im_self)
        method = new.instancemethod(self.call.im_func, im_self)
        return self.__class__(method, *self.args)
</pre>
<p>This iterator type is slightly more general than its name implies, as
it supports calls to any bound method (or other callable, but if the
callable is not a bound method, then method <tt class="docutils literal">__copy__</tt> will fail).  But
the use case is for the purpose of generating random streams, as in:</p>
<pre class="literal-block">
import random

def show5(it):
    for i, result in enumerate(it):
        print '%6.3f'%result,
        if i==4: break
    print

normit = RandomIterator(random.Random().gauss, 0, 1)
show5(normit)
copit = normit.__copy__()
show5(normit)
show5(copit)
</pre>
<p>which will display some output such as:</p>
<pre class="literal-block">
-0.536  1.936 -1.182 -1.690 -1.184
 0.666 -0.701  1.214  0.348  1.373
 0.666 -0.701  1.214  0.348  1.373
</pre>
<p>the key point being that the second and third lines are equal, because
the normit and copit iterators will step along the same &quot;underlying
sequence&quot;.  (As an aside, note that to get a copy of <tt class="docutils literal">self.call.im_self</tt>
we must use <tt class="docutils literal">copy.copy</tt>, NOT try getting at a <tt class="docutils literal">__copy__</tt> method directly,
because for example instances of <tt class="docutils literal">random.Random</tt> support copying via
<tt class="docutils literal">__getstate__</tt> and <tt class="docutils literal">__setstate__</tt>, NOT via <tt class="docutils literal">__copy__</tt>; indeed, using
copy.copy is the normal way to get a shallow copy of any object --
copyable iterators are different because of the already-mentioned
uncertainty about the result of <tt class="docutils literal">copy.copy</tt> supporting these &quot;copyable
iterator&quot; specs).</p>
</div>
<div class="section" id="details">
<h1><a class="toc-backref" href="#id10">Details</a></h1>
<p>Besides adding to the Python docs a recommendation that user-coded
iterator types support a <tt class="docutils literal">__copy__</tt> method (if and only if it can be
implemented with small costs in memory and runtime, and produce an
independently-iterable copy of an iterator object), this PEP's
implementation will specifically include the addition of copyability
to the iterators over sequences that built-in iter returns, and also
to the iterators over a dictionary returned by the methods <tt class="docutils literal">__iter__</tt>,
iterkeys, itervalues, and iteritems of built-in type dict.</p>
<p>Iterators produced by generator functions will not be copyable.
However, iterators produced by the new &quot;generator expressions&quot; of
Python 2.4 (<a class="reference external" href="/dev/peps/pep-0289">PEP 289</a> <a class="footnote-reference" href="#id4" id="id1">[3]</a>) should be copyable if their underlying
<tt class="docutils literal">iterator[s]</tt> are; the strict limitations on what is possible in a
generator expression, compared to the much vaster generality of a
generator, should make that feasible.  Similarly, the iterators
produced by the built-in function <tt class="docutils literal">enumerate</tt>, and certain functions
suppiled by module itertools, should be copyable if the underlying
iterators are.</p>
<p>The implementation of this PEP will also include the optimization of
the new itertools.tee function mentioned in the Motivation section.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id11">Rationale</a></h1>
<p>The main use case for (shallow) copying of an iterator is the same as
for the function <tt class="docutils literal">itertools.tee</tt> (new in 2.4).  User code will not
directly attempt to copy an iterator, because it would have to deal
separately with uncopyable cases; calling <tt class="docutils literal">itertools.tee</tt> will
internally perform the copy when appropriate, and implicitly fallback
to a maximally efficient non-copying strategy for iterators that are
not copyable.  (Occasionally, user code may want more direct control,
specifically in order to deal with non-copyable iterators by other
strategies, such as making a list or saving the sequence to disk).</p>
<p>A tee'd iterator may serve as a &quot;reference point&quot;, allowing processing
of a sequence to continue or resume from a known point, while the
other independent iterator can be freely advanced to &quot;explore&quot; a
further part of the sequence as needed.  A simple example: a generator
function which, given an iterator of numbers (assumed to be positive),
returns a corresponding iterator, each of whose items is the fraction
of the total corresponding to each corresponding item of the input
iterator.  The caller may pass the total as a value, if known in
advance; otherwise, the iterator returned by calling this generator
function will first compute the total.</p>
<pre class="literal-block">
def fractions(numbers, total=None):
    if total is None:
        numbers, aux = itertools.tee(numbers)
        total = sum(aux)
    total = float(total)
    for item in numbers:
        yield item / total
</pre>
<p>The ability to tee the numbers iterator allows this generator to
precompute the total, if needed, without necessarily requiring
O(N) auxiliary memory if the numbers iterator is copyable.</p>
<p>As another example of &quot;iterator bookmarking&quot;, consider a stream of
numbers with an occasional string as a &quot;postfix operator&quot; now and
then.  By far most frequent such operator is a '+', whereupon we must
sum all previous numbers (since the last previous operator if any, or
else since the start) and yield the result.  Sometimes we find a '*'
instead, which is the same except that the previous numbers must
instead be multiplied, not summed.</p>
<pre class="literal-block">
def filter_weird_stream(stream):
    it = iter(stream)
    while True:
        it, bookmark = itertools.tee(it)
        total = 0
        for item in it:
            if item=='+':
                yield total
                break
            elif item=='*':
                product = 1
                for item in bookmark:
                    if item=='*':
                        yield product
                        break
                    else:
                        product *= item
           else:
               total += item
</pre>
<p>Similar use cases of itertools.tee can support such tasks as
&quot;undo&quot; on a stream of commands represented by an iterator,
&quot;backtracking&quot; on the parse of a stream of tokens, and so on.
(Of course, in each case, one should also consider simpler
possibilities such as saving relevant portions of the sequence
into lists while stepping on the sequence with just one iterator,
depending on the details of one's task).</p>
<p>Here is an example, in pure Python, of how the 'enumerate'
built-in could be extended to support <tt class="docutils literal">__copy__</tt> if its underlying
iterator also supported <tt class="docutils literal">__copy__</tt>:</p>
<pre class="literal-block">
class enumerate(object):

    def __init__(self, it):
        self.it = iter(it)
        self.i = -1

    def __iter__(self):
        return self

    def next(self):
        self.i += 1
        return self.i, self.it.next()

    def __copy__(self):
        result = self.__class__.__new__()
        result.it = self.it.__copy__()
        result.i = self.i
        return result
</pre>
<p>Here is an example of the kind of &quot;fragility&quot; produced by &quot;accidental
copyability&quot; of an iterator -- the reason why one must NOT use
copy.copy expecting, if it succeeds, to receive as a result an
iterator which is iterable-on independently from the original.  Here
is an iterator class that iterates (in preorder) on &quot;trees&quot; which, for
simplicity, are just nested lists -- any item that's a list is treated
as a subtree, any other item as a leaf.</p>
<pre class="literal-block">
class ListreeIter(object):

    def __init__(self, tree):
        self.tree = [tree]
        self.indx = [-1]

    def __iter__(self):
        return self

    def next(self):
        if not self.indx:
            raise StopIteration
        self.indx[-1] += 1
        try:
            result = self.tree[-1][self.indx[-1]]
        except IndexError:
            self.tree.pop()
            self.indx.pop()
            return self.next()
        if type(result) is not list:
            return result
        self.tree.append(result)
        self.indx.append(-1)
        return self.next()
</pre>
<p>Now, for example, the following code:</p>
<pre class="literal-block">
import copy
x = [ [1,2,3], [4, 5, [6, 7, 8], 9], 10, 11, [12] ]

print 'showing all items:',
it = ListreeIter(x)
for i in it:
    print i,
    if i==6: cop = copy.copy(it)
print

print 'showing items &gt;6 again:'
for i in cop: print i,
print
</pre>
<p>does NOT work as intended -- the &quot;cop&quot; iterator gets consumed, and
exhausted, step by step as the original &quot;it&quot; iterator is, because
the accidental (rather than deliberate) copying performed by
<tt class="docutils literal">copy.copy</tt> shares, rather than duplicating the &quot;index&quot; list, which
is the mutable attribute <tt class="docutils literal">it.indx</tt> (a list of numerical indices).
Thus, this &quot;client code&quot; of the iterator, which attempts to iterate
twice over a portion of the sequence via a <tt class="docutils literal">copy.copy</tt> on the
iterator, is NOT correct.</p>
<p>Some correct solutions include using <tt class="docutils literal">itertools.tee</tt>, i.e., changing
the first for loop into:</p>
<pre class="literal-block">
for i in it:
    print i,
    if i==6:
        it, cop = itertools.tee(it)
        break
for i in it: print i,
</pre>
<p>(note that we MUST break the loop in two, otherwise we'd still
be looping on the ORIGINAL value of it, which must NOT be used
further after the call to tee!!!); or making a list, i.e.</p>
<pre class="literal-block">
for i in it:
    print i,
    if i==6:
        cop = lit = list(it)
        break
for i in lit: print i,
</pre>
<p>(again, the loop must be broken in two, since iterator 'it'
gets exhausted by the call <tt class="docutils literal">list(it)</tt>).</p>
<p>Finally, all of these solutions would work if Listiter supplied
a suitable <tt class="docutils literal">__copy__</tt> method, as this PEP recommends:</p>
<pre class="literal-block">
def __copy__(self):
    result = self.__class__.new()
    result.tree = copy.copy(self.tree)
    result.indx = copy.copy(self.indx)
    return result
</pre>
<p>There is no need to get any &quot;deeper&quot; in the copy, but the two
mutable &quot;index state&quot; attributes must indeed be copied in order
to achieve a &quot;proper&quot; (independently iterable) iterator-copy.</p>
<p>The recommended solution is to have class Listiter supply this
<tt class="docutils literal">__copy__</tt> method AND have client code use <tt class="docutils literal">itertools.tee</tt> (with
the split-in-two-parts loop as shown above).  This will make
client code maximally tolerant of different iterator types it
might be using AND achieve good performance for tee'ing of this
specific iterator type at the same time.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id12">References</a></h1>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Discussion on python-dev starting at post:
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2003-October/038969.html">https://mail.python.org/pipermail/python-dev/2003-October/038969.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>Online documentation for the copy module of the standard library:
<a class="reference external" href="http://docs.python.org/library/copy.html">http://docs.python.org/library/copy.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[3]</a></td><td><a class="reference external" href="/dev/peps/pep-0289">PEP 289</a>, Generator Expressions, Hettinger
<a class="reference external" href="http://www.python.org/dev/peps/pep-0289/">http://www.python.org/dev/peps/pep-0289/</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id13">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>

