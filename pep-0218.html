<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">218</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Adding a Built-In Set Object Type</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0218.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">gvwilson&#32;&#97;t&#32;ddj.com (Greg Wilson), python&#32;&#97;t&#32;rcn.com (Raymond Hettinger)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">31-Jul-2000</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.2</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id2">Introduction</a></li>
<li><a class="reference internal" href="#rationale" id="id3">Rationale</a></li>
<li><a class="reference internal" href="#proposal" id="id4">Proposal</a></li>
<li><a class="reference internal" href="#set-notation" id="id5">Set Notation</a></li>
<li><a class="reference internal" href="#history" id="id6">History</a></li>
<li><a class="reference internal" href="#mutability" id="id7">Mutability</a></li>
<li><a class="reference internal" href="#copyright" id="id8">Copyright</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id2">Introduction</a></h1>
<p>This PEP proposes adding a Set module to the standard Python
library, and to then make sets a built-in Python type if that
module is widely used.  After explaining why sets are desirable,
and why the common idiom of using dictionaries in their place is
inadequate, we describe how we intend built-in sets to work, and
then how the preliminary Set module will behave.  The last
section discusses the mutability (or otherwise) of sets and set
elements, and the solution which the Set module will implement.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id3">Rationale</a></h1>
<p>Sets are a fundamental mathematical structure, and are very
commonly used in algorithm specifications.  They are much less
frequently used in implementations, even when they are the &quot;right&quot;
structure.  Programmers frequently use lists instead, even when
the ordering information in lists is irrelevant, and by-value
lookups are frequent.  (Most medium-sized C programs contain a
depressing number of start-to-end searches through malloc'd
vectors to determine whether particular items are present or
not...)</p>
<p>Programmers are often told that they can implement sets as
dictionaries with &quot;don't care&quot; values.  Items can be added to
these &quot;sets&quot; by assigning the &quot;don't care&quot; value to them;
membership can be tested using <tt class="docutils literal">dict.has_key</tt>; and items can be
deleted using <tt class="docutils literal">del</tt>.  However, the other main operations on sets
(union, intersection, and difference) are not directly supported
by this representation, since their meaning is ambiguous for
dictionaries containing key/value pairs.</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id4">Proposal</a></h1>
<p>The long-term goal of this PEP is to add a built-in set type to
Python.  This type will be an unordered collection of unique
values, just as a dictionary is an unordered collection of
key/value pairs.</p>
<p>Iteration and comprehension will be implemented in the obvious
ways, so that:</p>
<pre class="literal-block">
for x in S:
</pre>
<p>will step through the elements of S in arbitrary order, while:</p>
<pre class="literal-block">
set(x**2 for x in S)
</pre>
<p>will produce a set containing the squares of all elements in S,
Membership will be tested using <tt class="docutils literal">in</tt> and <tt class="docutils literal">not in</tt>, and basic set
operations will be implemented by a mixture of overloaded
operators:</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<tbody valign="top">
<tr><td><tt class="docutils literal">|</tt></td>
<td>union</td>
</tr>
<tr><td><tt class="docutils literal">&amp;</tt></td>
<td>intersection</td>
</tr>
<tr><td><tt class="docutils literal">^</tt></td>
<td>symmetric difference</td>
</tr>
<tr><td><tt class="docutils literal">-</tt></td>
<td>asymmetric difference</td>
</tr>
<tr><td><tt class="docutils literal">== !=</tt></td>
<td>equality and inequality tests</td>
</tr>
<tr><td><tt class="docutils literal">&lt; &lt;= &gt;= &gt;</tt></td>
<td>subset and superset tests</td>
</tr>
</tbody>
</table>
<p>and methods:</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<tbody valign="top">
<tr><td><tt class="docutils literal">S.add(x)</tt></td>
<td>Add &quot;x&quot; to the set.</td>
</tr>
<tr><td><tt class="docutils literal">S.update(s)</tt></td>
<td>Add all elements of sequence &quot;s&quot; to the set.</td>
</tr>
<tr><td><tt class="docutils literal">S.remove(x)</tt></td>
<td>Remove &quot;x&quot; from the set.  If &quot;x&quot; is not
present, this method raises a <tt class="docutils literal">LookupError</tt>
exception.</td>
</tr>
<tr><td><tt class="docutils literal">S.discard(x)</tt></td>
<td>Remove &quot;x&quot; from the set if it is present, or
do nothing if it is not.</td>
</tr>
<tr><td><tt class="docutils literal">S.pop()</tt></td>
<td>Remove and return an arbitrary element,
raising a <tt class="docutils literal">LookupError</tt> if the element is
not present.</td>
</tr>
<tr><td><tt class="docutils literal">S.clear()</tt></td>
<td>Remove all elements from this set.</td>
</tr>
<tr><td><tt class="docutils literal">S.copy()</tt></td>
<td>Make a new set.</td>
</tr>
<tr><td><tt class="docutils literal">s.issuperset()</tt></td>
<td>Check for a superset relationship.</td>
</tr>
<tr><td><tt class="docutils literal">s.issubset()</tt></td>
<td>Check for a subset relationship.</td>
</tr>
</tbody>
</table>
<p>and two new built-in conversion functions:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<tbody valign="top">
<tr><td><tt class="docutils literal">set(x)</tt></td>
<td>Create a set containing the elements of the
collection &quot;x&quot;.</td>
</tr>
<tr><td><tt class="docutils literal">frozenset(x)</tt></td>
<td>Create an immutable set containing the elements
of the collection &quot;x&quot;.</td>
</tr>
</tbody>
</table>
<p>Notes:</p>
<ol class="arabic simple">
<li>We propose using the bitwise operators &quot;<tt class="docutils literal">|&amp;</tt>&quot; for intersection
and union.  While &quot;<tt class="docutils literal">+</tt>&quot; for union would be intuitive, &quot;<tt class="docutils literal">*</tt>&quot; for
intersection is not (very few of the people asked guessed what
it did correctly).</li>
<li>We considered using &quot;<tt class="docutils literal">+</tt>&quot; to add elements to a set, rather than
&quot;add&quot;.  However, Guido van Rossum pointed out that &quot;<tt class="docutils literal">+</tt>&quot; is
symmetric for other built-in types (although &quot;<tt class="docutils literal">*</tt>&quot; is not).  Use
of &quot;add&quot; will also avoid confusion between that operation and
set union.</li>
</ol>
</div>
<div class="section" id="set-notation">
<h1><a class="toc-backref" href="#id5">Set Notation</a></h1>
<p>The PEP originally proposed <tt class="docutils literal">{1,2,3}</tt> as the set notation and <tt class="docutils literal"><span class="pre">{-}</span></tt> for
the empty set.  Experience with Python 2.3's <tt class="docutils literal">sets.py</tt> showed that
the notation was not necessary.  Also, there was some risk of making
dictionaries less instantly recognizable.</p>
<p>It was also contemplated that the braced notation would support set
comprehensions; however, Python 2.4 provided generator expressions
which fully met that need and did so it a more general way.
(See <a class="reference external" href="/dev/peps/pep-0289">PEP 289</a> for details on generator expressions).</p>
<p>So, Guido ruled that there would not be a set syntax; however, the
issue could be revisited for Python 3000 (see <a class="reference external" href="/dev/peps/pep-3000">PEP 3000</a>).</p>
</div>
<div class="section" id="history">
<h1><a class="toc-backref" href="#id6">History</a></h1>
<p>To gain experience with sets, a pure python module was introduced
in Python 2.3.  Based on that implementation, the set and frozenset
types were introduced in Python 2.4.  The improvements are:</p>
<ul class="simple">
<li>Better hash algorithm for frozensets</li>
<li>More compact pickle format (storing only an element list
instead of a dictionary of key:value pairs where the value
is always <tt class="docutils literal">True</tt>).</li>
<li>Use a <tt class="docutils literal">__reduce__</tt> function so that deep copying is automatic.</li>
<li>The BaseSet concept was eliminated.</li>
<li>The <tt class="docutils literal">union_update()</tt> method became just <tt class="docutils literal">update()</tt>.</li>
<li>Auto-conversion between mutable and immutable sets was dropped.</li>
<li>The <tt class="docutils literal">_repr</tt> method was dropped (the need is met by the new
<tt class="docutils literal">sorted()</tt> built-in function).</li>
</ul>
<p>Tim Peters believes that the class's constructor should take a
single sequence as an argument, and populate the set with that
sequence's elements.  His argument is that in most cases,
programmers will be creating sets from pre-existing sequences, so
that this case should be the common one.  However, this would
require users to remember an extra set of parentheses when
initializing a set with known values:</p>
<pre class="literal-block">
&gt;&gt;&gt; Set((1, 2, 3, 4))       # case 1
</pre>
<p>On the other hand, feedback from a small number of novice Python
users (all of whom were very experienced with other languages)
indicates that people will find a &quot;parenthesis-free&quot; syntax more
natural:</p>
<pre class="literal-block">
&gt;&gt;&gt; Set(1, 2, 3, 4)         # case 2
</pre>
<p>Ultimately, we adopted the first strategy in which the initializer
takes a single iterable argument.</p>
</div>
<div class="section" id="mutability">
<h1><a class="toc-backref" href="#id7">Mutability</a></h1>
<p>The most difficult question to resolve in this proposal was
whether sets ought to be able to contain mutable elements.  A
dictionary's keys must be immutable in order to support fast,
reliable lookup.  While it would be easy to require set elements
to be immutable, this would preclude sets of sets (which are
widely used in graph algorithms and other applications).</p>
<p>Earlier drafts of <a class="reference external" href="/dev/peps/pep-0218">PEP 218</a> had only a single set type, but the
<tt class="docutils literal">sets.py</tt> implementation in Python 2.3 has two, Set and
ImmutableSet.  For Python 2.4, the new built-in types were named
<tt class="docutils literal">set</tt> and <tt class="docutils literal">frozenset</tt> which are slightly less cumbersome.</p>
<p>There are two classes implemented in the &quot;sets&quot; module.  Instances
of the Set class can be modified by the addition or removal of
elements, and the ImmutableSet class is &quot;frozen&quot;, with an
unchangeable collection of elements.  Therefore, an ImmutableSet
may be used as a dictionary key or as a set element, but cannot be
updated.  Both types of set require that their elements are
immutable, hashable objects.  Parallel comments apply to the &quot;set&quot;
and &quot;frozenset&quot; built-in types.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id8">Copyright</a></h1>
<p>This document has been placed in the Public Domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

