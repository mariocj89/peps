<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">505</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">None-aware operators</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0505.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Mark E. Haase &lt;mehaase&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Deferred</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">18-Sep-2015</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.8</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#pep-deferral" id="id11">PEP Deferral</a></li>
<li><a class="reference internal" href="#abstract" id="id12">Abstract</a></li>
<li><a class="reference internal" href="#background" id="id13">Background</a><ul>
<li><a class="reference internal" href="#specialness-of-none" id="id14">Specialness of <tt class="docutils literal">None</tt></a></li>
<li><a class="reference internal" href="#utility-of-none" id="id15">Utility of <tt class="docutils literal">None</tt></a></li>
<li><a class="reference internal" href="#behavior-in-other-languages" id="id16">Behavior In Other Languages</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rationale" id="id17">Rationale</a><ul>
<li><a class="reference internal" href="#existing-alternatives" id="id18">Existing Alternatives</a><ul>
<li><a class="reference internal" href="#or-operator" id="id19"><tt class="docutils literal">or</tt> Operator</a></li>
<li><a class="reference internal" href="#ternary-operator" id="id20">Ternary Operator</a></li>
</ul>
</li>
<li><a class="reference internal" href="#motivating-examples" id="id21">Motivating Examples</a></li>
<li><a class="reference internal" href="#usage-of-none-in-the-standard-library" id="id22">Usage Of <tt class="docutils literal">None</tt> In The Standard Library</a></li>
<li><a class="reference internal" href="#rejected-ideas" id="id23">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#none-aware-function-call" id="id24"><tt class="docutils literal">None</tt>-aware Function Call</a></li>
<li><a class="reference internal" href="#unary-postfix-operator" id="id25"><tt class="docutils literal">?</tt> Unary Postfix Operator</a></li>
<li><a class="reference internal" href="#haskell-style-maybe" id="id26">Haskell-style <tt class="docutils literal">Maybe</tt></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#specification" id="id27">Specification</a><ul>
<li><a class="reference internal" href="#operator-spelling" id="id28">Operator Spelling</a></li>
<li><a class="reference internal" href="#none-coalescing-operator" id="id29"><tt class="docutils literal">None</tt>-Coalescing Operator</a></li>
<li><a class="reference internal" href="#none-aware-attribute-access-operator" id="id30"><tt class="docutils literal">None</tt>-Aware Attribute Access Operator</a></li>
<li><a class="reference internal" href="#none-aware-index-access-slicing-operator" id="id31"><tt class="docutils literal">None</tt>-Aware Index Access/Slicing Operator</a></li>
<li><a class="reference internal" href="#generalized-coalescing" id="id32">Generalized Coalescing</a></li>
<li><a class="reference internal" href="#implementation" id="id33">Implementation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references" id="id34">References</a></li>
<li><a class="reference internal" href="#copyright" id="id35">Copyright</a></li>
</ul>
</div>
<div class="section" id="pep-deferral">
<h1><a class="toc-backref" href="#id11">PEP Deferral</a></h1>
<p>Further consideration of this PEP has been deferred until Python 3.8 at the
earliest.</p>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id12">Abstract</a></h1>
<p>Several modern programming languages have so-called &quot;<tt class="docutils literal">null</tt>-coalescing&quot; or
&quot;<tt class="docutils literal">null</tt>- aware&quot; operators, including C# <a class="footnote-reference" href="#id6" id="id1">[1]</a>, Dart <a class="footnote-reference" href="#id7" id="id2">[2]</a>, Perl, Swift, and PHP
(starting in version 7). These operators provide syntactic sugar for common
patterns involving null references.</p>
<ul class="simple">
<li>The &quot;<tt class="docutils literal">null</tt>-coalescing&quot; operator is a binary operator that returns its left
operand if it is not <tt class="docutils literal">null</tt>. Otherwise it returns its right operand.</li>
<li>The &quot;<tt class="docutils literal">null</tt>-aware member access&quot; operator accesses an instance member only
if that instance is non-<tt class="docutils literal">null</tt>. Otherwise it returns <tt class="docutils literal">null</tt>. (This is also
called a &quot;safe navigation&quot; operator.)</li>
<li>The &quot;<tt class="docutils literal">null</tt>-aware index access&quot; operator accesses an element of a collection
only if that collection is non-<tt class="docutils literal">null</tt>. Otherwise it returns <tt class="docutils literal">null</tt>. (This
is another type of &quot;safe navigation&quot; operator.)</li>
</ul>
<p>The purpose of this PEP is to explore the possibility of implementing similar
operators in Python. It provides some background material and then offers
several competing alternatives for implementation.</p>
<p>The initial reaction to this idea is majority negative. Even if ultimately
rejected, this PEP still serves a purpose: to fully document the reasons why
Python should not add this behavior, so that it can be pointed to in the future
when the question inevitably arises again. (This is the null alternative, so to
speak!)</p>
<p>This proposal advances multiple alternatives, and it should be considered
severable. It may be accepted in whole or in part. For example, the safe
navigation operators might be rejected even if the <tt class="docutils literal">null</tt>-coalescing operator
is approved, or vice-versa.</p>
<p>Of course, Python does not have <tt class="docutils literal">null</tt>; it has <tt class="docutils literal">None</tt>, which is conceptually
distinct. Although this PEP is inspired by &quot;<tt class="docutils literal">null</tt>-aware&quot; operators in other
languages, it uses the term &quot;<tt class="docutils literal">None</tt>-aware&quot; operators to describe some
hypothetical Python implementations.</p>
</div>
<div class="section" id="background">
<h1><a class="toc-backref" href="#id13">Background</a></h1>
<div class="section" id="specialness-of-none">
<h2><a class="toc-backref" href="#id14">Specialness of <tt class="docutils literal">None</tt></a></h2>
<p>The Python language does not currently define any special behavior for <tt class="docutils literal">None</tt>.
This PEP suggests making <tt class="docutils literal">None</tt> a special case. This loss of generality is a
noticeable drawback of the proposal. A generalization of <tt class="docutils literal">None</tt>-aware
operators is set forth later in this document in order to avoid this
specialization.</p>
</div>
<div class="section" id="utility-of-none">
<h2><a class="toc-backref" href="#id15">Utility of <tt class="docutils literal">None</tt></a></h2>
<p>One common criticism of adding special syntax for <tt class="docutils literal">None</tt> is that <tt class="docutils literal">None</tt>
shouldn't be used in the first place: it's a code smell. A related criticism is
that <tt class="docutils literal">None</tt>-aware operators are used to silence errors (such as the novice
misunderstanding of an implicit <tt class="docutils literal">return None</tt>) akin to <a class="reference external" href="http://php.net/manual/en/language.operators.errorcontrol.php">PHP's &#64; operator</a>. Therefore,
the utility of <tt class="docutils literal">None</tt> must be debated before discussing whether to add new
behavior around it.</p>
<p>Python does not have any concept of <tt class="docutils literal">null</tt>. Every Python identifier must
refer to an instance, so there cannot be any <tt class="docutils literal">null</tt> references. Python does
have a special instance called <tt class="docutils literal">None</tt> that can be used to represent missing
values, but <tt class="docutils literal">None</tt> is conceptually distinct from <tt class="docutils literal">null</tt>.</p>
<p>The most frequent use of <tt class="docutils literal">None</tt> in Python is to provide a default value for
optional arguments when some other default object is unwieldy. For example:
<tt class="docutils literal">def get(url, proxy=None):</tt>. In this case, <tt class="docutils literal">proxy</tt> is an optional
argument. If <tt class="docutils literal">proxy</tt> is <tt class="docutils literal">None</tt>, then the request should be sent directly to
the server; otherwise, the request should be routed through the specified proxy
server. This use of <tt class="docutils literal">None</tt> is preferred here to some other sentinel value or
the Null Object Pattern. <a class="footnote-reference" href="#id8" id="id3">[3]</a></p>
<p>Examples of this form abound. Consider <tt class="docutils literal">types.py</tt> in the standard library:</p>
<pre class="literal-block">
def prepare_class(name, bases=(), kwds=None):
    if kwds is None:
        kwds = {}
    else:
        kwds = dict(kwds)
    ...
</pre>
<p>Another frequent use of <tt class="docutils literal">None</tt> is interfacing with external systems. Many of
those other systems have a concept of <tt class="docutils literal">null</tt>. Therefore, Python code must have
a way of representing <tt class="docutils literal">null</tt>, and typically it is represented by <tt class="docutils literal">None</tt>. For
example, databases can have <tt class="docutils literal">null</tt> values, and most Python database drivers
will convert <tt class="docutils literal">null</tt> to <tt class="docutils literal">None</tt> when retrieving data from a database, and will
convert from <tt class="docutils literal">None</tt> back to <tt class="docutils literal">null</tt> when sending data to a database.</p>
<p>This convention of interchanging <tt class="docutils literal">null</tt> and <tt class="docutils literal">None</tt> is widespread in Python.
It is canonized in the Python DBAPI (PEP-249). <a class="footnote-reference" href="#id9" id="id4">[4]</a> The <tt class="docutils literal">json</tt> module in the
standard library and the third party PyYAML package both use <tt class="docutils literal">None</tt> to
represent their respective languages' <tt class="docutils literal">null</tt>.</p>
<p>The C language <tt class="docutils literal">null</tt> often bleeds into Python, too, particularly for thin
wrappers around C libraries. For example, in <tt class="docutils literal">pyopenssl</tt>, the <tt class="docutils literal">X509</tt> class
has a <tt class="docutils literal">get_notBefore()</tt> <a class="reference external" href="https://github.com/pyca/pyopenssl/blob/3257877f8846e4357b495fa6c9344d01b11cf16d/OpenSSL/crypto.py#L1219">method</a> that returns
either a timestamp or <tt class="docutils literal">None</tt>. This function is a thin wrapper around an
OpenSSL function with the return type <tt class="docutils literal">ASN1_TIME *</tt>. Because this C pointer
may be <tt class="docutils literal">null</tt>, the Python wrapper must be able to represent <tt class="docutils literal">null</tt>, and
<tt class="docutils literal">None</tt> is the chosen representation.</p>
<p>The representation of <tt class="docutils literal">null</tt> is particularly noticeable when Python code is
marshalling data between two systems. For example, consider a Python server that
fetches data from a database and converts it to JSON for consumption by another
process. In this case, it's often desirable that <tt class="docutils literal">null</tt> in the database can be
easily translated to <tt class="docutils literal">null</tt> in JSON. If <tt class="docutils literal">None</tt> is not used for this purpose,
then each package will have to define its own representation of <tt class="docutils literal">null</tt>, and
converting between these representations adds unnecessary complexity to the
Python glue code.</p>
<p>Therefore, the preference for avoiding <tt class="docutils literal">None</tt> is nothing more than a
preference. <tt class="docutils literal">None</tt> has legitimate uses, particularly in specific types of
software. Any hypothetical <tt class="docutils literal">None</tt>-aware operators should be construed as
syntactic sugar for simplifying common patterns involving <tt class="docutils literal">None</tt>, and <em>should
not be construed</em> as error handling behavior.</p>
</div>
<div class="section" id="behavior-in-other-languages">
<h2><a class="toc-backref" href="#id16">Behavior In Other Languages</a></h2>
<p>Given that <tt class="docutils literal">null</tt>-aware operators exist in other modern languages, it may be
helpful to quickly understand how they work in those languages:</p>
<pre class="literal-block">
/* Null-coalescing. */

String s1 = null;
String s2 = &quot;hello&quot;;
String s3 = s1 ?? s2;
Console.WriteLine(&quot;s3 is: &quot; + s3);
// s3 is: hello

/* Null-aware member access, a.k.a. safe navigation. */

Console.WriteLine(&quot;s1.Length is: &quot; + s1?.Length);
Console.WriteLine(&quot;s2.Length is: &quot; + s2?.Length);
// s1.Length is:
// s2.Length is: 5

/* Null-aware index access, a.k.a. safe navigation. */

Dictionary&lt;string,string&gt; d1 = null;
Dictionary&lt;string,string&gt; d2 = new Dictionary&lt;string, string&gt;
{
    { &quot;foo&quot;, &quot;bar&quot; },
    { &quot;baz&quot;, &quot;bat&quot; }
};

Console.WriteLine(&quot;d1[\&quot;foo\&quot;] is: &quot; + d1?[&quot;foo&quot;]);
Console.WriteLine(&quot;d2[\&quot;foo\&quot;] is: &quot; + d2?[&quot;foo&quot;]);
// d1[&quot;foo&quot;] is:
// d2[&quot;foo&quot;] is: bar

/* Short Circuiting */

Console.WriteLine(&quot;s1 trim/upper is: &quot; + s1?.Trim().Length);
Console.WriteLine(&quot;s2 trim/upper is: &quot; + s2?.Trim().Length);
// s1 trimmed length is:
// s2 trimmed length is: 5

String s4 = s1 ?? s2 ?? DoError();
Console.WriteLine(&quot;s4 is: &quot; + s4)
// s4 is: hello
</pre>
<p>A <a class="reference external" href="https://dotnetfiddle.net/SxQNG8">working example</a> can be viewed online.</p>
<p>Of utmost importance, notice the short circuiting behavior. The short circuiting
of <tt class="docutils literal"><span class="pre">??</span></tt> is similar to short circuiting of other boolean operators such as
<tt class="docutils literal">||</tt> or <tt class="docutils literal">&amp;&amp;</tt> and should not be surprising. Helpfully, <cite>?.</cite> is <em>also</em> short
circuiting: <tt class="docutils literal"><span class="pre">s1?.Trim()</span></tt> evaluates to null, but <tt class="docutils literal"><span class="pre">s1?.Trim().Length</span></tt> does not
attempt to dereference the <tt class="docutils literal">null</tt> pointer.</p>
</div>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id17">Rationale</a></h1>
<div class="section" id="existing-alternatives">
<h2><a class="toc-backref" href="#id18">Existing Alternatives</a></h2>
<p>Python does not have any specific <tt class="docutils literal">None</tt>-aware operators, but it does have
operators that can be used for a similar purpose. This section describes why
these alternatives may be undesirable for some common <tt class="docutils literal">None</tt> patterns.</p>
<div class="section" id="or-operator">
<h3><a class="toc-backref" href="#id19"><tt class="docutils literal">or</tt> Operator</a></h3>
<p>Similar behavior can be achieved with the <tt class="docutils literal">or</tt> operator, but <tt class="docutils literal">or</tt> checks
whether its left operand is false-y, not specifically <tt class="docutils literal">None</tt>. This can lead
to surprising behavior. Consider the scenario of computing the price of some
products a customer has in his/her shopping cart:</p>
<pre class="literal-block">
&gt;&gt;&gt; price = 100
&gt;&gt;&gt; default_quantity = 1
# If user didn't specify a quantity, then assume the default.
&gt;&gt;&gt; requested_quantity = None
&gt;&gt;&gt; (requested_quantity or default_quantity) * price
100
# The user added 5 items to the cart.
&gt;&gt;&gt; requested_quantity = 5
&gt;&gt;&gt; (requested_quantity or default_quantity) * price
500
# User removed 5 items from cart.
&gt;&gt;&gt; requested_quantity = 0
&gt;&gt;&gt; (requested_quantity or default_quantity) * price # oops!
100
</pre>
<p>An experienced Python developer should know how <tt class="docutils literal">or</tt> works and be capable of
avoiding bugs like this. However, getting in the habit of using <tt class="docutils literal">or</tt> for this
purpose still might cause an experienced developer to occasionally make this
mistake, especially when refactoring existing code and not carefully paying
attention to the possible values of the left-hand operand.</p>
<p>For inexperienced developers, the problem is worse. The top Google hit for
&quot;python null coalesce&quot; is a <a class="reference external" href="http://stackoverflow.com/questions/4978738/is-there-a-python-equivalent-of-the-c-sharp-null-coalescing-operator">StackOverflow page</a>, and the top answer says to use <tt class="docutils literal">or</tt>.
The top answer goes on to explain the caveats of using <tt class="docutils literal">or</tt> like this, but how
many beginning developers go on to read all those caveats? The accepted answer
on <a class="reference external" href="http://stackoverflow.com/questions/13710631/is-there-shorthand-for-returning-a-default-value-if-none-in-python">a more recent question</a> says to use
<tt class="docutils literal">or</tt> without any caveats at all. These two questions have a combined 26,000
views!</p>
<p>The common usage of <tt class="docutils literal">or</tt> for the purpose of providing default values is
undeniable, and yet it is also booby-trapped for unsuspecting newcomers. This
suggests that a safe operator for providing default values would have positive
utility. While some critics claim that <tt class="docutils literal">None</tt>-aware operators will be abused
for error handling, they are no more prone to abuse than <tt class="docutils literal">or</tt> is.</p>
</div>
<div class="section" id="ternary-operator">
<h3><a class="toc-backref" href="#id20">Ternary Operator</a></h3>
<p>Another common way to initialize default values is to use the ternary operator.
Here is an excerpt from the popular <a class="reference external" href="https://github.com/kennethreitz/requests/blob/14a555ac716866678bf17e43e23230d81a8149f5/requests/models.py#L212">Requests package</a>:</p>
<pre class="literal-block">
data = [] if data is None else data
files = [] if files is None else files
headers = {} if headers is None else headers
params = {} if params is None else params
hooks = {} if hooks is None else hooks
</pre>
<p>This particular formulation has the undesirable effect of putting the operands
in an unintuitive order: the brain thinks, &quot;use <tt class="docutils literal">data</tt> if possible and use
<tt class="docutils literal">[]</tt> as a fallback,&quot; but the code puts the fallback <em>before</em> the preferred
value.</p>
<p>The author of this package could have written it like this instead:</p>
<pre class="literal-block">
data = data if data is not None else []
files = files if files is not None else []
headers = headers if headers is not None else {}
params = params if params is not None else {}
hooks = hooks if hooks is not None else {}
</pre>
<p>This ordering of the operands is more intuitive, but it requires 4 extra
characters (for &quot;not &quot;). It also highlights the repetition of identifiers:
<tt class="docutils literal">data if data</tt>, <tt class="docutils literal">files if files</tt>, etc. This example benefits from short
identifiers, but what if the tested expression is longer and/or has side
effects? This is addressed in the next section.</p>
</div>
</div>
<div class="section" id="motivating-examples">
<h2><a class="toc-backref" href="#id21">Motivating Examples</a></h2>
<p>The purpose of this PEP is to simplify some common patterns involving <tt class="docutils literal">None</tt>.
This section presents some examples of common <tt class="docutils literal">None</tt> patterns and explains
the drawbacks.</p>
<p>This first example is from a Python web crawler that uses the popular Flask
framework as a front-end. This function retrieves information about a web site
from a SQL database and formats it as JSON to send to an HTTP client:</p>
<pre class="literal-block">
class SiteView(FlaskView):
    &#64;route('/site/&lt;id_&gt;', methods=['GET'])
    def get_site(self, id_):
        site = db.query('site_table').find(id_)

        return jsonify(
            first_seen=site.first_seen.isoformat() if site.first_seen is not None else None,
            id=site.id,
            is_active=site.is_active,
            last_seen=site.last_seen.isoformat() if site.last_seen is not None else None,
            url=site.url.rstrip('/')
        )
</pre>
<p>Both <tt class="docutils literal">first_seen</tt> and <tt class="docutils literal">last_seen</tt> are allowed to be <tt class="docutils literal">null</tt> in the
database, and they are also allowed to be <tt class="docutils literal">null</tt> in the JSON response. JSON
does not have a native way to represent a <tt class="docutils literal">datetime</tt>, so the server's contract
states that any non-<tt class="docutils literal">null</tt> date is represented as an ISO-8601 string.</p>
<p>Note that this code is invalid by PEP-8 standards: several lines are over the
line length limit. In fact, <em>including it in this document</em> violates the PEP
formatting standard! But it's not unreasonably indented, nor are any of the
identifiers excessively long. The excessive line length is due to the
repetition of identifiers on both sides of the ternary <tt class="docutils literal">if</tt> and the verbosity
of the ternary itself (10 characters out of a 78 character line length).</p>
<p>One way to fix this code is to replace each ternary with a full <tt class="docutils literal">if/else</tt>
block:</p>
<pre class="literal-block">
class SiteView(FlaskView):
    &#64;route('/site/&lt;id_&gt;', methods=['GET'])
    def get_site(self, id_):
        site = db.query('site_table').find(id_)

        if site.first_seen is None:
            first_seen = None
        else:
            first_seen = site.first_seen.isoformat()

        if site.last_seen is None:
            last_seen = None
        else:
            last_seen = site.last_seen.isoformat()

        return jsonify(
            first_seen=first_seen,
            id=site.id,
            is_active=site.is_active,
            last_seen=last_seen,
            url=site.url.rstrip('/')
        )
</pre>
<p>This version definitely isn't <em>bad</em>. It is easy to read and understand. On the
other hand, adding 8 lines of code to express this common behavior feels a bit
heavy, especially for a deliberately simplified example. If a larger, more
complicated data model was being used, then it would get tedious to continually
write in this long form. The readability would start to suffer as the number of
lines in the function grows, and a refactoring would be forced.</p>
<p>Another alternative is to rename some of the identifiers:</p>
<pre class="literal-block">
class SiteView(FlaskView):
    &#64;route('/site/&lt;id_&gt;', methods=['GET'])
    def get_site(self, id_):
        site = db.query('site_table').find(id_)

        fs = site.first_seen
        ls = site.last_seen

        return jsonify(
            first_seen=fs.isodate() if fs is not None else None,
            id=site.id,
            is_active=site.is_active,
            last_seen=ls.isodate() if ls is not None else None,,
            url=site.url.rstrip('/')
        )
</pre>
<p>This adds fewer lines of code than the previous example, but it comes at the
expense of introducing extraneous identifiers that amount to nothing more than
aliases. These new identifiers are short enough to fit a ternary expression onto
one line, but the identifiers are also less intuitive, e.g. <tt class="docutils literal">fs</tt> versus
<tt class="docutils literal">first_seen</tt>.</p>
<p>As a quick preview, consider an alternative rewrite using a new operator:</p>
<pre class="literal-block">
class SiteView(FlaskView):
    &#64;route('/site/&lt;id_&gt;', methods=['GET'])
    def get_site(self, id_):
        site = db.query('site_table').find(id_)

        return jsonify(
            first_seen=site.first_seen?.isoformat(),
            id=site.id,
            is_active=site.is_active,
            last_seen=site.last_seen?.isoformat(),
            url=site.url.rstrip('/')
        )
</pre>
<p>The <tt class="docutils literal"><span class="pre">?.</span></tt> operator behaves as a &quot;safe navigation&quot; operator, allowing a more
concise syntax where the expression <tt class="docutils literal">site.first_seen</tt> is not duplicated.</p>
<p>The next example is from a trending project on GitHub called <a class="reference external" href="https://github.com/lorien/grab/blob/4c95b18dcb0fa88eeca81f5643c0ebfb114bf728/grab/upload.py">Grab</a>, which is a Python scraping library:</p>
<pre class="literal-block">
class BaseUploadObject(object):
    def find_content_type(self, filename):
        ctype, encoding = mimetypes.guess_type(filename)
        if ctype is None:
            return 'application/octet-stream'
        else:
            return ctype

class UploadContent(BaseUploadObject):
    def __init__(self, content, filename=None, content_type=None):
        self.content = content
        if filename is None:
            self.filename = self.get_random_filename()
        else:
            self.filename = filename
        if content_type is None:
            self.content_type = self.find_content_type(self.filename)
        else:
            self.content_type = content_type

class UploadFile(BaseUploadObject):
    def __init__(self, path, filename=None, content_type=None):
        self.path = path
        if filename is None:
            self.filename = os.path.split(path)[1]
        else:
            self.filename = filename
        if content_type is None:
            self.content_type = self.find_content_type(self.filename)
        else:
            self.content_type = content_type
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">I don't know the author of the Grab project. I used it as an example
because it is a trending repo on GitHub and it has good examples of common
<tt class="docutils literal">None</tt> patterns.</p>
</div>
<p>This example contains several good examples of needing to provide default
values. It is a bit verbose as it is, and it is certainly not improved by the
ternary operator:</p>
<pre class="literal-block">
class BaseUploadObject(object):
    def find_content_type(self, filename):
        ctype, encoding = mimetypes.guess_type(filename)
        return 'application/octet-stream' if ctype is None else ctype

class UploadContent(BaseUploadObject):
    def __init__(self, content, filename=None, content_type=None):
        self.content = content
        self.filename = self.get_random_filename() if filename \
            is None else filename
        self.content_type = self.find_content_type(self.filename) \
            if content_type is None else content_type

class UploadFile(BaseUploadObject):
    def __init__(self, path, filename=None, content_type=None):
        self.path = path
        self.filename = os.path.split(path)[1] if filename is \
            None else filename
        self.content_type = self.find_content_type(self.filename) \
            if content_type is None else content_type
</pre>
<p>The first ternary expression is tidy, but it reverses the intuitive order of
the operands: it should return <tt class="docutils literal">ctype</tt> if it has a value and use the string
literal as fallback. The other ternary expressions are unintuitive and so
long that they must be wrapped. The overall readability is worsened, not
improved.</p>
<p>This code <em>might</em> be improved, though, if there was a syntactic shortcut for
this common need to supply a default value:</p>
<pre class="literal-block">
class BaseUploadObject(object):
    def find_ctype(self, filename):
        ctype, encoding = mimetypes.guess_type(filename)
        return ctype ?? 'application/octet-stream'

class UploadContent(BaseUploadObject):
    def __init__(self, content, filename=None, content_type=None):
        self.content = content
        self.filename = filename ?? self.get_random_filename()
        self.content_type = content_type ?? self.find_ctype(self.filename)

class UploadFile(BaseUploadObject):
    def __init__(self, path, filename=None, content_type=None):
        self.path = path
        self.filename = filename ?? os.path.split(path)[1]
        self.content_type = content_type ?? self.find_ctype(self.filename)
</pre>
<p>This syntax has an intuitive ordering of the operands, e.g. <tt class="docutils literal">ctype</tt> -- the
preferred value -- comes before the fallback value. The terseness of the syntax
also makes for fewer lines of code and less code to visually parse.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">I cheated on the last example: I renamed <tt class="docutils literal">find_content_type</tt> to
<tt class="docutils literal">find_ctype</tt> in order to fit two of the lines under 80 characters. If you
find this underhanded, you can go back and apply the same renaming to the
previous 2 examples. You'll find that it doesn't change the
conclusions.</p>
</div>
</div>
<div class="section" id="usage-of-none-in-the-standard-library">
<h2><a class="toc-backref" href="#id22">Usage Of <tt class="docutils literal">None</tt> In The Standard Library</a></h2>
<p>The previous sections show some code patterns that are claimed to be &quot;common&quot;,
but how common are they? The attached script <a class="reference external" href="https://github.com/python/peps/blob/master/pep-0505/find-pep505.py">find-pep505.py</a> is meant
to answer this question. It uses the <tt class="docutils literal">ast</tt> module to search for variations of
the following patterns in any <tt class="docutils literal">*.py</tt> file:</p>
<pre class="literal-block">
&gt;&gt;&gt; # None-coalescing if block
...
&gt;&gt;&gt; if a is None:
...     a = b

&gt;&gt;&gt; # [Possible] None-coalescing &quot;or&quot; operator
...
&gt;&gt;&gt; a or 'foo'
&gt;&gt;&gt; a or []
&gt;&gt;&gt; a or {}

&gt;&gt;&gt; # None-coalescing ternary
...
&gt;&gt;&gt; a if a is not None else b
&gt;&gt;&gt; b if a is None else a

&gt;&gt;&gt; # Safe navigation &quot;and&quot; operator
...
&gt;&gt;&gt; a and a.foo
&gt;&gt;&gt; a and a['foo']
&gt;&gt;&gt; a and a.foo()

&gt;&gt;&gt; # Safe navigation if block
...
&gt;&gt;&gt; if a is not None:
...     a.foo()

&gt;&gt;&gt; # Safe navigation ternary
...
&gt;&gt;&gt; a.foo if a is not None else b
&gt;&gt;&gt; b if a is None else a.foo
</pre>
<p>This script takes one or more names of Python source files to analyze:</p>
<pre class="literal-block">
$ python3 find-pep505.py test.py
$ find /usr/lib/python3.4 -name '*.py' | xargs python3 find-pep505.py
</pre>
<p>The script prints out any matches it finds. Sample:</p>
<pre class="literal-block">
None-coalescing if block: /usr/lib/python3.4/inspect.py:594
    if _filename is None:
         _filename = getsourcefile(object) or getfile(object)

[Possible] None-coalescing `or`: /usr/lib/python3.4/lib2to3/refactor.py:191
        self.explicit = explicit or []

None-coalescing ternary: /usr/lib/python3.4/decimal.py:3909
        self.clamp = clamp if clamp is not None else dc.clamp

Safe navigation `and`: /usr/lib/python3.4/weakref.py:512
        obj = info and info.weakref()

Safe navigation `if` block: /usr/lib/python3.4/http/cookiejar.py:1895
                        if k is not None:
                            lc = k.lower()
                        else:
                            lc = None

Safe navigation ternary: /usr/lib/python3.4/sre_parse.py:856
        literals = [None if s is None else s.encode('latin-1') for s in literals]
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Coalescing with <tt class="docutils literal">or</tt> is marked as a &quot;possible&quot; match, because it's not
trivial to infer whether <tt class="docutils literal">or</tt> is meant to coalesce False-y values
(correct) or if it meant to coalesce <tt class="docutils literal">None</tt> (incorrect). On the other
hand, we assume that <tt class="docutils literal">and</tt> is always incorrect for safe navigation.</p>
</div>
<p>The script has been tested against <a class="reference external" href="https://github.com/python/peps/blob/master/pep-0505/test.py">test.py</a> and the Python
3.4 standard library, but it should work on any arbitrary Python 3 source code.
The complete output from running it against the standard library is attached to
this proposal as <a class="reference external" href="https://github.com/python/peps/blob/master/pep-0505/find-pep505.out">find-pep505.out</a>.</p>
<p>The script counts how many matches it finds and prints the totals at the
end:</p>
<pre class="literal-block">
Total None-coalescing `if` blocks: 426
Total [possible] None-coalescing `or`: 119
Total None-coalescing ternaries: 21
Total Safe navigation `and`: 9
Total Safe navigation `if` blocks: 55
Total Safe navigation ternaries: 7
</pre>
<p>This is a total of 637 possible matches for these common code patterns in the
standard library. Allowing for some false positives and false negatives, it is
fair to say that these code patterns are definitely common in the standard
library.</p>
</div>
<div class="section" id="rejected-ideas">
<h2><a class="toc-backref" href="#id23">Rejected Ideas</a></h2>
<p>Several related ideas were discussed on python-ideas, and some of these were
roundly rejected by BDFL, the community, or both. For posterity's sake, some of
those ideas are recorded here.</p>
<div class="section" id="none-aware-function-call">
<h3><a class="toc-backref" href="#id24"><tt class="docutils literal">None</tt>-aware Function Call</a></h3>
<p>The <tt class="docutils literal">None</tt>-aware syntax applies to attribute and index access, so it seems
natural to ask if it should also apply to function invocation syntax. It might
be written as <tt class="docutils literal"><span class="pre">foo?()</span></tt>, where <tt class="docutils literal">foo</tt> is only called if it is not None.</p>
<p>This has been rejected on the basis of the proposed operators being intended
to aid traversal of partially populated hierarchical data structures, <em>not</em>
for traversal of arbitrary class hierarchies. This is reflected in the fact
that none of the other mainstream languages that already offer this syntax
have found it worthwhile to support a similar syntax for optional function
invocations.</p>
</div>
<div class="section" id="unary-postfix-operator">
<h3><a class="toc-backref" href="#id25"><tt class="docutils literal">?</tt> Unary Postfix Operator</a></h3>
<p>To generalize the <tt class="docutils literal">None</tt>-aware behavior and limit the number of new operators
introduced, a unary, postfix operator spelled <tt class="docutils literal">?</tt> was suggested. The idea is
that <tt class="docutils literal">?</tt> might return a special object that could would override dunder
methods that return <tt class="docutils literal">self</tt>. For example, <tt class="docutils literal">foo?</tt> would evaluate to <tt class="docutils literal">foo</tt> if
it is not <tt class="docutils literal">None</tt>, otherwise it would evaluate to an instance of
<tt class="docutils literal">NoneQuestion</tt>:</p>
<pre class="literal-block">
class NoneQuestion():
    def __call__(self, *args, **kwargs):
        return self

    def __getattr__(self, name):
        return self

    def __getitem__(self, key):
        return self
</pre>
<p>With this new operator and new type, an expression like <tt class="docutils literal"><span class="pre">foo?.bar[baz]</span></tt>
evaluates to <tt class="docutils literal">NoneQuestion</tt> if <tt class="docutils literal">foo</tt> is None. This is a nifty
generalization, but it's difficult to use in practice since most existing code
won't know what <tt class="docutils literal">NoneQuestion</tt> is.</p>
<p>Going back to one of the motivating examples above, consider the following:</p>
<pre class="literal-block">
&gt;&gt;&gt; import json
&gt;&gt;&gt; created = None
&gt;&gt;&gt; json.dumps({'created': created?.isoformat()})``
</pre>
<p>The JSON serializer does not know how to serialize <tt class="docutils literal">NoneQuestion</tt>, nor will
any other API. This proposal actually requires <em>lots of specialized logic</em>
throughout the standard library and any third party library.</p>
<p>At the same time, the <tt class="docutils literal">?</tt> operator may also be <strong>too general</strong>, in the sense
that it can be combined with any other operator. What should the following
expressions mean?:</p>
<pre class="literal-block">
&gt;&gt;&gt; x? + 1
&gt;&gt;&gt; x? -= 1
&gt;&gt;&gt; x? == 1
&gt;&gt;&gt; ~x?
</pre>
<p>This degree of generalization is not useful. The operators actually proposed
herein are intentionally limited to a few operators that are expected to make it
easier to write common code patterns.</p>
</div>
<div class="section" id="haskell-style-maybe">
<h3><a class="toc-backref" href="#id26">Haskell-style <tt class="docutils literal">Maybe</tt></a></h3>
<p>Haskell has a concept called <a class="reference external" href="https://wiki.haskell.org/Maybe">Maybe</a> that
encapsulates the idea of an optional value without relying on any special
keyword (e.g. <tt class="docutils literal">null</tt>) or any special instance (e.g. <tt class="docutils literal">None</tt>). In Haskell, the
purpose of <tt class="docutils literal">Maybe</tt> is to avoid separate handling of &quot;something&quot; and nothing&quot;.
The concept is so heavily intertwined with Haskell's lazy evaluation that it
doesn't translate cleanly into Python.</p>
<p>There is a Python package called <a class="reference external" href="https://pypi.python.org/pypi/pymaybe/0.1.1">pymaybe</a> that provides a rough
approximation. The documentation shows the following example that appears
relevant to the discussion at hand:</p>
<pre class="literal-block">
&gt;&gt;&gt; maybe('VALUE').lower()
'value'

&gt;&gt;&gt; maybe(None).invalid().method().or_else('unknown')
'unknown'
</pre>
<p>The function <tt class="docutils literal">maybe()</tt> returns either a <tt class="docutils literal">Something</tt> instance or a
<tt class="docutils literal">Nothing</tt> instance. Similar to the unary postfix operator described in the
previous section, <tt class="docutils literal">Nothing</tt> overrides dunder methods in order to allow
chaining on a missing value.</p>
<p>Note that <tt class="docutils literal">or_else()</tt> is eventually required to retrieve the underlying value
from <tt class="docutils literal">pymaybe</tt>'s wrappers. Furthermore, <tt class="docutils literal">pymaybe</tt> does not short circuit any
evaluation. Although <tt class="docutils literal">pymaybe</tt> has some strengths and may be useful in its own
right, it also demonstrates why a pure Python implementation of coalescing is
not nearly as powerful as support built into the language.</p>
</div>
</div>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id27">Specification</a></h1>
<p>This PEP suggests 3 new operators be added to Python:</p>
<ol class="arabic simple">
<li><tt class="docutils literal">None</tt>-coalescing operator</li>
<li><tt class="docutils literal">None</tt>-aware attribute access</li>
<li><tt class="docutils literal">None</tt>-aware index access/slicing</li>
</ol>
<p>We will continue to assume the same spellings as in
the previous sections in order to focus on behavior before diving into the much
more contentious issue of how to spell these operators.</p>
<p>A generalization of these operators is also proposed below under the heading
&quot;Generalized Coalescing&quot;.</p>
<div class="section" id="operator-spelling">
<h2><a class="toc-backref" href="#id28">Operator Spelling</a></h2>
<p>Despite significant support for the proposed operators, the majority of
discussion on python-ideas fixated on the spelling. Many alternative spellings
were proposed, both punctuation and keywords, but each alternative drew some
criticism. Spelling the operator as a keyword is problematic, because adding new
keywords to the language is not backwards compatible.</p>
<p>It is not impossible to add a new keyword, however, and we can look  at several
other PEPs for inspiration. For example,  <a class="reference external" href="https://www.python.org/dev/peps/pep-0492/">PEP-492</a>  introduced the new keywords
<tt class="docutils literal">async</tt> and <tt class="docutils literal">await</tt> into Python 3.5. These new keywords are fully backwards
compatible, because that PEP also introduces a new lexical context such that
<tt class="docutils literal">async</tt> and <tt class="docutils literal">await</tt> are only treated as keywords when used inside of an
<tt class="docutils literal">async def</tt> function. In other locations, <tt class="docutils literal">async</tt> and <tt class="docutils literal">await</tt> may be used
as identifiers.</p>
<p>It is also possible to craft a new operator out of existing keywords, as was
the case with <a class="reference external" href="https://www.python.org/dev/peps/pep-0308/">PEP-308</a>, which
created a ternary operator by cobbling together the <cite>if</cite> and <cite>else</cite> keywords
into a new operator.</p>
<p>In addition to the lexical acrobatics required to create a new keyword, keyword
operators are also undesirable for creating an assignment shortcut syntax. In
Dart, for example, <tt class="docutils literal">x <span class="pre">??=</span> y</tt> is an assignment shortcut that approximately
means <tt class="docutils literal">x = x <span class="pre">??</span> y</tt> except that <tt class="docutils literal">x</tt> is only evaluated once. If Python's
coalesce operator is a keyword, e.g. <tt class="docutils literal">foo</tt>, then the assignment shortcut would
be very ugly: <tt class="docutils literal">x foo= y</tt>.</p>
<p>Spelling new logical operators with punctuation is unlikely, for several
reasons. First, Python eschews punctuation for logical operators. For example,
it uses <tt class="docutils literal">not</tt> instead of <tt class="docutils literal">!</tt>, <tt class="docutils literal">or</tt> instead of <tt class="docutils literal">||</tt>, and <tt class="docutils literal">… if … else …</tt>
instead of   <tt class="docutils literal">… ? … : …</tt>.</p>
<p>Second, nearly every single punctuation character on a standard keyboard already
has special meaning in Python. The only exceptions are <tt class="docutils literal">$</tt>, <tt class="docutils literal">!</tt>, <tt class="docutils literal">?</tt>, and
backtick (as of Python 3). This leaves few options for a new, single-character
operator.</p>
<p>Third, other projects in the Python universe assign special meaning to
punctuation. For example,  <a class="reference external" href="https://ipython.org/ipython-doc/2/interactive/reference.html">IPython</a>  assigns
special meaning to <tt class="docutils literal">%</tt>, <tt class="docutils literal">%%</tt>, <tt class="docutils literal">?</tt>, <tt class="docutils literal"><span class="pre">??</span></tt>, <tt class="docutils literal">$</tt>, and <tt class="docutils literal">$$</tt>, among
others. Out of deference to those projects and the large communities using them,
introducing conflicting syntax into Python is undesirable.</p>
<p>The spellings <tt class="docutils literal"><span class="pre">??</span></tt> and <tt class="docutils literal"><span class="pre">?.</span></tt> will be familiar to programmers who have seen
them in other popular programming languages. Any alternative punctuation will be
just as ugly but without the benefit of familiarity from other languages.
Therefore, this proposal spells the new operators using the same punctuation
that already exists in other languages.</p>
</div>
<div class="section" id="none-coalescing-operator">
<h2><a class="toc-backref" href="#id29"><tt class="docutils literal">None</tt>-Coalescing Operator</a></h2>
<p>The <tt class="docutils literal">None</tt>-coalescing operator is a short-circuiting, binary operator that
behaves in the following way.</p>
<ol class="arabic simple">
<li>Evaluate the left operand first.</li>
<li>If the left operand is not <tt class="docutils literal">None</tt>, then return it immediately.</li>
<li>Else, evaluate the right operand and return the result.</li>
</ol>
<p>Consider the following examples. We will continue to use the spelling <tt class="docutils literal"><span class="pre">??</span></tt>
here, but keep in mind that alternative spellings will be discussed below:</p>
<pre class="literal-block">
&gt;&gt;&gt; 1 ?? 2
1
&gt;&gt;&gt; None ?? 2
2
</pre>
<p>Importantly, note that the right operand is not evaluated unless the left
operand is None:</p>
<pre class="literal-block">
&gt;&gt;&gt; def err(): raise Exception('foo')
&gt;&gt;&gt; 1 ?? err()
1
&gt;&gt;&gt; None ?? err()
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;stdin&gt;&quot;, line 1, in err
Exception: foo
</pre>
<p>The operator is left associative. Combined with its short circuiting behavior,
this makes the operator easy to chain:</p>
<pre class="literal-block">
&gt;&gt;&gt; timeout = None
&gt;&gt;&gt; local_timeout = 60
&gt;&gt;&gt; global_timeout = 300
&gt;&gt;&gt; timeout ?? local_timeout ?? global_timeout
60

&gt;&gt;&gt; local_timeout = None
&gt;&gt;&gt; timeout ?? local_timeout ?? global_timeout
300
</pre>
<p>The operator has higher precedence than the comparison operators <tt class="docutils literal">==</tt>, <tt class="docutils literal">&gt;</tt>,
<tt class="docutils literal">is</tt>, etc., but lower precedence than any bitwise or arithmetic operators.
This precedence is chosen for making &quot;default value&quot; expressions intuitive to
read and write:</p>
<pre class="literal-block">
&gt;&gt;&gt; not None ?? True
&gt;&gt;&gt; not (None ?? True) # Same precedence

&gt;&gt;&gt; 1 == None ?? 1
&gt;&gt;&gt; 1 == (None ?? 1) # Same precedence

&gt;&gt;&gt; 'foo' in None ?? ['foo', 'bar']
&gt;&gt;&gt; 'foo' in (None ?? ['foo', 'bar']) # Same precedence

&gt;&gt;&gt; 1 + None ?? 2
&gt;&gt;&gt; 1 + (None ?? 2) # Same precedence
</pre>
<p>Recall the example above of calculating the cost of items in a shopping cart,
and the easy-to-miss bug. This type of bug is not possible with the <tt class="docutils literal">None</tt>-
coalescing operator, because there is no implicit type coersion to <tt class="docutils literal">bool</tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; requested_quantity = 0
&gt;&gt;&gt; default_quantity = 1
&gt;&gt;&gt; price = 100
&gt;&gt;&gt; requested_quantity ?? default_quantity * price
0
</pre>
<p>The <tt class="docutils literal">None</tt>-coalescing operator also has a corresponding assignment shortcut.
The following assignments are semantically similar, except that <tt class="docutils literal">foo</tt> is only
looked up once when using the assignment shortcut:</p>
<pre class="literal-block">
&gt;&gt;&gt; foo ??= []
&gt;&gt;&gt; foo = foo ?? []
</pre>
<p>The <tt class="docutils literal">None</tt> coalescing operator improves readability, especially when handling
default function arguments. Consider again the example from the Requests
library, rewritten to use <tt class="docutils literal">None</tt>-coalescing:</p>
<pre class="literal-block">
def __init__(self, data=None, files=None, headers=None, params=None, hooks=None):
    self.data = data ?? []
    self.files = files ?? []
    self.headers = headers ?? {}
    self.params = params ?? {}
    self.hooks = hooks ?? {}
</pre>
<p>The operator makes the intent easier to follow (by putting operands in an
intuitive order) and is more concise than the ternary operator, while still
preserving the short circuit semantics of the code that it replaces.</p>
</div>
<div class="section" id="none-aware-attribute-access-operator">
<h2><a class="toc-backref" href="#id30"><tt class="docutils literal">None</tt>-Aware Attribute Access Operator</a></h2>
<p>The <tt class="docutils literal">None</tt>-aware attribute access operator (also called &quot;safe navigation&quot;)
checks its left operand. If the left operand is <tt class="docutils literal">None</tt>, then the operator
evaluates to <tt class="docutils literal">None</tt>. If the the left operand is not <tt class="docutils literal">None</tt>, then the
operator accesses the attribute named by the right operand:</p>
<pre class="literal-block">
&gt;&gt;&gt; from datetime import date
&gt;&gt;&gt; d = date.today()
&gt;&gt;&gt; d.year
2015

&gt;&gt;&gt; d = None
&gt;&gt;&gt; d.year
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'NoneType' object has no attribute 'year'

&gt;&gt;&gt; d?.year
None
</pre>
<p>The operator has the same precedence and associativity as the plain attribute
access operator <tt class="docutils literal">.</tt>, but this operator is also short-circuiting in a unique
way: if the left operand is <tt class="docutils literal">None</tt>, then any series of attribute access, index
access, slicing, or function call operators immediately to the right of it <em>are
not evaluated</em>:</p>
<pre class="literal-block">
&gt;&gt;&gt; name = ' The Black Knight '
&gt;&gt;&gt; name.strip()[4:].upper()
'BLACK KNIGHT'

&gt;&gt;&gt; name = None
&gt;&gt;&gt; name?.strip()[4:].upper()
None
</pre>
<p>If this operator did not short circuit in this way, then the second example
would partially evaluate <tt class="docutils literal"><span class="pre">name?.strip()</span></tt> to <tt class="docutils literal">None()</tt> and then fail with
<tt class="docutils literal">TypeError: 'NoneType' object is not callable</tt>.</p>
<p>To put it another way, the following expressions are semantically similar,
except that <tt class="docutils literal">name</tt> is only looked up once on the first line:</p>
<pre class="literal-block">
&gt;&gt;&gt; name?.strip()[4:].upper()
&gt;&gt;&gt; name.strip()[4:].upper() if name is not None else None
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">C# implements its safe navigation operators with the same short-circuiting
semantics, but Dart does not. In Dart, the second example (suitably
translated) would fail. The C# semantics are obviously superior, given the
original goal of writing common cases more concisely. The Dart semantics are
nearly useless.</p>
</div>
<p>This operator short circuits one or more attribute access, index access,
slicing, or function call operators that are adjacent to its right, but it
does not short circuit any other operators (logical, bitwise, arithmetic, etc.),
nor does it escape parentheses:</p>
<pre class="literal-block">
&gt;&gt;&gt; d = date.today()
&gt;&gt;&gt; d?.year.numerator + 1
2016

&gt;&gt;&gt; d = None
&gt;&gt;&gt; d?.year.numerator + 1
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

&gt;&gt;&gt; (d?.year).numerator + 1
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'NoneType' object has no attribute 'numerator'
</pre>
<p>Note that the error in the second example is not on the attribute access
<tt class="docutils literal">numerator</tt>. In fact, that attribute access is never performed. The error
occurs when adding <tt class="docutils literal">None + 1</tt>, because the <tt class="docutils literal">None</tt>-aware attribute access
does not short circuit <tt class="docutils literal">+</tt>.</p>
<p>The third example fails because the operator does not escape parentheses. In
that example, the attribute access <tt class="docutils literal">numerator</tt> is evaluated and fails because
<tt class="docutils literal">None</tt> does not have that attribute.</p>
<p>Finally, observe that short circuiting adjacent operators is not at all the same
thing as propagating <tt class="docutils literal">None</tt> throughout an expression:</p>
<pre class="literal-block">
&gt;&gt;&gt; user?.first_name.upper()
</pre>
<p>If <tt class="docutils literal">user</tt> is not <tt class="docutils literal">None</tt>, then <tt class="docutils literal">user.first_name</tt> is evaluated. If
<tt class="docutils literal">user.first_name</tt> evaluates to <tt class="docutils literal">None</tt>, then <tt class="docutils literal">user.first_name.upper()</tt> is
an error! In English, this expression says, &quot;<tt class="docutils literal">user</tt> is optional but if it has
a value, then it must have a <tt class="docutils literal">first_name</tt>, too.&quot;</p>
<p>If <tt class="docutils literal">first_name</tt> is supposed to be optional attribute, then the expression must
make that explicit:</p>
<pre class="literal-block">
&gt;&gt;&gt; user?.first_name?.upper()
</pre>
<p>The operator is not intended as an error silencing mechanism, and it would be
undesirable if its presence infected nearby operators.</p>
</div>
<div class="section" id="none-aware-index-access-slicing-operator">
<h2><a class="toc-backref" href="#id31"><tt class="docutils literal">None</tt>-Aware Index Access/Slicing Operator</a></h2>
<p>The <tt class="docutils literal">None</tt>-aware index access/slicing operator (also called &quot;safe navigation&quot;)
is nearly identical to the <tt class="docutils literal">None</tt>-aware attribute access operator. It combines
the familiar square bracket syntax <tt class="docutils literal">[]</tt> with new punctuation or a new keyword,
the spelling of which is discussed later:</p>
<pre class="literal-block">
&gt;&gt;&gt; person = {'name': 'Mark', 'age': 32}
&gt;&gt;&gt; person['name']
'Mark'

&gt;&gt;&gt; person = None
&gt;&gt;&gt; person['name']
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: 'NoneType' object is not subscriptable

&gt;&gt;&gt; person?.['name']
None
</pre>
<p>The <tt class="docutils literal">None</tt>-aware slicing operator behaves similarly:</p>
<pre class="literal-block">
&gt;&gt;&gt; name = 'The Black Knight'
&gt;&gt;&gt; name[4:]
'Black Knight'

&gt;&gt;&gt; name = None
&gt;&gt;&gt; name[4:]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: 'NoneType' object is not subscriptable

&gt;&gt;&gt; name?.[4:]
None
</pre>
<p>These operators have the same precedence as the plain index access and slicing
operators. They also have the same short-circuiting behavior as the
<tt class="docutils literal">None</tt>-aware attribute access.</p>
</div>
<div class="section" id="generalized-coalescing">
<h2><a class="toc-backref" href="#id32">Generalized Coalescing</a></h2>
<p>Making <tt class="docutils literal">None</tt> a special case is too specialized and magical. The behavior can
be generalized by making the <tt class="docutils literal">None</tt>-aware operators invoke a dunder method,
e.g. <tt class="docutils literal">__coalesce__(self)</tt> that returns <tt class="docutils literal">True</tt> if an object should be
coalesced and <tt class="docutils literal">False</tt> otherwise.</p>
<p>With this generalization, <tt class="docutils literal">object</tt> would implement a dunder method equivalent
to this:</p>
<pre class="literal-block">
def __coalesce__(self):
    return False
</pre>
<p><tt class="docutils literal">NoneType</tt> would implement a dunder method equivalent to this:</p>
<pre class="literal-block">
def __coalesce__(self):
    return True
</pre>
<p>If this generalization is accepted, then the operators will need to be renamed
such that the term <tt class="docutils literal">None</tt> is not used, e.g. &quot;Coalescing Operator&quot;, &quot;Coalesced
Member Access Operator&quot;, etc.</p>
<p>The coalesce operator would invoke this dunder method. The following two
expressions are semantically similar, except <cite>foo</cite> is only looked up once when
using the coalesce operator:</p>
<pre class="literal-block">
&gt;&gt;&gt; foo ?? bar
&gt;&gt;&gt; bar if foo.__coalesce__() else foo
</pre>
<p>The coalesced attribute and index access operators would invoke the same dunder
method:</p>
<pre class="literal-block">
&gt;&gt;&gt; user?.first_name.upper()
&gt;&gt;&gt; None if user.__coalesce__() else user.first_name.upper()
</pre>
<p>This generalization allows for domain-specific <tt class="docutils literal">null</tt> objects to be coalesced
just like <tt class="docutils literal">None</tt>. For example the <tt class="docutils literal">pyasn1</tt> package has a type called
<tt class="docutils literal">Null</tt> that represents an ASN.1 <tt class="docutils literal">null</tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; from pyasn1.type import univ
&gt;&gt;&gt; univ.Null() ?? univ.Integer(123)
Integer(123)
</pre>
<p>In addition to making the proposed operators less specialized, this
generalization also makes it easier to work with the Null Object Pattern, <a class="footnote-reference" href="#id8" id="id5">[3]</a>
for those developers who prefer to avoid using <tt class="docutils literal">None</tt>.</p>
</div>
<div class="section" id="implementation">
<h2><a class="toc-backref" href="#id33">Implementation</a></h2>
<p>The author of this PEP is not competent with grammars or lexers, and given the
contentiousness of this proposal, the implementation details for CPython will be
deferred until we have a clearer idea that one or more of the proposed
enhancements will be approved.</p>
<p>...TBD...</p>
</div>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id34">References</a></h1>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>C# Reference: Operators
(<a class="reference external" href="https://msdn.microsoft.com/en-us/library/6a71f45d.aspx">https://msdn.microsoft.com/en-us/library/6a71f45d.aspx</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>A Tour of the Dart Language: Operators
(<a class="reference external" href="https://www.dartlang.org/docs/dart-up-and-running/ch02.html#operators">https://www.dartlang.org/docs/dart-up-and-running/ch02.html#operators</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id5">2</a>)</em> Wikipedia: Null Object Pattern
(<a class="reference external" href="https://en.wikipedia.org/wiki/Null_Object_pattern">https://en.wikipedia.org/wiki/Null_Object_pattern</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>PEP-249:
(<a class="reference external" href="https://www.python.org/dev/peps/pep-0249/">https://www.python.org/dev/peps/pep-0249/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td>PEP-308
(<a class="reference external" href="https://www.python.org/dev/peps/pep-0308/">https://www.python.org/dev/peps/pep-0308/</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id35">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

