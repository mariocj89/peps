<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">501</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">General purpose string interpolation</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0501.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Nick Coghlan &lt;ncoghlan&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Deferred</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Requires:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0498">498</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">08-Aug-2015</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.6</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">08-Aug-2015, 23-Aug-2015, 30-Aug-2015</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id11">Abstract</a></li>
<li><a class="reference internal" href="#pep-deferral" id="id12">PEP Deferral</a></li>
<li><a class="reference internal" href="#summary-of-differences-from-pep-498" id="id13">Summary of differences from PEP 498</a></li>
<li><a class="reference internal" href="#proposal" id="id14">Proposal</a></li>
<li><a class="reference internal" href="#rationale" id="id15">Rationale</a></li>
<li><a class="reference internal" href="#specification" id="id16">Specification</a><ul>
<li><a class="reference internal" href="#conversion-specifiers" id="id17">Conversion specifiers</a></li>
<li><a class="reference internal" href="#writing-custom-renderers" id="id18">Writing custom renderers</a></li>
<li><a class="reference internal" href="#expression-evaluation" id="id19">Expression evaluation</a></li>
<li><a class="reference internal" href="#handling-code-injection-attacks" id="id20">Handling code injection attacks</a></li>
<li><a class="reference internal" href="#format-specifiers" id="id21">Format specifiers</a></li>
<li><a class="reference internal" href="#error-handling" id="id22">Error handling</a></li>
</ul>
</li>
<li><a class="reference internal" href="#possible-integration-with-the-logging-module" id="id23">Possible integration with the logging module</a></li>
<li><a class="reference internal" href="#discussion" id="id24">Discussion</a><ul>
<li><a class="reference internal" href="#deferring-support-for-binary-interpolation" id="id25">Deferring support for binary interpolation</a></li>
<li><a class="reference internal" href="#interoperability-with-str-only-interfaces" id="id26">Interoperability with str-only interfaces</a></li>
<li><a class="reference internal" href="#preserving-the-raw-template-string" id="id27">Preserving the raw template string</a></li>
<li><a class="reference internal" href="#creating-a-rich-object-rather-than-a-global-name-lookup" id="id28">Creating a rich object rather than a global name lookup</a></li>
<li><a class="reference internal" href="#building-atop-pep-498-rather-than-competing-with-it" id="id29">Building atop PEP 498, rather than competing with it</a></li>
<li><a class="reference internal" href="#deferring-consideration-of-possible-use-in-i18n-use-cases" id="id30">Deferring consideration of possible use in i18n use cases</a></li>
</ul>
</li>
<li><a class="reference internal" href="#acknowledgements" id="id31">Acknowledgements</a></li>
<li><a class="reference internal" href="#references" id="id32">References</a></li>
<li><a class="reference internal" href="#copyright" id="id33">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id11">Abstract</a></h1>
<p><a class="reference external" href="/dev/peps/pep-0498">PEP 498</a> proposes new syntactic support for string interpolation that is
transparent to the compiler, allow name references from the interpolation
operation full access to containing namespaces (as with any other expression),
rather than being limited to explicit name references. These are referred
to in the PEP as &quot;f-strings&quot; (a mnemonic for &quot;formatted strings&quot;).</p>
<p>However, it only offers this capability for string formatting, making it likely
we will see code like the following:</p>
<pre class="literal-block">
os.system(f&quot;echo {message_from_user}&quot;)
</pre>
<p>This kind of code is superficially elegant, but poses a significant problem
if the interpolated value <tt class="docutils literal">message_from_user</tt> is in fact provided by an
untrusted user: it's an opening for a form of code injection attack, where
the supplied user data has not been properly escaped before being passed to
the <tt class="docutils literal">os.system</tt> call.</p>
<p>To address that problem (and a number of other concerns), this PEP proposes
the complementary introduction of &quot;i-strings&quot; (a mnemonic for &quot;interpolation
template strings&quot;), where <tt class="docutils literal">f&quot;Message with {data}&quot;</tt> would produce the same
result as <tt class="docutils literal">format(i&quot;Message with <span class="pre">{data}&quot;)</span></tt>.</p>
<p>Some possible examples of the proposed syntax:</p>
<pre class="literal-block">
mycommand = sh(i&quot;cat {filename}&quot;)
myquery = sql(i&quot;SELECT {column} FROM {table};&quot;)
myresponse = html(i&quot;&lt;html&gt;&lt;body&gt;{response.body}&lt;/body&gt;&lt;/html&gt;&quot;)
logging.debug(i&quot;Message with {detailed} {debugging} {info}&quot;)
</pre>
</div>
<div class="section" id="pep-deferral">
<h1><a class="toc-backref" href="#id12">PEP Deferral</a></h1>
<p>This PEP is currently deferred pending further experience with <a class="reference external" href="/dev/peps/pep-0498">PEP 498</a>'s
simpler approach of only supporting eager rendering without the additional
complexity of also supporting deferred rendering.</p>
</div>
<div class="section" id="summary-of-differences-from-pep-498">
<h1>Summary of differences from <a class="reference external" href="/dev/peps/pep-0498">PEP 498</a></h1>
<p>The key additions this proposal makes relative to <a class="reference external" href="/dev/peps/pep-0498">PEP 498</a>:</p>
<ul class="simple">
<li>the &quot;i&quot; (interpolation template) prefix indicates delayed rendering, but
otherwise uses the same syntax and semantics as formatted strings</li>
<li>interpolation templates are available at runtime as a new kind of object
(<tt class="docutils literal">types.InterpolationTemplate</tt>)</li>
<li>the default rendering used by formatted strings is invoked on an
interpolation template object by calling <tt class="docutils literal">format(template)</tt> rather than
implicitly</li>
<li>while  f-string <tt class="docutils literal">f&quot;Message {here}&quot;</tt> would be <em>semantically</em> equivalent to
<tt class="docutils literal">format(i&quot;Message <span class="pre">{here}&quot;)</span></tt>, it is expected that the explicit syntax would
avoid the runtime overhead of using the delayed rendering machinery</li>
</ul>
<p>NOTE: This proposal spells out a draft API for <tt class="docutils literal">types.InterpolationTemplate</tt>.
The precise details of the structures and methods exposed by this type would
be informed by the reference implementation of <a class="reference external" href="/dev/peps/pep-0498">PEP 498</a>, so it makes sense to
gain experience with that as an internal API before locking down a public API
(if this extension proposal is accepted).</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id14">Proposal</a></h1>
<p>This PEP proposes the introduction of a new string prefix that declares the
string to be an interpolation template rather than an ordinary string:</p>
<pre class="literal-block">
template = i&quot;Substitute {names} and {expressions()} at runtime&quot;
</pre>
<p>This would be effectively interpreted as:</p>
<pre class="literal-block">
_raw_template = &quot;Substitute {names} and {expressions()} at runtime&quot;
_parsed_template = (
    (&quot;Substitute &quot;, &quot;names&quot;),
    (&quot; and &quot;, &quot;expressions()&quot;),
    (&quot; at runtime&quot;, None),
)
_field_values = (names, expressions())
_format_specifiers = (f&quot;&quot;, f&quot;&quot;)
template = types.InterpolationTemplate(_raw_template,
                                       _parsed_template,
                                       _field_values,
                                       _format_specifiers)
</pre>
<p>The <tt class="docutils literal">__format__</tt> method on <tt class="docutils literal">types.InterpolationTemplate</tt> would then
implement the following <tt class="docutils literal">str.format</tt> inspired semantics:</p>
<pre class="literal-block">
&gt;&gt;&gt; import datetime
&gt;&gt;&gt; name = 'Jane'
&gt;&gt;&gt; age = 50
&gt;&gt;&gt; anniversary = datetime.date(1991, 10, 12)
&gt;&gt;&gt; format(i'My name is {name}, my age next year is {age+1}, my anniversary is {anniversary:%A, %B %d, %Y}.')
'My name is Jane, my age next year is 51, my anniversary is Saturday, October 12, 1991.'
&gt;&gt;&gt; format(i'She said her name is {repr(name)}.')
&quot;She said her name is 'Jane'.&quot;
</pre>
<p>As with formatted strings, the interpolation template prefix can be combined with single-quoted, double-quoted and triple quoted strings, including raw strings.
It does not support combination with bytes literals.</p>
<p>Similarly, this PEP does not propose to remove or deprecate any of the existing
string formatting mechanisms, as those will remain valuable when formatting
strings that are not present directly in the source code of the application.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id15">Rationale</a></h1>
<p><a class="reference external" href="/dev/peps/pep-0498">PEP 498</a> makes interpolating values into strings with full access to Python's
lexical namespace semantics simpler, but it does so at the cost of creating a
situation where interpolating values into sensitive targets like SQL queries,
shell commands and HTML templates will enjoy a much cleaner syntax when handled
without regard for code injection attacks than when they are handled correctly.</p>
<p>This PEP proposes to provide the option of delaying the actual rendering
of an interpolation template to its <tt class="docutils literal">__format__</tt> method, allowing the use of
other template renderers by passing the template around as a first class object.</p>
<p>While very different in the technical details, the
<tt class="docutils literal">types.InterpolationTemplate</tt> interface proposed in this PEP is
conceptually quite similar to the <tt class="docutils literal">FormattableString</tt> type underlying the
<a class="reference external" href="https://msdn.microsoft.com/en-us/library/dn961160.aspx">native interpolation</a> support introduced in C# 6.0.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id16">Specification</a></h1>
<p>This PEP proposes the introduction of <tt class="docutils literal">i</tt> as a new string prefix that
results in the creation of an instance of a new type,
<tt class="docutils literal">types.InterpolationTemplate</tt>.</p>
<p>Interpolation template literals are Unicode strings (bytes literals are not
permitted), and string literal concatenation operates as normal, with the
entire combined literal forming the interpolation template.</p>
<p>The template string is parsed into literals, expressions and format specifiers
as described for f-strings in <a class="reference external" href="/dev/peps/pep-0498">PEP 498</a>. Conversion specifiers are handled
by the compiler, and appear as part of the field text in interpolation
templates.</p>
<p>However, rather than being rendered directly into a formatted strings, these
components are instead organised into an instance of a new type with the
following semantics:</p>
<pre class="literal-block">
class InterpolationTemplate:
    __slots__ = (&quot;raw_template&quot;, &quot;parsed_template&quot;,
                 &quot;field_values&quot;, &quot;format_specifiers&quot;)

    def __new__(cls, raw_template, parsed_template,
                     field_values, format_specifiers):
        self = super().__new__(cls)
        self.raw_template = raw_template
        self.parsed_template = parsed_template
        self.field_values = field_values
        self.format_specifiers = format_specifiers
        return self

    def __repr__(self):
        return (f&quot;&lt;{type(self).__qualname__} {repr(self._raw_template)} &quot;
                f&quot;at {id(self):#x}&gt;&quot;)

    def __format__(self, format_specifier):
        # When formatted, render to a string, and use string formatting
        return format(self.render(), format_specifier)

    def render(self, *, render_template=''.join,
                        render_field=format):
        # See definition of the template rendering semantics below
</pre>
<p>The result of an interpolation template expression is an instance of this
type, rather than an already rendered string - rendering only takes
place when the instance's <tt class="docutils literal">render</tt> method is called (either directly, or
indirectly via <tt class="docutils literal">__format__</tt>).</p>
<p>The compiler will pass the following details to the interpolation template for
later use:</p>
<ul class="simple">
<li>a string containing the raw template as written in the source code</li>
<li>a parsed template tuple that allows the renderer to render the
template without needing to reparse the raw string template for substitution
fields</li>
<li>a tuple containing the evaluated field values, in field substitution order</li>
<li>a tuple containing the field format specifiers, in field substitution order</li>
</ul>
<p>This structure is designed to take full advantage of compile time constant
folding by ensuring the parsed template is always constant, even when the
field values and format specifiers include variable substitution expressions.</p>
<p>The raw template is just the interpolation template as a string. By default,
it is used to provide a human readable representation for the interpolation
template.</p>
<p>The parsed template consists of a tuple of 2-tuples, with each 2-tuple
containing the following fields:</p>
<ul class="simple">
<li><tt class="docutils literal">leading_text</tt>:  a leading string literal. This will be the empty string if
the current field is at the start of the string, or immediately follows the
preceding field.</li>
<li><tt class="docutils literal">field_expr</tt>: the text of the expression element in the substitution field.
This will be None for a final trailing text segment.</li>
</ul>
<p>The tuple of evaluated field values holds the <em>results</em> of evaluating the
substitution expressions in the scope where the interpolation template appears.</p>
<p>The tuple of field specifiers holds the <em>results</em> of evaluating the field
specifiers as f-strings in the scope where the interpolation template appears.</p>
<p>The <tt class="docutils literal">InterpolationTemplate.render</tt> implementation then defines the rendering
process in terms of the following renderers:</p>
<ul class="simple">
<li>an overall <tt class="docutils literal">render_template</tt> operation that defines how the sequence of
literal template sections and rendered fields are composed into a fully
rendered result. The default template renderer is string concatenation
using <tt class="docutils literal"><span class="pre">''.join</span></tt>.</li>
<li>a per field <tt class="docutils literal">render_field</tt> operation that receives the field value and
format specifier for substitution fields within the template. The default
field renderer is the <tt class="docutils literal">format</tt> builtin.</li>
</ul>
<p>Given an appropriate parsed template representation and internal methods of
iterating over it, the semantics of template rendering would then be equivalent
to the following:</p>
<pre class="literal-block">
def render(self, *, render_template=''.join,
                    render_field=format):
    iter_fields = enumerate(self.parsed_template)
    values = self.field_values
    specifiers = self.format_specifiers
    template_parts = []
    for field_pos, (leading_text, field_expr) in iter_fields:
        template_parts.append(leading_text)
        if field_expr is not None:
            value = values[field_pos]
            specifier = specifiers[field_pos]
            rendered_field = render_field(value, specifier)
            template_parts.append(rendered_field)
    return render_template(template_parts)
</pre>
<div class="section" id="conversion-specifiers">
<h2><a class="toc-backref" href="#id17">Conversion specifiers</a></h2>
<p>NOTE:</p>
<blockquote>
Appropriate handling of conversion specifiers is currently an open question.
Exposing them more directly to custom renderers would increase the
complexity of the <tt class="docutils literal">InterpolationTemplate</tt> definition without providing an
increase in expressiveness (since they're redundant with calling the builtins
directly). At the same time, they <em>are</em> made available as arbitrary strings
when writing custom <tt class="docutils literal">string.Formatter</tt> implementations, so it may be
desirable to offer similar levels of flexibility of interpretation in
interpolation templates.</blockquote>
<p>The <tt class="docutils literal">!a</tt>, <tt class="docutils literal">!r</tt> and <tt class="docutils literal">!s</tt> conversion specifiers supported by <tt class="docutils literal">str.format</tt>
and hence <a class="reference external" href="/dev/peps/pep-0498">PEP 498</a> are handled in interpolation templates as follows:</p>
<ul class="simple">
<li>they're included unmodified in the raw template to ensure no information is
lost</li>
<li>they're <em>replaced</em> in the parsed template with the corresponding builtin
calls, in order to ensure that <tt class="docutils literal">field_expr</tt> always contains a valid
Python expression</li>
<li>the corresponding field value placed in the field values tuple is
converted appropriately <em>before</em> being passed to the interpolation
template</li>
</ul>
<p>This means that, for most purposes, the difference between the use of
conversion specifiers and calling the corresponding builtins in the
original interpolation template will be transparent to custom renderers. The
difference will only be apparent if reparsing the raw template, or attempting
to reconstruct the original template from the parsed template.</p>
</div>
<div class="section" id="writing-custom-renderers">
<h2><a class="toc-backref" href="#id18">Writing custom renderers</a></h2>
<p>Writing a custom renderer doesn't requiring any special syntax. Instead,
custom renderers are ordinary callables that process an interpolation
template directly either by calling the <tt class="docutils literal">render()</tt> method with alternate <tt class="docutils literal">render_template</tt> or <tt class="docutils literal">render_field</tt> implementations, or by accessing the
template's data attributes directly.</p>
<p>For example, the following function would render a template using objects'
<tt class="docutils literal">repr</tt> implementations rather than their native formatting support:</p>
<pre class="literal-block">
def reprformat(template):
    def render_field(value, specifier):
        return format(repr(value), specifier)
    return template.render(render_field=render_field)
</pre>
<p>When writing custom renderers, note that the return type of the overall
rendering operation is determined by the return type of the passed in <tt class="docutils literal">render_template</tt> callable. While this is expected to be a string in most
cases, producing non-string objects <em>is</em> permitted. For example, a custom
template renderer could involve an <tt class="docutils literal">sqlalchemy.sql.text</tt> call that produces
an <a class="reference external" href="http://docs.sqlalchemy.org/en/rel_1_0/core/tutorial.html#using-textual-sql">SQL Alchemy query object</a>.</p>
<p>Non-strings may also be returned from <tt class="docutils literal">render_field</tt>, as long as it is paired
with a <tt class="docutils literal">render_template</tt> implementation that expects that behaviour.</p>
</div>
<div class="section" id="expression-evaluation">
<h2><a class="toc-backref" href="#id19">Expression evaluation</a></h2>
<p>As with f-strings, the subexpressions that are extracted from the interpolation
template are evaluated in the context where the interpolation template
appears. This means the expression has full access to local, nonlocal and global variables. Any valid Python expression can be used inside <tt class="docutils literal">{}</tt>, including
function and method calls.</p>
<p>Because the substitution expressions are evaluated where the string appears in
the source code, there are no additional security concerns related to the
contents of the expression itself, as you could have also just written the
same expression and used runtime field parsing:</p>
<pre class="literal-block">
&gt;&gt;&gt; bar=10
&gt;&gt;&gt; def foo(data):
...   return data + 20
...
&gt;&gt;&gt; str(i'input={bar}, output={foo(bar)}')
'input=10, output=30'
</pre>
<p>Is essentially equivalent to:</p>
<pre class="literal-block">
&gt;&gt;&gt; 'input={}, output={}'.format(bar, foo(bar))
'input=10, output=30'
</pre>
</div>
<div class="section" id="handling-code-injection-attacks">
<h2><a class="toc-backref" href="#id20">Handling code injection attacks</a></h2>
<p>The <a class="reference external" href="/dev/peps/pep-0498">PEP 498</a> formatted string syntax makes it potentially attractive to write
code like the following:</p>
<pre class="literal-block">
runquery(f&quot;SELECT {column} FROM {table};&quot;)
runcommand(f&quot;cat {filename}&quot;)
return_response(f&quot;&lt;html&gt;&lt;body&gt;{response.body}&lt;/body&gt;&lt;/html&gt;&quot;)
</pre>
<p>These all represent potential vectors for code injection attacks, if any of the
variables being interpolated happen to come from an untrusted source. The
specific proposal in this PEP is designed to make it straightforward to write
use case specific renderers that take care of quoting interpolated values
appropriately for the relevant security context:</p>
<pre class="literal-block">
runquery(sql(i&quot;SELECT {column} FROM {table};&quot;))
runcommand(sh(i&quot;cat {filename}&quot;))
return_response(html(i&quot;&lt;html&gt;&lt;body&gt;{response.body}&lt;/body&gt;&lt;/html&gt;&quot;))
</pre>
<p>This PEP does not cover adding such renderers to the standard library
immediately, but rather proposes to ensure that they can be readily provided by
third party libraries, and potentially incorporated into the standard library
at a later date.</p>
<p>For example, a renderer that aimed to offer a POSIX shell style experience for
accessing external programs, without the significant risks posed by running
<tt class="docutils literal">os.system</tt> or enabling the system shell when using the <tt class="docutils literal">subprocess</tt> module
APIs, might provide an interface for running external programs similar to that
offered by the
<a class="reference external" href="http://julia.readthedocs.org/en/latest/manual/running-external-programs/">Julia programming language</a>,
only with the backtick based <tt class="docutils literal">\`cat $filename\`</tt> syntax replaced by
<tt class="docutils literal">i&quot;cat {filename}&quot;</tt> style interpolation templates.</p>
</div>
<div class="section" id="format-specifiers">
<h2><a class="toc-backref" href="#id21">Format specifiers</a></h2>
<p>Aside from separating them out from the substitution expression during parsing,
format specifiers are otherwise treated as opaque strings by the interpolation
template parser - assigning semantics to those (or, alternatively,
prohibiting their use) is handled at runtime by the field renderer.</p>
</div>
<div class="section" id="error-handling">
<h2><a class="toc-backref" href="#id22">Error handling</a></h2>
<p>Either compile time or run time errors can occur when processing interpolation
expressions. Compile time errors are limited to those errors that can be
detected when parsing a template string into its component tuples. These
errors all raise SyntaxError.</p>
<p>Unmatched braces:</p>
<pre class="literal-block">
&gt;&gt;&gt; i'x={x'
  File &quot;&lt;stdin&gt;&quot;, line 1
SyntaxError: missing '}' in interpolation expression
</pre>
<p>Invalid expressions:</p>
<pre class="literal-block">
&gt;&gt;&gt; i'x={!x}'
  File &quot;&lt;fstring&gt;&quot;, line 1
    !x
    ^
SyntaxError: invalid syntax
</pre>
<p>Run time errors occur when evaluating the expressions inside a
template string before creating the interpolation template object. See <a class="reference external" href="/dev/peps/pep-0498">PEP 498</a>
for some examples.</p>
<p>Different renderers may also impose additional runtime
constraints on acceptable interpolated expressions and other formatting
details, which will be reported as runtime exceptions.</p>
</div>
</div>
<div class="section" id="possible-integration-with-the-logging-module">
<h1><a class="toc-backref" href="#id23">Possible integration with the logging module</a></h1>
<p>One of the challenges with the logging module has been that we have previously
been unable to devise a reasonable migration strategy away from the use of
printf-style formatting. The runtime parsing and interpolation overhead for
logging messages also poses a problem for extensive logging of runtime events
for monitoring purposes.</p>
<p>While beyond the scope of this initial PEP, interpolation template support
could potentially be added to the logging module's event reporting APIs,
permitting relevant details to be captured using forms like:</p>
<pre class="literal-block">
logging.debug(i&quot;Event: {event}; Details: {data}&quot;)
logging.critical(i&quot;Error: {error}; Details: {data}&quot;)
</pre>
<p>Rather than the current mod-formatting style:</p>
<pre class="literal-block">
logging.debug(&quot;Event: %s; Details: %s&quot;, event, data)
logging.critical(&quot;Error: %s; Details: %s&quot;, event, data)
</pre>
<p>As the interpolation template is passed in as an ordinary argument, other
keyword arguments would also remain available:</p>
<pre class="literal-block">
logging.critical(i&quot;Error: {error}; Details: {data}&quot;, exc_info=True)
</pre>
<p>As part of any such integration, a recommended approach would need to be
defined for &quot;lazy evaluation&quot; of interpolated fields, as the <tt class="docutils literal">logging</tt>
module's existing delayed interpolation support provides access to
<a class="reference external" href="https://docs.python.org/3/library/logging.html#logrecord-attributes">various attributes</a> of the event <tt class="docutils literal">LogRecord</tt> instance.</p>
<p>For example, since interpolation expressions are arbitrary Python expressions,
string literals could be used to indicate cases where evaluation itself is
being deferred, not just rendering:</p>
<pre class="literal-block">
logging.debug(i&quot;Logger: {'record.name'}; Event: {event}; Details: {data}&quot;)
</pre>
<p>This could be further extended with idioms like using inline tuples to indicate
deferred function calls to be made only if the log message is actually
going to be rendered at current logging levels:</p>
<pre class="literal-block">
logging.debug(i&quot;Event: {event}; Details: {expensive_call, raw_data}&quot;)
</pre>
<p>This kind of approach would be possible as having access to the actual <em>text</em>
of the field expression would allow the logging renderer to distinguish
between inline tuples that appear in the field expression itself, and tuples
that happen to be passed in as data values in a normal field.</p>
</div>
<div class="section" id="discussion">
<h1><a class="toc-backref" href="#id24">Discussion</a></h1>
<p>Refer to <a class="reference external" href="/dev/peps/pep-0498">PEP 498</a> for additional discussion, as several of the points there
also apply to this PEP.</p>
<div class="section" id="deferring-support-for-binary-interpolation">
<h2><a class="toc-backref" href="#id25">Deferring support for binary interpolation</a></h2>
<p>Supporting binary interpolation with this syntax would be relatively
straightforward (the elements in the parsed fields tuple would just be
byte strings rather than text strings, and the default renderer would be
markedly less useful), but poses a significant likelihood of producing
confusing type errors when a text renderer was presented with
binary input.</p>
<p>Since the proposed syntax is useful without binary interpolation support, and
such support can be readily added later, further consideration of binary
interpolation is considered out of scope for the current PEP.</p>
</div>
<div class="section" id="interoperability-with-str-only-interfaces">
<h2><a class="toc-backref" href="#id26">Interoperability with str-only interfaces</a></h2>
<p>For interoperability with interfaces that only accept strings, interpolation
templates can still be prerendered with <tt class="docutils literal">format</tt>, rather than delegating the
rendering to the called function.</p>
<p>This reflects the key difference from <a class="reference external" href="/dev/peps/pep-0498">PEP 498</a>, which <em>always</em> eagerly applies
the default rendering, without any way to delegate the choice of renderer to
another section of the code.</p>
</div>
<div class="section" id="preserving-the-raw-template-string">
<h2><a class="toc-backref" href="#id27">Preserving the raw template string</a></h2>
<p>Earlier versions of this PEP failed to make the raw template string available
on the interpolation template. Retaining it makes it possible to provide a more
attractive template representation, as well as providing the ability to
precisely reconstruct the original string, including both the expression text
and the details of any eagerly rendered substitution fields in format specifiers.</p>
</div>
<div class="section" id="creating-a-rich-object-rather-than-a-global-name-lookup">
<h2><a class="toc-backref" href="#id28">Creating a rich object rather than a global name lookup</a></h2>
<p>Earlier versions of this PEP used an <tt class="docutils literal">__interpolate__</tt> builtin, rather than
a creating a new kind of object for later consumption by interpolation
functions. Creating a rich descriptive object with a useful default renderer
made it much easier to support customisation of the semantics of interpolation.</p>
</div>
<div class="section" id="building-atop-pep-498-rather-than-competing-with-it">
<h2>Building atop <a class="reference external" href="/dev/peps/pep-0498">PEP 498</a>, rather than competing with it</h2>
<p>Earlier versions of this PEP attempted to serve as a complete substitute for
<a class="reference external" href="/dev/peps/pep-0498">PEP 498</a>, rather than building a more flexible delayed rendering capability on
top of <a class="reference external" href="/dev/peps/pep-0498">PEP 498</a>'s eager rendering.</p>
<p>Assuming the presence of f-strings as a supporting capability simplified a
number of aspects of the proposal in this PEP (such as how to handle substitution
fields in format specifiers)</p>
</div>
<div class="section" id="deferring-consideration-of-possible-use-in-i18n-use-cases">
<h2><a class="toc-backref" href="#id30">Deferring consideration of possible use in i18n use cases</a></h2>
<p>The initial motivating use case for this PEP was providing a cleaner syntax
for i18n translation, as that requires access to the original unmodified
template. As such, it focused on compatibility with the substitution syntax used
in Python's <tt class="docutils literal">string.Template</tt> formatting and Mozilla's l20n project.</p>
<p>However, subsequent discussion revealed there are significant additional
considerations to be taken into account in the i18n use case, which don't
impact the simpler cases of handling interpolation into security sensitive
contexts (like HTML, system shells, and database queries), or producing
application debugging messages in the preferred language of the development
team (rather than the native language of end users).</p>
<p>Due to the original design of the <tt class="docutils literal">str.format</tt> substitution syntax in <a class="reference external" href="/dev/peps/pep-3101">PEP
3101</a> being inspired by C#'s string formatting syntax, the specific field
substitution syntax used in <a class="reference external" href="/dev/peps/pep-0498">PEP 498</a> is consistent not only with Python's own <tt class="docutils literal">str.format</tt> syntax, but also with string formatting in C#, including the
native &quot;$-string&quot; interpolation syntax introduced in C# 6.0 (released in July
2015).  The related <tt class="docutils literal">IFormattable</tt> interface in C# forms the basis of a
<a class="reference external" href="https://msdn.microsoft.com/en-us/library/system.iformattable.aspx">number of elements</a> of C#'s internationalization and localization
support.</p>
<p>This means that while this particular substitution syntax may not
currently be widely used for translation of <em>Python</em> applications (losing out
to traditional %-formatting and the designed-specifically-for-i18n
<tt class="docutils literal">string.Template</tt> formatting), it <em>is</em> a popular translation format in the
wider software development ecosystem (since it is already the preferred
format for translating C# applications).</p>
</div>
</div>
<div class="section" id="acknowledgements">
<h1><a class="toc-backref" href="#id31">Acknowledgements</a></h1>
<ul class="simple">
<li>Eric V. Smith for creating <a class="reference external" href="/dev/peps/pep-0498">PEP 498</a> and demonstrating the feasibility of
arbitrary expression substitution in string interpolation</li>
<li>Barry Warsaw, Armin Ronacher, and Mike Miller for their contributions to
exploring the feasibility of using this model of delayed rendering in i18n
use cases (even though the ultimate conclusion was that it was a poor fit,
at least for current approaches to i18n in Python)</li>
</ul>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id32">References</a></h1>
<table class="docutils footnote" frame="void" id="id1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>%-formatting
(<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting">https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>str.format
(<a class="reference external" href="https://docs.python.org/3/library/string.html#formatstrings">https://docs.python.org/3/library/string.html#formatstrings</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>string.Template documentation
(<a class="reference external" href="https://docs.python.org/3/library/string.html#template-strings">https://docs.python.org/3/library/string.html#template-strings</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td><a class="reference external" href="/dev/peps/pep-0215">PEP 215</a>: String Interpolation
(<a class="reference external" href="https://www.python.org/dev/peps/pep-0215/">https://www.python.org/dev/peps/pep-0215/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td><a class="reference external" href="/dev/peps/pep-0292">PEP 292</a>: Simpler String Substitutions
(<a class="reference external" href="https://www.python.org/dev/peps/pep-0292/">https://www.python.org/dev/peps/pep-0292/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[6]</td><td><a class="reference external" href="/dev/peps/pep-3101">PEP 3101</a>: Advanced String Formatting
(<a class="reference external" href="https://www.python.org/dev/peps/pep-3101/">https://www.python.org/dev/peps/pep-3101/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[7]</td><td><a class="reference external" href="/dev/peps/pep-0498">PEP 498</a>: Literal string formatting
(<a class="reference external" href="https://www.python.org/dev/peps/pep-0498/">https://www.python.org/dev/peps/pep-0498/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[8]</td><td>FormattableString and C# native string interpolation
(<a class="reference external" href="https://msdn.microsoft.com/en-us/library/dn961160.aspx">https://msdn.microsoft.com/en-us/library/dn961160.aspx</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[9]</td><td>IFormattable interface in C# (see remarks for globalization notes)
(<a class="reference external" href="https://msdn.microsoft.com/en-us/library/system.iformattable.aspx">https://msdn.microsoft.com/en-us/library/system.iformattable.aspx</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[10]</td><td>Running external commands in Julia
(<a class="reference external" href="http://julia.readthedocs.org/en/latest/manual/running-external-programs/">http://julia.readthedocs.org/en/latest/manual/running-external-programs/</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id33">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

