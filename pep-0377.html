<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">377</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Allow __enter__() methods to skip the statement body</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0377.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Nick Coghlan &lt;ncoghlan&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">8-Mar-2009</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.7, 3.1</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">8-Mar-2009</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id10">Abstract</a></li>
<li><a class="reference internal" href="#pep-rejection" id="id11">PEP Rejection</a></li>
<li><a class="reference internal" href="#proposed-change" id="id12">Proposed Change</a></li>
<li><a class="reference internal" href="#rationale-for-change" id="id13">Rationale for Change</a></li>
<li><a class="reference internal" href="#performance-impact" id="id14">Performance Impact</a></li>
<li><a class="reference internal" href="#reference-implementation" id="id15">Reference Implementation</a></li>
<li><a class="reference internal" href="#acknowledgements" id="id16">Acknowledgements</a></li>
<li><a class="reference internal" href="#references" id="id17">References</a></li>
<li><a class="reference internal" href="#copyright" id="id18">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id10">Abstract</a></h1>
<p>This PEP proposes a backwards compatible mechanism that allows <tt class="docutils literal">__enter__()</tt>
methods to skip the body of the associated <tt class="docutils literal">with</tt> statement. The lack of
this ability currently means the <tt class="docutils literal">contextlib.contextmanager</tt> decorator
is unable to fulfil its specification of being able to turn arbitrary
code into a context manager by moving it into a generator function
with a yield in the appropriate location. One symptom of this is that
<tt class="docutils literal">contextlib.nested</tt> will currently raise <tt class="docutils literal">RuntimeError</tt> in
situations where writing out the corresponding nested <tt class="docutils literal">with</tt>
statements would not <a class="footnote-reference" href="#id6" id="id1">[1]</a>.</p>
<p>The proposed change is to introduce a new flow control exception
<tt class="docutils literal">SkipStatement</tt>, and skip the execution of the <tt class="docutils literal">with</tt>
statement body if <tt class="docutils literal">__enter__()</tt> raises this exception.</p>
</div>
<div class="section" id="pep-rejection">
<h1><a class="toc-backref" href="#id11">PEP Rejection</a></h1>
<p>This PEP was rejected by Guido <a class="footnote-reference" href="#id9" id="id2">[4]</a> as it imposes too great an increase
in complexity without a proportional increase in expressiveness and
correctness. In the absence of compelling use cases that need the more
complex semantics proposed by this PEP the existing behaviour is
considered acceptable.</p>
</div>
<div class="section" id="proposed-change">
<h1><a class="toc-backref" href="#id12">Proposed Change</a></h1>
<p>The semantics of the <tt class="docutils literal">with</tt> statement will be changed to include a
new <tt class="docutils literal">try</tt>/<tt class="docutils literal">except</tt>/<tt class="docutils literal">else</tt> block around the call to <tt class="docutils literal">__enter__()</tt>.
If <tt class="docutils literal">SkipStatement</tt> is raised by the <tt class="docutils literal">__enter__()</tt> method, then
the main section of the <tt class="docutils literal">with</tt> statement (now located in the <tt class="docutils literal">else</tt>
clause) will not be executed. To avoid leaving the names in any <tt class="docutils literal">as</tt>
clause unbound in this case, a new <tt class="docutils literal">StatementSkipped</tt> singleton
(similar to the existing <tt class="docutils literal">NotImplemented</tt> singleton) will be
assigned to all names that appear in the <tt class="docutils literal">as</tt> clause.</p>
<p>The components of the <tt class="docutils literal">with</tt> statement remain as described in <a class="reference external" href="/dev/peps/pep-0343">PEP 343</a> <a class="footnote-reference" href="#id7" id="id3">[2]</a>:</p>
<pre class="literal-block">
with EXPR as VAR:
    BLOCK
</pre>
<p>After the modification, the <tt class="docutils literal">with</tt> statement semantics would
be as follows:</p>
<pre class="literal-block">
mgr = (EXPR)
exit = mgr.__exit__  # Not calling it yet
try:
    value = mgr.__enter__()
except SkipStatement:
    VAR = StatementSkipped
    # Only if &quot;as VAR&quot; is present and
    # VAR is a single name
    # If VAR is a tuple of names, then StatementSkipped
    # will be assigned to each name in the tuple
else:
    exc = True
    try:
        try:
            VAR = value  # Only if &quot;as VAR&quot; is present
            BLOCK
        except:
            # The exceptional case is handled here
            exc = False
            if not exit(*sys.exc_info()):
                raise
            # The exception is swallowed if exit() returns true
    finally:
        # The normal and non-local-goto cases are handled here
        if exc:
            exit(None, None, None)
</pre>
<p>With the above change in place for the <tt class="docutils literal">with</tt> statement semantics,
<tt class="docutils literal">contextlib.contextmanager()</tt> will then be modified to raise
<tt class="docutils literal">SkipStatement</tt> instead of <tt class="docutils literal">RuntimeError</tt> when the underlying
generator doesn't yield.</p>
</div>
<div class="section" id="rationale-for-change">
<h1><a class="toc-backref" href="#id13">Rationale for Change</a></h1>
<p>Currently, some apparently innocuous context managers may raise
<tt class="docutils literal">RuntimeError</tt> when executed. This occurs when the context
manager's <tt class="docutils literal">__enter__()</tt> method encounters a situation where
the written out version of the code corresponding to the
context manager would skip the code that is now the body
of the <tt class="docutils literal">with</tt> statement. Since the <tt class="docutils literal">__enter__()</tt> method
has no mechanism available to signal this to the interpreter,
it is instead forced to raise an exception that not only
skips the body of the <tt class="docutils literal">with</tt> statement, but also jumps over
all code until the nearest exception handler. This goes against
one of the design goals of the <tt class="docutils literal">with</tt> statement, which was to
be able to factor out arbitrary common exception handling code
into a single context manager by putting into a generator
function and replacing the variant part of the code with a
<tt class="docutils literal">yield</tt> statement.</p>
<p>Specifically, the following examples behave differently if
<tt class="docutils literal"><span class="pre">cmB().__enter__()</span></tt> raises an exception which <tt class="docutils literal"><span class="pre">cmA().__exit__()</span></tt>
then handles and suppresses:</p>
<pre class="literal-block">
with cmA():
  with cmB():
    do_stuff()
# This will resume here without executing &quot;do_stuff()&quot;

&#64;contextlib.contextmanager
def combined():
  with cmA():
    with cmB():
      yield

with combined():
  do_stuff()
# This will raise a RuntimeError complaining that the context
# manager's underlying generator didn't yield

with contextlib.nested(cmA(), cmB()):
  do_stuff()
# This will raise the same RuntimeError as the contextmanager()
# example (unsurprising, given that the nested() implementation
# uses contextmanager())

# The following class based version shows that the issue isn't
# specific to contextlib.contextmanager() (it also shows how
# much simpler it is to write context managers as generators
# instead of as classes!)
class CM(object):
  def __init__(self):
    self.cmA = None
    self.cmB = None

  def __enter__(self):
    if self.cmA is not None:
      raise RuntimeError(&quot;Can't re-use this CM&quot;)
    self.cmA = cmA()
    self.cmA.__enter__()
    try:
      self.cmB = cmB()
      self.cmB.__enter__()
    except:
      self.cmA.__exit__(*sys.exc_info())
      # Can't suppress in __enter__(), so must raise
      raise

  def __exit__(self, *args):
    suppress = False
    try:
      if self.cmB is not None:
        suppress = self.cmB.__exit__(*args)
    except:
      suppress = self.cmA.__exit__(*sys.exc_info()):
      if not suppress:
        # Exception has changed, so reraise explicitly
        raise
    else:
      if suppress:
        # cmB already suppressed the exception,
        # so don't pass it to cmA
        suppress = self.cmA.__exit__(None, None, None):
      else:
        suppress = self.cmA.__exit__(*args):
    return suppress
</pre>
<p>With the proposed semantic change in place, the contextlib based examples
above would then &quot;just work&quot;, but the class based version would need
a small adjustment to take advantage of the new semantics:</p>
<pre class="literal-block">
class CM(object):
  def __init__(self):
    self.cmA = None
    self.cmB = None

  def __enter__(self):
    if self.cmA is not None:
      raise RuntimeError(&quot;Can't re-use this CM&quot;)
    self.cmA = cmA()
    self.cmA.__enter__()
    try:
      self.cmB = cmB()
      self.cmB.__enter__()
    except:
      if self.cmA.__exit__(*sys.exc_info()):
        # Suppress the exception, but don't run
        # the body of the with statement either
        raise SkipStatement
      raise

  def __exit__(self, *args):
    suppress = False
    try:
      if self.cmB is not None:
        suppress = self.cmB.__exit__(*args)
    except:
      suppress = self.cmA.__exit__(*sys.exc_info()):
      if not suppress:
        # Exception has changed, so reraise explicitly
        raise
    else:
      if suppress:
        # cmB already suppressed the exception,
        # so don't pass it to cmA
        suppress = self.cmA.__exit__(None, None, None):
      else:
        suppress = self.cmA.__exit__(*args):
    return suppress
</pre>
<p>There is currently a tentative suggestion <a class="footnote-reference" href="#id8" id="id4">[3]</a> to add import-style syntax to
the <tt class="docutils literal">with</tt> statement to allow multiple context managers to be included in
a single <tt class="docutils literal">with</tt> statement without needing to use <tt class="docutils literal">contextlib.nested</tt>. In
that case the compiler has the option of simply emitting multiple <tt class="docutils literal">with</tt>
statements at the AST level, thus allowing the semantics of actual nested
<tt class="docutils literal">with</tt> statements to be reproduced accurately. However, such a change
would highlight rather than alleviate the problem the current PEP aims to
address: it would not be possible to use <tt class="docutils literal">contextlib.contextmanager</tt> to
reliably factor out such <tt class="docutils literal">with</tt> statements, as they would exhibit exactly
the same semantic differences as are seen with the <tt class="docutils literal">combined()</tt> context
manager in the above example.</p>
</div>
<div class="section" id="performance-impact">
<h1><a class="toc-backref" href="#id14">Performance Impact</a></h1>
<p>Implementing the new semantics makes it necessary to store the references
to the <tt class="docutils literal">__enter__</tt> and <tt class="docutils literal">__exit__</tt> methods in temporary variables instead
of on the stack. This results in a slight regression in <tt class="docutils literal">with</tt> statement
speed relative to Python 2.6/3.1. However, implementing a custom
<tt class="docutils literal">SETUP_WITH</tt> opcode would negate any differences between the two
approaches (as well as dramatically improving speed by eliminating more
than a dozen unnecessary trips around the eval loop).</p>
</div>
<div class="section" id="reference-implementation">
<h1><a class="toc-backref" href="#id15">Reference Implementation</a></h1>
<p>Patch attached to Issue 5251 <a class="footnote-reference" href="#id6" id="id5">[1]</a>. That patch uses only existing opcodes
(i.e. no <tt class="docutils literal">SETUP_WITH</tt>).</p>
</div>
<div class="section" id="acknowledgements">
<h1><a class="toc-backref" href="#id16">Acknowledgements</a></h1>
<p>James William Pye both raised the issue and suggested the basic outline of
the solution described in this PEP.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id17">References</a></h1>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id5">2</a>)</em> Issue 5251: contextlib.nested inconsistent with nested with statements
(<a class="reference external" href="http://bugs.python.org/issue5251">http://bugs.python.org/issue5251</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td><a class="reference external" href="/dev/peps/pep-0343">PEP 343</a>: The &quot;with&quot; Statement
(<a class="reference external" href="http://www.python.org/dev/peps/pep-0343/">http://www.python.org/dev/peps/pep-0343/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td>Import-style syntax to reduce indentation of nested with statements
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2009-March/003188.html">https://mail.python.org/pipermail/python-ideas/2009-March/003188.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[4]</a></td><td>Guido's rejection of the PEP
(<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2009-March/087263.html">https://mail.python.org/pipermail/python-dev/2009-March/087263.html</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id18">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>

