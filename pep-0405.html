<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">405</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Python Virtual Environments</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0405.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Carl Meyer &lt;carl&#32;&#97;t&#32;oddbird.net&gt;</td>
</tr>
<tr class="field"><th class="field-name">BDFL-Delegate:</th><td class="field-body">Nick Coghlan</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">13-Jun-2011</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.3</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">24-Oct-2011, 28-Oct-2011, 06-Mar-2012, 24-May-2012</td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2012-May/119668.html">https://mail.python.org/pipermail/python-dev/2012-May/119668.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id17">Abstract</a></li>
<li><a class="reference internal" href="#motivation" id="id18">Motivation</a></li>
<li><a class="reference internal" href="#specification" id="id19">Specification</a><ul>
<li><a class="reference internal" href="#isolation-from-system-site-packages" id="id20">Isolation from system site-packages</a></li>
<li><a class="reference internal" href="#creating-virtual-environments" id="id21">Creating virtual environments</a></li>
<li><a class="reference internal" href="#sysconfig-install-schemes-and-user-site" id="id22">Sysconfig install schemes and user-site</a></li>
<li><a class="reference internal" href="#copies-versus-symlinks" id="id23">Copies versus symlinks</a></li>
<li><a class="reference internal" href="#include-files" id="id24">Include files</a></li>
<li><a class="reference internal" href="#api" id="id25">API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility" id="id26">Backwards Compatibility</a><ul>
<li><a class="reference internal" href="#splitting-the-meanings-of-sys-prefix" id="id27">Splitting the meanings of <tt class="docutils literal">sys.prefix</tt></a></li>
<li><a class="reference internal" href="#impact-on-other-python-implementations" id="id28">Impact on other Python implementations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference-implementation" id="id29">Reference Implementation</a></li>
<li><a class="reference internal" href="#id2" id="id30">References</a></li>
<li><a class="reference internal" href="#copyright" id="id31">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id17">Abstract</a></h1>
<p>This PEP proposes to add to Python a mechanism for lightweight
&quot;virtual environments&quot; with their own site directories, optionally
isolated from system site directories.  Each virtual environment has
its own Python binary (allowing creation of environments with various
Python versions) and can have its own independent set of installed
Python packages in its site directories, but shares the standard
library with the base installed Python.</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id18">Motivation</a></h1>
<p>The utility of Python virtual environments has already been well
established by the popularity of existing third-party
virtual-environment tools, primarily Ian Bicking's <a class="reference external" href="http://www.virtualenv.org">virtualenv</a> <a class="footnote-reference" href="#id3" id="id4">[1]</a>.
Virtual environments are already widely used for dependency management
and isolation, ease of installing and using Python packages without
system-administrator access, and automated testing of Python software
across multiple Python versions, among other uses.</p>
<p>Existing virtual environment tools suffer from lack of support from
the behavior of Python itself.  Tools such as <a class="reference external" href="https://github.com/kvbik/rvirtualenv">rvirtualenv</a> <a class="footnote-reference" href="#id5" id="id6">[2]</a>, which do
not copy the Python binary into the virtual environment, cannot
provide reliable isolation from system site directories.  Virtualenv,
which does copy the Python binary, is forced to duplicate much of
Python's <tt class="docutils literal">site</tt> module and manually symlink/copy an ever-changing
set of standard-library modules into the virtual environment in order
to perform a delicate boot-strapping dance at every startup.
(Virtualenv must copy the binary in order to provide isolation, as
Python dereferences a symlinked executable before searching for
<tt class="docutils literal">sys.prefix</tt>.)</p>
<p>The <tt class="docutils literal">PYTHONHOME</tt> environment variable, Python's only existing
built-in solution for virtual environments, requires
copying/symlinking the entire standard library into every environment.
Copying the whole standard library is not a lightweight solution, and
cross-platform support for symlinks remains inconsistent (even on
Windows platforms that do support them, creating them often requires
administrator privileges).</p>
<p>A virtual environment mechanism integrated with Python and drawing on
years of experience with existing third-party tools can lower
maintenance, raise reliability, and be more easily available to all
Python users.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id19">Specification</a></h1>
<p>When the Python binary is executed, it attempts to determine its
prefix (which it stores in <tt class="docutils literal">sys.prefix</tt>), which is then used to find
the standard library and other key files, and by the <tt class="docutils literal">site</tt> module
to determine the location of the site-package directories.  Currently
the prefix is found (assuming <tt class="docutils literal">PYTHONHOME</tt> is not set) by first
walking up the filesystem tree looking for a marker file (<tt class="docutils literal">os.py</tt>)
that signifies the presence of the standard library, and if none is
found, falling back to the build-time prefix hardcoded in the binary.</p>
<p>This PEP proposes to add a new first step to this search.  If a
<tt class="docutils literal">pyvenv.cfg</tt> file is found either adjacent to the Python executable or
one directory above it (if the executable is a symlink, it is not
dereferenced), this file is scanned for lines of the form <tt class="docutils literal">key =
value</tt>.  If a <tt class="docutils literal">home</tt> key is found, this signifies that the Python
binary belongs to a virtual environment, and the value of the <tt class="docutils literal">home</tt>
key is the directory containing the Python executable used to create
this virtual environment.</p>
<p>In this case, prefix-finding continues as normal using the value of
the <tt class="docutils literal">home</tt> key as the effective Python binary location, which finds
the prefix of the base installation.  <tt class="docutils literal">sys.base_prefix</tt> is set to
this value, while <tt class="docutils literal">sys.prefix</tt> is set to the directory containing
<tt class="docutils literal">pyvenv.cfg</tt>.</p>
<p>(If <tt class="docutils literal">pyvenv.cfg</tt> is not found or does not contain the <tt class="docutils literal">home</tt> key,
prefix-finding continues normally, and <tt class="docutils literal">sys.prefix</tt> will be equal to
<tt class="docutils literal">sys.base_prefix</tt>.)</p>
<p>Also, <tt class="docutils literal">sys.base_exec_prefix</tt> is added, and handled similarly with
regard to <tt class="docutils literal">sys.exec_prefix</tt>. (<tt class="docutils literal">sys.exec_prefix</tt> is the equivalent of
<tt class="docutils literal">sys.prefix</tt>, but for platform-specific files; by default it has the
same value as <tt class="docutils literal">sys.prefix</tt>.)</p>
<p>The <tt class="docutils literal">site</tt> and <tt class="docutils literal">sysconfig</tt> standard-library modules are modified
such that the standard library and header files are found relative
to <tt class="docutils literal">sys.base_prefix</tt> / <tt class="docutils literal">sys.base_exec_prefix</tt>, while site-package
directories (&quot;purelib&quot; and &quot;platlib&quot;, in <tt class="docutils literal">sysconfig</tt> terms) are still
found relative to <tt class="docutils literal">sys.prefix</tt> / <tt class="docutils literal">sys.exec_prefix</tt>.</p>
<p>Thus, a Python virtual environment in its simplest form would consist
of nothing more than a copy or symlink of the Python binary
accompanied by a <tt class="docutils literal">pyvenv.cfg</tt> file and a site-packages directory.</p>
<div class="section" id="isolation-from-system-site-packages">
<h2><a class="toc-backref" href="#id20">Isolation from system site-packages</a></h2>
<p>By default, a virtual environment is entirely isolated from the
system-level site-packages directories.</p>
<p>If the <tt class="docutils literal">pyvenv.cfg</tt> file also contains a key
<tt class="docutils literal"><span class="pre">include-system-site-packages</span></tt> with a value of <tt class="docutils literal">true</tt> (not case
sensitive), the <tt class="docutils literal">site</tt> module will also add the system site
directories to <tt class="docutils literal">sys.path</tt> after the virtual environment site
directories.  Thus system-installed packages will still be importable,
but a package of the same name installed in the virtual environment
will take precedence.</p>
<p><a class="reference external" href="/dev/peps/pep-0370">PEP 370</a> user-level site-packages are considered part of the system
site-packages for venv purposes: they are not available from an
isolated venv, but are available from an
<tt class="docutils literal"><span class="pre">include-system-site-packages</span> = true</tt> venv.</p>
</div>
<div class="section" id="creating-virtual-environments">
<h2><a class="toc-backref" href="#id21">Creating virtual environments</a></h2>
<p>This PEP also proposes adding a new <tt class="docutils literal">venv</tt> module to the standard
library which implements the creation of virtual environments.  This
module can be executed using the <tt class="docutils literal"><span class="pre">-m</span></tt> flag:</p>
<pre class="literal-block">
python3 -m venv /path/to/new/virtual/environment
</pre>
<p>A <tt class="docutils literal">pyvenv</tt> installed script is also provided to make this more
convenient:</p>
<pre class="literal-block">
pyvenv /path/to/new/virtual/environment
</pre>
<p>Running this command creates the target directory (creating any parent
directories that don't exist already) and places a <tt class="docutils literal">pyvenv.cfg</tt> file
in it with a <tt class="docutils literal">home</tt> key pointing to the Python installation the
command was run from.  It also creates a <tt class="docutils literal">bin/</tt> (or <tt class="docutils literal">Scripts</tt> on
Windows) subdirectory containing a copy (or symlink) of the <tt class="docutils literal">python3</tt>
executable, and the <tt class="docutils literal">pysetup3</tt> script from the <tt class="docutils literal">packaging</tt> standard
library module (to facilitate easy installation of packages from PyPI
into the new venv).  And it creates an (initially empty)
<tt class="docutils literal"><span class="pre">lib/pythonX.Y/site-packages</span></tt> (or <tt class="docutils literal"><span class="pre">Lib\site-packages</span></tt> on Windows)
subdirectory.</p>
<p>If the target directory already exists an error will be raised, unless
the <tt class="docutils literal"><span class="pre">--clear</span></tt> option was provided, in which case the target
directory will be deleted and virtual environment creation will
proceed as usual.</p>
<p>The created <tt class="docutils literal">pyvenv.cfg</tt> file also includes the
<tt class="docutils literal"><span class="pre">include-system-site-packages</span></tt> key, set to <tt class="docutils literal">true</tt> if <tt class="docutils literal">pyvenv</tt> is
run with the <tt class="docutils literal"><span class="pre">--system-site-packages</span></tt> option, <tt class="docutils literal">false</tt> by default.</p>
<p>Multiple paths can be given to <tt class="docutils literal">pyvenv</tt>, in which case an identical
venv will be created, according to the given options, at each
provided path.</p>
<p>The <tt class="docutils literal">venv</tt> module also places &quot;shell activation scripts&quot; for POSIX and
Windows systems in the <tt class="docutils literal">bin</tt> or <tt class="docutils literal">Scripts</tt> directory of the
venv. These scripts simply add the virtual environment's <tt class="docutils literal">bin</tt> (or
<tt class="docutils literal">Scripts</tt>) directory to the front of the user's shell PATH.  This is
not strictly necessary for use of a virtual environment (as an explicit
path to the venv's python binary or scripts can just as well be used),
but it is convenient.</p>
<p>In order to allow <tt class="docutils literal">pysetup</tt> and other Python package managers to
install packages into the virtual environment the same way they would
install into a normal Python installation, and avoid special-casing
virtual environments in <tt class="docutils literal">sysconfig</tt> beyond using <tt class="docutils literal">sys.base_prefix</tt>
in place of <tt class="docutils literal">sys.prefix</tt> where appropriate, the internal virtual
environment layout mimics the layout of the Python installation itself
on each platform.  So a typical virtual environment layout on a POSIX
system would be:</p>
<pre class="literal-block">
pyvenv.cfg
bin/python3
bin/python
bin/pysetup3
include/
lib/python3.3/site-packages/
</pre>
<p>While on a Windows system:</p>
<pre class="literal-block">
pyvenv.cfg
Scripts/python.exe
Scripts/python3.dll
Scripts/pysetup3.exe
Scripts/pysetup3-script.py
        ... other DLLs and pyds...
Include/
Lib/site-packages/
</pre>
<p>Third-party packages installed into the virtual environment will have
their Python modules placed in the <tt class="docutils literal"><span class="pre">site-packages</span></tt> directory, and
their executables placed in <tt class="docutils literal">bin/</tt> or <tt class="docutils literal">Scripts</tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On a normal Windows system-level installation, the Python binary
itself wouldn't go inside the &quot;Scripts/&quot; subdirectory, as it does
in the default venv layout.  This is useful in a virtual
environment so that a user only has to add a single directory to
their shell PATH in order to effectively &quot;activate&quot; the virtual
environment.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On Windows, it is necessary to also copy or symlink DLLs and pyd
files from compiled stdlib modules into the env, because if the
venv is created from a non-system-wide Python installation,
Windows won't be able to find the Python installation's copies of
those files when Python is run from the venv.</p>
</div>
</div>
<div class="section" id="sysconfig-install-schemes-and-user-site">
<h2><a class="toc-backref" href="#id22">Sysconfig install schemes and user-site</a></h2>
<p>This approach explicitly chooses not to introduce a new sysconfig
install scheme for venvs. Rather, by modifying <tt class="docutils literal">sys.prefix</tt> we
ensure that existing install schemes which base locations on
<tt class="docutils literal">sys.prefix</tt> will simply work in a venv. Installation to other
install schemes (for instance, the user-site schemes) whose paths are
not relative to <tt class="docutils literal">sys.prefix</tt>, will not be affected by a venv at all.</p>
<p>It may be feasible to create an alternative implementation of Python
virtual environments based on a virtual-specific sysconfig scheme, but
it would be less robust, as it would require more code to be aware of
whether it is operating within a virtual environment or not.</p>
</div>
<div class="section" id="copies-versus-symlinks">
<h2><a class="toc-backref" href="#id23">Copies versus symlinks</a></h2>
<p>The technique in this PEP works equally well in general with a copied
or symlinked Python binary (and other needed DLLs on Windows).
Symlinking is preferable where possible, because in the case of an
upgrade to the underlying Python installation, a Python executable
copied in a venv might become out-of-sync with the installed standard
library and require manual upgrade.</p>
<p>There are some cross-platform difficulties with symlinks:</p>
<ul class="simple">
<li>Not all Windows versions support symlinks, and even on those that
do, creating them often requires administrator privileges.</li>
<li>On OS X framework builds of Python, sys.executable is just a stub
that executes the real Python binary.  Symlinking this stub does not
work; it must be copied.  (Fortunately the stub is also small, and
not changed by bugfix upgrades to Python, so copying it is not an
issue).</li>
</ul>
<p>Thus, this PEP proposes to symlink the binary on all platforms except
for Windows, and OS X framework builds. A <tt class="docutils literal"><span class="pre">--symlink</span></tt> option is
available to force the use of symlinks on Windows versions that
support them, if the appropriate permissions are available. (This
option has no effect on OS X framework builds, since symlinking can
never work there, and has no advantages).</p>
<p>On Windows, if <tt class="docutils literal"><span class="pre">--symlink</span></tt> is not used, this means that if the
underlying Python installation is upgraded, the Python binary and DLLs
in the venv should be updated, or there could be issues of mismatch
with the upgraded standard library. The pyvenv script accepts a
<tt class="docutils literal"><span class="pre">--upgrade</span></tt> option for easily performing this upgrade on an existing
venv.</p>
</div>
<div class="section" id="include-files">
<h2><a class="toc-backref" href="#id24">Include files</a></h2>
<p>Current virtualenv handles include files in this way:</p>
<p>On POSIX systems where the installed Python's include files are found in
<tt class="docutils literal"><span class="pre">${base_prefix}/include/pythonX.X</span></tt>, virtualenv creates
<tt class="docutils literal"><span class="pre">${venv}/include/</span></tt> and symlinks <tt class="docutils literal"><span class="pre">${base_prefix}/include/pythonX.X</span></tt>
to <tt class="docutils literal"><span class="pre">${venv}/include/pythonX.X</span></tt>. On Windows, where Python's include
files are found in <tt class="docutils literal">{{ sys.prefix <span class="pre">}}/Include</span></tt> and symlinks are not
reliably available, virtualenv copies <tt class="docutils literal">{{ sys.prefix <span class="pre">}}/Include</span></tt> to
<tt class="docutils literal"><span class="pre">${venv}/Include</span></tt>. This ensures that extension modules built and
installed within the virtualenv will always find the Python header files
they need in the expected location relative to <tt class="docutils literal">sys.prefix</tt>.</p>
<p>This solution is not ideal when an extension module installs its own
header files, as the default installation location for those header
files may be a symlink to a system directory that may not be
writable. One installer, pip, explicitly works around this by
installing header files to a nonstandard location
<tt class="docutils literal"><span class="pre">${venv}/include/site/pythonX.X/</span></tt>, as in Python there's currently no
standard abstraction for a site-specific include directory.</p>
<p>This PEP proposes a slightly different approach, though one with
essentially the same effect and the same set of advantages and
disadvantages. Rather than symlinking or copying include files into the
venv, we simply modify the sysconfig schemes so that header files are
always sought relative to <tt class="docutils literal">base_prefix</tt> rather than <tt class="docutils literal">prefix</tt>. (We
also create an <tt class="docutils literal">include/</tt> directory within the venv, so installers
have somewhere to put include files installed within the env).</p>
<p>Better handling of include files in distutils/packaging and, by
extension, pyvenv, is an area that may deserve its own future PEP. For
now, we propose that the behavior of virtualenv has thus far proved
itself to be at least &quot;good enough&quot; in practice.</p>
</div>
<div class="section" id="api">
<h2><a class="toc-backref" href="#id25">API</a></h2>
<p>The high-level method described above makes use of a simple API which
provides mechanisms for third-party virtual environment creators to
customize environment creation according to their needs.</p>
<p>The <tt class="docutils literal">venv</tt> module contains an <tt class="docutils literal">EnvBuilder</tt> class which accepts the
following keyword arguments on instantiation:</p>
<ul class="simple">
<li><tt class="docutils literal">system_site_packages</tt> - A Boolean value indicating that the
system Python site-packages should be available to the environment.
Defaults to <tt class="docutils literal">False</tt>.</li>
<li><tt class="docutils literal">clear</tt> - A Boolean value which, if true, will delete any existing
target directory instead of raising an exception.  Defaults to
<tt class="docutils literal">False</tt>.</li>
<li><tt class="docutils literal">symlinks</tt> - A Boolean value indicating whether to attempt to
symlink the Python binary (and any necessary DLLs or other binaries,
e.g. <tt class="docutils literal">pythonw.exe</tt>), rather than copying.  Defaults to <tt class="docutils literal">False</tt>.</li>
</ul>
<p>The instantiated env-builder has a <tt class="docutils literal">create</tt> method, which takes as
required argument the path (absolute or relative to the current
directory) of the target directory which is to contain the virtual
environment.  The <tt class="docutils literal">create</tt> method either creates the environment in
the specified directory, or raises an appropriate exception.</p>
<p>The <tt class="docutils literal">venv</tt> module also provides a module-level <tt class="docutils literal">create</tt> function
as a convenience:</p>
<pre class="literal-block">
def create(env_dir,
           system_site_packages=False, clear=False, use_symlinks=False):
    builder = EnvBuilder(
        system_site_packages=system_site_packages,
        clear=clear,
        use_symlinks=use_symlinks)
    builder.create(env_dir)
</pre>
<p>Creators of third-party virtual environment tools are free to use the
provided <tt class="docutils literal">EnvBuilder</tt> class as a base class.</p>
<p>The <tt class="docutils literal">create</tt> method of the <tt class="docutils literal">EnvBuilder</tt> class illustrates the
hooks available for customization:</p>
<pre class="literal-block">
def create(self, env_dir):
    &quot;&quot;&quot;
    Create a virtualized Python environment in a directory.

    :param env_dir: The target directory to create an environment in.

    &quot;&quot;&quot;
    env_dir = os.path.abspath(env_dir)
    context = self.create_directories(env_dir)
    self.create_configuration(context)
    self.setup_python(context)
    self.post_setup(context)
</pre>
<p>Each of the methods <tt class="docutils literal">create_directories</tt>, <tt class="docutils literal">create_configuration</tt>,
<tt class="docutils literal">setup_python</tt>, and <tt class="docutils literal">post_setup</tt> can be overridden.  The functions
of these methods are:</p>
<ul class="simple">
<li><tt class="docutils literal">create_directories</tt> - creates the environment directory and all
necessary directories, and returns a context object.  This is just a
holder for attributes (such as paths), for use by the other methods.</li>
<li><tt class="docutils literal">create_configuration</tt> - creates the <tt class="docutils literal">pyvenv.cfg</tt> configuration
file in the environment.</li>
<li><tt class="docutils literal">setup_python</tt> - creates a copy of the Python executable (and,
under Windows, DLLs) in the environment.</li>
<li><tt class="docutils literal">post_setup</tt> - A (no-op by default) hook method which can be
overridden in third party subclasses to pre-install packages or
install scripts in the virtual environment.</li>
</ul>
<p>In addition, <tt class="docutils literal">EnvBuilder</tt> provides a utility method that can be
called from <tt class="docutils literal">post_setup</tt> in subclasses to assist in installing
custom scripts into the virtual environment.  The method
<tt class="docutils literal">install_scripts</tt> accepts as arguments the <tt class="docutils literal">context</tt> object (see
above) and a path to a directory.  The directory should contain
subdirectories &quot;common&quot;, &quot;posix&quot;, &quot;nt&quot;, each containing scripts
destined for the bin directory in the environment.  The contents of
&quot;common&quot; and the directory corresponding to <tt class="docutils literal">os.name</tt> are copied
after doing some text replacement of placeholders:</p>
<ul class="simple">
<li><tt class="docutils literal">__VENV_DIR__</tt> is replaced with absolute path of the environment
directory.</li>
<li><tt class="docutils literal">__VENV_NAME__</tt> is replaced with the environment name (final path
segment of environment directory).</li>
<li><tt class="docutils literal">__VENV_BIN_NAME__</tt> is replaced with the name of the bin directory
(either <tt class="docutils literal">bin</tt> or <tt class="docutils literal">Scripts</tt>).</li>
<li><tt class="docutils literal">__VENV_PYTHON__</tt> is replaced with the absolute path of the
environment's executable.</li>
</ul>
<p>The <tt class="docutils literal">DistributeEnvBuilder</tt> subclass in the reference implementation
illustrates how the customization hook can be used in practice to
pre-install Distribute into the virtual environment.  It's not
envisaged that <tt class="docutils literal">DistributeEnvBuilder</tt> will be actually added to
Python core, but it makes the reference implementation more
immediately useful for testing and exploratory purposes.</p>
</div>
</div>
<div class="section" id="backwards-compatibility">
<h1><a class="toc-backref" href="#id26">Backwards Compatibility</a></h1>
<div class="section" id="splitting-the-meanings-of-sys-prefix">
<h2><a class="toc-backref" href="#id27">Splitting the meanings of <tt class="docutils literal">sys.prefix</tt></a></h2>
<p>Any virtual environment tool along these lines (which attempts to
isolate site-packages, while still making use of the base Python's
standard library with no need for it to be symlinked into the virtual
environment) is proposing a split between two different meanings
(among others) that are currently both wrapped up in <tt class="docutils literal">sys.prefix</tt>:
the answers to the questions &quot;Where is the standard library?&quot; and
&quot;Where is the site-packages location where third-party modules should
be installed?&quot;</p>
<p>This split could be handled by introducing a new <tt class="docutils literal">sys</tt> attribute for
either the former prefix or the latter prefix.  Either option
potentially introduces some backwards-incompatibility with software
written to assume the other meaning for <tt class="docutils literal">sys.prefix</tt>.  (Such
software should preferably be using the APIs in the <tt class="docutils literal">site</tt> and
<tt class="docutils literal">sysconfig</tt> modules to answer these questions rather than using
<tt class="docutils literal">sys.prefix</tt> directly, in which case there is no
backwards-compatibility issue, but in practice <tt class="docutils literal">sys.prefix</tt> is
sometimes used.)</p>
<p>The <a class="reference external" href="http://docs.python.org/dev/library/sys.html#sys.prefix">documentation</a> <a class="footnote-reference" href="#id15" id="id16">[7]</a> for <tt class="docutils literal">sys.prefix</tt> describes it as &quot;A string
giving the site-specific directory prefix where the platform
independent Python files are installed,&quot; and specifically mentions the
standard library and header files as found under <tt class="docutils literal">sys.prefix</tt>.  It
does not mention <tt class="docutils literal"><span class="pre">site-packages</span></tt>.</p>
<p>Maintaining this documented definition would mean leaving
<tt class="docutils literal">sys.prefix</tt> pointing to the base system installation (which is
where the standard library and header files are found), and
introducing a new value in <tt class="docutils literal">sys</tt> (something like
<tt class="docutils literal">sys.site_prefix</tt>) to point to the prefix for <tt class="docutils literal"><span class="pre">site-packages</span></tt>.
This would maintain the documented semantics of <tt class="docutils literal">sys.prefix</tt>, but
risk breaking isolation if third-party code uses <tt class="docutils literal">sys.prefix</tt> rather
than <tt class="docutils literal">sys.site_prefix</tt> or the appropriate <tt class="docutils literal">site</tt> API to find
site-packages directories.</p>
<p>The most notable case is probably <a class="reference external" href="http://peak.telecommunity.com/DevCenter/setuptools">setuptools</a> <a class="footnote-reference" href="#id7" id="id8">[3]</a> and its fork
<a class="reference external" href="http://packages.python.org/distribute/">distribute</a> <a class="footnote-reference" href="#id9" id="id10">[4]</a>, which mostly use <tt class="docutils literal">distutils</tt> and <tt class="docutils literal">sysconfig</tt> APIs,
but do use <tt class="docutils literal">sys.prefix</tt> directly to build up a list of site
directories for pre-flight checking where <tt class="docutils literal">pth</tt> files can usefully be
placed.</p>
<p>Otherwise, a <a class="reference external" href="http://www.google.com/codesearch#search/&amp;q=sys.prefix&amp;p=1&amp;type=cs">Google Code Search</a> <a class="footnote-reference" href="#id11" id="id12">[5]</a> turns up what appears to be a
roughly even mix of usage between packages using <tt class="docutils literal">sys.prefix</tt> to
build up a site-packages path and packages using it to e.g. eliminate
the standard-library from code-execution tracing.</p>
<p>Although it requires modifying the documented definition of
<tt class="docutils literal">sys.prefix</tt>, this PEP prefers to have <tt class="docutils literal">sys.prefix</tt> point to the
virtual environment (where <tt class="docutils literal"><span class="pre">site-packages</span></tt> is found), and introduce
<tt class="docutils literal">sys.base_prefix</tt> to point to the standard library and Python header
files. Rationale for this choice:</p>
<ul class="simple">
<li>It is preferable to err on the side of greater isolation of the
virtual environment.</li>
<li>Virtualenv already modifies <tt class="docutils literal">sys.prefix</tt> to point at the virtual
environment, and in practice this has not been a problem.</li>
<li>No modification is required to setuptools/distribute.</li>
</ul>
</div>
<div class="section" id="impact-on-other-python-implementations">
<h2><a class="toc-backref" href="#id28">Impact on other Python implementations</a></h2>
<p>The majority of this PEP's changes occur in the standard library, which is
shared by other Python implementations and should not present any
problem.</p>
<p>Other Python implementations will need to replicate the new
<tt class="docutils literal">sys.prefix</tt>-finding behavior of the interpreter bootstrap, including
locating and parsing the <tt class="docutils literal">pyvenv.cfg</tt> file, if it is present.</p>
</div>
</div>
<div class="section" id="reference-implementation">
<h1><a class="toc-backref" href="#id29">Reference Implementation</a></h1>
<p>The reference implementation is found in <a class="reference external" href="http://hg.python.org/sandbox/vsajip#venv">a clone of the CPython
Mercurial repository</a> <a class="footnote-reference" href="#id13" id="id14">[6]</a>.  To test it, build and run <tt class="docutils literal">bin/pyvenv
/path/to/new/venv</tt> to create a virtual environment.</p>
</div>
<div class="section" id="id2">
<h1><a class="toc-backref" href="#id30">References</a></h1>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[1]</a></td><td><a class="reference external" href="http://www.virtualenv.org">http://www.virtualenv.org</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[2]</a></td><td><a class="reference external" href="https://github.com/kvbik/rvirtualenv">https://github.com/kvbik/rvirtualenv</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[3]</a></td><td><a class="reference external" href="http://peak.telecommunity.com/DevCenter/setuptools">http://peak.telecommunity.com/DevCenter/setuptools</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[4]</a></td><td><a class="reference external" href="http://packages.python.org/distribute/">http://packages.python.org/distribute/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[5]</a></td><td><a class="reference external" href="http://www.google.com/codesearch#search/&amp;q=sys.prefix&amp;p=1&amp;type=cs">http://www.google.com/codesearch#search/&amp;q=sys.prefix&amp;p=1&amp;type=cs</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[6]</a></td><td><a class="reference external" href="http://hg.python.org/sandbox/vsajip#venv">http://hg.python.org/sandbox/vsajip#venv</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[7]</a></td><td><a class="reference external" href="http://docs.python.org/dev/library/sys.html#sys.prefix">http://docs.python.org/dev/library/sys.html#sys.prefix</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id31">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

