<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">308</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Conditional Expressions</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0308.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Guido van Rossum, Raymond Hettinger</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">7-Feb-2003</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">7-Feb-2003, 11-Feb-2003</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#adding-a-conditional-expression" id="id7">Adding a conditional expression</a></li>
<li><a class="reference internal" href="#references" id="id8">References</a></li>
<li><a class="reference internal" href="#introduction-to-earlier-draft-of-the-pep-kept-for-historical-purposes" id="id9">Introduction to earlier draft of the PEP (kept for historical purposes)</a></li>
<li><a class="reference internal" href="#proposal" id="id10">Proposal</a></li>
<li><a class="reference internal" href="#alternatives" id="id11">Alternatives</a></li>
<li><a class="reference internal" href="#summary-of-the-current-state-of-the-discussion" id="id12">Summary of the Current State of the Discussion</a></li>
<li><a class="reference internal" href="#short-circuit-behavior" id="id13">Short-Circuit Behavior</a></li>
<li><a class="reference internal" href="#detailed-results-of-voting" id="id14">Detailed Results of Voting</a><ul>
<li><a class="reference internal" href="#choice-key" id="id15">CHOICE KEY</a></li>
<li><a class="reference internal" href="#detail-for-write-in-votes-and-their-ranking" id="id16">Detail for write-in votes and their ranking</a></li>
</ul>
</li>
<li><a class="reference internal" href="#copyright" id="id17">Copyright</a></li>
</ul>
</div>
<div class="section" id="adding-a-conditional-expression">
<h1><a class="toc-backref" href="#id7">Adding a conditional expression</a></h1>
<p>On 9/29/2005, Guido decided to add conditional expressions in the
form of &quot;X if C else Y&quot;. <a class="footnote-reference" href="#id4" id="id1">[1]</a></p>
<p>The motivating use case was the prevalence of error-prone attempts
to achieve the same effect using &quot;and&quot; and &quot;or&quot;. <a class="footnote-reference" href="#id5" id="id2">[2]</a></p>
<p>Previous community efforts to add a conditional expression were
stymied by a lack of consensus on the best syntax.  That issue was
resolved by simply deferring to a BDFL best judgment call.</p>
<p>The decision was validated by reviewing how the syntax fared when
applied throughout the standard library (this review approximates a
sampling of real-world use cases, across a variety of applications,
written by a number of programmers with diverse backgrounds). <a class="footnote-reference" href="#id6" id="id3">[3]</a></p>
<p>The following change will be made to the grammar.  (The or_test
symbols is new, the others are modified.)</p>
<pre class="literal-block">
test: or_test ['if' or_test 'else' test] | lambdef
or_test: and_test ('or' and_test)*
...
testlist_safe: or_test [(',' or_test)+ [',']]
...
gen_for: 'for' exprlist 'in' or_test [gen_iter]
</pre>
<p>The new syntax nearly introduced a minor syntactical backwards
incompatibility.  In previous Python versions, the following is
legal:</p>
<pre class="literal-block">
[f for f in lambda x: x, lambda x: x**2 if f(1) == 1]
</pre>
<p>(I.e. a list comprehension where the sequence following 'in' is an
unparenthesized series of lambdas -- or just one lambda, even.)</p>
<p>In Python 3.0, the series of lambdas will have to be
parenthesized, e.g.:</p>
<pre class="literal-block">
[f for f in (lambda x: x, lambda x: x**2) if f(1) == 1]
</pre>
<p>This is because lambda binds less tight than the if-else
expression, but in this context, the lambda could already be
followed by an 'if' keyword that binds less tightly still (for
details, consider the grammar changes shown above).</p>
<p>However, in Python 2.5, a slightly different grammar is used that
is more backwards compatible, but constrains the grammar of a
lambda used in this position by forbidding the lambda's body to
contain an unparenthesized condition expression.  Examples:</p>
<pre class="literal-block">
[f for f in (1, lambda x: x if x &gt;= 0 else -1)]    # OK
[f for f in 1, (lambda x: x if x &gt;= 0 else -1)]    # OK
[f for f in 1, lambda x: (x if x &gt;= 0 else -1)]    # OK
[f for f in 1, lambda x: x if x &gt;= 0 else -1]      # INVALID
</pre>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id8">References</a></h1>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Pronouncement
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2005-September/056846.html">https://mail.python.org/pipermail/python-dev/2005-September/056846.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Motivating use case:
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2005-September/056546.html">https://mail.python.org/pipermail/python-dev/2005-September/056546.html</a>
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2005-September/056510.html">https://mail.python.org/pipermail/python-dev/2005-September/056510.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>Review in the context of real-world code fragments:
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2005-September/056803.html">https://mail.python.org/pipermail/python-dev/2005-September/056803.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="introduction-to-earlier-draft-of-the-pep-kept-for-historical-purposes">
<h1><a class="toc-backref" href="#id9">Introduction to earlier draft of the PEP (kept for historical purposes)</a></h1>
<p>Requests for an if-then-else (&quot;ternary&quot;) expression keep coming up
on comp.lang.python.  This PEP contains a concrete proposal of a
fairly Pythonic syntax.  This is the community's one chance: if
this PEP is approved with a clear majority, it will be implemented
in Python 2.4.  If not, the PEP will be augmented with a summary
of the reasons for rejection and the subject better not come up
again.  While the BDFL is co-author of this PEP, he is neither in
favor nor against this proposal; it is up to the community to
decide.  If the community can't decide, the BDFL will reject the
PEP.</p>
<p>After unprecedented community response (very good arguments were
made both pro and con) this PEP has been revised with the help of
Raymond Hettinger.  Without going through a complete revision
history, the main changes are a different proposed syntax, an
overview of proposed alternatives, the state of the curent
discussion, and a discussion of short-circuit behavior.</p>
<p>Following the discussion, a vote was held.  While there was an overall
interest in having some form of if-then-else expressions, no one
format was able to draw majority support.  Accordingly, the PEP was
rejected due to the lack of an overwhelming majority for change.
Also, a Python design principle has been to prefer the status quo
whenever there are doubts about which path to take.</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id10">Proposal</a></h1>
<p>The proposed syntax is as follows:</p>
<pre class="literal-block">
(if &lt;condition&gt;: &lt;expression1&gt; else: &lt;expression2&gt;)
</pre>
<p>Note that the enclosing parentheses are not optional.</p>
<p>The resulting expression is evaluated like this:</p>
<ul class="simple">
<li>First, &lt;condition&gt; is evaluated.</li>
<li>If &lt;condition&gt; is true, &lt;expression1&gt; is evaluated and is the
result of the whole thing.</li>
<li>If &lt;condition&gt; is false, &lt;expression2&gt; is evaluated and is the
result of the whole thing.</li>
</ul>
<p>A natural extension of this syntax is to allow one or more 'elif'
parts:</p>
<pre class="literal-block">
(if &lt;cond1&gt;: &lt;expr1&gt; elif &lt;cond2&gt;: &lt;expr2&gt; ... else: &lt;exprN&gt;)
</pre>
<p>This will be implemented if the proposal is accepted.</p>
<p>The downsides to the proposal are:</p>
<ul class="simple">
<li>the required parentheses</li>
<li>confusability with statement syntax</li>
<li>additional semantic loading of colons</li>
</ul>
<p>Note that at most one of &lt;expression1&gt; and &lt;expression2&gt; is
evaluated.  This is called a &quot;short-circuit expression&quot;; it is
similar to the way the second operand of 'and' / 'or' is only
evaluated if the first operand is true / false.</p>
<p>A common way to emulate an if-then-else expression is:</p>
<pre class="literal-block">
&lt;condition&gt; and &lt;expression1&gt; or &lt;expression2&gt;
</pre>
<p>However, this doesn't work the same way: it returns &lt;expression2&gt;
when &lt;expression1&gt; is false!  See FAQ 4.16 for alternatives that
work -- however, they are pretty ugly and require much more effort
to understand.</p>
</div>
<div class="section" id="alternatives">
<h1><a class="toc-backref" href="#id11">Alternatives</a></h1>
<p>Holger Krekel proposed a new, minimally invasive variant:</p>
<pre class="literal-block">
&lt;condition&gt; and &lt;expression1&gt; else &lt;expression2&gt;
</pre>
<p>The concept behind it is that a nearly complete ternary operator
already exists with and/or and this proposal is the least invasive
change that makes it complete.  Many respondants on the
newsgroup found this to be the most pleasing alternative.
However, a couple of respondants were able to post examples
that were mentally difficult to parse.  Later it was pointed
out that this construct works by having the &quot;else&quot; change the
existing meaning of &quot;and&quot;.</p>
<p>As a result, there is increasing support for Christian Tismer's
proposed variant of the same idea:</p>
<pre class="literal-block">
&lt;condition&gt; then &lt;expression1&gt; else &lt;expression2&gt;
</pre>
<p>The advantages are simple visual parsing, no required parentheses,
no change in the semantics of existing keywords, not as likely
as the proposal to be confused with statement syntax, and does
not further overload the colon.  The disadvantage is the
implementation costs of introducing a new keyword.  However,
unlike other new keywords, the word &quot;then&quot; seems unlikely to
have been used as a name in existing programs.</p>
<p>---</p>
<p>Many C-derived languages use this syntax:</p>
<pre class="literal-block">
&lt;condition&gt; ? &lt;expression1&gt; : &lt;expression2&gt;
</pre>
<p>Eric Raymond even implemented this.  The BDFL rejected this for
several reasons: the colon already has many uses in Python (even
though it would actually not be ambiguous, because the question
mark requires a matching colon); for people not used to C-derived
language, it is hard to understand.</p>
<p>---</p>
<p>The original version of this PEP proposed the following syntax:</p>
<pre class="literal-block">
&lt;expression1&gt; if &lt;condition&gt; else &lt;expression2&gt;
</pre>
<p>The out-of-order arrangement was found to be too uncomfortable
for many of participants in the discussion; especially when
&lt;expression1&gt; is long, it's easy to miss the conditional while
skimming.</p>
<p>---</p>
<p>Some have suggested adding a new builtin instead of extending the
syntax of the language.  For example:</p>
<pre class="literal-block">
cond(&lt;condition&gt;, &lt;expression1&gt;, &lt;expression2&gt;)
</pre>
<p>This won't work the way a syntax extension will because both
expression1 and expression2 must be evaluated before the function
is called.  There's no way to short-circuit the expression
evaluation.  It could work if 'cond' (or some other name) were
made a keyword, but that has all the disadvantages of adding a new
keyword, plus confusing syntax: it <strong>looks</strong> like a function call so
a casual reader might expect both &lt;expression1&gt; and &lt;expression2&gt;
to be evaluated.</p>
</div>
<div class="section" id="summary-of-the-current-state-of-the-discussion">
<h1><a class="toc-backref" href="#id12">Summary of the Current State of the Discussion</a></h1>
<p>Groups are falling into one of three camps:</p>
<ol class="arabic">
<li><p class="first">Adopt a ternary operator built using punctuation characters:</p>
<pre class="literal-block">
&lt;condition&gt; ? &lt;expression1&gt; : &lt;expression2&gt;
</pre>
</li>
<li><p class="first">Adopt a ternary operator built using new or existing keywords.
The leading examples are:</p>
<pre class="literal-block">
&lt;condition&gt; then &lt;expression1&gt; else &lt;expression2&gt;
(if &lt;condition&gt;: &lt;expression1&gt; else: &lt;expression2&gt;)
</pre>
</li>
<li><p class="first">Do nothing.</p>
</li>
</ol>
<p>The first two positions are relatively similar.</p>
<p>Some find that any form of punctuation makes the language more
cryptic.  Others find that punctuation style is appropriate for
expressions rather than statements and helps avoid a COBOL style:
3 plus 4 times 5.</p>
<p>Adapting existing keywords attempts to improve on punctuation
through explicit meaning and a more tidy appearance.  The downside
is some loss of the economy-of-expression provided by punctuation
operators.  The other downside is that it creates some degree of
confusion between the two meanings and two usages of the keywords.</p>
<p>Those difficulties are overcome by options which introduce new
keywords which take more effort to implement.</p>
<p>The last position is doing nothing.  Arguments in favor include
keeping the language simple and concise; maintaining backwards
compatibility; and that any every use case can already be already
expressed in terms of &quot;if&quot; and &quot;else&quot;.  Lambda expressions are an
exception as they require the conditional to be factored out into
a separate function definition.</p>
<p>The arguments against doing nothing are that the other choices
allow greater economy of expression and that current practices
show a propensity for erroneous uses of &quot;and&quot;, &quot;or&quot;, or one their
more complex, less visually unappealing workarounds.</p>
</div>
<div class="section" id="short-circuit-behavior">
<h1><a class="toc-backref" href="#id13">Short-Circuit Behavior</a></h1>
<p>The principal difference between the ternary operator and the
<tt class="docutils literal">cond()</tt> function is that the latter provides an expression form but
does not provide short-circuit evaluation.</p>
<p>Short-circuit evaluation is desirable on three occasions:</p>
<ol class="arabic simple">
<li>When an expression has side-effects</li>
<li>When one or both of the expressions are resource intensive</li>
<li>When the condition serves as a guard for the validity of the
expression.</li>
</ol>
<pre class="literal-block">
#  Example where all three reasons apply
data = isinstance(source, file)  ?  source.readlines()
                                 :  source.split()
</pre>
<ol class="arabic simple">
<li><tt class="docutils literal">readlines()</tt> moves the file pointer</li>
<li>for long sources, both alternatives take time</li>
<li><tt class="docutils literal">split()</tt> is only valid for strings and <tt class="docutils literal">readlines()</tt> is only
valid for file objects.</li>
</ol>
<p>Supporters of a <tt class="docutils literal">cond()</tt> function point out that the need for
short-circuit evaluation is rare.  Scanning through existing code
directories, they found that if/else did not occur often; and of
those only a few contained expressions that could be helped by
<tt class="docutils literal">cond()</tt> or a ternary operator; and that most of those had no need
for short-circuit evaluation.  Hence, <tt class="docutils literal">cond()</tt> would suffice for
most needs and would spare efforts to alter the syntax of the
language.</p>
<p>More supporting evidence comes from scans of C code bases which
show that its ternary operator used very rarely (as a percentage
of lines of code).</p>
<p>A counterpoint to that analysis is that the availability of a
ternary operator helped the programmer in every case because it
spared the need to search for side-effects.  Further, it would
preclude errors arising from distant modifications which introduce
side-effects.  The latter case has become more of a reality with
the advent of properties where even attribute access can be given
side-effects.</p>
<p>The BDFL's position is that short-circuit behavior is essential
for an if-then-else construct to be added to the language.</p>
</div>
<div class="section" id="detailed-results-of-voting">
<h1><a class="toc-backref" href="#id14">Detailed Results of Voting</a></h1>
<pre class="literal-block">
Votes rejecting all options:  82
Votes with rank ordering:     436
                              ---
Total votes received:         518


        ACCEPT                  REJECT                  TOTAL
        ---------------------   ---------------------   -----
        Rank1   Rank2   Rank3   Rank1   Rank2   Rank3
Letter
A       51      33      19      18      20      20      161
B       45      46      21      9       24      23      168
C       94      54      29      20      20      18      235
D       71      40      31      5       28      31      206
E       7       7       10              3       5       32
F       14      19      10              7       17      67
G       7       6       10      1       2       4       30
H       20      22      17      4       10      25      98
I       16      20      9       5       5       20      75
J       6       17      5       1               10      39
K       1               6               4       13      24
L               1       2               3       3       9
M       7       3       4       2       5       11      32
N               2       3               4       2       11
O       1       6       5       1       4       9       26
P       5       3       6       1       5       7       27
Q       18      7       15      6       5       11      62
Z                                               1       1
        ---     ---     ---     ---     ---     ---     ----
Total   363     286     202     73      149     230     1303
RejectAll                       82      82      82      246
        ---     ---     ---     ---     ---     ---     ----
Total   363     286     202     155     231     312     1549
</pre>
<div class="section" id="choice-key">
<h2><a class="toc-backref" href="#id15">CHOICE KEY</a></h2>
<pre class="literal-block">
A.  x if C else y
B.  if C then x else y
C.  (if C: x else: y)
D.  C ? x : y
E.  C ? x ! y
F.  cond(C, x, y)
G.  C ?? x || y
H.  C then x else y
I.  x when C else y
J.  C ? x else y
K.  C -&gt; x else y
L.  C -&gt; (x, y)
M.  [x if C else y]
N.  ifelse C: x else y
O.  &lt;if C then x else y&gt;
P.  C and x else y
Q.  any write-in vote
</pre>
</div>
<div class="section" id="detail-for-write-in-votes-and-their-ranking">
<h2><a class="toc-backref" href="#id16">Detail for write-in votes and their ranking</a></h2>
<pre class="literal-block">
3:  Q reject y x C elsethenif
2:  Q accept (C ? x ! y)
3:  Q reject ...
3:  Q accept  ? C : x : y
3:  Q accept (x if C, y otherwise)
3:  Q reject ...
3:  Q reject NONE
1:  Q accept   select : (&lt;c1&gt; : &lt;val1&gt;; [&lt;cx&gt; : &lt;valx&gt;; ]* elseval)
2:  Q reject if C: t else: f
3:  Q accept C selects x else y
2:  Q accept iff(C, x, y)    # &quot;if-function&quot;
1:  Q accept (y, x)[C]
1:  Q accept          C true: x false: y
3:  Q accept          C then: x else: y
3:  Q reject
3:  Q accept (if C: x elif C2: y else: z)
3:  Q accept C -&gt; x : y
1:  Q accept  x (if C), y
1:  Q accept if c: x else: y
3:  Q accept (c).{True:1, False:2}
2:  Q accept if c: x else: y
3:  Q accept (c).{True:1, False:2}
3:  Q accept if C: x else y
1:  Q accept  (x if C else y)
1:  Q accept ifelse(C, x, y)
2:  Q reject x or y &lt;- C
1:  Q accept (C ? x : y) required parens
1:  Q accept  iif(C, x, y)
1:  Q accept ?(C, x, y)
1:  Q accept switch-case
2:  Q accept multi-line if/else
1:  Q accept C: x else: y
2:  Q accept (C): x else: y
3:  Q accept if C: x else: y
1:  Q accept     x if C, else y
1:  Q reject choice: c1-&gt;a; c2-&gt;b; ...; z
3:  Q accept [if C then x else y]
3:  Q reject no other choice has x as the first element
1:  Q accept (x,y) ? C
3:  Q accept x if C else y (The &quot;else y&quot; being optional)
1:  Q accept (C ? x , y)
1:  Q accept  any outcome (i.e form or plain rejection) from a usability study
1:  Q reject (x if C else y)
1:  Q accept  (x if C else y)
2:  Q reject   NONE
3:  Q reject   NONE
3:  Q accept  (C ? x else y)
3:  Q accept  x when C else y
2:  Q accept  (x if C else y)
2:  Q accept cond(C1, x1, C2, x2, C3, x3,...)
1:  Q accept  (if C1: x elif C2: y else: z)
1:  Q reject cond(C, :x, :y)
3:  Q accept  (C and [x] or [y])[0]
2:  Q reject
3:  Q reject
3:  Q reject all else
1:  Q reject no-change
3:  Q reject deliberately omitted as I have no interest in any other proposal
2:  Q reject (C then x else Y)
1:  Q accept       if C: x else: y
1:  Q reject (if C then x else y)
3:  Q reject C?(x, y)
</pre>
</div>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id17">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>

