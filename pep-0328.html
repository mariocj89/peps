<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">328</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Imports: Multi-Line and Absolute/Relative</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0328.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Aahz &lt;aahz&#32;&#97;t&#32;pythoncraft.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">21-Dec-2003</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.4, 2,5, 2.6</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">8-Mar-2004</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id5">Abstract</a></li>
<li><a class="reference internal" href="#timeline" id="id6">Timeline</a></li>
<li><a class="reference internal" href="#rationale-for-parentheses" id="id7">Rationale for Parentheses</a></li>
<li><a class="reference internal" href="#rationale-for-absolute-imports" id="id8">Rationale for Absolute Imports</a></li>
<li><a class="reference internal" href="#rationale-for-relative-imports" id="id9">Rationale for Relative Imports</a></li>
<li><a class="reference internal" href="#guido-s-decision" id="id10">Guido's Decision</a></li>
<li><a class="reference internal" href="#relative-imports-and-name" id="id11">Relative Imports and __name__</a></li>
<li><a class="reference internal" href="#relative-imports-and-indirection-entries-in-sys-modules" id="id12">Relative Imports and Indirection Entries in sys.modules</a></li>
<li><a class="reference internal" href="#references" id="id13">References</a></li>
<li><a class="reference internal" href="#copyright" id="id14">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id5">Abstract</a></h1>
<p>The <tt class="docutils literal">import</tt> statement has two problems:</p>
<ul class="simple">
<li>Long <tt class="docutils literal">import</tt> statements can be difficult to write, requiring
various contortions to fit Pythonic style guidelines.</li>
<li>Imports can be ambiguous in the face of packages; within a package,
it's not clear whether <tt class="docutils literal">import foo</tt> refers to a module within the
package or some module outside the package.  (More precisely, a local
module or package can shadow another hanging directly off
<tt class="docutils literal">sys.path</tt>.)</li>
</ul>
<p>For the first problem, it is proposed that parentheses be permitted to
enclose multiple names, thus allowing Python's standard mechanisms for
multi-line values to apply.  For the second problem, it is proposed that
all <tt class="docutils literal">import</tt> statements be absolute by default (searching <tt class="docutils literal">sys.path</tt>
only) with special syntax (leading dots) for accessing package-relative
imports.</p>
</div>
<div class="section" id="timeline">
<h1><a class="toc-backref" href="#id6">Timeline</a></h1>
<p>In Python 2.5, you must enable the new absolute import behavior with</p>
<pre class="literal-block">
from __future__ import absolute_import
</pre>
<p>You may use relative imports freely.  In Python 2.6, any <tt class="docutils literal">import</tt>
statement that results in an intra-package import will raise
<tt class="docutils literal">DeprecationWarning</tt> (this also applies to <tt class="docutils literal">from &lt;&gt; import</tt> that
fails to use the relative import syntax).</p>
</div>
<div class="section" id="rationale-for-parentheses">
<h1><a class="toc-backref" href="#id7">Rationale for Parentheses</a></h1>
<p>Currently, if you want to import a lot of names from a module or
package, you have to choose one of several unpalatable options:</p>
<ul>
<li><p class="first">Write a long line with backslash continuations:</p>
<pre class="literal-block">
from Tkinter import Tk, Frame, Button, Entry, Canvas, Text, \
    LEFT, DISABLED, NORMAL, RIDGE, END
</pre>
</li>
<li><p class="first">Write multiple <tt class="docutils literal">import</tt> statements:</p>
<pre class="literal-block">
from Tkinter import Tk, Frame, Button, Entry, Canvas, Text
from Tkinter import LEFT, DISABLED, NORMAL, RIDGE, END
</pre>
</li>
</ul>
<p>(<tt class="docutils literal">import *</tt> is <em>not</em> an option ;-)</p>
<p>Instead, it should be possible to use Python's standard grouping
mechanism (parentheses) to write the <tt class="docutils literal">import</tt> statement:</p>
<pre class="literal-block">
from Tkinter import (Tk, Frame, Button, Entry, Canvas, Text,
    LEFT, DISABLED, NORMAL, RIDGE, END)
</pre>
<p>This part of the proposal had BDFL approval from the beginning.</p>
<p>Parentheses support was added to Python 2.4.</p>
</div>
<div class="section" id="rationale-for-absolute-imports">
<h1><a class="toc-backref" href="#id8">Rationale for Absolute Imports</a></h1>
<p>In Python 2.4 and earlier, if you're reading a module located inside a
package, it is not clear whether</p>
<pre class="literal-block">
import foo
</pre>
<p>refers to a top-level module or to another module inside the package.
As Python's library expands, more and more existing package internal
modules suddenly shadow standard library modules by accident.  It's a
particularly difficult problem inside packages because there's no way to
specify which module is meant.  To resolve the ambiguity, it is proposed
that <tt class="docutils literal">foo</tt> will always be a module or package reachable from
<tt class="docutils literal">sys.path</tt>.  This is called an absolute import.</p>
<p>The python-dev community chose absolute imports as the default because
they're the more common use case and because absolute imports can provide
all the functionality of relative (intra-package) imports  -- albeit at
the cost of difficulty when renaming package pieces higher up in the
hierarchy or when moving one package inside another.</p>
<p>Because this represents a change in semantics, absolute imports will
be optional in Python 2.5 and 2.6 through the use of</p>
<pre class="literal-block">
from __future__ import absolute_import
</pre>
<p>This part of the proposal had BDFL approval from the beginning.</p>
</div>
<div class="section" id="rationale-for-relative-imports">
<h1><a class="toc-backref" href="#id9">Rationale for Relative Imports</a></h1>
<p>With the shift to absolute imports, the question arose whether
relative imports should be allowed at all.  Several use cases were
presented, the most important of which is being able to rearrange the
structure of large packages without having to edit sub-packages.  In
addition, a module inside a package can't easily import itself without
relative imports.</p>
<p>Guido approved of the idea of relative imports, but there has been a
lot of disagreement on the spelling (syntax).  There does seem to be
agreement that relative imports will require listing specific names to
import (that is, <tt class="docutils literal">import foo</tt> as a bare term will always be an
absolute import).</p>
<p>Here are the contenders:</p>
<ul>
<li><p class="first">One from Guido:</p>
<pre class="literal-block">
from .foo import bar
</pre>
<p>and</p>
<pre class="literal-block">
from ...foo import bar
</pre>
<p>These two forms have a couple of different suggested semantics.  One
semantic is to make each dot represent one level.  There have been
many complaints about the difficulty of counting dots.  Another
option is to only allow one level of relative import.  That misses a
lot of functionality, and people still complained about missing the
dot in the one-dot form.  The final option is to define an algorithm
for finding relative modules and packages; the objection here is
&quot;Explicit is better than implicit&quot;.  (The algorithm proposed is
&quot;search up from current package directory until the ultimate package
parent gets hit&quot;.)</p>
<p>Some people have suggested other punctuation as the separator, such
as &quot;-&quot; or &quot;^&quot;.</p>
<p>Some people have suggested using &quot;*&quot;:</p>
<pre class="literal-block">
from *.foo import bar
</pre>
</li>
<li><p class="first">The next set of options is conflated from several posters:</p>
<pre class="literal-block">
from __pkg__.__pkg__ import
</pre>
<p>and</p>
<pre class="literal-block">
from .__parent__.__parent__ import
</pre>
<p>Many people (Guido included) think these look ugly, but they <em>are</em>
clear and explicit.  Overall, more people prefer <tt class="docutils literal">__pkg__</tt> as the
shorter option.</p>
</li>
<li><p class="first">One suggestion was to allow only sibling references.  In other words,
you would not be able to use relative imports to refer to modules
higher in the package tree.  You would then be able to do either</p>
<pre class="literal-block">
from .spam import eggs
</pre>
<p>or</p>
<pre class="literal-block">
import .spam.eggs
</pre>
</li>
<li><p class="first">Some people favor allowing indexed parents:</p>
<pre class="literal-block">
from -2.spam import eggs
</pre>
<p>In this scenario, importing from the current directory would be a
simple</p>
<pre class="literal-block">
from .spam import eggs
</pre>
</li>
<li><p class="first">Finally, some people dislike the way you have to change <tt class="docutils literal">import</tt>
to <tt class="docutils literal">from ... import</tt> when you want to dig inside a package.  They
suggest completely rewriting the <tt class="docutils literal">import</tt> syntax:</p>
<pre class="literal-block">
from MODULE import NAMES as RENAME searching HOW
</pre>
<p>or</p>
<pre class="literal-block">
import NAMES as RENAME from MODULE searching HOW
    [from NAMES] [in WHERE] import ...
</pre>
<p>However, this most likely could not be implemented for Python 2.5
(too big a change), and allowing relative imports is sufficiently
critical that we need something now (given that the standard
<tt class="docutils literal">import</tt> will change to absolute import).  More than that, this
proposed syntax has several open questions:</p>
<ul>
<li><p class="first">What is the precise proposed syntax?  (Which clauses are optional
under which circumstances?)</p>
</li>
<li><p class="first">How strongly does the <tt class="docutils literal">searching</tt> clause bind?  In other words,
do you write:</p>
<pre class="literal-block">
import foo as bar searching XXX, spam as ham searching XXX
</pre>
<p>or:</p>
<pre class="literal-block">
import foo as bar, spam as ham searching XXX
</pre>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="guido-s-decision">
<h1><a class="toc-backref" href="#id10">Guido's Decision</a></h1>
<p>Guido has Pronounced <a class="footnote-reference" href="#id3" id="id1">[1]</a> that relative imports will use leading dots.
A single leading dot indicates a relative import, starting with the
current package.  Two or more leading dots give a relative import to the
parent(s) of the current package, one level per dot after the first.
Here's a sample package layout:</p>
<pre class="literal-block">
package/
    __init__.py
    subpackage1/
        __init__.py
        moduleX.py
        moduleY.py
    subpackage2/
        __init__.py
        moduleZ.py
    moduleA.py
</pre>
<p>Assuming that the current file is either <tt class="docutils literal">moduleX.py</tt> or
<tt class="docutils literal">subpackage1/__init__.py</tt>, following are correct usages of the new
syntax:</p>
<pre class="literal-block">
from .moduleY import spam
from .moduleY import spam as ham
from . import moduleY
from ..subpackage1 import moduleY
from ..subpackage2.moduleZ import eggs
from ..moduleA import foo
from ...package import bar
from ...sys import path
</pre>
<p>Note that while that last case is legal, it is certainly discouraged
(&quot;insane&quot; was the word Guido used).</p>
<p>Relative imports must always use <tt class="docutils literal">from &lt;&gt; import</tt>; <tt class="docutils literal">import &lt;&gt;</tt> is
always absolute.  Of course, absolute imports can use <tt class="docutils literal">from &lt;&gt; import</tt>
by omitting the leading dots.  The reason <tt class="docutils literal">import .foo</tt> is prohibited
is because after</p>
<pre class="literal-block">
import XXX.YYY.ZZZ
</pre>
<p>then</p>
<pre class="literal-block">
XXX.YYY.ZZZ
</pre>
<p>is usable in an expression.  But</p>
<pre class="literal-block">
.moduleY
</pre>
<p>is not usable in an expression.</p>
</div>
<div class="section" id="relative-imports-and-name">
<h1><a class="toc-backref" href="#id11">Relative Imports and __name__</a></h1>
<p>Relative imports use a module's __name__ attribute to determine that
module's position in the package hierarchy. If the module's name does
not contain any package information (e.g. it is set to '__main__')
then relative imports are resolved as if the module were a top level
module, regardless of where the module is actually located on the file
system.</p>
</div>
<div class="section" id="relative-imports-and-indirection-entries-in-sys-modules">
<h1><a class="toc-backref" href="#id12">Relative Imports and Indirection Entries in sys.modules</a></h1>
<p>When packages were introduced, the concept of an indirection entry in
sys.modules came into existence <a class="footnote-reference" href="#id4" id="id2">[2]</a>.  When an entry in sys.modules
for a module within a package had a value of None, it represented that
the module actually referenced the top-level module.  For instance,
'Sound.Effects.string' might have a value of None in sys.modules.
That meant any import that resolved to that name actually was to
import the top-level 'string' module.</p>
<p>This introduced an optimization for when a relative import was meant
to resolve to an absolute import.  But since this PEP makes a very
clear delineation between absolute and relative imports, this
optimization is no longer needed.  When absolute/relative imports
become the only import semantics available then indirection entries in
sys.modules will no longer be supported.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id13">References</a></h1>
<p>For more background, see the following python-dev threads:</p>
<ul class="simple">
<li><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2003-December/040973.html">Re: Christmas Wishlist</a></li>
<li><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2003-December/041078.html">Re: Python-Dev Digest, Vol 5, Issue 57</a></li>
<li><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2003-December/041065.html">Relative import</a></li>
<li><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2003-December/041418.html">Another Strategy for Relative Import</a></li>
</ul>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2004-March/043739.html">https://mail.python.org/pipermail/python-dev/2004-March/043739.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="https://www.python.org/doc/essays/packages/">https://www.python.org/doc/essays/packages/</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id14">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>

