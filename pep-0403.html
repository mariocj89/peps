<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">403</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">General purpose decorator clause (aka &quot;&#64;in&quot; clause)</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0403.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Nick Coghlan &lt;ncoghlan&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Deferred</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">2011-10-13</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.4</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">2011-10-13</td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body">TBD</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id3">Abstract</a></li>
<li><a class="reference internal" href="#basic-examples" id="id4">Basic Examples</a></li>
<li><a class="reference internal" href="#proposal" id="id5">Proposal</a><ul>
<li><a class="reference internal" href="#syntax-change" id="id6">Syntax Change</a></li>
</ul>
</li>
<li><a class="reference internal" href="#design-discussion" id="id7">Design Discussion</a><ul>
<li><a class="reference internal" href="#background" id="id8">Background</a></li>
<li><a class="reference internal" href="#relation-to-pep-3150" id="id9">Relation to PEP 3150</a></li>
<li><a class="reference internal" href="#keyword-choice" id="id10">Keyword Choice</a></li>
<li><a class="reference internal" href="#better-debugging-support-for-functions-and-classes-with-short-names" id="id11">Better Debugging Support for Functions and Classes with Short Names</a></li>
<li><a class="reference internal" href="#possible-implementation-strategy" id="id12">Possible Implementation Strategy</a></li>
<li><a class="reference internal" href="#explaining-container-comprehensions-and-generator-expressions" id="id13">Explaining Container Comprehensions and Generator Expressions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#more-examples" id="id14">More Examples</a></li>
<li><a class="reference internal" href="#reference-implementation" id="id15">Reference Implementation</a></li>
<li><a class="reference internal" href="#acknowledgements" id="id16">Acknowledgements</a></li>
<li><a class="reference internal" href="#rejected-concepts" id="id17">Rejected Concepts</a><ul>
<li><a class="reference internal" href="#omitting-the-decorator-prefix-character" id="id18">Omitting the decorator prefix character</a></li>
<li><a class="reference internal" href="#anonymous-forward-references" id="id19">Anonymous Forward References</a></li>
<li><a class="reference internal" href="#using-a-nested-suite" id="id20">Using a nested suite</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references" id="id21">References</a></li>
<li><a class="reference internal" href="#copyright" id="id22">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id3">Abstract</a></h1>
<p>This PEP proposes the addition of a new <tt class="docutils literal">&#64;in</tt> decorator clause that makes
it possible to override the name binding step of a function or class
definition.</p>
<p>The new clause accepts a single simple statement that can make a forward
reference to decorated function or class definition.</p>
<p>This new clause is designed to be used whenever a &quot;one-shot&quot; function or
class is needed, and placing the function or class definition before the
statement that uses it actually makes the code harder to read. It also
avoids any name shadowing concerns by making sure the new name is visible
only to the statement in the <tt class="docutils literal">&#64;in</tt> clause.</p>
<p>This PEP is based heavily on many of the ideas in <a class="reference external" href="/dev/peps/pep-3150">PEP 3150</a> (Statement Local
Namespaces) so some elements of the rationale will be familiar to readers of
that PEP. Both PEPs remain deferred for the time being, primarily due to the
lack of compelling real world use cases in either PEP.</p>
</div>
<div class="section" id="basic-examples">
<h1><a class="toc-backref" href="#id4">Basic Examples</a></h1>
<p>Before diving into the long history of this problem and the detailed
rationale for this specific proposed solution, here are a few simple
examples of the kind of code it is designed to simplify.</p>
<p>As a trivial example, a weakref callback could be defined as follows:</p>
<pre class="literal-block">
&#64;in x = weakref.ref(target, report_destruction)
def report_destruction(obj):
    print(&quot;{} is being destroyed&quot;.format(obj))
</pre>
<p>This contrasts with the current (conceptually) &quot;out of order&quot; syntax for
this operation:</p>
<pre class="literal-block">
def report_destruction(obj):
    print(&quot;{} is being destroyed&quot;.format(obj))

x = weakref.ref(target, report_destruction)
</pre>
<p>That structure is OK when you're using the callable multiple times, but
it's irritating to be forced into it for one-off operations.</p>
<p>If the repetition of the name seems especially annoying, then a throwaway
name like <tt class="docutils literal">f</tt> can be used instead:</p>
<pre class="literal-block">
&#64;in x = weakref.ref(target, f)
def f(obj):
    print(&quot;{} is being destroyed&quot;.format(obj))
</pre>
<p>Similarly, a sorted operation on a particularly poorly defined type could
now be defined as:</p>
<pre class="literal-block">
&#64;in sorted_list = sorted(original, key=f)
def f(item):
    try:
        return item.calc_sort_order()
    except NotSortableError:
        return float('inf')
</pre>
<p>Rather than:</p>
<pre class="literal-block">
def force_sort(item):
    try:
        return item.calc_sort_order()
    except NotSortableError:
        return float('inf')

sorted_list = sorted(original, key=force_sort)
</pre>
<p>And early binding semantics in a list comprehension could be attained via:</p>
<pre class="literal-block">
&#64;in funcs = [adder(i) for i in range(10)]
def adder(i):
    return lambda x: x + i
</pre>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id5">Proposal</a></h1>
<p>This PEP proposes the addition of a new <tt class="docutils literal">&#64;in</tt> clause that is a variant
of the existing class and function decorator syntax.</p>
<p>The new <tt class="docutils literal">&#64;in</tt> clause precedes the decorator lines, and allows forward
references to the trailing function or class definition.</p>
<p>The trailing function or class definition is always named - the name of
the trailing definition is then used to make the forward reference from the
<tt class="docutils literal">&#64;in</tt> clause.</p>
<p>The <tt class="docutils literal">&#64;in</tt> clause is allowed to contain any simple statement (including
those that don't make any sense in that context, such as <tt class="docutils literal">pass</tt> - while
such code would be legal, there wouldn't be any point in writing it). This
permissive structure is easier to define and easier to explain, but a more
restrictive approach that only permits operations that &quot;make sense&quot; would
also be possible (see <a class="reference external" href="/dev/peps/pep-3150">PEP 3150</a> for a list of possible candidates).</p>
<p>The <tt class="docutils literal">&#64;in</tt> clause will not create a new scope - all name binding
operations aside from the trailing function or class definition will affect
the containing scope.</p>
<p>The name used in the trailing function or class definition is only visible
from the associated <tt class="docutils literal">&#64;in</tt> clause, and behaves as if it was an ordinary
variable defined in that scope. If any nested scopes are created in either
the <tt class="docutils literal">&#64;in</tt> clause or the trailing function or class definition, those scopes
will see the trailing function or class definition rather than any other
bindings for that name in the containing scope.</p>
<p>In a very real sense, this proposal is about making it possible to override
the implicit &quot;name = &lt;defined function or class&gt;&quot; name binding operation
that is part of every function or class definition, specifically in those
cases where the local name binding isn't actually needed.</p>
<p>Under this PEP, an ordinary class or function definition:</p>
<pre class="literal-block">
&#64;deco2
&#64;deco1
def name():
    ...
</pre>
<p>can be explained as being roughly equivalent to:</p>
<pre class="literal-block">
&#64;in name = deco2(deco1(name))
def name():
    ...
</pre>
<div class="section" id="syntax-change">
<h2><a class="toc-backref" href="#id6">Syntax Change</a></h2>
<p>Syntactically, only one new grammar rule is needed:</p>
<pre class="literal-block">
in_stmt: '&#64;in' simple_stmt decorated
</pre>
<p>Grammar: <a class="reference external" href="http://hg.python.org/cpython/file/default/Grammar/Grammar">http://hg.python.org/cpython/file/default/Grammar/Grammar</a></p>
</div>
</div>
<div class="section" id="design-discussion">
<h1><a class="toc-backref" href="#id7">Design Discussion</a></h1>
<div class="section" id="background">
<h2><a class="toc-backref" href="#id8">Background</a></h2>
<p>The question of &quot;multi-line lambdas&quot; has been a vexing one for many
Python users for a very long time, and it took an exploration of Ruby's
block functionality for me to finally understand why this bugs people
so much: Python's demand that the function be named and introduced
before the operation that needs it breaks the developer's flow of thought.
They get to a point where they go &quot;I need a one-shot operation that does
&lt;X&gt;&quot;, and instead of being able to just <em>say</em> that directly, they instead
have to back up, name a function to do &lt;X&gt;, then call that function from
the operation they actually wanted to do in the first place. Lambda
expressions can help sometimes, but they're no substitute for being able to
use a full suite.</p>
<p>Ruby's block syntax also heavily inspired the style of the solution in this
PEP, by making it clear that even when limited to <em>one</em> anonymous function per
statement, anonymous functions could still be incredibly useful. Consider how
many constructs Python has where one expression is responsible for the bulk of
the heavy lifting:</p>
<ul class="simple">
<li>comprehensions, generator expressions, map(), filter()</li>
<li>key arguments to sorted(), min(), max()</li>
<li>partial function application</li>
<li>provision of callbacks (e.g. for weak references or aysnchronous IO)</li>
<li>array broadcast operations in NumPy</li>
</ul>
<p>However, adopting Ruby's block syntax directly won't work for Python, since
the effectiveness of Ruby's blocks relies heavily on various conventions in
the way functions are <em>defined</em> (specifically, using Ruby's <tt class="docutils literal">yield</tt> syntax
to call blocks directly and the <tt class="docutils literal">&amp;arg</tt> mechanism to accept a block as a
function's final argument).</p>
<p>Since Python has relied on named functions for so long, the signatures of
APIs that accept callbacks are far more diverse, thus requiring a solution
that allows one-shot functions to be slotted in at the appropriate location.</p>
<p>The approach taken in this PEP is to retain the requirement to name the
function explicitly, but allow the relative order of the definition and the
statement that references it to be changed to match the developer's flow of
thought. The rationale is essentially the same as that used when introducing
decorators, but covering a broader set of applications.</p>
</div>
<div class="section" id="relation-to-pep-3150">
<h2>Relation to <a class="reference external" href="/dev/peps/pep-3150">PEP 3150</a></h2>
<p><a class="reference external" href="/dev/peps/pep-3150">PEP 3150</a> (Statement Local Namespaces) describes its primary motivation
as being to elevate ordinary assignment statements to be on par with <tt class="docutils literal">class</tt>
and <tt class="docutils literal">def</tt> statements where the name of the item to be defined is presented
to the reader in advance of the details of how the value of that item is
calculated. This PEP achieves the same goal in a different way, by allowing
the simple name binding of a standard function definition to be replaced
with something else (like assigning the result of the function to a value).</p>
<p>Despite having the same author, the two PEPs are in direct competition with
each other. <a class="reference external" href="/dev/peps/pep-0403">PEP 403</a> represents a minimalist approach that attempts to achieve
useful functionality with a minimum of change from the status quo. This PEP
instead aims for a more flexible standalone statement design, which requires
a larger degree of change to the language.</p>
<p>Note that where <a class="reference external" href="/dev/peps/pep-0403">PEP 403</a> is better suited to explaining the behaviour of
generator expressions correctly, this PEP is better able to explain the
behaviour of decorator clauses in general. Both PEPs support adequate
explanations for the semantics of container comprehensions.</p>
</div>
<div class="section" id="keyword-choice">
<h2><a class="toc-backref" href="#id10">Keyword Choice</a></h2>
<p>The proposal definitely requires <em>some</em> kind of prefix to avoid parsing
ambiguity and backwards compatibility problems with existing constructs.
It also needs to be clearly highlighted to readers, since it declares that
the following piece of code is going to be executed only after the trailing
function or class definition has been executed.</p>
<p>The <tt class="docutils literal">in</tt> keyword was chosen as an existing keyword that can be used to
denote the concept of a forward reference.</p>
<p>The <tt class="docutils literal">&#64;</tt> prefix was included in order to exploit the fact that Python
programmers are already used to decorator syntax as an indication of
out of order execution, where the function or class is actually defined
<em>first</em> and then decorators are applied in reverse order.</p>
<p>For functions, the construct is intended to be read as &quot;in &lt;this statement
that references NAME&gt; define NAME as a function that does &lt;operation&gt;&quot;.</p>
<p>The mapping to English prose isn't as obvious for the class definition case,
but the concept remains the same.</p>
</div>
<div class="section" id="better-debugging-support-for-functions-and-classes-with-short-names">
<h2><a class="toc-backref" href="#id11">Better Debugging Support for Functions and Classes with Short Names</a></h2>
<p>One of the objections to widespread use of lambda expressions is that they
have a negative effect on traceback intelligibility and other aspects of
introspection. Similar objections are raised regarding constructs that
promote short, cryptic function names (including this one, which requires
that the name of the trailing definition be supplied at least twice,
encouraging the use of shorthand placeholder names like <tt class="docutils literal">f</tt>).</p>
<p>However, the introduction of qualified names in <a class="reference external" href="/dev/peps/pep-3155">PEP 3155</a> means that even
anonymous classes and functions will now have different representations if
they occur in different scopes. For example:</p>
<pre class="literal-block">
&gt;&gt;&gt; def f():
...     return lambda: y
...
&gt;&gt;&gt; f()
&lt;function f.&lt;locals&gt;.&lt;lambda&gt; at 0x7f6f46faeae0&gt;
</pre>
<p>Anonymous functions (or functions that share a name) within the <em>same</em> scope
will still share representations (aside from the object ID), but this is
still a major improvement over the historical situation where everything
<em>except</em> the object ID was identical.</p>
</div>
<div class="section" id="possible-implementation-strategy">
<h2><a class="toc-backref" href="#id12">Possible Implementation Strategy</a></h2>
<p>This proposal has at least one titanic advantage over <a class="reference external" href="/dev/peps/pep-3150">PEP 3150</a>:
implementation should be relatively straightforward.</p>
<p>The <tt class="docutils literal">&#64;in</tt> clause will be included in the AST for the associated function or
class definition and the statement that references it. When the <tt class="docutils literal">&#64;in</tt>
clause is present, it will be emitted in place of the local name binding
operation normally implied by a function or class definition.</p>
<p>The one potentially tricky part is changing the meaning of the references to
the statement local function or namespace while within the scope of the
<tt class="docutils literal">in</tt> statement, but that shouldn't be too hard to address by maintaining
some additional state within the compiler (it's much easier to handle this
for a single name than it is for an unknown number of names in a full
nested suite).</p>
</div>
<div class="section" id="explaining-container-comprehensions-and-generator-expressions">
<h2><a class="toc-backref" href="#id13">Explaining Container Comprehensions and Generator Expressions</a></h2>
<p>One interesting feature of the proposed construct is that it can be used as
a primitive to explain the scoping and execution order semantics of
both generator expressions and container comprehensions:</p>
<pre class="literal-block">
seq2 = [x for x in y if q(x) for y in seq if p(y)]

# would be equivalent to

&#64;in seq2 = f(seq):
def f(seq)
    result = []
    for y in seq:
        if p(y):
            for x in y:
                if q(x):
                    result.append(x)
    return result
</pre>
<p>The important point in this expansion is that it explains why comprehensions
appear to misbehave at class scope: only the outermost iterator is evaluated
at class scope, while all predicates, nested iterators and value expressions
are evaluated inside a nested scope.</p>
<p>An equivalent expansion is possible for generator expressions:</p>
<pre class="literal-block">
gen = (x for x in y if q(x) for y in seq if p(y))

# would be equivalent to

&#64;in gen = g(seq):
def g(seq)
    for y in seq:
        if p(y):
            for x in y:
                if q(x):
                    yield x
</pre>
</div>
</div>
<div class="section" id="more-examples">
<h1><a class="toc-backref" href="#id14">More Examples</a></h1>
<p>Calculating attributes without polluting the local namespace (from os.py):</p>
<pre class="literal-block">
# Current Python (manual namespace cleanup)
def _createenviron():
    ... # 27 line function

environ = _createenviron()
del _createenviron

# Becomes:
&#64;in environ = _createenviron()
def _createenviron():
    ... # 27 line function
</pre>
<p>Loop early binding:</p>
<pre class="literal-block">
# Current Python (default argument hack)
funcs = [(lambda x, i=i: x + i) for i in range(10)]

# Becomes:
&#64;in funcs = [adder(i) for i in range(10)]
def adder(i):
    return lambda x: x + i

# Or even:
&#64;in funcs = [adder(i) for i in range(10)]
def adder(i):
    &#64;in return incr
    def incr(x):
        return x + i
</pre>
<p>A trailing class can be used as a statement local namespace:</p>
<pre class="literal-block">
# Evaluate subexpressions only once
&#64;in c = math.sqrt(x.a*x.a + x.b*x.b)
class x:
    a = calculate_a()
    b = calculate_b()
</pre>
<p>A function can be bound directly to a location which isn't a valid
identifier:</p>
<pre class="literal-block">
&#64;in dispatch[MyClass] = f
def f():
    ...
</pre>
<p>Constructs that verge on decorator abuse can be eliminated:</p>
<pre class="literal-block">
# Current Python
&#64;call
def f():
    ...

# Becomes:
&#64;in f()
def f():
    ...
</pre>
</div>
<div class="section" id="reference-implementation">
<h1><a class="toc-backref" href="#id15">Reference Implementation</a></h1>
<p>None as yet.</p>
</div>
<div class="section" id="acknowledgements">
<h1><a class="toc-backref" href="#id16">Acknowledgements</a></h1>
<p>Huge thanks to Gary Bernhardt for being blunt in pointing out that I had no
idea what I was talking about in criticising Ruby's blocks, kicking off a
rather enlightening process of investigation.</p>
</div>
<div class="section" id="rejected-concepts">
<h1><a class="toc-backref" href="#id17">Rejected Concepts</a></h1>
<p>To avoid retreading previously covered ground, some rejected alternatives
are documented in this section.</p>
<div class="section" id="omitting-the-decorator-prefix-character">
<h2><a class="toc-backref" href="#id18">Omitting the decorator prefix character</a></h2>
<p>Earlier versions of this proposal omitted the <tt class="docutils literal">&#64;</tt> prefix. However, without
that prefix, the bare <tt class="docutils literal">in</tt> keyword didn't associate the clause strongly
enough with the subsequent function or class definition. Reusing the
decorator prefix and explicitly characterising the new construct as a kind
of decorator clause is intended to help users link the two concepts and
see them as two variants of the same idea.</p>
</div>
<div class="section" id="anonymous-forward-references">
<h2><a class="toc-backref" href="#id19">Anonymous Forward References</a></h2>
<p>A previous incarnation of this PEP (see <a class="footnote-reference" href="#id2" id="id1">[1]</a>) proposed a syntax where the
new clause was introduced with <tt class="docutils literal">:</tt> and the forward reference was written
using <tt class="docutils literal">&#64;</tt>. Feedback on this variant was almost universally
negative, as it was considered both ugly and excessively magical:</p>
<pre class="literal-block">
:x = weakref.ref(target, &#64;)
def report_destruction(obj):
    print(&quot;{} is being destroyed&quot;.format(obj))
</pre>
<p>A more recent variant always used <tt class="docutils literal">...</tt> for forward references, along
with genuinely anonymous function and class definitions. However, this
degenerated quickly into a mass of unintelligible dots in more complex
cases:</p>
<pre class="literal-block">
in funcs = [...(i) for i in range(10)]
def ...(i):
  in return ...
  def ...(x):
      return x + i

in c = math.sqrt(....a*....a + ....b*....b)
class ...:
  a = calculate_a()
  b = calculate_b()
</pre>
</div>
<div class="section" id="using-a-nested-suite">
<h2><a class="toc-backref" href="#id20">Using a nested suite</a></h2>
<p>The problems with using a full nested suite are best described in
<a class="reference external" href="/dev/peps/pep-3150">PEP 3150</a>. It's comparatively difficult to implement properly, the scoping
semantics are harder to explain and it creates quite a few situations where
there are two ways to do it without clear guidelines for choosing between
them (as almost any construct that can be expressed with ordinary imperative
code could instead be expressed using a given statement). While the PEP does
propose some new <a class="reference external" href="/dev/peps/pep-0008">PEP 8</a> guidelines to help address that last problem, the
difficulties in implementation are not so easily dealt with.</p>
<p>By contrast, the decorator inspired syntax in this PEP explicitly limits the
new feature to cases where it should actually improve readability, rather
than harming it. As in the case of the original introduction of decorators,
the idea of this new syntax is that if it <em>can</em> be used (i.e. the local name
binding of the function is completely unnecessary) then it probably <em>should</em>
be used.</p>
<p>Another possible variant of this idea is to keep the decorator based
<em>semantics</em> of this PEP, while adopting the prettier syntax from <a class="reference external" href="/dev/peps/pep-3150">PEP 3150</a>:</p>
<pre class="literal-block">
x = weakref.ref(target, report_destruction) given:
    def report_destruction(obj):
        print(&quot;{} is being destroyed&quot;.format(obj))
</pre>
<p>There are a couple of problems with this approach. The main issue is that
this syntax variant uses something that looks like a suite, but really isn't
one. A secondary concern is that it's not clear how the compiler will know
which name(s) in the leading expression are forward references (although
that could potentially be addressed through a suitable definition of the
suite-that-is-not-a-suite in the language grammar).</p>
<p>However, a nested suite has not yet been ruled out completely. The latest
version of <a class="reference external" href="/dev/peps/pep-3150">PEP 3150</a> uses explicit forward reference and name binding
schemes that greatly simplify the semantics of the statement, and it
does offer the advantage of allowing the definition of arbitrary
subexpressions rather than being restricted to a single function or
class definition.</p>
</div>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id21">References</a></h1>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Start of python-ideas thread:
<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2011-October/012276.html">https://mail.python.org/pipermail/python-ideas/2011-October/012276.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id22">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

