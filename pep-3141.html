<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">3141</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">A Type Hierarchy for Numbers</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-3141.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Jeffrey Yasskin &lt;jyasskin&#32;&#97;t&#32;google.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">23-Apr-2007</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">25-Apr-2007, 16-May-2007, 02-Aug-2007</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id3">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id4">Rationale</a></li>
<li><a class="reference internal" href="#specification" id="id5">Specification</a><ul>
<li><a class="reference internal" href="#numeric-classes" id="id6">Numeric Classes</a></li>
<li><a class="reference internal" href="#changes-to-operations-and-magic-methods" id="id7">Changes to operations and __magic__ methods</a></li>
<li><a class="reference internal" href="#notes-for-type-implementors" id="id8">Notes for type implementors</a><ul>
<li><a class="reference internal" href="#adding-more-numeric-abcs" id="id9">Adding More Numeric ABCs</a></li>
<li><a class="reference internal" href="#implementing-the-arithmetic-operations" id="id10">Implementing the arithmetic operations</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#rejected-alternatives" id="id11">Rejected Alternatives</a></li>
<li><a class="reference internal" href="#the-decimal-type" id="id12">The Decimal Type</a></li>
<li><a class="reference internal" href="#references" id="id13">References</a></li>
<li><a class="reference internal" href="#acknowledgements" id="id14">Acknowledgements</a></li>
<li><a class="reference internal" href="#copyright" id="id15">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id3">Abstract</a></h1>
<p>This proposal defines a hierarchy of Abstract Base Classes (ABCs) (<a class="reference external" href="/dev/peps/pep-3119">PEP
3119</a>) to represent number-like classes. It proposes a hierarchy of
<tt class="docutils literal">Number :&gt; Complex :&gt; Real :&gt; Rational :&gt; Integral</tt> where <tt class="docutils literal">A :&gt; B</tt>
means &quot;A is a supertype of B&quot;. The hierarchy is inspired by Scheme's
numeric tower <a class="footnote-reference" href="#schemetower" id="id1">[4]</a>.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id4">Rationale</a></h1>
<p>Functions that take numbers as arguments should be able to determine
the properties of those numbers, and if and when overloading based on
types is added to the language, should be overloadable based on the
types of the arguments. For example, slicing requires its arguments to
be <tt class="docutils literal">Integrals</tt>, and the functions in the <tt class="docutils literal">math</tt> module require
their arguments to be <tt class="docutils literal">Real</tt>.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id5">Specification</a></h1>
<p>This PEP specifies a set of Abstract Base Classes, and suggests a
general strategy for implementing some of the methods. It uses
terminology from <a class="reference external" href="/dev/peps/pep-3119">PEP 3119</a>, but the hierarchy is intended to be
meaningful for any systematic method of defining sets of classes.</p>
<p>The type checks in the standard library should use these classes
instead of the concrete built-ins.</p>
<div class="section" id="numeric-classes">
<h2><a class="toc-backref" href="#id6">Numeric Classes</a></h2>
<p>We begin with a Number class to make it easy for people to be fuzzy
about what kind of number they expect. This class only helps with
overloading; it doesn't provide any operations.</p>
<pre class="literal-block">
class Number(metaclass=ABCMeta): pass
</pre>
<p>Most implementations of complex numbers will be hashable, but if you
need to rely on that, you'll have to check it explicitly: mutable
numbers are supported by this hierarchy.</p>
<pre class="literal-block">
class Complex(Number):
    &quot;&quot;&quot;Complex defines the operations that work on the builtin complex type.

    In short, those are: conversion to complex, bool(), .real, .imag,
    +, -, *, /, **, abs(), .conjugate(), ==, and !=.

    If it is given heterogenous arguments, and doesn't have special
    knowledge about them, it should fall back to the builtin complex
    type as described below.
    &quot;&quot;&quot;

    &#64;abstractmethod
    def __complex__(self):
        &quot;&quot;&quot;Return a builtin complex instance.&quot;&quot;&quot;

    def __bool__(self):
        &quot;&quot;&quot;True if self != 0.&quot;&quot;&quot;
        return self != 0

    &#64;abstractproperty
    def real(self):
        &quot;&quot;&quot;Retrieve the real component of this number.

        This should subclass Real.
        &quot;&quot;&quot;
        raise NotImplementedError

    &#64;abstractproperty
    def imag(self):
        &quot;&quot;&quot;Retrieve the real component of this number.

        This should subclass Real.
        &quot;&quot;&quot;
        raise NotImplementedError

    &#64;abstractmethod
    def __add__(self, other):
        raise NotImplementedError

    &#64;abstractmethod
    def __radd__(self, other):
        raise NotImplementedError

    &#64;abstractmethod
    def __neg__(self):
        raise NotImplementedError

    def __pos__(self):
        &quot;&quot;&quot;Coerces self to whatever class defines the method.&quot;&quot;&quot;
        raise NotImplementedError

    def __sub__(self, other):
        return self + -other

    def __rsub__(self, other):
        return -self + other

    &#64;abstractmethod
    def __mul__(self, other):
        raise NotImplementedError

    &#64;abstractmethod
    def __rmul__(self, other):
        raise NotImplementedError

    &#64;abstractmethod
    def __div__(self, other):
        &quot;&quot;&quot;a/b; should promote to float or complex when necessary.&quot;&quot;&quot;
        raise NotImplementedError

    &#64;abstractmethod
    def __rdiv__(self, other):
        raise NotImplementedError

    &#64;abstractmethod
    def __pow__(self, exponent):
        &quot;&quot;&quot;a**b; should promote to float or complex when necessary.&quot;&quot;&quot;
        raise NotImplementedError

    &#64;abstractmethod
    def __rpow__(self, base):
        raise NotImplementedError

    &#64;abstractmethod
    def __abs__(self):
        &quot;&quot;&quot;Returns the Real distance from 0.&quot;&quot;&quot;
        raise NotImplementedError

    &#64;abstractmethod
    def conjugate(self):
        &quot;&quot;&quot;(x+y*i).conjugate() returns (x-y*i).&quot;&quot;&quot;
        raise NotImplementedError

    &#64;abstractmethod
    def __eq__(self, other):
        raise NotImplementedError

    # __ne__ is inherited from object and negates whatever __eq__ does.
</pre>
<p>The <tt class="docutils literal">Real</tt> ABC indicates that the value is on the real line, and
supports the operations of the <tt class="docutils literal">float</tt> builtin. Real numbers are
totally ordered except for NaNs (which this PEP basically ignores).</p>
<pre class="literal-block">
class Real(Complex):
    &quot;&quot;&quot;To Complex, Real adds the operations that work on real numbers.

    In short, those are: conversion to float, trunc(), math.floor(),
    math.ceil(), round(), divmod(), //, %, &lt;, &lt;=, &gt;, and &gt;=.

    Real also provides defaults for some of the derived operations.
    &quot;&quot;&quot;

    # XXX What to do about the __int__ implementation that's
    # currently present on float?  Get rid of it?

    &#64;abstractmethod
    def __float__(self):
        &quot;&quot;&quot;Any Real can be converted to a native float object.&quot;&quot;&quot;
        raise NotImplementedError

    &#64;abstractmethod
    def __trunc__(self):
        &quot;&quot;&quot;Truncates self to an Integral.

        Returns an Integral i such that:
          * i&gt;=0 iff self&gt;0;
          * abs(i) &lt;= abs(self);
          * for any Integral j satisfying the first two conditions,
            abs(i) &gt;= abs(j) [i.e. i has &quot;maximal&quot; abs among those].
        i.e. &quot;truncate towards 0&quot;.
        &quot;&quot;&quot;
        raise NotImplementedError

    &#64;abstractmethod
    def __floor__(self):
        &quot;&quot;&quot;Finds the greatest Integral &lt;= self.&quot;&quot;&quot;
        raise NotImplementedError

    &#64;abstractmethod
    def __ceil__(self):
        &quot;&quot;&quot;Finds the least Integral &gt;= self.&quot;&quot;&quot;
        raise NotImplementedError

    &#64;abstractmethod
    def __round__(self, ndigits:Integral=None):
        &quot;&quot;&quot;Rounds self to ndigits decimal places, defaulting to 0.

        If ndigits is omitted or None, returns an Integral,
        otherwise returns a Real, preferably of the same type as
        self. Types may choose which direction to round half. For
        example, float rounds half toward even.

        &quot;&quot;&quot;
        raise NotImplementedError

    def __divmod__(self, other):
        &quot;&quot;&quot;The pair (self // other, self % other).

        Sometimes this can be computed faster than the pair of
        operations.
        &quot;&quot;&quot;
        return (self // other, self % other)

    def __rdivmod__(self, other):
        &quot;&quot;&quot;The pair (self // other, self % other).

        Sometimes this can be computed faster than the pair of
        operations.
        &quot;&quot;&quot;
        return (other // self, other % self)

    &#64;abstractmethod
    def __floordiv__(self, other):
        &quot;&quot;&quot;The floor() of self/other. Integral.&quot;&quot;&quot;
        raise NotImplementedError

    &#64;abstractmethod
    def __rfloordiv__(self, other):
        &quot;&quot;&quot;The floor() of other/self.&quot;&quot;&quot;
        raise NotImplementedError

    &#64;abstractmethod
    def __mod__(self, other):
        &quot;&quot;&quot;self % other

        See
        https://mail.python.org/pipermail/python-3000/2006-May/001735.html
        and consider using &quot;self/other - trunc(self/other)&quot;
        instead if you're worried about round-off errors.
        &quot;&quot;&quot;
        raise NotImplementedError

    &#64;abstractmethod
    def __rmod__(self, other):
        &quot;&quot;&quot;other % self&quot;&quot;&quot;
        raise NotImplementedError

    &#64;abstractmethod
    def __lt__(self, other):
        &quot;&quot;&quot;&lt; on Reals defines a total ordering, except perhaps for NaN.&quot;&quot;&quot;
        raise NotImplementedError

    &#64;abstractmethod
    def __le__(self, other):
        raise NotImplementedError

    # __gt__ and __ge__ are automatically done by reversing the arguments.
    # (But __le__ is not computed as the opposite of __gt__!)

    # Concrete implementations of Complex abstract methods.
    # Subclasses may override these, but don't have to.

    def __complex__(self):
        return complex(float(self))

    &#64;property
    def real(self):
        return +self

    &#64;property
    def imag(self):
        return 0

    def conjugate(self):
        &quot;&quot;&quot;Conjugate is a no-op for Reals.&quot;&quot;&quot;
        return +self
</pre>
<p>We should clean up Demo/classes/Rat.py and promote it into
rational.py in the standard library. Then it will implement the
Rational ABC.</p>
<pre class="literal-block">
class Rational(Real, Exact):
    &quot;&quot;&quot;.numerator and .denominator should be in lowest terms.&quot;&quot;&quot;

    &#64;abstractproperty
    def numerator(self):
        raise NotImplementedError

    &#64;abstractproperty
    def denominator(self):
        raise NotImplementedError

    # Concrete implementation of Real's conversion to float.
    # (This invokes Integer.__div__().)

    def __float__(self):
        return self.numerator / self.denominator
</pre>
<p>And finally integers:</p>
<pre class="literal-block">
class Integral(Rational):
    &quot;&quot;&quot;Integral adds a conversion to int and the bit-string operations.&quot;&quot;&quot;

    &#64;abstractmethod
    def __int__(self):
        raise NotImplementedError

    def __index__(self):
        &quot;&quot;&quot;__index__() exists because float has __int__().&quot;&quot;&quot;
        return int(self)

    def __lshift__(self, other):
        return int(self) &lt;&lt; int(other)

    def __rlshift__(self, other):
        return int(other) &lt;&lt; int(self)

    def __rshift__(self, other):
        return int(self) &gt;&gt; int(other)

    def __rrshift__(self, other):
        return int(other) &gt;&gt; int(self)

    def __and__(self, other):
        return int(self) &amp; int(other)

    def __rand__(self, other):
        return int(other) &amp; int(self)

    def __xor__(self, other):
        return int(self) ^ int(other)

    def __rxor__(self, other):
        return int(other) ^ int(self)

    def __or__(self, other):
        return int(self) | int(other)

    def __ror__(self, other):
        return int(other) | int(self)

    def __invert__(self):
        return ~int(self)

    # Concrete implementations of Rational and Real abstract methods.
    def __float__(self):
        &quot;&quot;&quot;float(self) == float(int(self))&quot;&quot;&quot;
        return float(int(self))

    &#64;property
    def numerator(self):
        &quot;&quot;&quot;Integers are their own numerators.&quot;&quot;&quot;
        return +self

    &#64;property
    def denominator(self):
        &quot;&quot;&quot;Integers have a denominator of 1.&quot;&quot;&quot;
        return 1
</pre>
</div>
<div class="section" id="changes-to-operations-and-magic-methods">
<h2><a class="toc-backref" href="#id7">Changes to operations and __magic__ methods</a></h2>
<p>To support more precise narrowing from float to int (and more
generally, from Real to Integral), we propose the following new
__magic__ methods, to be called from the corresponding library
functions. All of these return Integrals rather than Reals.</p>
<ol class="arabic simple">
<li><tt class="docutils literal">__trunc__(self)</tt>, called from a new builtin <tt class="docutils literal">trunc(x)</tt>, which
returns the Integral closest to <tt class="docutils literal">x</tt> between 0 and <tt class="docutils literal">x</tt>.</li>
<li><tt class="docutils literal">__floor__(self)</tt>, called from <tt class="docutils literal">math.floor(x)</tt>, which returns
the greatest Integral <tt class="docutils literal">&lt;= x</tt>.</li>
<li><tt class="docutils literal">__ceil__(self)</tt>, called from <tt class="docutils literal">math.ceil(x)</tt>, which returns the
least Integral <tt class="docutils literal">&gt;= x</tt>.</li>
<li><tt class="docutils literal">__round__(self)</tt>, called from <tt class="docutils literal">round(x)</tt>, which returns the
Integral closest to <tt class="docutils literal">x</tt>, rounding half as the type chooses.
<tt class="docutils literal">float</tt> will change in 3.0 to round half toward even. There is
also a 2-argument version, <tt class="docutils literal">__round__(self, ndigits)</tt>, called
from <tt class="docutils literal">round(x, ndigits)</tt>, which should return a Real.</li>
</ol>
<p>In 2.6, <tt class="docutils literal">math.floor</tt>, <tt class="docutils literal">math.ceil</tt>, and <tt class="docutils literal">round</tt> will continue to
return floats.</p>
<p>The <tt class="docutils literal">int()</tt> conversion implemented by <tt class="docutils literal">float</tt> is equivalent to
<tt class="docutils literal">trunc()</tt>.  In general, the <tt class="docutils literal">int()</tt> conversion should try
<tt class="docutils literal">__int__()</tt> first and if it is not found, try <tt class="docutils literal">__trunc__()</tt>.</p>
<p><tt class="docutils literal">complex.__{divmod,mod,floordiv,int,float}__</tt> also go away. It would
be nice to provide a nice error message to help confused porters, but
not appearing in <tt class="docutils literal">help(complex)</tt> is more important.</p>
</div>
<div class="section" id="notes-for-type-implementors">
<h2><a class="toc-backref" href="#id8">Notes for type implementors</a></h2>
<p>Implementors should be careful to make equal numbers equal and
hash them to the same values. This may be subtle if there are two
different extensions of the real numbers. For example, a complex type
could reasonably implement hash() as follows:</p>
<pre class="literal-block">
def __hash__(self):
    return hash(complex(self))
</pre>
<p>but should be careful of any values that fall outside of the built in
complex's range or precision.</p>
<div class="section" id="adding-more-numeric-abcs">
<h3><a class="toc-backref" href="#id9">Adding More Numeric ABCs</a></h3>
<p>There are, of course, more possible ABCs for numbers, and this would
be a poor hierarchy if it precluded the possibility of adding
those. You can add <tt class="docutils literal">MyFoo</tt> between <tt class="docutils literal">Complex</tt> and <tt class="docutils literal">Real</tt> with:</p>
<pre class="literal-block">
class MyFoo(Complex): ...
MyFoo.register(Real)
</pre>
</div>
<div class="section" id="implementing-the-arithmetic-operations">
<h3><a class="toc-backref" href="#id10">Implementing the arithmetic operations</a></h3>
<p>We want to implement the arithmetic operations so that mixed-mode
operations either call an implementation whose author knew about the
types of both arguments, or convert both to the nearest built in type
and do the operation there. For subtypes of Integral, this means that
__add__ and __radd__ should be defined as:</p>
<pre class="literal-block">
class MyIntegral(Integral):

    def __add__(self, other):
        if isinstance(other, MyIntegral):
            return do_my_adding_stuff(self, other)
        elif isinstance(other, OtherTypeIKnowAbout):
            return do_my_other_adding_stuff(self, other)
        else:
            return NotImplemented

    def __radd__(self, other):
        if isinstance(other, MyIntegral):
            return do_my_adding_stuff(other, self)
        elif isinstance(other, OtherTypeIKnowAbout):
            return do_my_other_adding_stuff(other, self)
        elif isinstance(other, Integral):
            return int(other) + int(self)
        elif isinstance(other, Real):
            return float(other) + float(self)
        elif isinstance(other, Complex):
            return complex(other) + complex(self)
        else:
            return NotImplemented
</pre>
<p>There are 5 different cases for a mixed-type operation on subclasses
of Complex. I'll refer to all of the above code that doesn't refer to
MyIntegral and OtherTypeIKnowAbout as &quot;boilerplate&quot;. <tt class="docutils literal">a</tt> will be an
instance of <tt class="docutils literal">A</tt>, which is a subtype of <tt class="docutils literal">Complex</tt> (<tt class="docutils literal">a : A &lt;:
Complex</tt>), and <tt class="docutils literal">b : B &lt;: Complex</tt>. I'll consider <tt class="docutils literal">a + b</tt>:</p>
<ol class="arabic simple">
<li>If A defines an __add__ which accepts b, all is well.</li>
<li>If A falls back to the boilerplate code, and it were to return
a value from __add__, we'd miss the possibility that B defines
a more intelligent __radd__, so the boilerplate should return
NotImplemented from __add__. (Or A may not implement __add__ at
all.)</li>
<li>Then B's __radd__ gets a chance. If it accepts a, all is well.</li>
<li>If it falls back to the boilerplate, there are no more possible
methods to try, so this is where the default implementation
should live.</li>
<li>If B &lt;: A, Python tries B.__radd__ before A.__add__. This is
ok, because it was implemented with knowledge of A, so it can
handle those instances before delegating to Complex.</li>
</ol>
<p>If <tt class="docutils literal"><span class="pre">A&lt;:Complex</span></tt> and <tt class="docutils literal"><span class="pre">B&lt;:Real</span></tt> without sharing any other knowledge,
then the appropriate shared operation is the one involving the built
in complex, and both __radd__s land there, so <tt class="docutils literal">a+b == b+a</tt>.</p>
</div>
</div>
</div>
<div class="section" id="rejected-alternatives">
<h1><a class="toc-backref" href="#id11">Rejected Alternatives</a></h1>
<p>The initial version of this PEP defined an algebraic hierarchy
inspired by a Haskell Numeric Prelude <a class="footnote-reference" href="#numericprelude" id="id2">[3]</a> including
MonoidUnderPlus, AdditiveGroup, Ring, and Field, and mentioned several
other possible algebraic types before getting to the numbers. We had
expected this to be useful to people using vectors and matrices, but
the NumPy community really wasn't interested, and we ran into the
issue that even if <tt class="docutils literal">x</tt> is an instance of <tt class="docutils literal">X &lt;: MonoidUnderPlus</tt>
and <tt class="docutils literal">y</tt> is an instance of <tt class="docutils literal">Y &lt;: MonoidUnderPlus</tt>, <tt class="docutils literal">x + y</tt> may
still not make sense.</p>
<p>Then we gave the numbers a much more branching structure to include
things like the Gaussian Integers and Z/nZ, which could be Complex but
wouldn't necessarily support things like division. The community
decided that this was too much complication for Python, so I've now
scaled back the proposal to resemble the Scheme numeric tower much
more closely.</p>
</div>
<div class="section" id="the-decimal-type">
<h1><a class="toc-backref" href="#id12">The Decimal Type</a></h1>
<p>After consultation with its authors it has been decided that the
<tt class="docutils literal">Decimal</tt> type should not at this time be made part of the numeric
tower.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id13">References</a></h1>
<table class="docutils footnote" frame="void" id="pep3119" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Introducing Abstract Base Classes
(<a class="reference external" href="http://www.python.org/dev/peps/pep-3119/">http://www.python.org/dev/peps/pep-3119/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="classtree" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>Possible Python 3K Class Tree?, wiki page by Bill Janssen
(<a class="reference external" href="http://wiki.python.org/moin/AbstractBaseClasses">http://wiki.python.org/moin/AbstractBaseClasses</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="numericprelude" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[3]</a></td><td>NumericPrelude: An experimental alternative hierarchy
of numeric type classes
(<a class="reference external" href="http://darcs.haskell.org/numericprelude/docs/html/index.html">http://darcs.haskell.org/numericprelude/docs/html/index.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="schemetower" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[4]</a></td><td>The Scheme numerical tower
(<a class="reference external" href="http://www.swiss.ai.mit.edu/ftpdir/scheme-reports/r5rs-html/r5rs_8.html#SEC50">http://www.swiss.ai.mit.edu/ftpdir/scheme-reports/r5rs-html/r5rs_8.html#SEC50</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="acknowledgements">
<h1><a class="toc-backref" href="#id14">Acknowledgements</a></h1>
<p>Thanks to Neal Norwitz for encouraging me to write this PEP in the
first place, to Travis Oliphant for pointing out that the numpy people
didn't really care about the algebraic concepts, to Alan Isaac for
reminding me that Scheme had already done this, and to Guido van
Rossum and lots of other people on the mailing list for refining the
concept.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id15">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

