<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">261</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Support for &quot;wide&quot; Unicode characters</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0261.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Paul Prescod &lt;paul&#32;&#97;t&#32;prescod.net&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">27-Jun-2001</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.2</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">27-Jun-2001</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id1">Abstract</a></li>
<li><a class="reference internal" href="#glossary" id="id2">Glossary</a></li>
<li><a class="reference internal" href="#proposed-solution" id="id3">Proposed Solution</a></li>
<li><a class="reference internal" href="#implementation" id="id4">Implementation</a></li>
<li><a class="reference internal" href="#notes" id="id5">Notes</a></li>
<li><a class="reference internal" href="#rejected-suggestions" id="id6">Rejected Suggestions</a></li>
<li><a class="reference internal" href="#references" id="id7">References</a></li>
<li><a class="reference internal" href="#copyright" id="id8">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id1">Abstract</a></h1>
<p>Python 2.1 unicode characters can have ordinals only up to <tt class="docutils literal"><span class="pre">2**16</span> - 1</tt>.
This range corresponds to a range in Unicode known as the Basic
Multilingual Plane. There are now characters in Unicode that live
on other &quot;planes&quot;. The largest addressable character in Unicode
has the ordinal <tt class="docutils literal">17 * <span class="pre">2**16</span> - 1</tt> (<tt class="docutils literal">0x10ffff</tt>). For readability, we
will call this TOPCHAR and call characters in this range &quot;wide
characters&quot;.</p>
</div>
<div class="section" id="glossary">
<h1><a class="toc-backref" href="#id2">Glossary</a></h1>
<dl class="docutils">
<dt>Character</dt>
<dd>Used by itself, means the addressable units of a Python
Unicode string.</dd>
<dt>Code point</dt>
<dd>A code point is an integer between 0 and TOPCHAR.
If you imagine Unicode as a mapping from integers to
characters, each integer is a code point. But the
integers between 0 and TOPCHAR that do not map to
characters are also code points. Some will someday
be used for characters. Some are guaranteed never
to be used for characters.</dd>
<dt>Codec</dt>
<dd>A set of functions for translating between physical
encodings (e.g. on disk or coming in from a network)
into logical Python objects.</dd>
<dt>Encoding</dt>
<dd>Mechanism for representing abstract characters in terms of
physical bits and bytes. Encodings allow us to store
Unicode characters on disk and transmit them over networks
in a manner that is compatible with other Unicode software.</dd>
<dt>Surrogate pair</dt>
<dd>Two physical characters that represent a single logical
character. Part of a convention for representing 32-bit
code points in terms of two 16-bit code points.</dd>
<dt>Unicode string</dt>
<dd>A Python type representing a sequence of code points with
&quot;string semantics&quot; (e.g. case conversions, regular
expression compatibility, etc.) Constructed with the
<tt class="docutils literal">unicode()</tt> function.</dd>
</dl>
</div>
<div class="section" id="proposed-solution">
<h1><a class="toc-backref" href="#id3">Proposed Solution</a></h1>
<p>One solution would be to merely increase the maximum ordinal
to a larger value. Unfortunately the only straightforward
implementation of this idea is to use 4 bytes per character.
This has the effect of doubling the size of most Unicode
strings. In order to avoid imposing this cost on every
user, Python 2.2 will allow the 4-byte implementation as a
build-time option. Users can choose whether they care about
wide characters or prefer to preserve memory.</p>
<p>The 4-byte option is called &quot;wide <tt class="docutils literal">Py_UNICODE</tt>&quot;. The 2-byte option
is called &quot;narrow <tt class="docutils literal">Py_UNICODE</tt>&quot;.</p>
<p>Most things will behave identically in the wide and narrow worlds.</p>
<ul>
<li><p class="first"><tt class="docutils literal">unichr(i)</tt> for 0 &lt;= i &lt; <tt class="docutils literal"><span class="pre">2**16</span></tt> (<tt class="docutils literal">0x10000</tt>) always returns a
length-one string.</p>
</li>
<li><p class="first"><tt class="docutils literal">unichr(i)</tt> for <tt class="docutils literal"><span class="pre">2**16</span></tt> &lt;= i &lt;= TOPCHAR will return a
length-one string on wide Python builds. On narrow builds it will
raise <tt class="docutils literal">ValueError</tt>.</p>
<p><strong>ISSUE</strong></p>
<blockquote>
<p>Python currently allows <tt class="docutils literal">\U</tt> literals that cannot be
represented as a single Python character. It generates two
Python characters known as a &quot;surrogate pair&quot;. Should this
be disallowed on future narrow Python builds?</p>
</blockquote>
<p><strong>Pro:</strong></p>
<blockquote>
<p>Python already the construction of a surrogate pair
for a large unicode literal character escape sequence.
This is basically designed as a simple way to construct
&quot;wide characters&quot; even in a narrow Python build. It is also
somewhat logical considering that the Unicode-literal syntax
is basically a short-form way of invoking the unicode-escape
codec.</p>
</blockquote>
<p><strong>Con:</strong></p>
<blockquote>
<p>Surrogates could be easily created this way but the user
still needs to be careful about slicing, indexing, printing
etc. Therefore, some have suggested that Unicode
literals should not support surrogates.</p>
</blockquote>
<p><strong>ISSUE</strong></p>
<blockquote>
<p>Should Python allow the construction of characters that do
not correspond to Unicode code points?  Unassigned Unicode
code points should obviously be legal (because they could
be assigned at any time). But code points above TOPCHAR are
guaranteed never to be used by Unicode. Should we allow access
to them anyhow?</p>
</blockquote>
<p><strong>Pro:</strong></p>
<blockquote>
<p>If a Python user thinks they know what they're doing why
should we try to prevent them from violating the Unicode
spec? After all, we don't stop 8-bit strings from
containing non-ASCII characters.</p>
</blockquote>
<p><strong>Con:</strong></p>
<blockquote>
<p>Codecs and other Unicode-consuming code will have to be
careful of these characters which are disallowed by the
Unicode specification.</p>
</blockquote>
</li>
<li><p class="first"><tt class="docutils literal">ord()</tt> is always the inverse of <tt class="docutils literal">unichr()</tt></p>
</li>
<li><p class="first">There is an integer value in the sys module that describes the
largest ordinal for a character in a Unicode string on the current
interpreter. <tt class="docutils literal">sys.maxunicode</tt> is <tt class="docutils literal"><span class="pre">2**16-1</span></tt> (<tt class="docutils literal">0xffff</tt>) on narrow builds
of Python and TOPCHAR on wide builds.</p>
<p><strong>ISSUE:</strong></p>
<blockquote>
<p>Should there be distinct constants for accessing
TOPCHAR and the real upper bound for the domain of
<tt class="docutils literal">unichr</tt> (if they differ)? There has also been a
suggestion of <tt class="docutils literal">sys.unicodewidth</tt> which can take the
values <tt class="docutils literal">'wide'</tt> and <tt class="docutils literal">'narrow'</tt>.</p>
</blockquote>
</li>
<li><p class="first">every Python Unicode character represents exactly one Unicode code
point (i.e. Python Unicode Character = Abstract Unicode character).</p>
</li>
<li><p class="first">codecs will be upgraded to support &quot;wide characters&quot;
(represented directly in UCS-4, and as variable-length sequences
in UTF-8 and UTF-16). This is the main part of the implementation
left to be done.</p>
</li>
<li><p class="first">There is a convention in the Unicode world for encoding a 32-bit
code point in terms of two 16-bit code points. These are known
as &quot;surrogate pairs&quot;. Python's codecs will adopt this convention
and encode 32-bit code points as surrogate pairs on narrow Python
builds.</p>
<p><strong>ISSUE</strong></p>
<blockquote>
<p>Should there be a way to tell codecs not to generate
surrogates and instead treat wide characters as
errors?</p>
</blockquote>
<p><strong>Pro:</strong></p>
<blockquote>
<p>I might want to write code that works only with
fixed-width characters and does not have to worry about
surrogates.</p>
</blockquote>
<p><strong>Con:</strong></p>
<blockquote>
<p>No clear proposal of how to communicate this to codecs.</p>
</blockquote>
</li>
<li><p class="first">there are no restrictions on constructing strings that use
code points &quot;reserved for surrogates&quot; improperly. These are
called &quot;isolated surrogates&quot;. The codecs should disallow reading
these from files, but you could construct them using string
literals or <tt class="docutils literal">unichr()</tt>.</p>
</li>
</ul>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id4">Implementation</a></h1>
<p>There is a new define:</p>
<pre class="literal-block">
#define Py_UNICODE_SIZE 2
</pre>
<p>To test whether UCS2 or UCS4 is in use, the derived macro
<tt class="docutils literal">Py_UNICODE_WIDE</tt> should be used, which is defined when UCS-4 is in
use.</p>
<p>There is a new configure option:</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<tbody valign="top">
<tr><td>--enable-unicode=ucs2</td>
<td>configures a narrow <tt class="docutils literal">Py_UNICODE</tt>, and uses
wchar_t if it fits</td>
</tr>
<tr><td>--enable-unicode=ucs4</td>
<td>configures a wide <cite>Py_UNICODE`</cite>, and uses
wchar_t if it fits</td>
</tr>
<tr><td>--enable-unicode</td>
<td>same as &quot;=ucs2&quot;</td>
</tr>
<tr><td>--disable-unicode</td>
<td>entirely remove the Unicode functionality.</td>
</tr>
</tbody>
</table>
<p>It is also proposed that one day <tt class="docutils literal"><span class="pre">--enable-unicode</span></tt> will just
default to the width of your platforms <tt class="docutils literal">wchar_t</tt>.</p>
<p>Windows builds will be narrow for a while based on the fact that
there have been few requests for wide characters, those requests
are mostly from hard-core programmers with the ability to buy
their own Python and Windows itself is strongly biased towards
16-bit characters.</p>
</div>
<div class="section" id="notes">
<h1><a class="toc-backref" href="#id5">Notes</a></h1>
<p>This PEP does NOT imply that people using Unicode need to use a
4-byte encoding for their files on disk or sent over the network.
It only allows them to do so. For example, ASCII is still a
legitimate (7-bit) Unicode-encoding.</p>
<p>It has been proposed that there should be a module that handles
surrogates in narrow Python builds for programmers. If someone
wants to implement that, it will be another PEP. It might also be
combined with features that allow other kinds of character-,
word- and line- based indexing.</p>
</div>
<div class="section" id="rejected-suggestions">
<h1><a class="toc-backref" href="#id6">Rejected Suggestions</a></h1>
<p>More or less the status-quo</p>
<blockquote>
We could officially say that Python characters are 16-bit and
require programmers to implement wide characters in their
application logic by combining surrogate pairs. This is a heavy
burden because emulating 32-bit characters is likely to be
very inefficient if it is coded entirely in Python. Plus these
abstracted pseudo-strings would not be legal as input to the
regular expression engine.</blockquote>
<p>&quot;Space-efficient Unicode&quot; type</p>
<blockquote>
Another class of solution is to use some efficient storage
internally but present an abstraction of wide characters to
the programmer. Any of these would require a much more complex
implementation than the accepted solution. For instance consider
the impact on the regular expression engine. In theory, we could
move to this implementation in the future without breaking Python
code. A future Python could &quot;emulate&quot; wide Python semantics on
narrow Python. Guido is not willing to undertake the
implementation right now.</blockquote>
<p>Two types</p>
<blockquote>
We could introduce a 32-bit Unicode type alongside the 16-bit
type. There is a lot of code that expects there to be only a
single Unicode type.</blockquote>
<p>This PEP represents the least-effort solution. Over the next
several years, 32-bit Unicode characters will become more common
and that may either convince us that we need a more sophisticated
solution or (on the other hand) convince us that simply
mandating wide Unicode characters is an appropriate solution.
Right now the two options on the table are do nothing or do
this.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id7">References</a></h1>
<p>Unicode Glossary: <a class="reference external" href="http://www.unicode.org/glossary/">http://www.unicode.org/glossary/</a></p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id8">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

