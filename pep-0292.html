<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">292</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Simpler String Substitutions</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0292.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">barry&#32;&#97;t&#32;python.org (Barry Warsaw)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">18-Jun-2002</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.4</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">18-Jun-2002, 23-Mar-2004, 22-Aug-2004</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id9">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id10">Rationale</a></li>
<li><a class="reference internal" href="#a-simpler-proposal" id="id11">A Simpler Proposal</a></li>
<li><a class="reference internal" href="#why-and-braces" id="id12">Why <tt class="docutils literal">$</tt> and Braces?</a></li>
<li><a class="reference internal" href="#comparison-to-pep-215" id="id13">Comparison to PEP 215</a></li>
<li><a class="reference internal" href="#internationalization" id="id14">Internationalization</a></li>
<li><a class="reference internal" href="#reference-implementation" id="id15">Reference Implementation</a></li>
<li><a class="reference internal" href="#references" id="id16">References</a></li>
<li><a class="reference internal" href="#copyright" id="id17">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id9">Abstract</a></h1>
<p>This PEP describes a simpler string substitution feature, also
known as string interpolation.  This PEP is &quot;simpler&quot; in two
respects:</p>
<ol class="arabic simple">
<li>Python's current string substitution feature
(i.e. <tt class="docutils literal">%</tt>-substitution) is complicated and error prone.  This PEP
is simpler at the cost of some expressiveness.</li>
<li><a class="reference external" href="/dev/peps/pep-0215">PEP 215</a> proposed an alternative string interpolation feature,
introducing a new <tt class="docutils literal">$</tt> string prefix.  <a class="reference external" href="/dev/peps/pep-0292">PEP 292</a> is simpler than
this because it involves no syntax changes and has much simpler
rules for what substitutions can occur in the string.</li>
</ol>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id10">Rationale</a></h1>
<p>Python currently supports a string substitution syntax based on
C's <tt class="docutils literal">printf()</tt> '<tt class="docutils literal">%</tt>' formatting character <a class="footnote-reference" href="#id4" id="id1">[1]</a>.  While quite rich,
<tt class="docutils literal">%</tt>-formatting codes are also error prone, even for
experienced Python programmers.  A common mistake is to leave off
the trailing format character, e.g. the '<tt class="docutils literal">s</tt>' in <tt class="docutils literal"><span class="pre">&quot;%(name)s&quot;</span></tt>.</p>
<p>In addition, the rules for what can follow a <tt class="docutils literal">%</tt> sign are fairly
complex, while the usual application rarely needs such complexity.
Most scripts need to do some string interpolation, but most of
those use simple 'stringification' formats, i.e. <tt class="docutils literal">%s</tt> or <tt class="docutils literal">%(name)s</tt>
This form should be made simpler and less error prone.</p>
</div>
<div class="section" id="a-simpler-proposal">
<h1><a class="toc-backref" href="#id11">A Simpler Proposal</a></h1>
<p>We propose the addition of a new class, called <tt class="docutils literal">Template</tt>, which
will live in the string module.  The <tt class="docutils literal">Template</tt> class supports new
rules for string substitution; its value contains placeholders,
introduced with the <tt class="docutils literal">$</tt> character.  The following rules for
<tt class="docutils literal">$</tt>-placeholders apply:</p>
<ol class="arabic simple">
<li><tt class="docutils literal">$$</tt> is an escape; it is replaced with a single <tt class="docutils literal">$</tt></li>
<li><tt class="docutils literal">$identifier</tt> names a substitution placeholder matching a mapping
key of &quot;identifier&quot;.  By default, &quot;identifier&quot; must spell a
Python identifier as defined in <a class="footnote-reference" href="#id5" id="id2">[2]</a>.  The first non-identifier
character after the <tt class="docutils literal">$</tt> character terminates this placeholder
specification.</li>
<li><tt class="docutils literal">${identifier}</tt> is equivalent to <tt class="docutils literal">$identifier</tt>.  It is required
when valid identifier characters follow the placeholder but are
not part of the placeholder, e.g. <tt class="docutils literal"><span class="pre">&quot;${noun}ification&quot;</span></tt>.</li>
</ol>
<p>If the <tt class="docutils literal">$</tt> character appears at the end of the line, or is followed
by any other character than those described above, a <tt class="docutils literal">ValueError</tt>
will be raised at interpolation time.  Values in mapping are
converted automatically to strings.</p>
<p>No other characters have special meaning, however it is possible
to derive from the <tt class="docutils literal">Template</tt> class to define different substitution
rules.  For example, a derived class could allow for periods in
the placeholder (e.g. to support a kind of dynamic namespace and
attribute path lookup), or could define a delimiter character
other than <tt class="docutils literal">$</tt>.</p>
<p>Once the <tt class="docutils literal">Template</tt> has been created, substitutions can be performed
by calling one of two methods:</p>
<ul>
<li><p class="first"><tt class="docutils literal">substitute()</tt>.  This method returns a new string which results
when the values of a mapping are substituted for the
placeholders in the <tt class="docutils literal">Template</tt>.  If there are placeholders which
are not present in the mapping, a <tt class="docutils literal">KeyError</tt> will be raised.</p>
</li>
<li><p class="first"><tt class="docutils literal">safe_substitute()</tt>.  This is similar to the <tt class="docutils literal">substitute()</tt> method,
except that <tt class="docutils literal">KeyErrors</tt> are never raised (due to placeholders
missing from the mapping).  When a placeholder is missing, the
original placeholder will appear in the resulting string.</p>
<p>Here are some examples:</p>
<pre class="literal-block">
&gt;&gt;&gt; from string import Template
&gt;&gt;&gt; s = Template('${name} was born in ${country}')
&gt;&gt;&gt; print s.substitute(name='Guido', country='the Netherlands')
Guido was born in the Netherlands
&gt;&gt;&gt; print s.substitute(name='Guido')
Traceback (most recent call last):
[...]
KeyError: 'country'
&gt;&gt;&gt; print s.safe_substitute(name='Guido')
Guido was born in ${country}
</pre>
</li>
</ul>
<p>The signature of <tt class="docutils literal">substitute()</tt> and <tt class="docutils literal">safe_substitute()</tt> allows for
passing the mapping of placeholders to values, either as a single
dictionary-like object in the first positional argument, or as
keyword arguments as shown above.  The exact details and
signatures of these two methods is reserved for the standard
library documentation.</p>
</div>
<div class="section" id="why-and-braces">
<h1><a class="toc-backref" href="#id12">Why <tt class="docutils literal">$</tt> and Braces?</a></h1>
<p>The BDFL said it best <a class="footnote-reference" href="#id7" id="id3">[4]</a>: &quot;The <tt class="docutils literal">$</tt> means &quot;substitution&quot; in so many
languages besides Perl that I wonder where you've been. [...]
We're copying this from the shell.&quot;</p>
<p>Thus the substitution rules are chosen because of the similarity
with so many other languages.  This makes the substitution rules
easier to teach, learn, and remember.</p>
</div>
<div class="section" id="comparison-to-pep-215">
<h1>Comparison to <a class="reference external" href="/dev/peps/pep-0215">PEP 215</a></h1>
<p><a class="reference external" href="/dev/peps/pep-0215">PEP 215</a> describes an alternate proposal for string interpolation.
Unlike that PEP, this one does not propose any new syntax for
Python.  All the proposed new features are embodied in a new
library module.  <a class="reference external" href="/dev/peps/pep-0215">PEP 215</a> proposes a new string prefix
representation such as <tt class="docutils literal">$&quot;&quot;</tt> which signal to Python that a new type
of string is present.  <tt class="docutils literal">$</tt>-strings would have to interact with the
existing r-prefixes and u-prefixes, essentially doubling the
number of string prefix combinations.</p>
<p><a class="reference external" href="/dev/peps/pep-0215">PEP 215</a> also allows for arbitrary Python expressions inside the
<tt class="docutils literal">$</tt>-strings, so that you could do things like:</p>
<pre class="literal-block">
import sys
print $&quot;sys = $sys, sys = $sys.modules['sys']&quot;
</pre>
<p>which would return:</p>
<pre class="literal-block">
sys = &lt;module 'sys' (built-in)&gt;, sys = &lt;module 'sys' (built-in)&gt;
</pre>
<p>It's generally accepted that the rules in <a class="reference external" href="/dev/peps/pep-0215">PEP 215</a> are safe in the
sense that they introduce no new security issues (see <a class="reference external" href="/dev/peps/pep-0215">PEP 215</a>,
&quot;Security Issues&quot; for details).  However, the rules are still
quite complex, and make it more difficult to see the substitution
placeholder in the original <tt class="docutils literal">$</tt>-string.</p>
<p>The interesting thing is that the <tt class="docutils literal">Template</tt> class defined in this
PEP is designed for inheritance and, with a little extra work,
it's possible to support <a class="reference external" href="/dev/peps/pep-0215">PEP 215</a>'s functionality using existing
Python syntax.</p>
<p>For example, one could define subclasses of <tt class="docutils literal">Template</tt> and dict that
allowed for a more complex placeholder syntax and a mapping that
evaluated those placeholders.</p>
</div>
<div class="section" id="internationalization">
<h1><a class="toc-backref" href="#id14">Internationalization</a></h1>
<p>The implementation supports internationalization by recording the
original template string in the <tt class="docutils literal">Template</tt> instance's <tt class="docutils literal">template</tt>
attribute.  This attribute would serve as the lookup key in an
gettext-based catalog.  It is up to the application to turn the
resulting string back into a <tt class="docutils literal">Template</tt> for substitution.</p>
<p>However, the <tt class="docutils literal">Template</tt> class was designed to work more intuitively
in an internationalized application, by supporting the mixing-in
of <tt class="docutils literal">Template</tt> and unicode subclasses.  Thus an internationalized
application could create an application-specific subclass,
multiply inheriting from <tt class="docutils literal">Template</tt> and unicode, and using instances
of that subclass as the gettext catalog key.  Further, the
subclass could alias the special <tt class="docutils literal">__mod__()</tt> method to either
<tt class="docutils literal">.substitute()</tt> or <tt class="docutils literal">.safe_substitute()</tt> to provide a more traditional
string/unicode like <tt class="docutils literal">%</tt>-operator substitution syntax.</p>
</div>
<div class="section" id="reference-implementation">
<h1><a class="toc-backref" href="#id15">Reference Implementation</a></h1>
<p>The implementation has been committed to the Python 2.4 source tree.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id16">References</a></h1>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>String Formatting Operations
<a class="reference external" href="http://docs.python.org/library/stdtypes.html#string-formatting-operations">http://docs.python.org/library/stdtypes.html#string-formatting-operations</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Identifiers and Keywords
<a class="reference external" href="http://docs.python.org/reference/lexical_analysis.html#identifiers-and-keywords">http://docs.python.org/reference/lexical_analysis.html#identifiers-and-keywords</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>Guido's python-dev posting from 21-Jul-2002
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2002-July/026397.html">https://mail.python.org/pipermail/python-dev/2002-July/026397.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[4]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2002-June/025652.html">https://mail.python.org/pipermail/python-dev/2002-June/025652.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td>Reference Implementation
<a class="reference external" href="http://sourceforge.net/tracker/index.php?func=detail&amp;aid=1014055&amp;group_id=5470&amp;atid=305470">http://sourceforge.net/tracker/index.php?func=detail&amp;aid=1014055&amp;group_id=5470&amp;atid=305470</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id17">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>

