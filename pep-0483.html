<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">483</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">The Theory of Type Hints</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0483.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Guido van Rossum &lt;guido&#32;&#97;t&#32;python.org&gt;, Ivan Levkivskyi &lt;levkivskyi&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Discussions-To:</th><td class="field-body">Python-Ideas &lt;<a class="reference external" href="mailto:python-ideas&#64;python.org?subject=PEP%20483">python-ideas&#32;&#97;t&#32;python.org</a>&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Draft</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Informational</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">19-Dec-2014</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id3">Abstract</a></li>
<li><a class="reference internal" href="#introduction" id="id4">Introduction</a><ul>
<li><a class="reference internal" href="#notational-conventions" id="id5">Notational conventions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#background" id="id6">Background</a><ul>
<li><a class="reference internal" href="#subtype-relationships" id="id7">Subtype relationships</a></li>
</ul>
</li>
<li><a class="reference internal" href="#summary-of-gradual-typing" id="id8">Summary of gradual typing</a><ul>
<li><a class="reference internal" href="#types-vs-classes" id="id9">Types vs. Classes</a></li>
<li><a class="reference internal" href="#fundamental-building-blocks" id="id10">Fundamental building blocks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generic-types" id="id11">Generic types</a><ul>
<li><a class="reference internal" href="#type-variables" id="id12">Type variables</a></li>
<li><a class="reference internal" href="#defining-and-using-generic-types" id="id13">Defining and using generic types</a></li>
<li><a class="reference internal" href="#covariance-and-contravariance" id="id14">Covariance and Contravariance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pragmatics" id="id15">Pragmatics</a><ul>
<li><a class="reference internal" href="#predefined-generic-types-and-protocols-in-typing-py" id="id16">Predefined generic types and Protocols in typing.py</a></li>
</ul>
</li>
<li><a class="reference internal" href="#copyright" id="id17">Copyright</a></li>
<li><a class="reference internal" href="#references-and-footnotes" id="id18">References and Footnotes</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id3">Abstract</a></h1>
<p>This PEP lays out the theory referenced by <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a>.</p>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id4">Introduction</a></h1>
<p>This document lays out the theory of the new type hinting proposal for
Python 3.5. It's not quite a full proposal or specification because
there are many details that need to be worked out, but it lays out the
theory without which it is hard to discuss more detailed specifications.
We start by recalling basic concepts of type theory; then we explain
gradual typing; then we state some general rules and
define the new special types (such as <tt class="docutils literal">Union</tt>) that can be used
in annotations; and finally we define the approach to generic types
and pragmatic aspects of type hinting.</p>
<div class="section" id="notational-conventions">
<h2><a class="toc-backref" href="#id5">Notational conventions</a></h2>
<ul class="simple">
<li><tt class="docutils literal">t1</tt>, <tt class="docutils literal">t2</tt>, etc. and <tt class="docutils literal">u1</tt>, <tt class="docutils literal">u2</tt>, etc. are types. Sometimes we write
<tt class="docutils literal">ti</tt> or <tt class="docutils literal">tj</tt> to refer to &quot;any of <tt class="docutils literal">t1</tt>, <tt class="docutils literal">t2</tt>, etc.&quot;</li>
<li><tt class="docutils literal">T</tt>, <tt class="docutils literal">U</tt> etc. are type variables (defined with <tt class="docutils literal">TypeVar()</tt>, see below).</li>
<li>Objects, classes defined with a class statement, and instances are
denoted using standard <a class="reference external" href="/dev/peps/pep-0008">PEP 8</a> conventions.</li>
<li>the symbol <tt class="docutils literal">==</tt> applied to types in the context of this PEP means that
two expressions represent the same type.</li>
<li>Note that <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a> makes a distinction between types and classes
(a type is a concept for the type checker,
while a class is a runtime concept).  In this PEP we clarify
this distinction but avoid unnecessary strictness to allow more
flexibility in the implementation of type checkers.</li>
</ul>
</div>
</div>
<div class="section" id="background">
<h1><a class="toc-backref" href="#id6">Background</a></h1>
<p>There are many definitions of the concept of type in the literature.
Here we assume that type is a set of values and a set of functions that
one can apply to these values.</p>
<p>There are several ways to define a particular type:</p>
<ul>
<li><p class="first">By explicitly listing all values.  E.g., <tt class="docutils literal">True</tt> and <tt class="docutils literal">False</tt>
form the type <tt class="docutils literal">bool</tt>.</p>
</li>
<li><p class="first">By specifying functions which can be used with variables of
a type.  E.g. all objects that have a <tt class="docutils literal">__len__</tt> method form
the type <tt class="docutils literal">Sized</tt>.  Both <tt class="docutils literal">[1, 2, 3]</tt> and <tt class="docutils literal">'abc'</tt> belong to
this type, since one can call <tt class="docutils literal">len</tt> on them:</p>
<pre class="literal-block">
len([1, 2, 3])  # OK
len('abc')      # also OK
len(42)         # not a member of Sized
</pre>
</li>
<li><p class="first">By a simple class definition, for example if one defines a class:</p>
<pre class="literal-block">
class UserID(int):
    pass
</pre>
<p>then all instances of this class also form a type.</p>
</li>
<li><p class="first">There are also more complex types.  E.g., one can define the type
<tt class="docutils literal">FancyList</tt> as all lists containing only instances of <tt class="docutils literal">int</tt>, <tt class="docutils literal">str</tt>
or their subclasses.  The value <tt class="docutils literal">[1, 'abc', UserID(42)]</tt> has this type.</p>
</li>
</ul>
<p>It is important for the user to be able to define types in a form
that can be understood by type checkers.
The goal of this PEP is to propose such a systematic way of defining types
for type annotations of variables and functions using <a class="reference external" href="/dev/peps/pep-3107">PEP 3107</a> syntax.
These annotations can be used to avoid many kind of bugs, for documentation
purposes, or maybe even to increase speed of program execution.
Here we only focus on avoiding bugs by using a static type checker.</p>
<div class="section" id="subtype-relationships">
<h2><a class="toc-backref" href="#id7">Subtype relationships</a></h2>
<p>A crucial notion for static type checker is the subtype relationship.
It arises from the question: If <tt class="docutils literal">first_var</tt> has type <tt class="docutils literal">first_type</tt>, and
<tt class="docutils literal">second_var</tt> has type <tt class="docutils literal">second_type</tt>, is it safe to assign
<tt class="docutils literal">first_var = second_var</tt>?</p>
<p>A strong criterion for when it <em>should</em> be safe is:</p>
<ul class="simple">
<li>every value from <tt class="docutils literal">second_type</tt> is also in the set of values
of <tt class="docutils literal">first_type</tt>; and</li>
<li>every function from <tt class="docutils literal">first_type</tt> is also in the set of functions
of <tt class="docutils literal">second_type</tt>.</li>
</ul>
<p>The relation defined thus is called a subtype relation.</p>
<p>By this definition:</p>
<ul class="simple">
<li>Every type is a subtype of itself.</li>
<li>The set of values becomes smaller in the process of subtyping,
while the set of functions becomes larger.</li>
</ul>
<p>An intuitive example: Every <tt class="docutils literal">Dog</tt> is an <tt class="docutils literal">Animal</tt>, also <tt class="docutils literal">Dog</tt>
has more functions, for example it can bark, therefore <tt class="docutils literal">Dog</tt>
is a subtype of <tt class="docutils literal">Animal</tt>.  Conversely, <tt class="docutils literal">Animal</tt> is not a subtype of <tt class="docutils literal">Dog</tt>.</p>
<p>A more formal example: Integers are subtype of real numbers.
Indeed, every integer is of course also a real number, and integers
support more operations, such as, e.g., bitwise shifts <tt class="docutils literal">&lt;&lt;</tt> and <tt class="docutils literal">&gt;&gt;</tt>:</p>
<pre class="literal-block">
lucky_number = 3.14    # type: float
lucky_number = 42      # Safe
lucky_number * 2       # This works
lucky_number &lt;&lt; 5      # Fails

unlucky_number = 13    # type: int
unlucky_number &lt;&lt; 5    # This works
unlucky_number = 2.72  # Unsafe
</pre>
<p>Let us also consider a tricky example: If <tt class="docutils literal">List[int]</tt> denotes the type
formed by all lists containing only integer numbers,
then it is <em>not</em> a subtype of <tt class="docutils literal">List[float]</tt>, formed by all lists that contain
only real numbers. The first condition of subtyping holds,
but appending a real number only works with <tt class="docutils literal">List[float]</tt> so that
the second condition fails:</p>
<pre class="literal-block">
def append_pi(lst: List[float]) -&gt; None:
    lst += [3.14]

my_list = [1, 3, 5]  # type: List[int]

append_pi(my_list)   # Naively, this should be safe...

my_list[-1] &lt;&lt; 5     # ... but this fails
</pre>
<p>There are two widespread approaches to <em>declare</em> subtype information
to type checker.</p>
<p>In nominal subtyping, the type tree is based on the class tree,
i.e., <tt class="docutils literal">UserID</tt> is considered a subtype of <tt class="docutils literal">int</tt>.
This approach should be used under control of the type checker,
because in Python one can override attributes in an incompatible way:</p>
<pre class="literal-block">
class Base:
    answer = '42' # type: str

class Derived(Base):
    answer = 5 # should be marked as error by type checker
</pre>
<p>In structural subtyping the subtype relation is deduced from the
declared methods, i.e., <tt class="docutils literal">UserID</tt> and <tt class="docutils literal">int</tt> would be considered the same type.
While this may occasionally cause confusion,
structural subtyping is considered more flexible.
We strive to provide support for both approaches, so that
structural information can be used in addition to nominal subtyping.</p>
</div>
</div>
<div class="section" id="summary-of-gradual-typing">
<h1><a class="toc-backref" href="#id8">Summary of gradual typing</a></h1>
<p>Gradual typing allows one to annotate only part of a program,
thus leverage desirable aspects of both dynamic and static typing.</p>
<p>We define a new relationship, is-consistent-with, which is similar to
is-subtype-of, except it is not transitive when the new type <tt class="docutils literal">Any</tt> is
involved. (Neither relationship is symmetric.) Assigning <tt class="docutils literal">a_value</tt>
to <tt class="docutils literal">a_variable</tt> is OK if the type of <tt class="docutils literal">a_value</tt> is consistent with
the type of <tt class="docutils literal">a_variable</tt>. (Compare this to &quot;... if the type of <tt class="docutils literal">a_value</tt>
is a subtype of the type of <tt class="docutils literal">a_variable</tt>&quot;, which states one of the
fundamentals of OO programming.) The is-consistent-with relationship is
defined by three rules:</p>
<ul class="simple">
<li>A type <tt class="docutils literal">t1</tt> is consistent with a type <tt class="docutils literal">t2</tt> if <tt class="docutils literal">t1</tt> is a
subtype of <tt class="docutils literal">t2</tt>. (But not the other way around.)</li>
<li><tt class="docutils literal">Any</tt> is consistent with every type. (But <tt class="docutils literal">Any</tt> is not a subtype
of every type.)</li>
<li>Every type is consistent with <tt class="docutils literal">Any</tt>. (But every type is not a subtype
of <tt class="docutils literal">Any</tt>.)</li>
</ul>
<p>That's all! See Jeremy Siek's blog post <a class="reference external" href="http://wphomes.soic.indiana.edu/jsiek/what-is-gradual-typing/">What is Gradual
Typing</a>
for a longer explanation and motivation. <tt class="docutils literal">Any</tt> can be considered a type
that has all values and all methods. Combined with the definition of
subtyping above, this places <tt class="docutils literal">Any</tt> partially at the top (it has all values)
and bottom (it has all methods) of the type hierarchy. Contrast this to
<tt class="docutils literal">object</tt> -- it is not consistent with
most types (e.g. you can't use an <tt class="docutils literal">object()</tt> instance where an
<tt class="docutils literal">int</tt> is expected). IOW both <tt class="docutils literal">Any</tt> and <tt class="docutils literal">object</tt> mean
&quot;any type is allowed&quot; when used to annotate an argument, but only <tt class="docutils literal">Any</tt>
can be passed no matter what type is expected (in essence, <tt class="docutils literal">Any</tt>
declares a fallback to dynamic typing and shuts up complaints
from the static checker).</p>
<p>Here's an example showing how these rules work out in practice:</p>
<p>Say we have an <tt class="docutils literal">Employee</tt> class, and a subclass <tt class="docutils literal">Manager</tt>:</p>
<pre class="literal-block">
class Employee: ...
class Manager(Employee): ...
</pre>
<p>Let's say variable <tt class="docutils literal">worker</tt> is declared with type <tt class="docutils literal">Employee</tt>:</p>
<pre class="literal-block">
worker = Employee()  # type: Employee
</pre>
<p>Now it's okay to assign a <tt class="docutils literal">Manager</tt> instance to <tt class="docutils literal">worker</tt> (rule 1):</p>
<pre class="literal-block">
worker = Manager()
</pre>
<p>It's not okay to assign an <tt class="docutils literal">Employee</tt> instance to a variable declared with
type <tt class="docutils literal">Manager</tt>:</p>
<pre class="literal-block">
boss = Manager()  # type: Manager
boss = Employee()  # Fails static check
</pre>
<p>However, suppose we have a variable whose type is <tt class="docutils literal">Any</tt>:</p>
<pre class="literal-block">
something = some_func()  # type: Any
</pre>
<p>Now it's okay to assign <tt class="docutils literal">something</tt> to <tt class="docutils literal">worker</tt> (rule 2):</p>
<pre class="literal-block">
worker = something  # OK
</pre>
<p>Of course it's also okay to assign <tt class="docutils literal">worker</tt> to <tt class="docutils literal">something</tt> (rule 3),
but we didn't need the concept of consistency for that:</p>
<pre class="literal-block">
something = worker  # OK
</pre>
<div class="section" id="types-vs-classes">
<h2><a class="toc-backref" href="#id9">Types vs. Classes</a></h2>
<p>In Python, classes are object factories defined by the <tt class="docutils literal">class</tt> statement,
and returned by the <tt class="docutils literal">type(obj)</tt> built-in function. Class is a dynamic,
runtime concept.</p>
<p>Type concept is described above, types appear in variable
and function type annotations, can be constructed
from building blocks described below, and are used by static type checkers.</p>
<p>Every class is a type as discussed above.
But it is tricky and error prone to implement a class that exactly represents
semantics of a given type, and it is not a goal of <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a>.
<em>The static types described in PEP 484, should not be confused with
the runtime classes.</em> Examples:</p>
<ul>
<li><p class="first"><tt class="docutils literal">int</tt> is a class and a type.</p>
</li>
<li><p class="first"><tt class="docutils literal">UserID</tt> is a class and a type.</p>
</li>
<li><p class="first"><tt class="docutils literal">Union[str, int]</tt> is a type but not a proper class:</p>
<pre class="literal-block">
class MyUnion(Union[str, int]): ...  # raises TypeError

Union[str, int]()  # raises TypeError
</pre>
</li>
</ul>
<p>Typing interface is implemented with classes, i.e., at runtime it is possible
to evaluate, e.g., <tt class="docutils literal"><span class="pre">Generic[T].__bases__</span></tt>. But to emphasize the distinction
between classes and types the following general rules apply:</p>
<ul class="simple">
<li>No types defined below (i.e. <tt class="docutils literal">Any</tt>, <tt class="docutils literal">Union</tt>, etc.) can be instantiated,
an attempt to do so will raise <tt class="docutils literal">TypeError</tt>.
(But non-abstract subclasses of <tt class="docutils literal">Generic</tt> can be.)</li>
<li>No types defined below can be subclassed, except for <tt class="docutils literal">Generic</tt> and
classes derived from it.</li>
<li>All of these will raise <tt class="docutils literal">TypeError</tt> if they appear
in <tt class="docutils literal">isinstance</tt> or <tt class="docutils literal">issubclass</tt> (except for unparametrized generics).</li>
</ul>
</div>
<div class="section" id="fundamental-building-blocks">
<h2><a class="toc-backref" href="#id10">Fundamental building blocks</a></h2>
<ul class="simple">
<li><strong>Any</strong>. Every type is consistent with <tt class="docutils literal">Any</tt>; and
it is also consistent with every type (see above).</li>
<li><strong>Union[t1, t2, ...]</strong>. Types that are subtype of at least one of
<tt class="docutils literal">t1</tt> etc. are subtypes of this.<ul>
<li>Unions whose components are all subtypes of <tt class="docutils literal">t1</tt> etc. are subtypes
of this.
Example: <tt class="docutils literal">Union[int, str]</tt> is a subtype of <tt class="docutils literal">Union[int, float, str]</tt>.</li>
<li>The order of the arguments doesn't matter.
Example: <tt class="docutils literal">Union[int, str] == Union[str, int]</tt>.</li>
<li>If <tt class="docutils literal">ti</tt> is itself a <tt class="docutils literal">Union</tt> the result is flattened.
Example: <tt class="docutils literal">Union[int, Union[float, str]] == Union[int, float, str]</tt>.</li>
<li>If <tt class="docutils literal">ti</tt> and <tt class="docutils literal">tj</tt> have a subtype relationship,
the less specific type survives.
Example: <tt class="docutils literal">Union[Employee, Manager] == Union[Employee]</tt>.</li>
<li><tt class="docutils literal">Union[t1]</tt> returns just <tt class="docutils literal">t1</tt>. <tt class="docutils literal">Union[]</tt> is illegal,
so is <tt class="docutils literal"><span class="pre">Union[()]</span></tt></li>
<li>Corollary: <tt class="docutils literal"><span class="pre">Union[...,</span> object, <span class="pre">...]</span></tt> returns <tt class="docutils literal">object</tt>.</li>
</ul>
</li>
<li><strong>Optional[t1]</strong>. Alias for <tt class="docutils literal">Union[t1, None]</tt>, i.e. <tt class="docutils literal">Union[t1,
type(None)]</tt>.</li>
<li><strong>Tuple[t1, t2, ..., tn]</strong>. A tuple whose items are instances of <tt class="docutils literal">t1</tt>,
etc. Example: <tt class="docutils literal">Tuple[int, float]</tt> means a tuple of two items, the
first is an <tt class="docutils literal">int</tt>, the second is a <tt class="docutils literal">float</tt>; e.g., <tt class="docutils literal">(42, 3.14)</tt>.<ul>
<li><tt class="docutils literal">Tuple[u1, u2, <span class="pre">...,</span> um]</tt> is a subtype of <tt class="docutils literal">Tuple[t1, t2, <span class="pre">...,</span> tn]</tt>
if they have the same length <tt class="docutils literal"><span class="pre">n==m</span></tt> and each <tt class="docutils literal">ui</tt>
is a subtype of <tt class="docutils literal">ti</tt>.</li>
<li>To spell the type of the empty tuple, use <tt class="docutils literal"><span class="pre">Tuple[()]</span></tt>.</li>
<li>A variadic homogeneous tuple type can be written <tt class="docutils literal">Tuple[t1, <span class="pre">...]</span></tt>.
(That's three dots, a literal ellipsis;
and yes, that's a valid token in Python's syntax.)</li>
</ul>
</li>
<li><strong>Callable[[t1, t2, ..., tn], tr]</strong>. A function with positional
argument types <tt class="docutils literal">t1</tt> etc., and return type <tt class="docutils literal">tr</tt>. The argument list may be
empty <tt class="docutils literal"><span class="pre">n==0</span></tt>. There is no way to indicate optional or keyword
arguments, nor varargs, but you can say the argument list is entirely
unchecked by writing <tt class="docutils literal"><span class="pre">Callable[...,</span> tr]</tt> (again, a literal ellipsis).</li>
</ul>
<p>We might add:</p>
<ul class="simple">
<li><strong>Intersection[t1, t2, ...]</strong>. Types that are subtype of <em>each</em> of
<tt class="docutils literal">t1</tt>, etc are subtypes of this. (Compare to <tt class="docutils literal">Union</tt>, which has <em>at
least one</em> instead of <em>each</em> in its definition.)<ul>
<li>The order of the arguments doesn't matter. Nested intersections
are flattened, e.g. <tt class="docutils literal">Intersection[int, Intersection[float, str]]
== Intersection[int, float, str]</tt>.</li>
<li>An intersection of fewer types is a supertype of an intersection of
more types, e.g. <tt class="docutils literal">Intersection[int, str]</tt> is a supertype
of <tt class="docutils literal">Intersection[int, float, str]</tt>.</li>
<li>An intersection of one argument is just that argument,
e.g. <tt class="docutils literal">Intersection[int]</tt> is <tt class="docutils literal">int</tt>.</li>
<li>When argument have a subtype relationship, the more specific type
survives, e.g. <tt class="docutils literal">Intersection[str, Employee, Manager]</tt> is
<tt class="docutils literal">Intersection[str, Manager]</tt>.</li>
<li><tt class="docutils literal">Intersection[]</tt> is illegal, so is <tt class="docutils literal"><span class="pre">Intersection[()]</span></tt>.</li>
<li>Corollary: <tt class="docutils literal">Any</tt> disappears from the argument list, e.g.
<tt class="docutils literal">Intersection[int, str, Any] == Intersection[int, str]</tt>.
<tt class="docutils literal">Intersection[Any, object]</tt> is <tt class="docutils literal">object</tt>.</li>
<li>The interaction between <tt class="docutils literal">Intersection</tt> and <tt class="docutils literal">Union</tt> is complex but
should be no surprise if you understand the interaction between
intersections and unions of regular sets (note that sets of types can be
infinite in size, since there is no limit on the number
of new subclasses).</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="generic-types">
<h1><a class="toc-backref" href="#id11">Generic types</a></h1>
<p>The fundamental building blocks defined above allow to construct new types
in a generic manner. For example, <tt class="docutils literal">Tuple</tt> can take a concrete type <tt class="docutils literal">float</tt>
and make a concrete type <tt class="docutils literal">Vector = Tuple[float, <span class="pre">...]</span></tt>, or it can take
another type <tt class="docutils literal">UserID</tt> and make another concrete type
<tt class="docutils literal">Registry = Tuple[UserID, <span class="pre">...]</span></tt>. Such semantics is known as generic type
constructor, it is similar to semantics of functions, but a function takes
a value and returns a value, while generic type constructor takes a type and
&quot;returns&quot; a type.</p>
<p>It is common when a particular class or a function behaves in such a type
generic manner. Consider two examples:</p>
<ul>
<li><p class="first">Container classes, such as <tt class="docutils literal">list</tt> or <tt class="docutils literal">dict</tt>, typically contain only
values of a particular type. Therefore, a user might want to type annotate
them as such:</p>
<pre class="literal-block">
users = [] # type: List[UserID]
users.append(UserID(42)) # OK
users.append('Some guy') # Should be rejected by the type checker

examples = {} # type: Dict[str, Any]
examples['first example'] = object() # OK
examples[2] = None                   # rejected by the type checker
</pre>
</li>
<li><p class="first">The following function can take two arguments of type <tt class="docutils literal">int</tt> and return
an <tt class="docutils literal">int</tt>, of take two arguments of type <tt class="docutils literal">float</tt> and return
a <tt class="docutils literal">float</tt>, etc.:</p>
<pre class="literal-block">
def add(x, y):
    return x + y

add(1, 2) == 3
add('1', '2') == '12'
add(2.7, 3.5) == 6.2
</pre>
</li>
</ul>
<p>To allow type annotations in situations from the first example, built-in
containers and container abstract base classes are extended with type
parameters, so that they behave as generic type constructors.
Classes, that behave as generic type constructors are called <em>generic types</em>.
Example:</p>
<pre class="literal-block">
from typing import Iterable

class Task:
    ...

def work(todo_list: Iterable[Task]) -&gt; None:
    ...
</pre>
<p>Here <tt class="docutils literal">Iterable</tt> is a generic type that takes a concrete type <tt class="docutils literal">Task</tt>
and returns a concrete type <tt class="docutils literal">Iterable[Task]</tt>.</p>
<p>Functions that behave in the type generic manner (as in second example)
are called <em>generic functions</em>.
Type annotations of generic functions are allowed by <em>type variables</em>.
Their semantics with respect to generic types is somewhat similar
to semantics of parameters in functions. But one does not assign
concrete types to type variables, it is the task of a static type checker
to find their possible values and warn the user if it cannot find.
Example:</p>
<pre class="literal-block">
def take_first(seq: Sequence[T]) -&gt; T: # a generic function
    return seq[0]

accumulator = 0 # type: int

accumulator += take_first([1, 2, 3])   # Safe, T deduced to be int
accumulator += take_first((2.7, 3.5))  # Unsafe
</pre>
<p>Type variables are used extensively in type annotations, also internal
machinery of the type inference in type checkers is typically build on
type variables. Therefore, let us consider them in detail.</p>
<div class="section" id="type-variables">
<h2><a class="toc-backref" href="#id12">Type variables</a></h2>
<p><tt class="docutils literal">X = <span class="pre">TypeVar('X')</span></tt> declares a unique type variable. The name must match
the variable name. By default, a type variable ranges
over all possible types. Example:</p>
<pre class="literal-block">
def do_nothing(one_arg: T, other_arg: T) -&gt; None:
    pass

do_nothing(1, 2)               # OK, T is int
do_nothing('abc', UserID(42))  # also OK, T is object
</pre>
<p><tt class="docutils literal">Y = <span class="pre">TypeVar('Y',</span> t1, t2, <span class="pre">...)</span></tt>. Ditto, constrained to <tt class="docutils literal">t1</tt>, etc. Behaves
similar to <tt class="docutils literal">Union[t1, t2, <span class="pre">...]</span></tt>. A constrained type variable ranges only
over constrains <tt class="docutils literal">t1</tt>, etc. <em>exactly</em>; subclasses of the constrains are
replaced by the most-derived base class among <tt class="docutils literal">t1</tt>, etc. Examples:</p>
<ul>
<li><p class="first">Function type annotation with a constrained type variable:</p>
<pre class="literal-block">
S = TypeVar('S', str, bytes)

def longest(first: S, second: S) -&gt; S:
    return first if len(first) &gt;= len(second) else second

result = longest('a', 'abc')  # The inferred type for result is str

result = longest('a', b'abc')  # Fails static type check
</pre>
<p>In this example, both arguments to <tt class="docutils literal">longest()</tt> must have the same type
(<tt class="docutils literal">str</tt> or <tt class="docutils literal">bytes</tt>), and moreover, even if the arguments are instances
of a common <tt class="docutils literal">str</tt> subclass, the return type is still <tt class="docutils literal">str</tt>, not that
subclass (see next example).</p>
</li>
<li><p class="first">For comparison, if the type variable was unconstrained, the common
subclass would be chosen as the return type, e.g.:</p>
<pre class="literal-block">
S = TypeVar('S')

def longest(first: S, second: S) -&gt; S:
    return first if len(first) &gt;= len(second) else second

class MyStr(str): ...

result = longest(MyStr('a'), MyStr('abc'))
</pre>
<p>The inferred type of <tt class="docutils literal">result</tt> is <tt class="docutils literal">MyStr</tt> (whereas in the <tt class="docutils literal">AnyStr</tt> example
it would be <tt class="docutils literal">str</tt>).</p>
</li>
<li><p class="first">Also for comparison, if a <tt class="docutils literal">Union</tt> is used, the return type also has to be
a <tt class="docutils literal">Union</tt>:</p>
<pre class="literal-block">
U = Union[str, bytes]

def longest(first: U, second: U) -&gt; U:
    return first if len(first) &gt;= len(second) else second

result = longest('a', 'abc')
</pre>
<p>The inferred type of <tt class="docutils literal">result</tt> is still <tt class="docutils literal">Union[str, bytes]</tt>, even though
both arguments are <tt class="docutils literal">str</tt>.</p>
<p>Note that the type checker will reject this function:</p>
<pre class="literal-block">
def concat(first: U, second: U) -&gt; U:
    return x + y  # Error: can't concatenate str and bytes
</pre>
<p>For such cases where parameters could change their types only simultaneously
one should use constrained type variables.</p>
</li>
</ul>
</div>
<div class="section" id="defining-and-using-generic-types">
<h2><a class="toc-backref" href="#id13">Defining and using generic types</a></h2>
<p>Users can declare their classes as generic types using
the special building block <tt class="docutils literal">Generic</tt>. The definition
<tt class="docutils literal">class MyGeneric(Generic[X, Y, <span class="pre">...]):</span> ...</tt> defines a generic type
<tt class="docutils literal">MyGeneric</tt> over type variables <tt class="docutils literal">X</tt>, etc. <tt class="docutils literal">MyGeneric</tt> itself becomes
parameterizable, e.g. <tt class="docutils literal">MyGeneric[int, str, <span class="pre">...]</span></tt> is a specific type with
substitutions <tt class="docutils literal">X <span class="pre">-&gt;</span> int</tt>, etc. Example:</p>
<pre class="literal-block">
class CustomQueue(Generic[T]):

    def put(self, task: T) -&gt; None:
        ...
    def get(self) -&gt; T:
        ...

def communicate(queue: CustomQueue[str]) -&gt; Optional[str]:
    ...
</pre>
<p>Classes that derive from generic types become generic.
A class can subclass multiple generic types. However,
classes derived from specific types returned by generics are
not generic. Examples:</p>
<pre class="literal-block">
class TodoList(Iterable[T], Container[T]):
    def check(self, item: T) -&gt; None:
        ...

def check_all(todo: TodoList[T]) -&gt; None:  # TodoList is generic
    ...

class URLList(Iterable[bytes]):
    def scrape_all(self) -&gt; None:
        ...

def search(urls: URLList) -&gt; Optional[bytes]  # URLList is not generic
    ...
</pre>
<p>Subclassing a generic type imposes the subtype relation on the corresponding
specific types, so that <tt class="docutils literal">TodoList[t1]</tt> is a subtype of <tt class="docutils literal">Iterable[t1]</tt>
in the above example.</p>
<p>Generic types can be specialized (indexed) in several steps.
Every type variable could be substituted by a specific type
or by another generic type. If <tt class="docutils literal">Generic</tt> appears in the base class list,
then it should contain all type variables, and the order of type parameters is
determined by the order in which they appear in <tt class="docutils literal">Generic</tt>. Examples:</p>
<pre class="literal-block">
Table = Dict[int, T]     # Table is generic
Messages = Table[bytes]  # Same as Dict[int, bytes]

class BaseGeneric(Generic[T, S]):
    ...

class DerivedGeneric(BaseGeneric[int, T]): # DerivedGeneric has one parameter
    ...

SpecificType = DerivedGeneric[int]         # OK

class MyDictView(Generic[S, T, U], Iterable[Tuple[U, T]]):
    ...

Example = MyDictView[list, int, str]       # S -&gt; list, T -&gt; int, U -&gt; str
</pre>
<p>If a generic type appears in a type annotation with a type variable omitted,
it is assumed to be <tt class="docutils literal">Any</tt>. Such form could be used as a fallback
to dynamic typing and is allowed for use with <tt class="docutils literal">issubclass</tt>
and <tt class="docutils literal">isinstance</tt>. All type information in instances is erased at runtime.
Examples:</p>
<pre class="literal-block">
def count(seq: Sequence) -&gt; int:      # Same as Sequence[Any]
    ...

class FrameworkBase(Generic[S, T]):
    ...

class UserClass:
    ...

issubclass(UserClass, FrameworkBase)  # This is OK

class Node(Generic[T]):
   ...

IntNode = Node[int]
my_node = IntNode()  # at runtime my_node.__class__ is Node
                     # inferred static type of my_node is Node[int]
</pre>
</div>
<div class="section" id="covariance-and-contravariance">
<h2><a class="toc-backref" href="#id14">Covariance and Contravariance</a></h2>
<p>If <tt class="docutils literal">t2</tt> is a subtype of <tt class="docutils literal">t1</tt>, then a generic
type constructor <tt class="docutils literal">GenType</tt> is called:</p>
<ul class="simple">
<li>Covariant, if <tt class="docutils literal">GenType[t2]</tt> is a subtype of <tt class="docutils literal">GenType[t1]</tt>
for all such <tt class="docutils literal">t1</tt> and <tt class="docutils literal">t2</tt>.</li>
<li>Contravariant,  if <tt class="docutils literal">GenType[t1]</tt> is a subtype of <tt class="docutils literal">GenType[t2]</tt>
for all such <tt class="docutils literal">t1</tt> and <tt class="docutils literal">t2</tt>.</li>
<li>Invariant, if neither of the above is true.</li>
</ul>
<p>To better understand this definition, let us make an analogy with
ordinary functions. Assume that we have:</p>
<pre class="literal-block">
def cov(x: float) -&gt; float:
    return 2*x

def contra(x: float) -&gt; float:
    return -x

def inv(x: float) -&gt; float:
    return x*x
</pre>
<p>If <tt class="docutils literal">x1 &lt; x2</tt>, then <em>always</em> <tt class="docutils literal">cov(x1) &lt; cov(x2)</tt>, and
<tt class="docutils literal">contra(x2) &lt; contra(x1)</tt>, while nothing could be said about <tt class="docutils literal">inv</tt>.
Replacing <tt class="docutils literal">&lt;</tt> with is-subtype-of, and functions with generic type
constructor we get examples of covariant, contravariant,
and invariant behavior. Let us now consider practical examples:</p>
<ul class="simple">
<li><tt class="docutils literal">Union</tt> behaves covariantly in all its arguments.
Indeed, as discussed above, <tt class="docutils literal">Union[t1, t2, <span class="pre">...]</span></tt> is a subtype of
<tt class="docutils literal">Union[u1, u2, <span class="pre">...]</span></tt>, if <tt class="docutils literal">t1</tt> is a subtype of <tt class="docutils literal">u1</tt>, etc.</li>
<li><tt class="docutils literal">FrozenSet[T]</tt> is also covariant. Let us consider <tt class="docutils literal">int</tt> and
<tt class="docutils literal">float</tt> in place of <tt class="docutils literal">T</tt>. First, <tt class="docutils literal">int</tt> is a subtype of <tt class="docutils literal">float</tt>.
Second, set of values of <tt class="docutils literal">FrozenSet[int]</tt> is
clearly a subset of values of <tt class="docutils literal">FrozenSet[float]</tt>, while set of functions
from <tt class="docutils literal">FrozenSet[float]</tt> is a subset of set of functions
from <tt class="docutils literal">FrozenSet[int]</tt>. Therefore, by definition <tt class="docutils literal">FrozenSet[int]</tt>
is a subtype of <tt class="docutils literal">FrozenSet[float]</tt>.</li>
<li><tt class="docutils literal">List[T]</tt> is invariant. Indeed, although set of values of <tt class="docutils literal">List[int]</tt>
is a subset of values of <tt class="docutils literal">List[float]</tt>, only <tt class="docutils literal">int</tt> could be appended
to a <tt class="docutils literal">List[int]</tt>, as discussed in section &quot;Background&quot;. Therefore,
<tt class="docutils literal">List[int]</tt> is not a subtype of <tt class="docutils literal">List[float]</tt>. This is a typical
situation with mutable types, they are typically invariant.</li>
</ul>
<p>One of the best examples to illustrate (somewhat counterintuitive)
contravariant behavior is the callable type.
It is covariant in the return type, but contravariant in the
arguments. For two callable types that
differ only in the return type, the subtype relationship for the
callable types follows that of the return types. Examples:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">Callable[[],</span> int]</tt> is a subtype of <tt class="docutils literal"><span class="pre">Callable[[],</span> float]</tt>.</li>
<li><tt class="docutils literal"><span class="pre">Callable[[],</span> Manager]</tt> is a subtype of <tt class="docutils literal"><span class="pre">Callable[[],</span> Employee]</tt>.</li>
</ul>
<p>While for two callable types that differ
only in the type of one argument, the subtype relationship for the
callable types goes <em>in the opposite direction</em> as for the argument
types. Examples:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">Callable[[float],</span> None]</tt> is a subtype of <tt class="docutils literal"><span class="pre">Callable[[int],</span> None]</tt>.</li>
<li><tt class="docutils literal"><span class="pre">Callable[[Employee],</span> None]</tt> is a subtype of <tt class="docutils literal"><span class="pre">Callable[[Manager],</span> None]</tt>.</li>
</ul>
<p>Yes, you read that right. Indeed, if
a function that can calculate the salary for a manager is expected:</p>
<pre class="literal-block">
def calculate_all(lst: List[Manager], salary: Callable[[Manager], Decimal]):
    ...
</pre>
<p>then <tt class="docutils literal"><span class="pre">Callable[[Employee],</span> Decimal]</tt> that can calculate a salary for any
employee is also acceptable.</p>
<p>The example with <tt class="docutils literal">Callable</tt> shows how to make more precise type annotations
for functions: choose the most general type for every argument,
and the most specific type for the return value.</p>
<p>It is possible to <em>declare</em> the variance for user defined generic types by
using special keywords <tt class="docutils literal">covariant</tt> and <tt class="docutils literal">contravariant</tt> in the
definition of type variables used as parameters.
Types are invariant by default. Examples:</p>
<pre class="literal-block">
T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)

class LinkedList(Generic[T]):  # invariant by default
    ...
    def append(self, element: T) -&gt; None:
        ...

class Box(Generic[T_co]):      #  this type is declared covariant
    def __init__(self, content: T_co) -&gt; None:
        self._content = content
    def get_content(self) -&gt; T_co:
        return self._content

class Sink(Generic[T_contra]): # this type is declared contravariant
    def send_to_nowhere(self, data: T_contra) -&gt; None:
        with open(os.devnull, 'w') as devnull:
            print(data, file=devnull)
</pre>
<p>Note, that although the variance is defined via type variables, it is not
a property of type variables, but a property of generic types.
In complex definitions of derived generics, variance <em>only</em>
determined from type variables used. A complex example:</p>
<pre class="literal-block">
T_co = TypeVar('T_co', Employee, Manager, covariant=True)
T_contra = TypeVar('T_contra', Employee, Manager, contravariant=True)

class Base(Generic[T_contra]):
    ...

class Derived(Base[T_co]):
    ...
</pre>
<p>A type checker finds from the second declaration that <tt class="docutils literal">Derived[Manager]</tt>
is a subtype of <tt class="docutils literal">Derived[Employee]</tt>, and <tt class="docutils literal">Derived[t1]</tt>
is a subtype of <tt class="docutils literal">Base[t1]</tt>.
If we denote the is-subtype-of relationship with <tt class="docutils literal">&lt;</tt>, then the
full diagram of subtyping for this case will be:</p>
<pre class="literal-block">
Base[Manager]    &gt;  Base[Employee]
    v                   v
Derived[Manager] &lt;  Derived[Employee]
</pre>
<p>so that a type checker will also find that, e.g., <tt class="docutils literal">Derived[Manager]</tt> is
a subtype of <tt class="docutils literal">Base[Employee]</tt>.</p>
<p>For more information on type variables, generic types, and variance,
see <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a>, the <a class="reference external" href="http://mypy.readthedocs.io/en/latest/generics.html">mypy docs on
generics</a>,
and <a class="reference external" href="http://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29">Wikipedia</a>.</p>
</div>
</div>
<div class="section" id="pragmatics">
<h1><a class="toc-backref" href="#id15">Pragmatics</a></h1>
<p>Some things are irrelevant to the theory but make practical use more
convenient. (This is not a full list; I probably missed a few and some
are still controversial or not fully specified.)</p>
<ul>
<li><p class="first">Where a type is expected, <tt class="docutils literal">None</tt> can be substituted for <tt class="docutils literal">type(None)</tt>;
e.g. <tt class="docutils literal">Union[t1, None] == Union[t1, type(None)]</tt>.</p>
</li>
<li><p class="first">Type aliases, e.g.:</p>
<pre class="literal-block">
Point = Tuple[float, float]
def distance(point: Point) -&gt; float: ...
</pre>
</li>
<li><p class="first">Forward references via strings, e.g.:</p>
<pre class="literal-block">
class MyComparable:
    def compare(self, other: 'MyComparable') -&gt; int: ...
</pre>
</li>
<li><p class="first">If a default of <tt class="docutils literal">None</tt> is specified, the type is implicitly
<tt class="docutils literal">Optional</tt>, e.g.:</p>
<pre class="literal-block">
def get(key: KT, default: VT = None) -&gt; VT: ...
</pre>
</li>
<li><p class="first">Type variables can be declared in unconstrained, constrained,
or bounded form. The variance of a generic type can also
be indicated using a type variable declared with special keyword
arguments, thus avoiding any special syntax, e.g.:</p>
<pre class="literal-block">
T = TypeVar('T', bound=complex)

def add(x: T, y: T) -&gt; T:
    return x + y

T_co = TypeVar('T_co', covariant=True)

class ImmutableList(Generic[T_co]): ...
</pre>
</li>
<li><p class="first">Type declaration in comments, e.g.:</p>
<pre class="literal-block">
lst = []  # type: Sequence[int]
</pre>
</li>
<li><p class="first">Casts using <tt class="docutils literal">cast(T, obj)</tt>, e.g.:</p>
<pre class="literal-block">
zork = cast(Any, frobozz())
</pre>
</li>
<li><p class="first">Other things, e.g. overloading and stub modules, see <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a>.</p>
</li>
</ul>
<div class="section" id="predefined-generic-types-and-protocols-in-typing-py">
<h2><a class="toc-backref" href="#id16">Predefined generic types and Protocols in typing.py</a></h2>
<p>(See also the <a class="reference external" href="https://github.com/python/typing/blob/master/src/typing.py">typing.py module</a>.)</p>
<ul class="simple">
<li>Everything from <tt class="docutils literal">collections.abc</tt> (but <tt class="docutils literal">Set</tt> renamed to <tt class="docutils literal">AbstractSet</tt>).</li>
<li><tt class="docutils literal">Dict</tt>, <tt class="docutils literal">List</tt>, <tt class="docutils literal">Set</tt>, <tt class="docutils literal">FrozenSet</tt>, a few more.</li>
<li><tt class="docutils literal">re.Pattern[AnyStr]</tt>, <tt class="docutils literal">re.Match[AnyStr]</tt>.</li>
<li><tt class="docutils literal">io.IO[AnyStr]</tt>, <tt class="docutils literal">io.TextIO ~ io.IO[str]</tt>, <tt class="docutils literal">io.BinaryIO ~ io.IO[bytes]</tt>.</li>
</ul>
</div>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id17">Copyright</a></h1>
<p>This document is licensed under the <a class="reference external" href="http://www.opencontent.org/openpub/">Open Publication License</a> <a class="footnote-reference" href="#id1" id="id2">[1]</a>.</p>
</div>
<div class="section" id="references-and-footnotes">
<h1><a class="toc-backref" href="#id18">References and Footnotes</a></h1>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
<table class="docutils footnote" frame="void" id="id1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td><a class="reference external" href="http://www.opencontent.org/openpub/">http://www.opencontent.org/openpub/</a></td></tr>
</tbody>
</table>
</div>

