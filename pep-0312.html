<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">312</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Simple Implicit Lambda</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0312.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Roman Suzi &lt;rnd&#32;&#97;t&#32;onego.ru&gt;, Alex Martelli &lt;aleaxit&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Deferred</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">11-Feb-2003</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.4</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id5">Abstract</a></li>
<li><a class="reference internal" href="#deferral" id="id6">Deferral</a></li>
<li><a class="reference internal" href="#motivation" id="id7">Motivation</a></li>
<li><a class="reference internal" href="#rationale" id="id8">Rationale</a></li>
<li><a class="reference internal" href="#syntax" id="id9">Syntax</a></li>
<li><a class="reference internal" href="#examples-of-use" id="id10">Examples of Use</a></li>
<li><a class="reference internal" href="#implementation" id="id11">Implementation</a></li>
<li><a class="reference internal" href="#discussion" id="id12">Discussion</a></li>
<li><a class="reference internal" href="#credits" id="id13">Credits</a></li>
<li><a class="reference internal" href="#references" id="id14">References</a></li>
<li><a class="reference internal" href="#copyright" id="id15">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id5">Abstract</a></h1>
<p>This PEP proposes to make argumentless lambda keyword optional in
some cases where it is not grammatically ambiguous.</p>
</div>
<div class="section" id="deferral">
<h1><a class="toc-backref" href="#id6">Deferral</a></h1>
<p>The BDFL hates the unary colon syntax.  This PEP needs to go back
to the drawing board and find a more Pythonic syntax (perhaps an
alternative unary operator).  See python-dev discussion on
17 June 2005 <a class="footnote-reference" href="#id3" id="id1">[1]</a>.</p>
<p>Also, it is probably a good idea to eliminate the alternative
propositions which have no chance at all.  The examples section
is good and highlights the readability improvements.  It would
carry more weight with additional examples and with real-world
referents (instead of the abstracted dummy calls to <tt class="docutils literal">:A</tt> and <tt class="docutils literal">:B</tt>).</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id7">Motivation</a></h1>
<p>Lambdas are useful for defining anonymous functions, e.g. for use
as callbacks or (pseudo)-lazy evaluation schemes.  Often, lambdas
are not used when they would be appropriate, just because the
keyword &quot;lambda&quot; makes code look complex.  Omitting lambda in some
special cases is possible, with small and backwards compatible
changes to the grammar, and provides a cheap cure against such
&quot;lambdaphobia&quot;.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id8">Rationale</a></h1>
<p>Sometimes people do not use lambdas because they fear to introduce
a term with a theory behind it.  This proposal makes introducing
argumentless lambdas easier, by omitting the &quot;lambda&quot; keyword.
itself.  Implementation can be done simply changing grammar so it
lets the &quot;lambda&quot; keyword be implied in a few well-known cases.
In particular, adding surrounding brackets lets you specify
nullary lambda anywhere.</p>
</div>
<div class="section" id="syntax">
<h1><a class="toc-backref" href="#id9">Syntax</a></h1>
<p>An argumentless &quot;lambda&quot; keyword can be omitted in the following
cases:</p>
<ul class="simple">
<li>immediately after &quot;=&quot; in named parameter assignment or default
value assignment;</li>
<li>immediately after &quot;(&quot; in any expression;</li>
<li>immediately after a &quot;,&quot; in a function argument list;</li>
<li>immediately after a &quot;:&quot; in a dictionary literal; (not
implemented)</li>
<li>in an assignment statement; (not implemented)</li>
</ul>
</div>
<div class="section" id="examples-of-use">
<h1><a class="toc-backref" href="#id10">Examples of Use</a></h1>
<ol class="arabic">
<li><p class="first">Inline <tt class="docutils literal">if</tt>:</p>
<pre class="literal-block">
def ifelse(cond, true_part, false_part):
    if cond:
        return true_part()
    else:
        return false_part()

# old syntax:
print ifelse(a &lt; b, lambda:A, lambda:B)

# new syntax:
print ifelse(a &lt; b, :A, :B)

# parts A and B may require extensive processing, as in:
print ifelse(a &lt; b, :ext_proc1(A), :ext_proc2(B))
</pre>
</li>
<li><p class="first">Locking:</p>
<pre class="literal-block">
def with(alock, acallable):
    alock.acquire()
    try:
        acallable()
    finally:
        alock.release()

with(mylock, :x(y(), 23, z(), 'foo'))
</pre>
</li>
</ol>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id11">Implementation</a></h1>
<p>Implementation requires some tweaking of the <tt class="docutils literal">Grammar/Grammar</tt> file
in the Python sources, and some adjustment of
<tt class="docutils literal">Modules/parsermodule.c</tt> to make syntactic and pragmatic changes.</p>
<p>(Some grammar/parser guru is needed to make a full
implementation.)</p>
<p>Here are the changes needed to <tt class="docutils literal">Grammar</tt> to allow implicit lambda:</p>
<pre class="literal-block">
varargslist: (fpdef ['=' imptest] ',')* ('*' NAME [',' '**'
NAME] | '**' NAME) | fpdef ['=' imptest] (',' fpdef ['='
imptest])* [',']

imptest: test | implambdef

atom: '(' [imptestlist] ')' | '[' [listmaker] ']' |
'{' [dictmaker] '}' | '`' testlist1 '`' | NAME | NUMBER | STRING+

implambdef: ':' test

imptestlist: imptest (',' imptest)* [',']

argument: [test '='] imptest
</pre>
<p>Three new non-terminals are needed: <tt class="docutils literal">imptest</tt> for the place where
implicit lambda may occur, <tt class="docutils literal">implambdef</tt> for the implicit lambda
definition itself, <tt class="docutils literal">imptestlist</tt> for a place where <tt class="docutils literal">imptest</tt>'s may
occur.</p>
<p>This implementation is not complete. First, because some files in
Parser module need to be updated. Second, some additional places
aren't implemented, see Syntax section above.</p>
</div>
<div class="section" id="discussion">
<h1><a class="toc-backref" href="#id12">Discussion</a></h1>
<p>This feature is not a high-visibility one (the only novel part is
the absence of lambda). The feature is intended to make null-ary
lambdas more appealing syntactically, to provide lazy evaluation
of expressions in some simple cases. This proposal is not targeted
at more advanced cases (demanding arguments for the lambda).</p>
<p>There is an alternative proposition for implicit lambda: implicit
lambda with unused arguments. In this case the function defined by
such lambda can accept any parameters, i.e. be equivalent to:
<tt class="docutils literal">lambda *args: expr</tt>. This form would be more powerful.  Grep in the
standard library revealed that such lambdas are indeed in use.</p>
<p>One more extension can provide a way to have a list of parameters
passed to a function defined by implicit lambda. However, such
parameters need some special name to be accessed and are unlikely
to be included in the language. Possible local names for such
parameters are: <tt class="docutils literal">_</tt>, <tt class="docutils literal">__args__</tt>, <tt class="docutils literal">__</tt>. For example:</p>
<pre class="literal-block">
reduce(:_[0] + _[1], [1,2,3], 0)
reduce(:__[0] + __[1], [1,2,3], 0)
reduce(:__args__[0] + __args__[1], [1,2,3], 0)
</pre>
<p>These forms do not look very nice, and in the PEP author's opinion
do not justify the removal of the lambda keyword in such cases.</p>
</div>
<div class="section" id="credits">
<h1><a class="toc-backref" href="#id13">Credits</a></h1>
<p>The idea of dropping lambda was first coined by Paul Rubin at 08
Feb 2003 16:39:30 -0800 in comp.lang.python while discussing the
thread &quot;For review: <a class="reference external" href="/dev/peps/pep-0308">PEP 308</a> - If-then-else expression&quot; <a class="footnote-reference" href="#id4" id="id2">[2]</a>.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id14">References</a></h1>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Guido van Rossum, Recommend accepting <a class="reference external" href="/dev/peps/pep-0312">PEP 312</a> -- Simple Implicit Lambda
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2005-June/054304.html">https://mail.python.org/pipermail/python-dev/2005-June/054304.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Guido van Rossum, For review: <a class="reference external" href="/dev/peps/pep-0308">PEP 308</a> - If-then-else expression
<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2003-February/033178.html">https://mail.python.org/pipermail/python-dev/2003-February/033178.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id15">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>

