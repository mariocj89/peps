<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">471</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">os.scandir() function -- a better and faster directory iterator</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0471.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Ben Hoyt &lt;benhoyt&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">BDFL-Delegate:</th><td class="field-body">Victor Stinner &lt;victor.stinner&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">30-May-2014</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.5</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">27-Jun-2014, 8-Jul-2014, 14-Jul-2014</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id15">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id16">Rationale</a></li>
<li><a class="reference internal" href="#implementation" id="id17">Implementation</a></li>
<li><a class="reference internal" href="#specifics-of-proposal" id="id18">Specifics of proposal</a><ul>
<li><a class="reference internal" href="#os-scandir" id="id19">os.scandir()</a></li>
<li><a class="reference internal" href="#os-walk" id="id20">os.walk()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples" id="id21">Examples</a><ul>
<li><a class="reference internal" href="#notes-on-caching" id="id22">Notes on caching</a></li>
<li><a class="reference internal" href="#notes-on-exception-handling" id="id23">Notes on exception handling</a></li>
</ul>
</li>
<li><a class="reference internal" href="#support" id="id24">Support</a></li>
<li><a class="reference internal" href="#use-in-the-wild" id="id25">Use in the wild</a></li>
<li><a class="reference internal" href="#rejected-ideas" id="id26">Rejected ideas</a><ul>
<li><a class="reference internal" href="#naming" id="id27">Naming</a></li>
<li><a class="reference internal" href="#wildcard-support" id="id28">Wildcard support</a></li>
<li><a class="reference internal" href="#methods-not-following-symlinks-by-default" id="id29">Methods not following symlinks by default</a></li>
<li><a class="reference internal" href="#direntry-attributes-being-properties" id="id30">DirEntry attributes being properties</a></li>
<li><a class="reference internal" href="#direntry-fields-being-static-attribute-only-objects" id="id31">DirEntry fields being &quot;static&quot; attribute-only objects</a></li>
<li><a class="reference internal" href="#direntry-fields-being-static-with-an-ensure-lstat-option" id="id32">DirEntry fields being static with an ensure_lstat option</a></li>
<li><a class="reference internal" href="#return-values-being-name-stat-result-two-tuples" id="id33">Return values being (name, stat_result) two-tuples</a></li>
<li><a class="reference internal" href="#return-values-being-overloaded-stat-result-objects" id="id34">Return values being overloaded stat_result objects</a></li>
<li><a class="reference internal" href="#return-values-being-pathlib-path-objects" id="id35">Return values being pathlib.Path objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#possible-improvements" id="id36">Possible improvements</a></li>
<li><a class="reference internal" href="#previous-discussion" id="id37">Previous discussion</a></li>
<li><a class="reference internal" href="#id1" id="id38">References</a></li>
<li><a class="reference internal" href="#copyright" id="id39">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id15">Abstract</a></h1>
<p>This PEP proposes including a new directory iteration function,
<tt class="docutils literal">os.scandir()</tt>, in the standard library. This new function adds
useful functionality and increases the speed of <tt class="docutils literal">os.walk()</tt> by 2-20
times (depending on the platform and file system) by avoiding calls to
<tt class="docutils literal">os.stat()</tt> in most cases.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id16">Rationale</a></h1>
<p>Python's built-in <tt class="docutils literal">os.walk()</tt> is significantly slower than it needs
to be, because -- in addition to calling <tt class="docutils literal">os.listdir()</tt> on each
directory -- it executes the <tt class="docutils literal">stat()</tt> system call or
<tt class="docutils literal">GetFileAttributes()</tt> on each file to determine whether the entry is
a directory or not.</p>
<p>But the underlying system calls -- <tt class="docutils literal">FindFirstFile</tt> /
<tt class="docutils literal">FindNextFile</tt> on Windows and <tt class="docutils literal">readdir</tt> on POSIX systems --
already tell you whether the files returned are directories or not, so
no further system calls are needed. Further, the Windows system calls
return all the information for a <tt class="docutils literal">stat_result</tt> object on the directory
entry, such as file size and last modification time.</p>
<p>In short, you can reduce the number of system calls required for a
tree function like <tt class="docutils literal">os.walk()</tt> from approximately 2N to N, where N
is the total number of files and directories in the tree. (And because
directory trees are usually wider than they are deep, it's often much
better than this.)</p>
<p>In practice, removing all those extra system calls makes <tt class="docutils literal">os.walk()</tt>
about <strong>8-9 times as fast on Windows</strong>, and about <strong>2-3 times as fast
on POSIX systems</strong>. So we're not talking about micro-
optimizations. See more <a class="reference external" href="https://github.com/benhoyt/scandir#benchmarks">benchmarks here</a> <a class="footnote-reference" href="#id2" id="id3">[1]</a>.</p>
<p>Somewhat relatedly, many people (see Python <a class="reference external" href="http://bugs.python.org/issue11406">Issue 11406</a> <a class="footnote-reference" href="#id4" id="id5">[2]</a>) are also
keen on a version of <tt class="docutils literal">os.listdir()</tt> that yields filenames as it
iterates instead of returning them as one big list. This improves
memory efficiency for iterating very large directories.</p>
<p>So, as well as providing a <tt class="docutils literal">scandir()</tt> iterator function for calling
directly, Python's existing <tt class="docutils literal">os.walk()</tt> function can be sped up a
huge amount.</p>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id17">Implementation</a></h1>
<p>The implementation of this proposal was written by Ben Hoyt (initial
version) and Tim Golden (who helped a lot with the C extension
module). It lives on GitHub at <a class="reference external" href="https://github.com/benhoyt/scandir">benhoyt/scandir</a> <a class="footnote-reference" href="#id7" id="id8">[3]</a>. (The implementation
may lag behind the updates to this PEP a little.)</p>
<p>Note that this module has been used and tested (see &quot;Use in the wild&quot;
section in this PEP), so it's more than a proof-of-concept. However,
it is marked as beta software and is not extensively battle-tested.
It will need some cleanup and more thorough testing before going into
the standard library, as well as integration into <tt class="docutils literal">posixmodule.c</tt>.</p>
</div>
<div class="section" id="specifics-of-proposal">
<h1><a class="toc-backref" href="#id18">Specifics of proposal</a></h1>
<div class="section" id="os-scandir">
<h2><a class="toc-backref" href="#id19">os.scandir()</a></h2>
<p>Specifically, this PEP proposes adding a single function to the <tt class="docutils literal">os</tt>
module in the standard library, <tt class="docutils literal">scandir</tt>, that takes a single,
optional string as its argument:</p>
<pre class="literal-block">
scandir(path='.') -&gt; generator of DirEntry objects
</pre>
<p>Like <tt class="docutils literal">listdir</tt>, <tt class="docutils literal">scandir</tt> calls the operating system's directory
iteration system calls to get the names of the files in the given
<tt class="docutils literal">path</tt>, but it's different from <tt class="docutils literal">listdir</tt> in two ways:</p>
<ul class="simple">
<li>Instead of returning bare filename strings, it returns lightweight
<tt class="docutils literal">DirEntry</tt> objects that hold the filename string and provide
simple methods that allow access to the additional data the
operating system may have returned.</li>
<li>It returns a generator instead of a list, so that <tt class="docutils literal">scandir</tt> acts
as a true iterator instead of returning the full list immediately.</li>
</ul>
<p><tt class="docutils literal">scandir()</tt> yields a <tt class="docutils literal">DirEntry</tt> object for each file and
sub-directory in <tt class="docutils literal">path</tt>. Just like <tt class="docutils literal">listdir</tt>, the <tt class="docutils literal">'.'</tt>
and <tt class="docutils literal"><span class="pre">'..'</span></tt> pseudo-directories are skipped, and the entries are
yielded in system-dependent order. Each <tt class="docutils literal">DirEntry</tt> object has the
following attributes and methods:</p>
<ul class="simple">
<li><tt class="docutils literal">name</tt>: the entry's filename, relative to the scandir <tt class="docutils literal">path</tt>
argument (corresponds to the return values of <tt class="docutils literal">os.listdir</tt>)</li>
<li><tt class="docutils literal">path</tt>: the entry's full path name (not necessarily an absolute
path) -- the equivalent of <tt class="docutils literal">os.path.join(scandir_path,
entry.name)</tt></li>
<li><tt class="docutils literal">inode()</tt>: return the inode number of the entry. The result is cached on
the <tt class="docutils literal">DirEntry</tt> object, use <tt class="docutils literal">os.stat(entry.path,
<span class="pre">follow_symlinks=False).st_ino</span></tt> to fetch up-to-date information.
On Unix, no system call is required.</li>
<li><tt class="docutils literal"><span class="pre">is_dir(*,</span> follow_symlinks=True)</tt>: similar to
<tt class="docutils literal">pathlib.Path.is_dir()</tt>, but the return value is cached on the
<tt class="docutils literal">DirEntry</tt> object; doesn't require a system call in most cases;
don't follow symbolic links if <tt class="docutils literal">follow_symlinks</tt> is False</li>
<li><tt class="docutils literal"><span class="pre">is_file(*,</span> follow_symlinks=True)</tt>: similar to
<tt class="docutils literal">pathlib.Path.is_file()</tt>, but the return value is cached on the
<tt class="docutils literal">DirEntry</tt> object; doesn't require a system call in most cases;
don't follow symbolic links if <tt class="docutils literal">follow_symlinks</tt> is False</li>
<li><tt class="docutils literal">is_symlink()</tt>: similar to <tt class="docutils literal">pathlib.Path.is_symlink()</tt>, but the
return value is cached on the <tt class="docutils literal">DirEntry</tt> object; doesn't require a
system call in most cases</li>
<li><tt class="docutils literal"><span class="pre">stat(*,</span> follow_symlinks=True)</tt>: like <tt class="docutils literal">os.stat()</tt>, but the
return value is cached on the <tt class="docutils literal">DirEntry</tt> object; does not require a
system call on Windows (except for symlinks); don't follow symbolic links
(like <tt class="docutils literal">os.lstat()</tt>) if <tt class="docutils literal">follow_symlinks</tt> is False</li>
</ul>
<p>All <em>methods</em> may perform system calls in some cases and therefore
possibly raise <tt class="docutils literal">OSError</tt> -- see the &quot;Notes on exception handling&quot;
section for more details.</p>
<p>The <tt class="docutils literal">DirEntry</tt> attribute and method names were chosen to be the same
as those in the new <tt class="docutils literal">pathlib</tt> module where possible, for
consistency. The only difference in functionality is that the
<tt class="docutils literal">DirEntry</tt> methods cache their values on the entry object after the
first call.</p>
<p>Like the other functions in the <tt class="docutils literal">os</tt> module, <tt class="docutils literal">scandir()</tt> accepts
either a bytes or str object for the <tt class="docutils literal">path</tt> parameter, and
returns the <tt class="docutils literal">DirEntry.name</tt> and <tt class="docutils literal">DirEntry.path</tt> attributes with
the same type as <tt class="docutils literal">path</tt>. However, it is <em>strongly recommended</em>
to use the str type, as this ensures cross-platform support for
Unicode filenames. (On Windows, bytes filenames have been deprecated
since Python 3.3).</p>
</div>
<div class="section" id="os-walk">
<h2><a class="toc-backref" href="#id20">os.walk()</a></h2>
<p>As part of this proposal, <tt class="docutils literal">os.walk()</tt> will also be modified to use
<tt class="docutils literal">scandir()</tt> rather than <tt class="docutils literal">listdir()</tt> and <tt class="docutils literal">os.path.isdir()</tt>. This
will increase the speed of <tt class="docutils literal">os.walk()</tt> very significantly (as
mentioned above, by 2-20 times, depending on the system).</p>
</div>
</div>
<div class="section" id="examples">
<h1><a class="toc-backref" href="#id21">Examples</a></h1>
<p>First, a very simple example of <tt class="docutils literal">scandir()</tt> showing use of the
<tt class="docutils literal">DirEntry.name</tt> attribute and the <tt class="docutils literal">DirEntry.is_dir()</tt> method:</p>
<pre class="literal-block">
def subdirs(path):
    &quot;&quot;&quot;Yield directory names not starting with '.' under given path.&quot;&quot;&quot;
    for entry in os.scandir(path):
        if not entry.name.startswith('.') and entry.is_dir():
            yield entry.name
</pre>
<p>This <tt class="docutils literal">subdirs()</tt> function will be significantly faster with scandir
than <tt class="docutils literal">os.listdir()</tt> and <tt class="docutils literal">os.path.isdir()</tt> on both Windows and POSIX
systems, especially on medium-sized or large directories.</p>
<p>Or, for getting the total size of files in a directory tree, showing
use of the <tt class="docutils literal">DirEntry.stat()</tt> method and <tt class="docutils literal">DirEntry.path</tt>
attribute:</p>
<pre class="literal-block">
def get_tree_size(path):
    &quot;&quot;&quot;Return total size of files in given path and subdirs.&quot;&quot;&quot;
    total = 0
    for entry in os.scandir(path):
        if entry.is_dir(follow_symlinks=False):
            total += get_tree_size(entry.path)
        else:
            total += entry.stat(follow_symlinks=False).st_size
    return total
</pre>
<p>This also shows the use of the <tt class="docutils literal">follow_symlinks</tt> parameter to
<tt class="docutils literal">is_dir()</tt> -- in a recursive function like this, we probably don't
want to follow links. (To properly follow links in a recursive
function like this we'd want special handling for the case where
following a symlink leads to a recursive loop.)</p>
<p>Note that <tt class="docutils literal">get_tree_size()</tt> will get a huge speed boost on Windows,
because no extra stat call are needed, but on POSIX systems the size
information is not returned by the directory iteration functions, so
this function won't gain anything there.</p>
<div class="section" id="notes-on-caching">
<h2><a class="toc-backref" href="#id22">Notes on caching</a></h2>
<p>The <tt class="docutils literal">DirEntry</tt> objects are relatively dumb -- the <tt class="docutils literal">name</tt> and
<tt class="docutils literal">path</tt> attributes are obviously always cached, and the <tt class="docutils literal">is_X</tt>
and <tt class="docutils literal">stat</tt> methods cache their values (immediately on Windows via
<tt class="docutils literal">FindNextFile</tt>, and on first use on POSIX systems via a <tt class="docutils literal">stat</tt>
system call) and never refetch from the system.</p>
<p>For this reason, <tt class="docutils literal">DirEntry</tt> objects are intended to be used and
thrown away after iteration, not stored in long-lived data structured
and the methods called again and again.</p>
<p>If developers want &quot;refresh&quot; behaviour (for example, for watching a
file's size change), they can simply use <tt class="docutils literal">pathlib.Path</tt> objects,
or call the regular <tt class="docutils literal">os.stat()</tt> or <tt class="docutils literal">os.path.getsize()</tt> functions
which get fresh data from the operating system every call.</p>
</div>
<div class="section" id="notes-on-exception-handling">
<h2><a class="toc-backref" href="#id23">Notes on exception handling</a></h2>
<p><tt class="docutils literal">DirEntry.is_X()</tt> and <tt class="docutils literal">DirEntry.stat()</tt> are explicitly methods
rather than attributes or properties, to make it clear that they may
not be cheap operations (although they often are), and they may do a
system call. As a result, these methods may raise <tt class="docutils literal">OSError</tt>.</p>
<p>For example, <tt class="docutils literal">DirEntry.stat()</tt> will always make a system call on
POSIX-based systems, and the <tt class="docutils literal">DirEntry.is_X()</tt> methods will make a
<tt class="docutils literal">stat()</tt> system call on such systems if <tt class="docutils literal">readdir()</tt> does not
support <tt class="docutils literal">d_type</tt> or returns a <tt class="docutils literal">d_type</tt> with a value of
<tt class="docutils literal">DT_UNKNOWN</tt>, which can occur under certain conditions or on
certain file systems.</p>
<p>Often this does not matter -- for example, <tt class="docutils literal">os.walk()</tt> as defined in
the standard library only catches errors around the <tt class="docutils literal">listdir()</tt>
calls.</p>
<p>Also, because the exception-raising behaviour of the <tt class="docutils literal">DirEntry.is_X</tt>
methods matches that of <tt class="docutils literal">pathlib</tt> -- which only raises <tt class="docutils literal">OSError</tt>
in the case of permissions or other fatal errors, but returns False
if the path doesn't exist or is a broken symlink -- it's often
not necessary to catch errors around the <tt class="docutils literal">is_X()</tt> calls.</p>
<p>However, when a user requires fine-grained error handling, it may be
desirable to catch <tt class="docutils literal">OSError</tt> around all method calls and handle as
appropriate.</p>
<p>For example, below is a version of the <tt class="docutils literal">get_tree_size()</tt> example
shown above, but with fine-grained error handling added:</p>
<pre class="literal-block">
def get_tree_size(path):
    &quot;&quot;&quot;Return total size of files in path and subdirs. If
    is_dir() or stat() fails, print an error message to stderr
    and assume zero size (for example, file has been deleted).
    &quot;&quot;&quot;
    total = 0
    for entry in os.scandir(path):
        try:
            is_dir = entry.is_dir(follow_symlinks=False)
        except OSError as error:
            print('Error calling is_dir():', error, file=sys.stderr)
            continue
        if is_dir:
            total += get_tree_size(entry.path)
        else:
            try:
                total += entry.stat(follow_symlinks=False).st_size
            except OSError as error:
                print('Error calling stat():', error, file=sys.stderr)
    return total
</pre>
</div>
</div>
<div class="section" id="support">
<h1><a class="toc-backref" href="#id24">Support</a></h1>
<p>The scandir module on GitHub has been forked and used quite a bit (see
&quot;Use in the wild&quot; in this PEP), but there's also been a fair bit of
direct support for a scandir-like function from core developers and
others on the python-dev and python-ideas mailing lists. A sampling:</p>
<ul class="simple">
<li><strong>python-dev</strong>: a good number of +1's and very few negatives for
scandir and <a class="reference external" href="/dev/peps/pep-0471">PEP 471</a> on <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2014-June/135217.html">this June 2014 python-dev thread</a></li>
<li><strong>Nick Coghlan</strong>, a core Python developer: &quot;I've had the local Red
Hat release engineering team express their displeasure at having to
stat every file in a network mounted directory tree for info that is
present in the dirent structure, so a definite +1 to os.scandir from
me, so long as it makes that info available.&quot;
[<a class="reference external" href="http://bugs.python.org/issue11406">source1</a>]</li>
<li><strong>Tim Golden</strong>, a core Python developer, supports scandir enough to
have spent time refactoring and significantly improving scandir's C
extension module.
[<a class="reference external" href="https://github.com/tjguk/scandir">source2</a>]</li>
<li><strong>Christian Heimes</strong>, a core Python developer: &quot;+1 for something
like yielddir()&quot;
[<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2012-November/017772.html">source3</a>]
and &quot;Indeed! I'd like to see the feature in 3.4 so I can remove my
own hack from our code base.&quot;
[<a class="reference external" href="http://bugs.python.org/issue11406">source4</a>]</li>
<li><strong>Gregory P. Smith</strong>, a core Python developer: &quot;As 3.4beta1 happens
tonight, this isn't going to make 3.4 so i'm bumping this to 3.5.
I really like the proposed design outlined above.&quot;
[<a class="reference external" href="http://bugs.python.org/issue11406">source5</a>]</li>
<li><strong>Guido van Rossum</strong> on the possibility of adding scandir to Python
3.5 (as it was too late for 3.4): &quot;The ship has likewise sailed for
adding scandir() (whether to os or pathlib). By all means experiment
and get it ready for consideration for 3.5, but I don't want to add
it to 3.4.&quot;
[<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2013-November/130583.html">source6</a>]</li>
</ul>
<p>Support for this PEP itself (meta-support?) was given by Nick Coghlan
on python-dev: &quot;A PEP reviewing all this for 3.5 and proposing a
specific os.scandir API would be a good thing.&quot;
[<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2013-November/130588.html">source7</a>]</p>
</div>
<div class="section" id="use-in-the-wild">
<h1><a class="toc-backref" href="#id25">Use in the wild</a></h1>
<p>To date, the <tt class="docutils literal">scandir</tt> implementation is definitely useful, but has
been clearly marked &quot;beta&quot;, so it's uncertain how much use of it there
is in the wild. Ben Hoyt has had several reports from people using it.
For example:</p>
<ul class="simple">
<li>Chris F: &quot;I am processing some pretty large directories and was half
expecting to have to modify getdents. So thanks for saving me the
effort.&quot; [via personal email]</li>
<li>bschollnick: &quot;I wanted to let you know about this, since I am using
Scandir as a building block for this code. Here's a good example of
scandir making a radical performance improvement over os.listdir.&quot;
[<a class="reference external" href="https://github.com/benhoyt/scandir/issues/19">source8</a>]</li>
<li>Avram L: &quot;I'm testing our scandir for a project I'm working on.
Seems pretty solid, so first thing, just want to say nice work!&quot;
[via personal email]</li>
<li>Matt Z: &quot;I used scandir to dump the contents of a network dir in
under 15 seconds. 13 root dirs, 60,000 files in the structure. This
will replace some old VBA code embedded in a spreadsheet that was
taking 15-20 minutes to do the exact same thing.&quot; [via personal
email]</li>
</ul>
<p>Others have <a class="reference external" href="https://github.com/benhoyt/scandir/issues/12">requested a PyPI package</a> <a class="footnote-reference" href="#id9" id="id10">[4]</a> for it, which has been
created. See <a class="reference external" href="https://pypi.python.org/pypi/scandir">PyPI package</a> <a class="footnote-reference" href="#id11" id="id12">[5]</a>.</p>
<p>GitHub stats don't mean too much, but scandir does have several
watchers, issues, forks, etc. Here's the run-down as of the stats as
of July 7, 2014:</p>
<ul class="simple">
<li>Watchers: 17</li>
<li>Stars: 57</li>
<li>Forks: 20</li>
<li>Issues: 4 open, 26 closed</li>
</ul>
<p>Also, because this PEP will increase the speed of <tt class="docutils literal">os.walk()</tt>
significantly, there are thousands of developers and scripts, and a lot
of production code, that would benefit from it. For example, on GitHub,
there are almost as many uses of <tt class="docutils literal">os.walk</tt> (194,000) as there are of
<tt class="docutils literal">os.mkdir</tt> (230,000).</p>
</div>
<div class="section" id="rejected-ideas">
<h1><a class="toc-backref" href="#id26">Rejected ideas</a></h1>
<div class="section" id="naming">
<h2><a class="toc-backref" href="#id27">Naming</a></h2>
<p>The only other real contender for this function's name was
<tt class="docutils literal">iterdir()</tt>. However, <tt class="docutils literal">iterX()</tt> functions in Python (mostly found
in Python 2) tend to be simple iterator equivalents of their
non-iterator counterparts. For example, <tt class="docutils literal">dict.iterkeys()</tt> is just an
iterator version of <tt class="docutils literal">dict.keys()</tt>, but the objects returned are
identical. In <tt class="docutils literal">scandir()</tt>'s case, however, the return values are
quite different objects (<tt class="docutils literal">DirEntry</tt> objects vs filename strings), so
this should probably be reflected by a difference in name -- hence
<tt class="docutils literal">scandir()</tt>.</p>
<p>See some <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2014-June/135228.html">relevant discussion on python-dev</a>.</p>
</div>
<div class="section" id="wildcard-support">
<h2><a class="toc-backref" href="#id28">Wildcard support</a></h2>
<p><tt class="docutils literal">FindFirstFile</tt>/<tt class="docutils literal">FindNextFile</tt> on Windows support passing a
&quot;wildcard&quot; like <tt class="docutils literal">*.jpg</tt>, so at first folks (this PEP's author
included) felt it would be a good idea to include a
<tt class="docutils literal">windows_wildcard</tt> keyword argument to the <tt class="docutils literal">scandir</tt> function so
users could pass this in.</p>
<p>However, on further thought and discussion it was decided that this
would be bad idea, <em>unless it could be made cross-platform</em> (a
<tt class="docutils literal">pattern</tt> keyword argument or similar). This seems easy enough at
first -- just use the OS wildcard support on Windows, and something
like <tt class="docutils literal">fnmatch</tt> or <tt class="docutils literal">re</tt> afterwards on POSIX-based systems.</p>
<p>Unfortunately the exact Windows wildcard matching rules aren't really
documented anywhere by Microsoft, and they're quite quirky (see this
<a class="reference external" href="http://blogs.msdn.com/b/oldnewthing/archive/2007/12/17/6785519.aspx">blog post</a>),
meaning it's very problematic to emulate using <tt class="docutils literal">fnmatch</tt> or regexes.</p>
<p>So the consensus was that Windows wildcard support was a bad idea.
It would be possible to add at a later date if there's a
cross-platform way to achieve it, but not for the initial version.</p>
<p>Read more on the <a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2012-November/017770.html">this Nov 2012 python-ideas thread</a>
and this <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2014-June/135217.html">June 2014 python-dev thread on PEP 471</a>.</p>
</div>
<div class="section" id="methods-not-following-symlinks-by-default">
<h2><a class="toc-backref" href="#id29">Methods not following symlinks by default</a></h2>
<p>There was much debate on python-dev (see messages in <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2014-July/135485.html">this thread</a>)
over whether the <tt class="docutils literal">DirEntry</tt> methods should follow symbolic links or
not (when the <tt class="docutils literal">is_X()</tt> methods had no <tt class="docutils literal">follow_symlinks</tt> parameter).</p>
<p>Initially they did not (see previous versions of this PEP and the
scandir.py module), but Victor Stinner made a pretty compelling case on
python-dev that following symlinks by default is a better idea, because:</p>
<ul class="simple">
<li>following links is usually what you want (in 92% of cases in the
standard library, functions using <tt class="docutils literal">os.listdir()</tt> and
<tt class="docutils literal">os.path.isdir()</tt> do follow symlinks)</li>
<li>that's the precedent set by the similar functions
<tt class="docutils literal">os.path.isdir()</tt> and <tt class="docutils literal">pathlib.Path.is_dir()</tt>, so to do
otherwise would be confusing</li>
<li>with the non-link-following approach, if you wanted to follow links
you'd have to say something like <tt class="docutils literal">if (entry.is_symlink() and
os.path.isdir(entry.path)) or entry.is_dir()</tt>, which is clumsy</li>
</ul>
<p>As a case in point that shows the non-symlink-following version is
error prone, this PEP's author had a bug caused by getting this
exact test wrong in his initial implementation of <tt class="docutils literal">scandir.walk()</tt>
in scandir.py (see <a class="reference external" href="https://github.com/benhoyt/scandir/issues/4">Issue #4 here</a>).</p>
<p>In the end there was not total agreement that the methods should
follow symlinks, but there was basic consensus among the most involved
participants, and this PEP's author believes that the above case is
strong enough to warrant following symlinks by default.</p>
<p>In addition, it's straightforward to call the relevant methods with
<tt class="docutils literal">follow_symlinks=False</tt> if the other behaviour is desired.</p>
</div>
<div class="section" id="direntry-attributes-being-properties">
<h2><a class="toc-backref" href="#id30">DirEntry attributes being properties</a></h2>
<p>In some ways it would be nicer for the <tt class="docutils literal">DirEntry</tt> <tt class="docutils literal">is_X()</tt> and
<tt class="docutils literal">stat()</tt> to be properties instead of methods, to indicate they're
very cheap or free. However, this isn't quite the case, as <tt class="docutils literal">stat()</tt>
will require an OS call on POSIX-based systems but not on Windows.
Even <tt class="docutils literal">is_dir()</tt> and friends may perform an OS call on POSIX-based
systems if the <tt class="docutils literal">dirent.d_type</tt> value is <tt class="docutils literal">DT_UNKNOWN</tt> (on certain
file systems).</p>
<p>Also, people would expect the attribute access <tt class="docutils literal">entry.is_dir</tt> to
only ever raise <tt class="docutils literal">AttributeError</tt>, not <tt class="docutils literal">OSError</tt> in the case it
makes a system call under the covers. Calling code would have to have
a <tt class="docutils literal">try</tt>/<tt class="docutils literal">except</tt> around what looks like a simple attribute access,
and so it's much better to make them <em>methods</em>.</p>
<p>See <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2013-May/126184.html">this May 2013 python-dev thread</a>
where this PEP author makes this case and there's agreement from a
core developers.</p>
</div>
<div class="section" id="direntry-fields-being-static-attribute-only-objects">
<h2><a class="toc-backref" href="#id31">DirEntry fields being &quot;static&quot; attribute-only objects</a></h2>
<p>In <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2014-July/135303.html">this July 2014 python-dev message</a>,
Paul Moore suggested a solution that was a &quot;thin wrapper round the OS
feature&quot;, where the <tt class="docutils literal">DirEntry</tt> object had only static attributes:
<tt class="docutils literal">name</tt>, <tt class="docutils literal">path</tt>, and <tt class="docutils literal">is_X</tt>, with the <tt class="docutils literal">st_X</tt> attributes only
present on Windows. The idea was to use this simpler, lower-level
function as a building block for higher-level functions.</p>
<p>At first there was general agreement that simplifying in this way was
a good thing. However, there were two problems with this approach.
First, the assumption is the <tt class="docutils literal">is_dir</tt> and similar attributes are
always present on POSIX, which isn't the case (if <tt class="docutils literal">d_type</tt> is not
present or is <tt class="docutils literal">DT_UNKNOWN</tt>). Second, it's a much harder-to-use API
in practice, as even the <tt class="docutils literal">is_dir</tt> attributes aren't always present
on POSIX, and would need to be tested with <tt class="docutils literal">hasattr()</tt> and then
<tt class="docutils literal">os.stat()</tt> called if they weren't present.</p>
<p>See <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2014-July/135312.html">this July 2014 python-dev response</a>
from this PEP's author detailing why this option is a non-ideal
solution, and the subsequent reply from Paul Moore voicing agreement.</p>
</div>
<div class="section" id="direntry-fields-being-static-with-an-ensure-lstat-option">
<h2><a class="toc-backref" href="#id32">DirEntry fields being static with an ensure_lstat option</a></h2>
<p>Another seemingly simpler and attractive option was suggested by
Nick Coghlan in this <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2014-June/135261.html">June 2014 python-dev message</a>:
make <tt class="docutils literal">DirEntry.is_X</tt> and <tt class="docutils literal">DirEntry.lstat_result</tt> properties, and
populate <tt class="docutils literal">DirEntry.lstat_result</tt> at iteration time, but only if
the new argument <tt class="docutils literal">ensure_lstat=True</tt> was specified on the
<tt class="docutils literal">scandir()</tt> call.</p>
<p>This does have the advantage over the above in that you can easily get
the stat result from <tt class="docutils literal">scandir()</tt> if you need it. However, it has the
serious disadvantage that fine-grained error handling is messy,
because <tt class="docutils literal">stat()</tt> will be called (and hence potentially raise
<tt class="docutils literal">OSError</tt>) during iteration, leading to a rather ugly, hand-made
iteration loop:</p>
<pre class="literal-block">
it = os.scandir(path)
while True:
    try:
        entry = next(it)
    except OSError as error:
        handle_error(path, error)
    except StopIteration:
        break
</pre>
<p>Or it means that <tt class="docutils literal">scandir()</tt> would have to accept an <tt class="docutils literal">onerror</tt>
argument -- a function to call when <tt class="docutils literal">stat()</tt> errors occur during
iteration. This seems to this PEP's author neither as direct nor as
Pythonic as <tt class="docutils literal">try</tt>/<tt class="docutils literal">except</tt> around a <tt class="docutils literal">DirEntry.stat()</tt> call.</p>
<p>Another drawback is that <tt class="docutils literal">os.scandir()</tt> is written to make code faster.
Always calling <tt class="docutils literal">os.lstat()</tt> on POSIX would not bring any speedup. In most
cases, you don't need the full <tt class="docutils literal">stat_result</tt> object -- the <tt class="docutils literal">is_X()</tt>
methods are enough and this information is already known.</p>
<p>See <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2014-July/135312.html">Ben Hoyt's July 2014 reply</a>
to the discussion summarizing this and detailing why he thinks the
original <a class="reference external" href="/dev/peps/pep-0471">PEP 471</a> proposal is &quot;the right one&quot; after all.</p>
</div>
<div class="section" id="return-values-being-name-stat-result-two-tuples">
<h2><a class="toc-backref" href="#id33">Return values being (name, stat_result) two-tuples</a></h2>
<p>Initially this PEP's author proposed this concept as a function called
<tt class="docutils literal">iterdir_stat()</tt> which yielded two-tuples of (name, stat_result).
This does have the advantage that there are no new types introduced.
However, the <tt class="docutils literal">stat_result</tt> is only partially filled on POSIX-based
systems (most fields set to <tt class="docutils literal">None</tt> and other quirks), so they're not
really <tt class="docutils literal">stat_result</tt> objects at all, and this would have to be
thoroughly documented as different from <tt class="docutils literal">os.stat()</tt>.</p>
<p>Also, Python has good support for proper objects with attributes and
methods, which makes for a saner and simpler API than two-tuples. It
also makes the <tt class="docutils literal">DirEntry</tt> objects more extensible and future-proof
as operating systems add functionality and we want to include this in
<tt class="docutils literal">DirEntry</tt>.</p>
<p>See also some previous discussion:</p>
<ul class="simple">
<li><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2013-May/126148.html">May 2013 python-dev thread</a>
where Nick Coghlan makes the original case for a <tt class="docutils literal">DirEntry</tt>-style
object.</li>
<li><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2014-June/135244.html">June 2014 python-dev thread</a>
where Nick Coghlan makes (another) good case against the two-tuple
approach.</li>
</ul>
</div>
<div class="section" id="return-values-being-overloaded-stat-result-objects">
<h2><a class="toc-backref" href="#id34">Return values being overloaded stat_result objects</a></h2>
<p>Another alternative discussed was making the return values to be
overloaded <tt class="docutils literal">stat_result</tt> objects with <tt class="docutils literal">name</tt> and <tt class="docutils literal">path</tt>
attributes. However, apart from this being a strange (and strained!)
kind of overloading, this has the same problems mentioned above --
most of the <tt class="docutils literal">stat_result</tt> information is not fetched by
<tt class="docutils literal">readdir()</tt> on POSIX systems, only (part of) the <tt class="docutils literal">st_mode</tt> value.</p>
</div>
<div class="section" id="return-values-being-pathlib-path-objects">
<h2><a class="toc-backref" href="#id35">Return values being pathlib.Path objects</a></h2>
<p>With Antoine Pitrou's new standard library <tt class="docutils literal">pathlib</tt> module, it
at first seems like a great idea for <tt class="docutils literal">scandir()</tt> to return instances
of <tt class="docutils literal">pathlib.Path</tt>. However, <tt class="docutils literal">pathlib.Path</tt>'s <tt class="docutils literal">is_X()</tt> and
<tt class="docutils literal">stat()</tt> functions are explicitly not cached, whereas <tt class="docutils literal">scandir</tt>
has to cache them by design, because it's (often) returning values
from the original directory iteration system call.</p>
<p>And if the <tt class="docutils literal">pathlib.Path</tt> instances returned by <tt class="docutils literal">scandir</tt> cached
stat values, but the ordinary <tt class="docutils literal">pathlib.Path</tt> objects explicitly
don't, that would be more than a little confusing.</p>
<p>Guido van Rossum explicitly rejected <tt class="docutils literal">pathlib.Path</tt> caching stat in
the context of scandir <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2013-November/130583.html">here</a>,
making <tt class="docutils literal">pathlib.Path</tt> objects a bad choice for scandir return
values.</p>
</div>
</div>
<div class="section" id="possible-improvements">
<h1><a class="toc-backref" href="#id36">Possible improvements</a></h1>
<p>There are many possible improvements one could make to scandir, but
here is a short list of some this PEP's author has in mind:</p>
<ul class="simple">
<li>scandir could potentially be further sped up by calling <tt class="docutils literal">readdir</tt>
/ <tt class="docutils literal">FindNextFile</tt> say 50 times per <tt class="docutils literal">Py_BEGIN_ALLOW_THREADS</tt> block
so that it stays in the C extension module for longer, and may be
somewhat faster as a result. This approach hasn't been tested, but
was suggested by on Issue 11406 by Antoine Pitrou.
[<a class="reference external" href="http://bugs.python.org/msg130125">source9</a>]</li>
<li>scandir could use a free list to avoid the cost of memory allocation
for each iteration -- a short free list of 10 or maybe even 1 may help.
Suggested by Victor Stinner on a <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2014-June/135232.html">python-dev thread on June 27</a> <a class="footnote-reference" href="#id13" id="id14">[6]</a>.</li>
</ul>
</div>
<div class="section" id="previous-discussion">
<h1><a class="toc-backref" href="#id37">Previous discussion</a></h1>
<ul class="simple">
<li><a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2012-November/017770.html">Original November 2012 thread Ben Hoyt started on python-ideas</a>
about speeding up <tt class="docutils literal">os.walk()</tt></li>
<li>Python <a class="reference external" href="http://bugs.python.org/issue11406">Issue 11406</a> <a class="footnote-reference" href="#id4" id="id6">[2]</a>, which includes the original proposal for a
scandir-like function</li>
<li><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2013-May/126119.html">Further May 2013 thread Ben Hoyt started on python-dev</a>
that refined the <tt class="docutils literal">scandir()</tt> API, including Nick Coghlan's
suggestion of scandir yielding <tt class="docutils literal">DirEntry</tt>-like objects</li>
<li><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2013-November/130572.html">November 2013 thread Ben Hoyt started on python-dev</a>
to discuss the interaction between scandir and the new <tt class="docutils literal">pathlib</tt>
module</li>
<li><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2014-June/135215.html">June 2014 thread Ben Hoyt started on python-dev</a>
to discuss the first version of this PEP, with extensive discussion
about the API</li>
<li><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2014-July/135377.html">First July 2014 thread Ben Hoyt started on python-dev</a>
to discuss his updates to <a class="reference external" href="/dev/peps/pep-0471">PEP 471</a></li>
<li><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2014-July/135485.html">Second July 2014 thread Ben Hoyt started on python-dev</a>
to discuss the remaining decisions needed to finalize <a class="reference external" href="/dev/peps/pep-0471">PEP 471</a>,
specifically whether the <tt class="docutils literal">DirEntry</tt> methods should follow symlinks
by default</li>
<li><a class="reference external" href="http://stackoverflow.com/questions/2485719/very-quickly-getting-total-size-of-folder">Question on StackOverflow</a>
about why <tt class="docutils literal">os.walk()</tt> is slow and pointers on how to fix it (this
inspired the author of this PEP early on)</li>
<li><a class="reference external" href="https://github.com/benhoyt/betterwalk">BetterWalk</a>, this PEP's
author's previous attempt at this, on which the scandir code is based</li>
</ul>
</div>
<div class="section" id="id1">
<h1><a class="toc-backref" href="#id38">References</a></h1>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td><a class="reference external" href="https://github.com/benhoyt/scandir#benchmarks">https://github.com/benhoyt/scandir#benchmarks</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id5">1</a>, <a class="fn-backref" href="#id6">2</a>)</em> <a class="reference external" href="http://bugs.python.org/issue11406">http://bugs.python.org/issue11406</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[3]</a></td><td><a class="reference external" href="https://github.com/benhoyt/scandir">https://github.com/benhoyt/scandir</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[4]</a></td><td><a class="reference external" href="https://github.com/benhoyt/scandir/issues/12">https://github.com/benhoyt/scandir/issues/12</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[5]</a></td><td><a class="reference external" href="https://pypi.python.org/pypi/scandir">https://pypi.python.org/pypi/scandir</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[6]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2014-June/135232.html">https://mail.python.org/pipermail/python-dev/2014-June/135232.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id39">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

