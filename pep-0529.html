<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">529</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Change Windows filesystem encoding to UTF-8</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0529.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Steve Dower &lt;steve.dower&#32;&#97;t&#32;python.org&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">27-Aug-2016</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.6</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">01-Sep-2016, 04-Sep-2016</td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2016-September/146277.html">https://mail.python.org/pipermail/python-dev/2016-September/146277.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id3">Abstract</a></li>
<li><a class="reference internal" href="#background" id="id4">Background</a></li>
<li><a class="reference internal" href="#proposal" id="id5">Proposal</a></li>
<li><a class="reference internal" href="#specific-changes" id="id6">Specific Changes</a><ul>
<li><a class="reference internal" href="#update-sys-getfilesystemencoding" id="id7">Update sys.getfilesystemencoding</a></li>
<li><a class="reference internal" href="#add-sys-getfilesystemencodeerrors" id="id8">Add sys.getfilesystemencodeerrors</a></li>
<li><a class="reference internal" href="#update-path-converter" id="id9">Update path_converter</a></li>
<li><a class="reference internal" href="#remove-unused-ansi-code" id="id10">Remove unused ANSI code</a></li>
<li><a class="reference internal" href="#add-legacy-mode" id="id11">Add legacy mode</a></li>
<li><a class="reference internal" href="#undeprecate-bytes-paths-on-windows" id="id12">Undeprecate bytes paths on Windows</a></li>
<li><a class="reference internal" href="#beta-experiment" id="id13">Beta experiment</a></li>
<li><a class="reference internal" href="#affected-modules" id="id14">Affected Modules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rejected-alternatives" id="id15">Rejected Alternatives</a><ul>
<li><a class="reference internal" href="#use-strict-mbcs-decoding" id="id16">Use strict mbcs decoding</a></li>
<li><a class="reference internal" href="#make-bytes-paths-an-error-on-windows" id="id17">Make bytes paths an error on Windows</a></li>
<li><a class="reference internal" href="#make-bytes-paths-an-error-on-all-platforms" id="id18">Make bytes paths an error on all platforms</a></li>
</ul>
</li>
<li><a class="reference internal" href="#code-that-may-break" id="id19">Code that may break</a><ul>
<li><a class="reference internal" href="#not-managing-encodings-across-boundaries" id="id20">Not managing encodings across boundaries</a></li>
<li><a class="reference internal" href="#explicitly-using-mbcs" id="id21">Explicitly using 'mbcs'</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references" id="id22">References</a></li>
<li><a class="reference internal" href="#copyright" id="id23">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id3">Abstract</a></h1>
<p>Historically, Python uses the ANSI APIs for interacting with the Windows
operating system, often via C Runtime functions. However, these have been long
discouraged in favor of the UTF-16 APIs. Within the operating system, all text
is represented as UTF-16, and the ANSI APIs perform encoding and decoding using
the active code page. See <a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx">Naming Files, Paths, and Namespaces</a> <a class="footnote-reference" href="#id1" id="id2">[1]</a> for
more details.</p>
<p>This PEP proposes changing the default filesystem encoding on Windows to utf-8,
and changing all filesystem functions to use the Unicode APIs for filesystem
paths. This will not affect code that uses strings to represent paths, however
those that use bytes for paths will now be able to correctly round-trip all
valid paths in Windows filesystems. Currently, the conversions between Unicode
(in the OS) and bytes (in Python) were lossy and would fail to round-trip
characters outside of the user's active code page.</p>
<p>Notably, this does not impact the encoding of the contents of files. These will
continue to default to <tt class="docutils literal">locale.getpreferredencoding()</tt> (for text files) or
plain bytes (for binary files). This only affects the encoding used when users
pass a bytes object to Python where it is then passed to the operating system as
a path name.</p>
</div>
<div class="section" id="background">
<h1><a class="toc-backref" href="#id4">Background</a></h1>
<p>File system paths are almost universally represented as text with an encoding
determined by the file system. In Python, we expose these paths via a number of
interfaces, such as the <tt class="docutils literal">os</tt> and <tt class="docutils literal">io</tt> modules. Paths may be passed either
direction across these interfaces, that is, from the filesystem to the
application (for example, <tt class="docutils literal">os.listdir()</tt>), or from the application to the
filesystem (for example, <tt class="docutils literal">os.unlink()</tt>).</p>
<p>When paths are passed between the filesystem and the application, they are
either passed through as a bytes blob or converted to/from str using
<tt class="docutils literal">os.fsencode()</tt> and <tt class="docutils literal">os.fsdecode()</tt> or explicit encoding using
<tt class="docutils literal">sys.getfilesystemencoding()</tt>. The result of encoding a string with
<tt class="docutils literal">sys.getfilesystemencoding()</tt> is a blob of bytes in the native format for the
default file system.</p>
<p>On Windows, the native format for the filesystem is utf-16-le. The recommended
platform APIs for accessing the filesystem all accept and return text encoded in
this format. However, prior to Windows NT (and possibly further back), the
native format was a configurable machine option and a separate set of APIs
existed to accept this format. The option (the &quot;active code page&quot;) and these
APIs (the &quot;*A functions&quot;) still exist in recent versions of Windows for
backwards compatibility, though new functionality often only has a utf-16-le API
(the &quot;*W functions&quot;).</p>
<p>In Python, str is recommended because it can correctly round-trip all characters
used in paths (on POSIX with surrogateescape handling; on Windows because str
maps to the native representation). On Windows bytes cannot round-trip all
characters used in paths, as Python internally uses the *A functions and hence
the encoding is &quot;whatever the active code page is&quot;. Since the active code page
cannot represent all Unicode characters, the conversion of a path into bytes can
lose information without warning or any available indication.</p>
<p>As a demonstration of this:</p>
<pre class="literal-block">
&gt;&gt;&gt; open('test\uAB00.txt', 'wb').close()
&gt;&gt;&gt; import glob
&gt;&gt;&gt; glob.glob('test*')
['test\uab00.txt']
&gt;&gt;&gt; glob.glob(b'test*')
[b'test?.txt']
</pre>
<p>The Unicode character in the second call to glob has been replaced by a '?',
which means passing the path back into the filesystem will result in a
<tt class="docutils literal">FileNotFoundError</tt>. The same results may be observed with <tt class="docutils literal">os.listdir()</tt> or
any function that matches the return type to the parameter type.</p>
<p>While one user-accessible fix is to use str everywhere, POSIX systems generally
do not suffer from data loss when using bytes exclusively as the bytes are the
canonical representation. Even if the encoding is &quot;incorrect&quot; by some standard,
the file system will still map the bytes back to the file. Making use of this
avoids the cost of decoding and reencoding, such that (theoretically, and only
on POSIX), code such as this may be faster because of the use of <tt class="docutils literal"><span class="pre">b'.'</span></tt>
compared to using <tt class="docutils literal">'.'</tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for f in os.listdir(b'.'):
...     os.stat(f)
...
</pre>
<p>As a result, POSIX-focused library authors prefer to use bytes to represent
paths. For some authors it is also a convenience, as their code may receive
bytes already known to be encoded correctly, while others are attempting to
simplify porting their code from Python 2. However, the correctness assumptions
do not carry over to Windows where Unicode is the canonical representation, and
errors may result. This potential data loss is why the use of bytes paths on
Windows was deprecated in Python 3.3 - all of the above code snippets produce
deprecation warnings on Windows.</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id5">Proposal</a></h1>
<p>Currently the default filesystem encoding is 'mbcs', which is a meta-encoder
that uses the active code page. However, when bytes are passed to the filesystem
they go through the *A APIs and the operating system handles encoding. In this
case, paths are always encoded using the equivalent of 'mbcs:replace' with no
opportunity for Python to override or change this.</p>
<p>This proposal would remove all use of the *A APIs and only ever call the *W
APIs. When Windows returns paths to Python as <tt class="docutils literal">str</tt>, they will be decoded from
utf-16-le and returned as text (in whatever the minimal representation is). When
Python code requests paths as <tt class="docutils literal">bytes</tt>, the paths will be transcoded from
utf-16-le into utf-8 using surrogatepass (Windows does not validate surrogate
pairs, so it is possible to have invalid surrogates in filenames). Equally, when
paths are provided as <tt class="docutils literal">bytes</tt>, they are transcoded from utf-8 into utf-16-le
and passed to the *W APIs.</p>
<p>The use of utf-8 will not be configurable, except for the provision of a
&quot;legacy mode&quot; flag to revert to the previous behaviour.</p>
<p>The <tt class="docutils literal">surrogateescape</tt> error mode does not apply here, as the concern is not
about retaining non-sensical bytes. Any path returned from the operating system
will be valid Unicode, while invalid paths created by the user should raise a
decoding error (currently these would raise <tt class="docutils literal">OSError</tt> or a subclass).</p>
<p>The choice of utf-8 bytes (as opposed to utf-16-le bytes) is to ensure the
ability to round-trip path names and allow basic manipulation (for example,
using the <tt class="docutils literal">os.path</tt> module) when assuming an ASCII-compatible encoding. Using
utf-16-le as the encoding is more pure, but will cause more issues than are
resolved.</p>
<p>This change would also undeprecate the use of bytes paths on Windows. No change
to the semantics of using bytes as a path is required - as before, they must be
encoded with the encoding specified by <tt class="docutils literal">sys.getfilesystemencoding()</tt>.</p>
</div>
<div class="section" id="specific-changes">
<h1><a class="toc-backref" href="#id6">Specific Changes</a></h1>
<div class="section" id="update-sys-getfilesystemencoding">
<h2><a class="toc-backref" href="#id7">Update sys.getfilesystemencoding</a></h2>
<p>Remove the default value for <tt class="docutils literal">Py_FileSystemDefaultEncoding</tt> and set it in
<tt class="docutils literal">initfsencoding()</tt> to utf-8, or if the legacy-mode switch is enabled to mbcs.</p>
<p>Update the implementations of <tt class="docutils literal">PyUnicode_DecodeFSDefaultAndSize()</tt> and
<tt class="docutils literal">PyUnicode_EncodeFSDefault()</tt> to use the utf-8 codec, or if the legacy-mode
switch is enabled the existing mbcs codec.</p>
</div>
<div class="section" id="add-sys-getfilesystemencodeerrors">
<h2><a class="toc-backref" href="#id8">Add sys.getfilesystemencodeerrors</a></h2>
<p>As the error mode may now change between <tt class="docutils literal">surrogatepass</tt> and <tt class="docutils literal">replace</tt>,
Python code that manually performs encoding also needs access to the current
error mode. This includes the implementation of <tt class="docutils literal">os.fsencode()</tt> and
<tt class="docutils literal">os.fsdecode()</tt>, which currently assume an error mode based on the codec.</p>
<p>Add a public <tt class="docutils literal">Py_FileSystemDefaultEncodeErrors</tt>, similar to the existing
<tt class="docutils literal">Py_FileSystemDefaultEncoding</tt>. The default value on Windows will be
<tt class="docutils literal">surrogatepass</tt> or in legacy mode, <tt class="docutils literal">replace</tt>. The default value on all other
platforms will be <tt class="docutils literal">surrogateescape</tt>.</p>
<p>Add a public <tt class="docutils literal">sys.getfilesystemencodeerrors()</tt> function that returns the
current error mode.</p>
<p>Update the implementations of <tt class="docutils literal">PyUnicode_DecodeFSDefaultAndSize()</tt> and
<tt class="docutils literal">PyUnicode_EncodeFSDefault()</tt> to use the variable for error mode rather than
constant strings.</p>
<p>Update the implementations of <tt class="docutils literal">os.fsencode()</tt> and <tt class="docutils literal">os.fsdecode()</tt> to use
<tt class="docutils literal">sys.getfilesystemencodeerrors()</tt> instead of assuming the mode.</p>
</div>
<div class="section" id="update-path-converter">
<h2><a class="toc-backref" href="#id9">Update path_converter</a></h2>
<p>Update the path converter to always decode bytes or buffer objects into text
using <tt class="docutils literal">PyUnicode_DecodeFSDefaultAndSize()</tt>.</p>
<p>Change the <tt class="docutils literal">narrow</tt> field from a <tt class="docutils literal">char*</tt> string into a flag that indicates
whether the original object was bytes. This is required for functions that need
to return paths using the same type as was originally provided.</p>
</div>
<div class="section" id="remove-unused-ansi-code">
<h2><a class="toc-backref" href="#id10">Remove unused ANSI code</a></h2>
<p>Remove all code paths using the <tt class="docutils literal">narrow</tt> field, as these will no longer be
reachable by any caller. These are only used within <tt class="docutils literal">posixmodule.c</tt>. Other
uses of paths should have use of bytes paths replaced with decoding and use of
the *W APIs.</p>
</div>
<div class="section" id="add-legacy-mode">
<h2><a class="toc-backref" href="#id11">Add legacy mode</a></h2>
<p>Add a legacy mode flag, enabled by the environment variable
<tt class="docutils literal">PYTHONLEGACYWINDOWSFSENCODING</tt> or by a function call to
<tt class="docutils literal">sys._enablelegacywindowsfsencoding()</tt>. The function call can only be
used to enable the flag and should be used by programs as close to
initialization as possible. Legacy mode cannot be disabled while Python is
running.</p>
<p>When this flag is set, the default filesystem encoding is set to mbcs rather
than utf-8, and the error mode is set to <tt class="docutils literal">replace</tt> rather than
<tt class="docutils literal">surrogatepass</tt>. Paths will continue to decode to wide characters and only *W
APIs will be called, however, the bytes passed in and received from Python will
be encoded the same as prior to this change.</p>
</div>
<div class="section" id="undeprecate-bytes-paths-on-windows">
<h2><a class="toc-backref" href="#id12">Undeprecate bytes paths on Windows</a></h2>
<p>Using bytes as paths on Windows is currently deprecated. We would announce that
this is no longer the case, and that paths when encoded as bytes should use
whatever is returned from <tt class="docutils literal">sys.getfilesystemencoding()</tt> rather than the user's
active code page.</p>
</div>
<div class="section" id="beta-experiment">
<h2><a class="toc-backref" href="#id13">Beta experiment</a></h2>
<p>To assist with determining the impact of this change, we propose applying it to
3.6.0b1 provisionally with the intent being to make a final decision before
3.6.0b4.</p>
<p>During the experiment period, decoding and encoding exception messages will be
expanded to include a link to an active online discussion and encourage
reporting of problems.</p>
<p>If it is decided to revert the functionality for 3.6.0b4, the implementation
change would be to permanently enable the legacy mode flag, change the
environment variable to <tt class="docutils literal">PYTHONWINDOWSUTF8FSENCODING</tt> and function to
<tt class="docutils literal">sys._enablewindowsutf8fsencoding()</tt> to allow enabling the functionality
on a case-by-case basis, as opposed to disabling it.</p>
<p>It is expected that if we cannot feasibly make the change for 3.6 due to
compatibility concerns, it will not be possible to make the change at any later
time in Python 3.x.</p>
</div>
<div class="section" id="affected-modules">
<h2><a class="toc-backref" href="#id14">Affected Modules</a></h2>
<p>This PEP implicitly includes all modules within the Python that either pass path
names to the operating system, or otherwise use <tt class="docutils literal">sys.getfilesystemencoding()</tt>.</p>
<p>As of 3.6.0a4, the following modules require modification:</p>
<ul class="simple">
<li><tt class="docutils literal">os</tt></li>
<li><tt class="docutils literal">_overlapped</tt></li>
<li><tt class="docutils literal">_socket</tt></li>
<li><tt class="docutils literal">subprocess</tt></li>
<li><tt class="docutils literal">zipimport</tt></li>
</ul>
<p>The following modules use <tt class="docutils literal">sys.getfilesystemencoding()</tt> but do not need
modification:</p>
<ul class="simple">
<li><tt class="docutils literal">gc</tt> (already assumes bytes are utf-8)</li>
<li><tt class="docutils literal">grp</tt> (not compiled for Windows)</li>
<li><tt class="docutils literal">http.server</tt> (correctly includes codec name with transmitted data)</li>
<li><tt class="docutils literal">idlelib.editor</tt> (should not be needed; has fallback handling)</li>
<li><tt class="docutils literal">nis</tt> (not compiled for Windows)</li>
<li><tt class="docutils literal">pwd</tt> (not compiled for Windows)</li>
<li><tt class="docutils literal">spwd</tt> (not compiled for Windows)</li>
<li><tt class="docutils literal">_ssl</tt> (only used for ASCII constants)</li>
<li><tt class="docutils literal">tarfile</tt> (code unused on Windows)</li>
<li><tt class="docutils literal">_tkinter</tt> (already assumes bytes are utf-8)</li>
<li><tt class="docutils literal">wsgiref</tt> (assumed as the default encoding for unknown environments)</li>
<li><tt class="docutils literal">zipapp</tt> (code unused on Windows)</li>
</ul>
<p>The following native code uses one of the encoding or decoding functions, but do
not require any modification:</p>
<ul class="simple">
<li><tt class="docutils literal">Parser/parsetok.c</tt> (docs already specify <tt class="docutils literal">sys.getfilesystemencoding()</tt>)</li>
<li><tt class="docutils literal">Python/ast.c</tt> (docs already specify <tt class="docutils literal">sys.getfilesystemencoding()</tt>)</li>
<li><tt class="docutils literal">Python/compile.c</tt> (undocumented, but Python filesystem encoding implied)</li>
<li><tt class="docutils literal">Python/errors.c</tt> (docs already specify <tt class="docutils literal">os.fsdecode()</tt>)</li>
<li><tt class="docutils literal">Python/fileutils.c</tt> (code unused on Windows)</li>
<li><tt class="docutils literal">Python/future.c</tt> (undocumented, but Python filesystem encoding implied)</li>
<li><tt class="docutils literal">Python/import.c</tt> (docs already specify utf-8)</li>
<li><tt class="docutils literal">Python/importdl.c</tt> (code unused on Windows)</li>
<li><tt class="docutils literal">Python/pythonrun.c</tt> (docs already specify <tt class="docutils literal">sys.getfilesystemencoding()</tt>)</li>
<li><tt class="docutils literal">Python/symtable.c</tt> (undocumented, but Python filesystem encoding implied)</li>
<li><tt class="docutils literal">Python/thread.c</tt> (code unused on Windows)</li>
<li><tt class="docutils literal">Python/traceback.c</tt> (encodes correctly for comparing strings)</li>
<li><tt class="docutils literal">Python/_warnings.c</tt> (docs already specify <tt class="docutils literal">os.fsdecode()</tt>)</li>
</ul>
</div>
</div>
<div class="section" id="rejected-alternatives">
<h1><a class="toc-backref" href="#id15">Rejected Alternatives</a></h1>
<div class="section" id="use-strict-mbcs-decoding">
<h2><a class="toc-backref" href="#id16">Use strict mbcs decoding</a></h2>
<p>This is essentially the same as the proposed change, but instead of changing
<tt class="docutils literal">sys.getfilesystemencoding()</tt> to utf-8 it is changed to mbcs (which
dynamically maps to the active code page).</p>
<p>This approach allows the use of new functionality that is only available as *W
APIs and also detection of encoding/decoding errors. For example, rather than
silently replacing Unicode characters with '?', it would be possible to warn or
fail the operation.</p>
<p>Compared to the proposed fix, this could enable some new functionality but does
not fix any of the problems described initially. New runtime errors may cause
some problems to be more obvious and lead to fixes, provided library maintainers
are interested in supporting Windows and adding a separate code path to treat
filesystem paths as strings.</p>
<p>Making the encoding mbcs without strict errors is equivalent to the legacy-mode
switch being enabled by default. This is a possible course of action if there is
significant breakage of actual code and a need to extend the deprecation period,
but still a desire to have the simplifications to the CPython source.</p>
</div>
<div class="section" id="make-bytes-paths-an-error-on-windows">
<h2><a class="toc-backref" href="#id17">Make bytes paths an error on Windows</a></h2>
<p>By preventing the use of bytes paths on Windows completely we prevent users from
hitting encoding issues.</p>
<p>However, the motivation for this PEP is to increase the likelihood that code
written on POSIX will also work correctly on Windows. This alternative would
move the other direction and make such code completely incompatible. As this
does not benefit users in any way, we reject it.</p>
</div>
<div class="section" id="make-bytes-paths-an-error-on-all-platforms">
<h2><a class="toc-backref" href="#id18">Make bytes paths an error on all platforms</a></h2>
<p>By deprecating and then disable the use of bytes paths on all platforms we
prevent users from hitting encoding issues regardless of where the code was
originally written. This would require a full deprecation cycle, as there are
currently no warnings on platforms other than Windows.</p>
<p>This is likely to be seen as a hostile action against Python developers in
general, and as such is rejected at this time.</p>
</div>
</div>
<div class="section" id="code-that-may-break">
<h1><a class="toc-backref" href="#id19">Code that may break</a></h1>
<p>The following code patterns may break or see different behaviour as a result of
this change. Each of these examples would have been fragile in code intended for
cross-platform use. The suggested fixes demonstrate the most compatible way to
handle path encoding issues across all platforms and across multiple Python
versions.</p>
<p>Note that all of these examples produce deprecation warnings on Python 3.3 and
later.</p>
<div class="section" id="not-managing-encodings-across-boundaries">
<h2><a class="toc-backref" href="#id20">Not managing encodings across boundaries</a></h2>
<p>Code that does not manage encodings when crossing protocol boundaries may
currently be working by chance, but could encounter issues when either encoding
changes. Note that the source of <tt class="docutils literal">filename</tt> may be any function that returns
a bytes object, as illustrated in a second example below:</p>
<pre class="literal-block">
&gt;&gt;&gt; filename = open('filename_in_mbcs.txt', 'rb').read()
&gt;&gt;&gt; text = open(filename, 'r').read()
</pre>
<p>To correct this code, the encoding of the bytes in <tt class="docutils literal">filename</tt> should be
specified, either when reading from the file or before using the value:</p>
<pre class="literal-block">
&gt;&gt;&gt; # Fix 1: Open file as text (default encoding)
&gt;&gt;&gt; filename = open('filename_in_mbcs.txt', 'r').read()
&gt;&gt;&gt; text = open(filename, 'r').read()

&gt;&gt;&gt; # Fix 2: Open file as text (explicit encoding)
&gt;&gt;&gt; filename = open('filename_in_mbcs.txt', 'r', encoding='mbcs').read()
&gt;&gt;&gt; text = open(filename, 'r').read()

&gt;&gt;&gt; # Fix 3: Explicitly decode the path
&gt;&gt;&gt; filename = open('filename_in_mbcs.txt', 'rb').read()
&gt;&gt;&gt; text = open(filename.decode('mbcs'), 'r').read()
</pre>
<p>Where the creator of <tt class="docutils literal">filename</tt> is separated from the user of <tt class="docutils literal">filename</tt>,
the encoding is important information to include:</p>
<pre class="literal-block">
&gt;&gt;&gt; some_object.filename = r'C:\Users\Steve\Documents\my_file.txt'.encode('mbcs')

&gt;&gt;&gt; filename = some_object.filename
&gt;&gt;&gt; type(filename)
&lt;class 'bytes'&gt;
&gt;&gt;&gt; text = open(filename, 'r').read()
</pre>
<p>To fix this code for best compatibility across operating systems and Python
versions, the filename should be exposed as str:</p>
<pre class="literal-block">
&gt;&gt;&gt; # Fix 1: Expose as str
&gt;&gt;&gt; some_object.filename = r'C:\Users\Steve\Documents\my_file.txt'

&gt;&gt;&gt; filename = some_object.filename
&gt;&gt;&gt; type(filename)
&lt;class 'str'&gt;
&gt;&gt;&gt; text = open(filename, 'r').read()
</pre>
<p>Alternatively, the encoding used for the path needs to be made available to the
user. Specifying <tt class="docutils literal">os.fsencode()</tt> (or <tt class="docutils literal">sys.getfilesystemencoding()</tt>) is an
acceptable choice, or a new attribute could be added with the exact encoding:</p>
<pre class="literal-block">
&gt;&gt;&gt; # Fix 2: Use fsencode
&gt;&gt;&gt; some_object.filename = os.fsencode(r'C:\Users\Steve\Documents\my_file.txt')

&gt;&gt;&gt; filename = some_object.filename
&gt;&gt;&gt; type(filename)
&lt;class 'bytes'&gt;
&gt;&gt;&gt; text = open(filename, 'r').read()


&gt;&gt;&gt; # Fix 3: Expose as explicit encoding
&gt;&gt;&gt; some_object.filename = r'C:\Users\Steve\Documents\my_file.txt'.encode('cp437')
&gt;&gt;&gt; some_object.filename_encoding = 'cp437'

&gt;&gt;&gt; filename = some_object.filename
&gt;&gt;&gt; type(filename)
&lt;class 'bytes'&gt;
&gt;&gt;&gt; filename = filename.decode(some_object.filename_encoding)
&gt;&gt;&gt; type(filename)
&lt;class 'str'&gt;
&gt;&gt;&gt; text = open(filename, 'r').read()
</pre>
</div>
<div class="section" id="explicitly-using-mbcs">
<h2><a class="toc-backref" href="#id21">Explicitly using 'mbcs'</a></h2>
<p>Code that explicitly encodes text using 'mbcs' before passing to file system
APIs is now passing incorrectly encoded bytes. Note that the source of
<tt class="docutils literal">filename</tt> in this example is not relevant, provided that it is a str:</p>
<pre class="literal-block">
&gt;&gt;&gt; filename = open('files.txt', 'r').readline().rstrip()
&gt;&gt;&gt; text = open(filename.encode('mbcs'), 'r')
</pre>
<p>To correct this code, the string should be passed without explicit encoding, or
should use <tt class="docutils literal">os.fsencode()</tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; # Fix 1: Do not encode the string
&gt;&gt;&gt; filename = open('files.txt', 'r').readline().rstrip()
&gt;&gt;&gt; text = open(filename, 'r')

&gt;&gt;&gt; # Fix 2: Use correct encoding
&gt;&gt;&gt; filename = open('files.txt', 'r').readline().rstrip()
&gt;&gt;&gt; text = open(os.fsencode(filename), 'r')
</pre>
</div>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id22">References</a></h1>
<table class="docutils footnote" frame="void" id="id1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td><a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id23">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
</div>

