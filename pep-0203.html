<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">203</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Augmented Assignments</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0203.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">thomas&#32;&#97;t&#32;python.org (Thomas Wouters)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">13-Jul-2000</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.0</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">14-Aug-2000</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id7">Introduction</a></li>
<li><a class="reference internal" href="#proposed-semantics" id="id8">Proposed Semantics</a></li>
<li><a class="reference internal" href="#rationale" id="id9">Rationale</a></li>
<li><a class="reference internal" href="#new-methods" id="id10">New methods</a></li>
<li><a class="reference internal" href="#implementation" id="id11">Implementation</a></li>
<li><a class="reference internal" href="#open-issues" id="id12">Open Issues</a></li>
<li><a class="reference internal" href="#copyright" id="id13">Copyright</a></li>
<li><a class="reference internal" href="#references" id="id14">References</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id7">Introduction</a></h1>
<p>This PEP describes the <em>augmented assignment</em> proposal for Python 2.0.  This
PEP tracks the status and ownership of this feature, slated for introduction
in Python 2.0.  It contains a description of the feature and outlines changes
necessary to support the feature.  This PEP summarizes discussions held in
mailing list forums <a class="footnote-reference" href="#id4" id="id1">[1]</a>, and provides URLs for further information where
appropriate.  The CVS revision history of this file contains the definitive
historical record.</p>
</div>
<div class="section" id="proposed-semantics">
<h1><a class="toc-backref" href="#id8">Proposed Semantics</a></h1>
<p>The proposed patch that adds augmented assignment to Python introduces the
following new operators:</p>
<pre class="literal-block">
+= -= *= /= %= **= &lt;&lt;= &gt;&gt;= &amp;= ^= |=
</pre>
<p>They implement the same operator as their normal binary form, except that the
operation is done <em>in-place</em> when the left-hand side object supports it, and
that the left-hand side is only evaluated once.</p>
<p>They truly behave as augmented assignment, in that they perform all of the
normal load and store operations, in addition to the binary operation they are
intended to do.  So, given the expression:</p>
<pre class="literal-block">
x += y
</pre>
<p>The object <tt class="docutils literal">x</tt> is loaded, then <tt class="docutils literal">y</tt> is added to it, and the resulting
object is stored back in the original place.  The precise action performed on
the two arguments depends on the type of <tt class="docutils literal">x</tt>, and possibly of <tt class="docutils literal">y</tt>.</p>
<p>The idea behind augmented assignment in Python is that it isn't just an easier
way to write the common practice of storing the result of a binary operation
in its left-hand operand, but also a way for the left-hand operand in question
to know that it should operate <em>on itself</em>, rather than creating a modified
copy of itself.</p>
<p>To make this possible, a number of new <em>hooks</em> are added to Python classes and
C extension types, which are called when the object in question is used as the
left hand side of an augmented assignment operation.  If the class or type
does not implement the <em>in-place</em> hooks, the normal hooks for the particular
binary operation are used.</p>
<p>So, given an instance object <tt class="docutils literal">x</tt>, the expression:</p>
<pre class="literal-block">
x += y
</pre>
<p>tries to call <tt class="docutils literal">x.__iadd__(y)</tt>, which is the <em>in-place</em> variant of
<tt class="docutils literal">__add__</tt> .  If <tt class="docutils literal">__iadd__</tt> is not present, <tt class="docutils literal">x.__add__(y)</tt> is attempted,
and finally <tt class="docutils literal">y.__radd__(x)</tt> if <tt class="docutils literal">__add__</tt> is missing too.  There is no
<em>right-hand-side</em> variant of <tt class="docutils literal">__iadd__</tt>, because that would require for
<tt class="docutils literal">y</tt> to know how to in-place modify <tt class="docutils literal">x</tt>, which is unsafe to say the least.
The <tt class="docutils literal">__iadd__</tt> hook should behave similar to <tt class="docutils literal">__add__</tt>, returning the
result of the operation (which could be <tt class="docutils literal">self</tt>) which is to be assigned to
the variable <tt class="docutils literal">x</tt>.</p>
<p>For C extension types, the <em>hooks</em> are members of the <tt class="docutils literal">PyNumberMethods</tt> and
<tt class="docutils literal">PySequenceMethods</tt> structures.  Some special semantics apply to make the
use of these methods, and the mixing of Python instance objects and C types,
as unsurprising as possible.</p>
<p>In the generic case of <tt class="docutils literal">x &lt;augop&gt; y</tt> (or a similar case using the
<tt class="docutils literal">PyNumber_InPlace</tt> API functions) the principal object being operated on is
<tt class="docutils literal">x</tt>.  This differs from normal binary operations, where <tt class="docutils literal">x</tt> and <tt class="docutils literal">y</tt>
could be considered <em>co-operating</em>, because unlike in binary operations, the
operands in an in-place operation cannot be swapped.  However, in-place
operations do fall back to normal binary operations when in-place modification
is not supported, resulting in the following rules:</p>
<ul>
<li><p class="first">If the left-hand object (<tt class="docutils literal">x</tt>) is an instance object, and it has a
<tt class="docutils literal">__coerce__</tt> method, call that function with <tt class="docutils literal">y</tt> as the argument.  If
coercion succeeds, and the resulting left-hand object is a different object
than <tt class="docutils literal">x</tt>, stop processing it as in-place and call the appropriate function
for the normal binary operation, with the coerced <tt class="docutils literal">x</tt> and <tt class="docutils literal">y</tt> as
arguments.  The result of the operation is whatever that function returns.</p>
<p>If coercion does not yield a different object for <tt class="docutils literal">x</tt>, or <tt class="docutils literal">x</tt> does not
define a <tt class="docutils literal">__coerce__</tt> method, and <tt class="docutils literal">x</tt> has the appropriate <tt class="docutils literal">__ihook__</tt>
for this operation, call that method with <tt class="docutils literal">y</tt> as the argument, and the
result of the operation is whatever that method returns.</p>
</li>
<li><p class="first">Otherwise, if the left-hand object is not an instance object, but its type
does define the in-place function for this operation, call that function
with <tt class="docutils literal">x</tt> and <tt class="docutils literal">y</tt> as the arguments, and the result of the operation is
whatever that function returns.</p>
<p>Note that no coercion on either <tt class="docutils literal">x</tt> or <tt class="docutils literal">y</tt> is done in this case, and
it's perfectly valid for a C type to receive an instance object as the
second argument; that is something that cannot happen with normal binary
operations.</p>
</li>
<li><p class="first">Otherwise, process it exactly as a normal binary operation (not in-place),
including argument coercion.  In short, if either argument is an instance
object, resolve the operation through <tt class="docutils literal">__coerce__</tt>, <tt class="docutils literal">__hook__</tt> and
<tt class="docutils literal">__rhook__</tt>.  Otherwise, both objects are C types, and they are coerced
and passed to the appropriate function.</p>
</li>
<li><p class="first">If no way to process the operation can be found, raise a <tt class="docutils literal">TypeError</tt> with
an error message specific to the operation.</p>
</li>
<li><p class="first">Some special casing exists to account for the case of <tt class="docutils literal">+</tt> and <tt class="docutils literal">*</tt>,
which have a special meaning for sequences: for <tt class="docutils literal">+</tt>, sequence
concatenation, no coercion what so ever is done if a C type defines
<tt class="docutils literal">sq_concat</tt> or <tt class="docutils literal">sq_inplace_concat</tt>.  For <tt class="docutils literal">*</tt>, sequence repeating,
<tt class="docutils literal">y</tt> is converted to a C integer before calling either
<tt class="docutils literal">sq_inplace_repeat</tt> and <tt class="docutils literal">sq_repeat</tt>.  This is done even if <tt class="docutils literal">y</tt> is an
instance, though not if <tt class="docutils literal">x</tt> is an instance.</p>
</li>
</ul>
<p>The in-place function should always return a new reference, either to the
old <tt class="docutils literal">x</tt> object if the operation was indeed performed in-place, or to a new
object.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id9">Rationale</a></h1>
<p>There are two main reasons for adding this feature to Python: simplicity of
expression, and support for in-place operations. The end result is a tradeoff
between simplicity of syntax and simplicity of expression; like most new
features, augmented assignment doesn't add anything that was previously
impossible. It merely makes these things easier to do.</p>
<p>Adding augmented assignment will make Python's syntax more complex.  Instead
of a single assignment operation, there are now twelve assignment operations,
eleven of which also perform a binary operation.  However, these eleven new
forms of assignment are easy to understand as the coupling between assignment
and the binary operation, and they require no large conceptual leap to
understand.  Furthermore, languages that do have augmented assignment have
shown that they are a popular, much used feature. Expressions of the form:</p>
<pre class="literal-block">
&lt;x&gt; = &lt;x&gt; &lt;operator&gt; &lt;y&gt;
</pre>
<p>are common enough in those languages to make the extra syntax worthwhile, and
Python does not have significantly fewer of those expressions.  Quite the
opposite, in fact, since in Python you can also concatenate lists with a
binary operator, something that is done quite frequently.  Writing the above
expression as:</p>
<pre class="literal-block">
&lt;x&gt; &lt;operator&gt;= &lt;y&gt;
</pre>
<p>is both more readable and less error prone, because it is instantly obvious to
the reader that it is <tt class="docutils literal">&lt;x&gt;</tt> that is being changed, and not <tt class="docutils literal">&lt;x&gt;</tt> that is
being replaced by something almost, but not quite, entirely unlike <tt class="docutils literal">&lt;x&gt;</tt>.</p>
<p>The new in-place operations are especially useful to matrix calculation and
other applications that require large objects.  In order to efficiently deal
with the available program memory, such packages cannot blindly use the
current binary operations.  Because these operations always create a new
object, adding a single item to an existing (large) object would result in
copying the entire object (which may cause the application to run out of
memory), add the single item, and then possibly delete the original object,
depending on reference count.</p>
<p>To work around this problem, the packages currently have to use methods or
functions to modify an object in-place, which is definitely less readable than
an augmented assignment expression.  Augmented assignment won't solve all the
problems for these packages, since some operations cannot be expressed in the
limited set of binary operators to start with, but it is a start.  A
different PEP <a class="footnote-reference" href="#id6" id="id2">[3]</a> is looking at adding new operators.</p>
</div>
<div class="section" id="new-methods">
<h1><a class="toc-backref" href="#id10">New methods</a></h1>
<p>The proposed implementation adds the following 11 possible <em>hooks</em> which
Python classes can implement to overload the augmented assignment operations:</p>
<pre class="literal-block">
__iadd__
__isub__
__imul__
__idiv__
__imod__
__ipow__
__ilshift__
__irshift__
__iand__
__ixor__
__ior__
</pre>
<p>The <em>i</em> in <tt class="docutils literal">__iadd__</tt> stands for <em>in-place</em>.</p>
<p>For C extension types, the following struct members are added.</p>
<p>To <tt class="docutils literal">PyNumberMethods</tt>:</p>
<pre class="literal-block">
binaryfunc nb_inplace_add;
binaryfunc nb_inplace_subtract;
binaryfunc nb_inplace_multiply;
binaryfunc nb_inplace_divide;
binaryfunc nb_inplace_remainder;
binaryfunc nb_inplace_power;
binaryfunc nb_inplace_lshift;
binaryfunc nb_inplace_rshift;
binaryfunc nb_inplace_and;
binaryfunc nb_inplace_xor;
binaryfunc nb_inplace_or;
</pre>
<p>To <tt class="docutils literal">PySequenceMethods</tt>:</p>
<pre class="literal-block">
binaryfunc sq_inplace_concat;
intargfunc sq_inplace_repeat;
</pre>
<p>In order to keep binary compatibility, the <tt class="docutils literal">tp_flags</tt> TypeObject member is
used to determine whether the TypeObject in question has allocated room for
these slots.  Until a clean break in binary compatibility is made (which may
or may not happen before 2.0) code that wants to use one of the new struct
members must first check that they are available with the
<tt class="docutils literal">PyType_HasFeature()</tt> macro:</p>
<pre class="literal-block">
if (PyType_HasFeature(x-&gt;ob_type, Py_TPFLAGS_HAVE_INPLACE_OPS) &amp;&amp;
    x-&gt;ob_type-&gt;tp_as_number &amp;&amp; x-&gt;ob_type-&gt;tp_as_number-&gt;nb_inplace_add) {
        /* ... */
</pre>
<p>This check must be made even before testing the method slots for <tt class="docutils literal">NULL</tt>
values!  The macro only tests whether the slots are available, not whether
they are filled with methods or not.</p>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id11">Implementation</a></h1>
<p>The current implementation of augmented assignment <a class="footnote-reference" href="#id5" id="id3">[2]</a> adds, in addition to
the methods and slots already covered, 13 new bytecodes and 13 new API
functions.</p>
<p>The API functions are simply in-place versions of the current binary-operation
API functions:</p>
<pre class="literal-block">
PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2);
PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2);
PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2);
PyNumber_InPlaceDivide(PyObject *o1, PyObject *o2);
PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2);
PyNumber_InPlacePower(PyObject *o1, PyObject *o2);
PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2);
PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2);
PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2);
PyNumber_InPlaceXor(PyObject *o1, PyObject *o2);
PyNumber_InPlaceOr(PyObject *o1, PyObject *o2);
PySequence_InPlaceConcat(PyObject *o1, PyObject *o2);
PySequence_InPlaceRepeat(PyObject *o, int count);
</pre>
<p>They call either the Python class hooks (if either of the objects is a Python
class instance) or the C type's number or sequence methods.</p>
<p>The new bytecodes are:</p>
<pre class="literal-block">
INPLACE_ADD
INPLACE_SUBTRACT
INPLACE_MULTIPLY
INPLACE_DIVIDE
INPLACE_REMAINDER
INPLACE_POWER
INPLACE_LEFTSHIFT
INPLACE_RIGHTSHIFT
INPLACE_AND
INPLACE_XOR
INPLACE_OR
ROT_FOUR
DUP_TOPX
</pre>
<p>The <tt class="docutils literal">INPLACE_*</tt> bytecodes mirror the <tt class="docutils literal">BINARY_*</tt> bytecodes, except that
they are implemented as calls to the <tt class="docutils literal">InPlace</tt> API functions.  The other two
bytecodes are <em>utility</em> bytecodes: <tt class="docutils literal">ROT_FOUR</tt> behaves like <tt class="docutils literal">ROT_THREE</tt>
except that the four topmost stack items are rotated.</p>
<p><tt class="docutils literal">DUP_TOPX</tt> is a bytecode that takes a single argument, which should be an
integer between 1 and 5 (inclusive) which is the number of items to duplicate
in one block.  Given a stack like this (where the right side of the list is
the <em>top</em> of the stack):</p>
<pre class="literal-block">
[1, 2, 3, 4, 5]
</pre>
<p><tt class="docutils literal">DUP_TOPX 3</tt> would duplicate the top 3 items, resulting in this stack:</p>
<pre class="literal-block">
[1, 2, 3, 4, 5, 3, 4, 5]
</pre>
<p><tt class="docutils literal">DUP_TOPX</tt> with an argument of 1 is the same as <tt class="docutils literal">DUP_TOP</tt>.  The limit of 5
is purely an implementation limit .  The implementation of augmented
assignment requires only <tt class="docutils literal">DUP_TOPX</tt> with an argument of 2 and 3, and could
do without this new opcode at the cost of a fair number of <tt class="docutils literal">DUP_TOP</tt> and
<tt class="docutils literal">ROT_*</tt>.</p>
</div>
<div class="section" id="open-issues">
<h1><a class="toc-backref" href="#id12">Open Issues</a></h1>
<p>The <tt class="docutils literal">PyNumber_InPlace</tt> API is only a subset of the normal <tt class="docutils literal">PyNumber</tt> API:
only those functions that are required to support the augmented assignment
syntax are included. If other in-place API functions are needed, they can be
added later.</p>
<p>The <tt class="docutils literal">DUP_TOPX</tt> bytecode is a conveniency bytecode, and is not actually
necessary.  It should be considered whether this bytecode is worth having.
There seems to be no other possible use for this bytecode at this time.</p>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id13">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id14">References</a></h1>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://www.python.org/pipermail/python-list/2000-June/059556.html">http://www.python.org/pipermail/python-list/2000-June/059556.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td><a class="reference external" href="http://sourceforge.net/patch?func=detailpatch&amp;patch_id=100699&amp;group_id=5470">http://sourceforge.net/patch?func=detailpatch&amp;patch_id=100699&amp;group_id=5470</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[3]</a></td><td><a class="reference external" href="/dev/peps/pep-0211">PEP 211</a>, Adding A New Outer Product Operator, Wilson
<a class="reference external" href="http://www.python.org/dev/peps/pep-0211/">http://www.python.org/dev/peps/pep-0211/</a></td></tr>
</tbody>
</table>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

