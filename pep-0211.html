<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">211</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Adding A New Outer Product Operator</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0211.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">gvwilson&#32;&#97;t&#32;ddj.com (Greg Wilson)</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">15-Jul-2000</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.1</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://www.python.org/dev/peps/pep-0465/#rejected-alternatives-to-adding-a-new-operator">https://www.python.org/dev/peps/pep-0465/#rejected-alternatives-to-adding-a-new-operator</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id13">Introduction</a></li>
<li><a class="reference internal" href="#background" id="id14">Background</a></li>
<li><a class="reference internal" href="#iterators" id="id15">Iterators</a></li>
<li><a class="reference internal" href="#discussion" id="id16">Discussion</a></li>
<li><a class="reference internal" href="#alternatives" id="id17">Alternatives</a></li>
<li><a class="reference internal" href="#acknowledgments" id="id18">Acknowledgments</a></li>
<li><a class="reference internal" href="#references" id="id19">References</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id13">Introduction</a></h1>
<p>This PEP describes a proposal to define <tt class="docutils literal">&#64;</tt> (pronounced &quot;across&quot;)
as a new outer product operator in Python 2.2.  When applied to
sequences (or other iterable objects), this operator will combine
their iterators, so that:</p>
<pre class="literal-block">
for (i, j) in S &#64; T:
    pass
</pre>
<p>will be equivalent to:</p>
<pre class="literal-block">
for i in S:
    for j in T:
        pass
</pre>
<p>Classes will be able to overload this operator using the special
methods <tt class="docutils literal">__across__</tt>, <tt class="docutils literal">__racross__</tt>, and <tt class="docutils literal">__iacross__</tt>.  In
particular, the new Numeric module (<a class="reference external" href="/dev/peps/pep-0209">PEP 209</a>) will overload this
operator for multi-dimensional arrays to implement matrix
multiplication.</p>
</div>
<div class="section" id="background">
<h1><a class="toc-backref" href="#id14">Background</a></h1>
<p>Number-crunching is now just a small part of computing, but many
programmers --- including many Python users --- still need to
express complex mathematical operations in code.  Most numerical
languages, such as APL, Fortran-90, MATLAB, IDL, and Mathematica,
therefore provide two forms of the common arithmetic operators.
One form works element-by-element, e.g. multiplies corresponding
elements of its matrix arguments.  The other implements the
&quot;mathematical&quot; definition of that operation, e.g. performs
row-column matrix multiplication.</p>
<p>Zhu and Lielens have proposed doubling up Python's operators in
this way <a class="footnote-reference" href="#id8" id="id1">[1]</a>.  Their proposal would create six new binary infix
operators, and six new in-place operators.</p>
<p>The original version of this proposal was much more conservative.
The author consulted the developers of GNU Octave <a class="footnote-reference" href="#id9" id="id2">[2]</a>, an open
source clone of MATLAB.  Its developers agreed that providing an
infix operator for matrix multiplication was important: numerical
programmers really do care whether they have to write <tt class="docutils literal">mmul(A,B)</tt>
instead of <tt class="docutils literal">A op B</tt>.</p>
<p>On the other hand, when asked how important it was to have infix
operators for matrix solution and other operations, Prof. James
Rawlings replied <a class="footnote-reference" href="#id10" id="id3">[3]</a>:</p>
<blockquote>
I DON'T think it's a must have, and I do a lot of matrix
inversion. I cannot remember if its <tt class="docutils literal">A\b</tt> or <tt class="docutils literal">b\A</tt> so I always
write <tt class="docutils literal"><span class="pre">inv(A)*b</span></tt> instead. I recommend dropping <tt class="docutils literal">\</tt>.</blockquote>
<p>Based on this discussion, and feedback from students at the US
national laboratories and elsewhere, we recommended adding only
one new operator, for matrix multiplication, to Python.</p>
</div>
<div class="section" id="iterators">
<h1><a class="toc-backref" href="#id15">Iterators</a></h1>
<p>The planned addition of iterators to Python 2.2 opens up a broader
scope for this proposal.  As part of the discussion of <a class="reference external" href="/dev/peps/pep-0201">PEP 201</a>,
Lockstep Iteration <a class="footnote-reference" href="#id11" id="id4">[4]</a>, the author of this proposal conducted an
informal usability experiment <a class="footnote-reference" href="#id12" id="id5">[5]</a>.  The results showed that users
are psychologically receptive to &quot;cross-product&quot; loop syntax.  For
example, most users expected:</p>
<pre class="literal-block">
S = [10, 20, 30]
T = [1, 2, 3]
for x in S; y in T:
    print x+y,
</pre>
<p>to print <tt class="docutils literal">11 12 13 21 22 23 31 32 33</tt>.  We believe that users will
have the same reaction to:</p>
<pre class="literal-block">
for (x, y) in S &#64; T:
    print x+y
</pre>
<p>i.e. that they will naturally interpret this as a tidy way to
write loop nests.</p>
<p>This is where iterators come in.  Actually constructing the
cross-product of two (or more) sequences before executing the loop
would be very expensive.  On the other hand, <tt class="docutils literal">&#64;</tt> could be defined
to get its arguments' iterators, and then create an outer iterator
which returns tuples of the values returned by the inner
iterators.</p>
</div>
<div class="section" id="discussion">
<h1><a class="toc-backref" href="#id16">Discussion</a></h1>
<ol class="arabic">
<li><p class="first">Adding a named function &quot;across&quot; would have less impact on
Python than a new infix operator.  However, this would not make
Python more appealing to numerical programmers, who really do
care whether they can write matrix multiplication using an
operator, or whether they have to write it as a function call.</p>
</li>
<li><p class="first"><tt class="docutils literal">&#64;</tt> would have be chainable in the same way as comparison
operators, i.e.:</p>
<pre class="literal-block">
(1, 2) &#64; (3, 4) &#64; (5, 6)
</pre>
<p>would have to return <tt class="docutils literal">(1, 3, 5) ... (2, 4, 6)</tt>, and <em>not</em>
<tt class="docutils literal">((1, 3), 5) ... ((2, 4), 6)`</tt>.  This should not require special
support from the parser, as the outer iterator created by the
first <tt class="docutils literal">&#64;</tt> could easily be taught how to combine itself with
ordinary iterators.</p>
</li>
<li><p class="first">There would have to be some way to distinguish restartable
iterators from ones that couldn't be restarted.  For example,
if <tt class="docutils literal">S</tt> is an input stream (e.g. a file), and <tt class="docutils literal">L</tt> is a list, then <tt class="docutils literal">S
&#64; L</tt> is straightforward, but <tt class="docutils literal">L &#64; S</tt> is not, since iteration
through the stream cannot be repeated.  This could be treated
as an error, or by having the outer iterator detect
non-restartable inner iterators and cache their values.</p>
</li>
<li><p class="first">Whiteboard testing of this proposal in front of three novice
Python users (all of them experienced programmers) indicates
that users will expect:</p>
<pre class="literal-block">
&quot;ab&quot; &#64; &quot;cd&quot;
</pre>
<p>to return four strings, not four tuples of pairs of
characters.  Opinion was divided on what:</p>
<pre class="literal-block">
(&quot;a&quot;, &quot;b&quot;) &#64; &quot;cd&quot;
</pre>
<p>ought to return...</p>
</li>
</ol>
</div>
<div class="section" id="alternatives">
<h1><a class="toc-backref" href="#id17">Alternatives</a></h1>
<ol class="arabic">
<li><p class="first">Do nothing --- keep Python simple.</p>
<p>This is always the default choice.</p>
</li>
<li><p class="first">Add a named function instead of an operator.</p>
<p>Python is not primarily a numerical language; it may not be worth
complexifying it for this special case.  However, support for real
matrix multiplication <em>is</em> frequently requested, and the proposed
semantics for <tt class="docutils literal">&#64;</tt> for built-in sequence types would simplify
expression of a very common idiom (nested loops).</p>
</li>
<li><p class="first">Introduce prefixed forms of all existing operators, such as
<tt class="docutils literal">~*</tt> and <tt class="docutils literal">~+</tt>, as proposed in <a class="reference external" href="/dev/peps/pep-0225">PEP 225</a> <a class="footnote-reference" href="#id8" id="id6">[1]</a>.</p>
<p>Our objections to this are that there isn't enough demand to
justify the additional complexity (see Rawlings' comments <a class="footnote-reference" href="#id10" id="id7">[3]</a>),
and that the proposed syntax fails the &quot;low toner&quot; readability
test.</p>
</li>
</ol>
</div>
<div class="section" id="acknowledgments">
<h1><a class="toc-backref" href="#id18">Acknowledgments</a></h1>
<p>I am grateful to Huaiyu Zhu for initiating this discussion, and to
James Rawlings and students in various Python courses for their
discussions of what numerical programmers really care about.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id19">References</a></h1>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id6">2</a>)</em> <a class="reference external" href="/dev/peps/pep-0225">PEP 225</a>, Elementwise/Objectwise Operators, Zhu, Lielens
<a class="reference external" href="http://www.python.org/dev/peps/pep-0225/">http://www.python.org/dev/peps/pep-0225/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="http://bevo.che.wisc.edu/octave/">http://bevo.che.wisc.edu/octave/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id7">2</a>)</em> <a class="reference external" href="http://www.egroups.com/message/python-numeric/4">http://www.egroups.com/message/python-numeric/4</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td><a class="reference external" href="/dev/peps/pep-0201">PEP 201</a>, Lockstep Iteration, Warsaw
<a class="reference external" href="http://www.python.org/dev/peps/pep-0201/">http://www.python.org/dev/peps/pep-0201/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2000-July/006427.html">https://mail.python.org/pipermail/python-dev/2000-July/006427.html</a></td></tr>
</tbody>
</table>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

