<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">562</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Module __getattr__ and __dir__</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Ivan Levkivskyi &lt;levkivskyi&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">09-Sep-2017</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.7</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">09-Sep-2017</td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2017-December/151033.html">https://mail.python.org/pipermail/python-dev/2017-December/151033.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id7">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id8">Rationale</a></li>
<li><a class="reference internal" href="#specification" id="id9">Specification</a></li>
<li><a class="reference internal" href="#backwards-compatibility-and-impact-on-performance" id="id10">Backwards compatibility and impact on performance</a></li>
<li><a class="reference internal" href="#discussion" id="id11">Discussion</a></li>
<li><a class="reference internal" href="#references" id="id12">References</a></li>
<li><a class="reference internal" href="#copyright" id="id13">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id7">Abstract</a></h1>
<p>It is proposed to support <tt class="docutils literal">__getattr__</tt> and <tt class="docutils literal">__dir__</tt> function defined
on modules to provide basic customization of module attribute access.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id8">Rationale</a></h1>
<p>It is sometimes convenient to customize or otherwise have control over
access to module attributes. A typical example is managing deprecation
warnings. Typical workarounds are assigning <tt class="docutils literal">__class__</tt> of a module object
to a custom subclass of <tt class="docutils literal">types.ModuleType</tt> or replacing the <tt class="docutils literal">sys.modules</tt>
item with a custom wrapper instance. It would be convenient to simplify this
procedure by recognizing <tt class="docutils literal">__getattr__</tt> defined directly in a module that
would act like a normal <tt class="docutils literal">__getattr__</tt> method, except that it will be defined
on module <em>instances</em>. For example:</p>
<pre class="literal-block">
# lib.py

from warnings import warn

deprecated_names = [&quot;old_function&quot;, ...]

def _deprecated_old_function(arg, other):
    ...

def __getattr__(name):
    if name in deprecated_names:
        warn(f&quot;{name} is deprecated&quot;, DeprecationWarning)
        return globals()[f&quot;_deprecated_{name}&quot;]
    raise AttributeError(f&quot;module {__name__} has no attribute {name}&quot;)

# main.py

from lib import old_function  # Works, but emits the warning
</pre>
<p>Another widespread use case for <tt class="docutils literal">__getattr__</tt> would be lazy submodule
imports. Consider a simple example:</p>
<pre class="literal-block">
# lib/__init__.py

import importlib

__all__ = ['submod', ...]

def __getattr__(name):
    if name in __all__:
        return importlib.import_module(&quot;.&quot; + name, __name__)
    raise AttributeError(f&quot;module {__name__!r} has no attribute {name!r}&quot;)

# lib/submod.py

print(&quot;Submodule loaded&quot;)
class HeavyClass:
    ...

# main.py

import lib
lib.submodule.HeavyClass  # prints &quot;Submodule loaded&quot;
</pre>
<p>There is a related proposal <a class="reference external" href="/dev/peps/pep-0549">PEP 549</a> that proposes to support instance
properties for a similar functionality. The difference is this PEP proposes
a faster and simpler mechanism, but provides more basic customization.
An additional motivation for this proposal is that <a class="reference external" href="/dev/peps/pep-0484">PEP 484</a> already defines
the use of module <tt class="docutils literal">__getattr__</tt> for this purpose in Python stub files,
see <a class="footnote-reference" href="#id4" id="id1">[1]</a>.</p>
<p>In addition, to allow modifying result of a <tt class="docutils literal">dir()</tt> call on a module
to show deprecated and other dynamically generated attributes, it is
proposed to support module level <tt class="docutils literal">__dir__</tt> function. For example:</p>
<pre class="literal-block">
# lib.py

deprecated_names = [&quot;old_function&quot;, ...]
__all__ = [&quot;new_function_one&quot;, &quot;new_function_two&quot;, ...]

def new_function_one(arg, other):
   ...
def new_function_two(arg, other):
    ...

def __dir__():
    return sorted(__all__ + deprecated_names)

# main.py

import lib

dir(lib)  # prints [&quot;new_function_one&quot;, &quot;new_function_two&quot;, &quot;old_function&quot;, ...]
</pre>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id9">Specification</a></h1>
<p>The <tt class="docutils literal">__getattr__</tt> function at the module level should accept one argument
which is the name of an attribute and return the computed value or raise
an <tt class="docutils literal">AttributeError</tt>:</p>
<pre class="literal-block">
def __getattr__(name: str) -&gt; Any: ...
</pre>
<p>If an attribute is not found on a module object through the normal lookup
(i.e. <tt class="docutils literal">object.__getattribute__</tt>), then <tt class="docutils literal">__getattr__</tt> is searched in
the module <tt class="docutils literal">__dict__</tt> before raising an <tt class="docutils literal">AttributeError</tt>. If found, it is
called with the attribute name and the result is returned. Looking up a name
as a module global will bypass module <tt class="docutils literal">__getattr__</tt>. This is intentional,
otherwise calling <tt class="docutils literal">__getattr__</tt> for builtins will significantly harm
performance.</p>
<p>The <tt class="docutils literal">__dir__</tt> function should accept no arguments, and return
a list of strings that represents the names accessible on module:</p>
<pre class="literal-block">
def __dir__() -&gt; List[str]: ...
</pre>
<p>If present, this function overrides the standard <tt class="docutils literal">dir()</tt> search on
a module.</p>
<p>The reference implementation for this PEP can be found in <a class="footnote-reference" href="#id5" id="id2">[2]</a>.</p>
</div>
<div class="section" id="backwards-compatibility-and-impact-on-performance">
<h1><a class="toc-backref" href="#id10">Backwards compatibility and impact on performance</a></h1>
<p>This PEP may break code that uses module level (global) names <tt class="docutils literal">__getattr__</tt>
and <tt class="docutils literal">__dir__</tt>.  (But the language reference explicitly reserves <em>all</em>
undocumented dunder names, and allows &quot;breakage without warning&quot;; see <a class="footnote-reference" href="#id6" id="id3">[3]</a>.)
The performance implications of this PEP are minimal, since <tt class="docutils literal">__getattr__</tt>
is called only for missing attributes.</p>
<p>Some tools that perform module attributes discovery might not expect
<tt class="docutils literal">__getattr__</tt>. This problem is not new however, since it is already possible
to replace a module with a module subclass with overridden <tt class="docutils literal">__getattr__</tt> and
<tt class="docutils literal">__dir__</tt>, but with this PEP such problems can occur more often.</p>
</div>
<div class="section" id="discussion">
<h1><a class="toc-backref" href="#id11">Discussion</a></h1>
<p>Note that the use of module <tt class="docutils literal">__getattr__</tt> requires care to keep the referred
objects pickleable. For example, the <tt class="docutils literal">__name__</tt> attribute of a function
should correspond to the name with which it is accessible via
<tt class="docutils literal">__getattr__</tt>:</p>
<pre class="literal-block">
def keep_pickleable(func):
    func.__name__ = func.__name__.replace('_deprecated_', '')
    func.__qualname__ = func.__qualname__.replace('_deprecated_', '')
    return func

&#64;keep_pickleable
def _deprecated_old_function(arg, other):
    ...
</pre>
<p>One should be also careful to avoid recursion as one would do with
a class level <tt class="docutils literal">__getattr__</tt>.</p>
<p>To use a module global with triggering <tt class="docutils literal">__getattr__</tt> (for example if one
wants to use a lazy loaded submodule) one can access it as:</p>
<pre class="literal-block">
sys.modules[__name__].some_global
</pre>
<p>or as:</p>
<pre class="literal-block">
from . import some_global
</pre>
<p>Note that the latter sets the module attribute, thus <tt class="docutils literal">__getattr__</tt> will be
called only once.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id12">References</a></h1>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="/dev/peps/pep-0484">PEP 484</a> section about <tt class="docutils literal">__getattr__</tt> in stub files
(<a class="reference external" href="https://www.python.org/dev/peps/pep-0484/#stub-files">https://www.python.org/dev/peps/pep-0484/#stub-files</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>The reference implementation
(<a class="reference external" href="https://github.com/ilevkivskyi/cpython/pull/3/files">https://github.com/ilevkivskyi/cpython/pull/3/files</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>Reserved classes of identifiers
(<a class="reference external" href="https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers">https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id13">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

