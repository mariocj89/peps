<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">3121</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Extension Module Initialization and Finalization</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-3121.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Martin von LÃ¶wis &lt;martin&#32;&#97;t&#32;v.loewis.de&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Accepted</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">27-Apr-2007</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.0</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id3">Abstract</a></li>
<li><a class="reference internal" href="#problems" id="id4">Problems</a><ul>
<li><a class="reference internal" href="#module-finalization" id="id5">Module Finalization</a></li>
<li><a class="reference internal" href="#entry-point-name-conflicts" id="id6">Entry point name conflicts</a></li>
<li><a class="reference internal" href="#entry-point-signature" id="id7">Entry point signature</a></li>
<li><a class="reference internal" href="#multiple-interpreters" id="id8">Multiple Interpreters</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification" id="id9">Specification</a></li>
<li><a class="reference internal" href="#example" id="id10">Example</a></li>
<li><a class="reference internal" href="#discussion" id="id11">Discussion</a></li>
<li><a class="reference internal" href="#references" id="id12">References</a></li>
<li><a class="reference internal" href="#copyright" id="id13">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id3">Abstract</a></h1>
<p>Extension module initialization currently has a few deficiencies.
There is no cleanup for modules, the entry point name might give
naming conflicts, the entry functions don't follow the usual calling
convention, and multiple interpreters are not supported well. This PEP
addresses these issues.</p>
</div>
<div class="section" id="problems">
<h1><a class="toc-backref" href="#id4">Problems</a></h1>
<div class="section" id="module-finalization">
<h2><a class="toc-backref" href="#id5">Module Finalization</a></h2>
<p>Currently, extension modules are initialized usually once and then
&quot;live&quot; forever. The only exception is when Py_Finalize() is called:
then the initialization routine is invoked a second time. This is bad
from a resource management point of view: memory and other resources
might get allocated each time initialization is called, but there is
no way to reclaim them. As a result, there is currently no way to
completely release all resources Python has allocated.</p>
</div>
<div class="section" id="entry-point-name-conflicts">
<h2><a class="toc-backref" href="#id6">Entry point name conflicts</a></h2>
<p>The entry point is currently called init&lt;module&gt;. This might conflict
with other symbols also called init&lt;something&gt;. In particular,
initsocket is known to have conflicted in the past (this specific
problem got resolved as a side effect of renaming the module to
_socket).</p>
</div>
<div class="section" id="entry-point-signature">
<h2><a class="toc-backref" href="#id7">Entry point signature</a></h2>
<p>The entry point is currently a procedure (returning void).  This
deviates from the usual calling conventions; callers can find out
whether there was an error during initialization only by checking
PyErr_Occurred. The entry point should return a PyObject*, which will
be the module created, or NULL in case of an exception.</p>
</div>
<div class="section" id="multiple-interpreters">
<h2><a class="toc-backref" href="#id8">Multiple Interpreters</a></h2>
<p>Currently, extension modules share their state across all
interpreters. This allows for undesirable information leakage across
interpreters: one script could permanently corrupt objects in an
extension module, possibly breaking all scripts in other interpreters.</p>
</div>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id9">Specification</a></h1>
<p>The module initialization routines change their signature
to:</p>
<pre class="literal-block">
PyObject *PyInit_&lt;modulename&gt;()
</pre>
<p>The initialization routine will be invoked once per
interpreter, when the module is imported. It should
return a new module object each time.</p>
<p>In order to store per-module state in C variables,
each module object will contain a block of memory
that is interpreted only by the module. The amount
of memory used for the module is specified at
the point of creation of the module.</p>
<p>In addition to the initialization function, a module
may implement a number of additional callback
functions, which are invoked when the module's
tp_traverse, tp_clear, and tp_free functions are
invoked, and when the module is reloaded.</p>
<p>The entire module definition is combined in a struct
PyModuleDef:</p>
<pre class="literal-block">
struct PyModuleDef{
  PyModuleDef_Base m_base;  /* To be filled out by the interpreter */
  Py_ssize_t m_size; /* Size of per-module data */
  PyMethodDef *m_methods;
  inquiry m_reload;
  traverseproc m_traverse;
  inquiry m_clear;
  freefunc m_free;
};
</pre>
<p>Creation of a module is changed to expect an optional
PyModuleDef*. The module state will be
null-initialized.</p>
<p>Each module method will be passed the module object
as the first parameter. To access the module data,
a function:</p>
<pre class="literal-block">
void* PyModule_GetState(PyObject*);
</pre>
<p>will be provided. In addition, to lookup a module
more efficiently than going through sys.modules,
a function:</p>
<pre class="literal-block">
PyObject* PyState_FindModule(struct PyModuleDef*);
</pre>
<p>will be provided. This lookup function will use an
index located in the m_base field, to find the
module by index, not by name.</p>
<p>As all Python objects should be controlled through
the Python memory management, usage of &quot;static&quot;
type objects is discouraged, unless the type object
itself has no memory-managed state. To simplify
definition of heap types, a new method:</p>
<pre class="literal-block">
PyTypeObject* PyType_Copy(PyTypeObject*);
</pre>
<p>is added.</p>
</div>
<div class="section" id="example">
<h1><a class="toc-backref" href="#id10">Example</a></h1>
<p>xxmodule.c would be changed to remove the initxx
function, and add the following code instead:</p>
<pre class="literal-block">
struct xxstate{
  PyObject *ErrorObject;
  PyObject *Xxo_Type;
};

#define xxstate(o) ((struct xxstate*)PyModule_GetState(o))

static int xx_traverse(PyObject *m, visitproc v,
                       void *arg)
{
  Py_VISIT(xxstate(m)-&gt;ErrorObject);
  Py_VISIT(xxstate(m)-&gt;Xxo_Type);
  return 0;
}

static int xx_clear(PyObject *m)
{
  Py_CLEAR(xxstate(m)-&gt;ErrorObject);
  Py_CLEAR(xxstate(m)-&gt;Xxo_Type);
  return 0;
}

static struct PyModuleDef xxmodule = {
  {}, /* m_base */
  sizeof(struct xxstate),
  &amp;xx_methods,
  0,  /* m_reload */
  xx_traverse,
  xx_clear,
  0,  /* m_free - not needed, since all is done in m_clear */
}

PyObject*
PyInit_xx()
{
  PyObject *res = PyModule_New(&quot;xx&quot;, &amp;xxmodule);
  if (!res) return NULL;
  xxstate(res)-&gt;ErrorObject = PyErr_NewException(&quot;xx.error&quot;, NULL, NULL);
  if (!xxstate(res)-&gt;ErrorObject) {
    Py_DECREF(res);
    return NULL;
  }
  xxstate(res)-&gt;XxoType = PyType_Copy(&amp;Xxo_Type);
  if (!xxstate(res)-&gt;Xxo_Type) {
    Py_DECREF(res);
    return NULL;
  }
  return res;
}
</pre>
</div>
<div class="section" id="discussion">
<h1><a class="toc-backref" href="#id11">Discussion</a></h1>
<p>Tim Peters reports in <a class="footnote-reference" href="#id2" id="id1">[1]</a> that PythonLabs considered such a feature
at one point, and lists the following additional hooks which aren't
currently supported in this PEP:</p>
<ul class="simple">
<li>when the module object is deleted from sys.modules</li>
<li>when Py_Finalize is called</li>
<li>when Python exits</li>
<li>when the Python DLL is unloaded (Windows only)</li>
</ul>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id12">References</a></h1>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Tim Peters, reporting earlier conversation about such a feature
<a class="reference external" href="https://mail.python.org/pipermail/python-3000/2006-April/000726.html">https://mail.python.org/pipermail/python-3000/2006-April/000726.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id13">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

