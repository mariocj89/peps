<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">264</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Future statements in simulated shells</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0264.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Michael Hudson &lt;mwh&#32;&#97;t&#32;python.net&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Requires:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0236">236</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">30-Jul-2001</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.2</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">30-Jul-2001</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id3">Abstract</a></li>
<li><a class="reference internal" href="#specification" id="id4">Specification</a></li>
<li><a class="reference internal" href="#backward-compatibility" id="id5">Backward Compatibility</a></li>
<li><a class="reference internal" href="#forward-compatibility" id="id6">Forward Compatibility</a></li>
<li><a class="reference internal" href="#issues" id="id7">Issues</a></li>
<li><a class="reference internal" href="#implementation" id="id8">Implementation</a></li>
<li><a class="reference internal" href="#references" id="id9">References</a></li>
<li><a class="reference internal" href="#copyright" id="id10">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id3">Abstract</a></h1>
<p>As noted in <a class="reference external" href="/dev/peps/pep-0236">PEP 236</a>, there is no clear way for &quot;simulated
interactive shells&quot; to simulate the behaviour of <tt class="docutils literal">__future__</tt>
statements in &quot;real&quot; interactive shells, i.e. have <tt class="docutils literal">__future__</tt>
statements' effects last the life of the shell.</p>
<p>The PEP also takes the opportunity to clean up the other
unresolved issue mentioned in <a class="reference external" href="/dev/peps/pep-0236">PEP 236</a>, the inability to stop
<tt class="docutils literal">compile()</tt> inheriting the effect of future statements affecting the
code calling <tt class="docutils literal">compile()</tt>.</p>
<p>This PEP proposes to address the first problem by adding an
optional fourth argument to the builtin function &quot;compile&quot;, adding
information to the <tt class="docutils literal">_Feature</tt> instances defined in <tt class="docutils literal">__future__.py</tt> and
adding machinery to the standard library modules &quot;codeop&quot; and
&quot;code&quot; to make the construction of such shells easy.</p>
<p>The second problem is dealt with by simply adding <em>another</em>
optional argument to <tt class="docutils literal">compile()</tt>, which if non-zero suppresses the
inheriting of future statements' effects.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id4">Specification</a></h1>
<p>I propose adding a fourth, optional, &quot;flags&quot; argument to the
builtin &quot;compile&quot; function.  If this argument is omitted,
there will be no change in behaviour from that of Python 2.1.</p>
<p>If it is present it is expected to be an integer, representing
various possible compile time options as a bitfield.  The
bitfields will have the same values as the <tt class="docutils literal">CO_*</tt> flags already used
by the C part of Python interpreter to refer to future statements.</p>
<p><tt class="docutils literal">compile()</tt> shall raise a <tt class="docutils literal">ValueError</tt> exception if it does not
recognize any of the bits set in the supplied flags.</p>
<p>The flags supplied will be bitwise-&quot;or&quot;ed with the flags that
would be set anyway, unless the new fifth optional argument is a
non-zero integer, in which case the flags supplied will be exactly
the set used.</p>
<p>The above-mentioned flags are not currently exposed to Python.  I
propose adding <tt class="docutils literal">.compiler_flag</tt> attributes to the <tt class="docutils literal">_Feature</tt> objects
in <tt class="docutils literal">__future__.py</tt> that contain the necessary bits, so one might
write code such as:</p>
<pre class="literal-block">
import __future__
def compile_generator(func_def):
    return compile(func_def, &quot;&lt;input&gt;&quot;, &quot;suite&quot;,
                __future__.generators.compiler_flag)
</pre>
<p>A recent change means that these same bits can be used to tell if
a code object was compiled with a given feature; for instance</p>
<pre class="literal-block">
codeob.co_flags &amp; __future__.generators.compiler_flag``
</pre>
<p>will be non-zero if and only if the code object &quot;codeob&quot; was
compiled in an environment where generators were allowed.</p>
<p>I will also add a <tt class="docutils literal">.all_feature_flags</tt> attribute to the <tt class="docutils literal">__future__</tt>
module, giving a low-effort way of enumerating all the <tt class="docutils literal">__future__</tt>
options supported by the running interpreter.</p>
<p>I also propose adding a pair of classes to the standard library
module codeop.</p>
<p>One - <tt class="docutils literal">Compile</tt> - will sport a <tt class="docutils literal">__call__</tt> method which will act much
like the builtin &quot;compile&quot; of 2.1 with the difference that after
it has compiled a <tt class="docutils literal">__future__</tt> statement, it &quot;remembers&quot; it and
compiles all subsequent code with the <tt class="docutils literal">__future__</tt> option in effect.</p>
<p>It will do this by using the new features of the <tt class="docutils literal">__future__</tt> module
mentioned above.</p>
<p>Objects of the other class added to codeop - <tt class="docutils literal">CommandCompiler</tt> -
will do the job of the existing <tt class="docutils literal">codeop.compile_command</tt> function,
but in a <tt class="docutils literal">__future__</tt>-aware way.</p>
<p>Finally, I propose to modify the class <tt class="docutils literal">InteractiveInterpreter</tt> in
the standard library module code to use a <tt class="docutils literal">CommandCompiler</tt> to
emulate still more closely the behaviour of the default Python
shell.</p>
</div>
<div class="section" id="backward-compatibility">
<h1><a class="toc-backref" href="#id5">Backward Compatibility</a></h1>
<p>Should be very few or none; the changes to compile will make no
difference to existing code, nor will adding new functions or
classes to codeop.  Existing code using
<tt class="docutils literal">code.InteractiveInterpreter</tt> may change in behaviour, but only for
the better in that the &quot;real&quot; Python shell will be being better
impersonated.</p>
</div>
<div class="section" id="forward-compatibility">
<h1><a class="toc-backref" href="#id6">Forward Compatibility</a></h1>
<p>The fiddling that needs to be done to <tt class="docutils literal">Lib/__future__.py</tt> when
adding a <tt class="docutils literal">__future__</tt> feature will be a touch more complicated.
Everything else should just work.</p>
</div>
<div class="section" id="issues">
<h1><a class="toc-backref" href="#id7">Issues</a></h1>
<p>I hope the above interface is not too disruptive to implement for
Jython.</p>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id8">Implementation</a></h1>
<p>A series of preliminary implementations are at <a class="footnote-reference" href="#id2" id="id1">[1]</a>.</p>
<p>After light massaging by Tim Peters, they have now been checked in.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id9">References</a></h1>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://sourceforge.net/tracker/?func=detail&amp;atid=305470&amp;aid=449043&amp;group_id=5470">http://sourceforge.net/tracker/?func=detail&amp;atid=305470&amp;aid=449043&amp;group_id=5470</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id10">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
End: -->
</div>

