<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">511</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">API for code transformers</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0511.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Victor Stinner &lt;victor.stinner&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Rejected</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">4-January-2016</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.6</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#rejection-notice" id="id3">Rejection Notice</a></li>
<li><a class="reference internal" href="#abstract" id="id4">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id5">Rationale</a><ul>
<li><a class="reference internal" href="#usage-1-ast-optimizer" id="id6">Usage 1: AST optimizer</a></li>
<li><a class="reference internal" href="#usage-2-preprocessor" id="id7">Usage 2: Preprocessor</a></li>
<li><a class="reference internal" href="#usage-3-disable-all-optimization" id="id8">Usage 3: Disable all optimization</a></li>
<li><a class="reference internal" href="#usage-4-write-new-bytecode-optimizers-in-python" id="id9">Usage 4: Write new bytecode optimizers in Python</a></li>
</ul>
</li>
<li><a class="reference internal" href="#use-cases" id="id10">Use Cases</a><ul>
<li><a class="reference internal" href="#interactive-interpreter" id="id11">Interactive interpreter</a></li>
<li><a class="reference internal" href="#build-a-transformed-package" id="id12">Build a transformed package</a></li>
<li><a class="reference internal" href="#install-a-package-containing-transformed-pyc-files" id="id13">Install a package containing transformed .pyc files</a></li>
<li><a class="reference internal" href="#build-pyc-files-when-installing-a-package" id="id14">Build .pyc files when installing a package</a></li>
<li><a class="reference internal" href="#execute-transformed-code" id="id15">Execute transformed code</a></li>
</ul>
</li>
<li><a class="reference internal" href="#code-transformer-api" id="id16">Code transformer API</a><ul>
<li><a class="reference internal" href="#code-transformer-method" id="id17">code_transformer() method</a></li>
<li><a class="reference internal" href="#ast-transformer-method" id="id18">ast_transformer() method</a></li>
</ul>
</li>
<li><a class="reference internal" href="#changes" id="id19">Changes</a><ul>
<li><a class="reference internal" href="#api-to-get-set-code-transformers" id="id20">API to get/set code transformers</a></li>
<li><a class="reference internal" href="#optimizer-tag" id="id21">Optimizer tag</a></li>
<li><a class="reference internal" href="#peephole-optimizer" id="id22">Peephole optimizer</a></li>
<li><a class="reference internal" href="#ast-enhancements" id="id23">AST enhancements</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples" id="id24">Examples</a><ul>
<li><a class="reference internal" href="#pyc-filenames" id="id25">.pyc filenames</a></li>
<li><a class="reference internal" href="#bytecode-transformer" id="id26">Bytecode transformer</a></li>
<li><a class="reference internal" href="#ast-transformer" id="id27">AST transformer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-python-implementations" id="id28">Other Python implementations</a></li>
<li><a class="reference internal" href="#discussion" id="id29">Discussion</a></li>
<li><a class="reference internal" href="#prior-art" id="id30">Prior Art</a><ul>
<li><a class="reference internal" href="#ast-optimizers" id="id31">AST optimizers</a></li>
<li><a class="reference internal" href="#python-preprocessors" id="id32">Python Preprocessors</a></li>
<li><a class="reference internal" href="#bytecode-transformers" id="id33">Bytecode transformers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#copyright" id="id34">Copyright</a></li>
</ul>
</div>
<div class="section" id="rejection-notice">
<h1><a class="toc-backref" href="#id3">Rejection Notice</a></h1>
<p>This PEP was rejected by its author.</p>
<p>This PEP was seen as blessing new Python-like programming languages
which are close but incompatible with the regular Python language. It
was decided to not promote syntaxes incompatible with Python.</p>
<p>This PEP was also seen as a nice tool to experiment new Python features,
but it is already possible to experiment them without the PEP, only with
importlib hooks. If a feature becomes useful, it should be directly part
of Python, instead of depending on an third party Python module.</p>
<p>Finally, this PEP was driven was the FAT Python optimization project
which was abandonned in 2016, since it was not possible to show any
significant speedup, but also because of the lack of time to implement
the most advanced and complex optimizations.</p>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id4">Abstract</a></h1>
<p>Propose an API to register bytecode and AST transformers. Add also <tt class="docutils literal"><span class="pre">-o</span>
OPTIM_TAG</tt> command line option to change <tt class="docutils literal">.pyc</tt> filenames, <tt class="docutils literal"><span class="pre">-o</span>
noopt</tt> disables the peephole optimizer. Raise an <tt class="docutils literal">ImportError</tt>
exception on import if the <tt class="docutils literal">.pyc</tt> file is missing and the code
transformers required to transform the code are missing.  code
transformers are not needed code transformed ahead of time (loaded from
<tt class="docutils literal">.pyc</tt> files).</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id5">Rationale</a></h1>
<p>Python does not provide a standard way to transform the code. Projects
transforming the code use various hooks. The MacroPy project uses an
import hook: it adds its own module finder in <tt class="docutils literal">sys.meta_path</tt> to
hook its AST transformer. Another option is to monkey-patch the
builtin <tt class="docutils literal">compile()</tt> function. There are even more options to
hook a code transformer.</p>
<p>Python 3.4 added a <tt class="docutils literal">compile_source()</tt> method to
<tt class="docutils literal">importlib.abc.SourceLoader</tt>. But code transformation is wider than
just importing modules, see described use cases below.</p>
<p>Writing an optimizer or a preprocessor is out of the scope of this PEP.</p>
<div class="section" id="usage-1-ast-optimizer">
<h2><a class="toc-backref" href="#id6">Usage 1: AST optimizer</a></h2>
<p>Transforming an Abstract Syntax Tree (AST) is a convenient
way to implement an optimizer. It's easier to work on the AST than
working on the bytecode, AST contains more information and is more high
level.</p>
<p>Since the optimization can done ahead of time, complex but slow
optimizations can be implemented.</p>
<p>Example of optimizations which can be implemented with an AST optimizer:</p>
<ul class="simple">
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Copy_propagation">Copy propagation</a>:
replace <tt class="docutils literal">x=1; y=x</tt> with <tt class="docutils literal">x=1; y=1</tt></li>
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Constant_folding">Constant folding</a>:
replace <tt class="docutils literal">1+1</tt> with <tt class="docutils literal">2</tt></li>
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Dead_code_elimination">Dead code elimination</a></li>
</ul>
<p>Using guards (see the <a class="reference external" href="https://www.python.org/dev/peps/pep-0510/">PEP 510</a>), it is possible to
implement a much wider choice of optimizations. Examples:</p>
<ul class="simple">
<li>Simplify iterable: replace <tt class="docutils literal">range(3)</tt> with <tt class="docutils literal">(0, 1, 2)</tt> when used
as iterable</li>
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Loop_unrolling">Loop unrolling</a></li>
<li>Call pure builtins: replace <tt class="docutils literal"><span class="pre">len(&quot;abc&quot;)</span></tt> with <tt class="docutils literal">3</tt></li>
<li>Copy used builtin symbols to constants</li>
<li>See also <a class="reference external" href="https://fatoptimizer.readthedocs.org/en/latest/optimizations.html">optimizations implemented in fatoptimizer</a>,
a static optimizer for Python 3.6.</li>
</ul>
<p>The following issues can be implemented with an AST optimizer:</p>
<ul class="simple">
<li><a class="reference external" href="https://bugs.python.org/issue1346238">Issue #1346238</a>: A constant folding
optimization pass for the AST</li>
<li><a class="reference external" href="http://bugs.python.org/issue2181">Issue #2181</a>:
optimize out local variables at end of function</li>
<li><a class="reference external" href="http://bugs.python.org/issue2499">Issue #2499</a>:
Fold unary + and not on constants</li>
<li><a class="reference external" href="http://bugs.python.org/issue4264">Issue #4264</a>:
Patch: optimize code to use LIST_APPEND instead of calling list.append</li>
<li><a class="reference external" href="http://bugs.python.org/issue7682">Issue #7682</a>:
Optimisation of if with constant expression</li>
<li><a class="reference external" href="https://bugs.python.org/issue10399">Issue #10399</a>: AST
Optimization: inlining of function calls</li>
<li><a class="reference external" href="http://bugs.python.org/issue11549">Issue #11549</a>:
Build-out an AST optimizer, moving some functionality out of the
peephole optimizer</li>
<li><a class="reference external" href="http://bugs.python.org/issue17068">Issue #17068</a>:
peephole optimization for constant strings</li>
<li><a class="reference external" href="http://bugs.python.org/issue17430">Issue #17430</a>:
missed peephole optimization</li>
</ul>
</div>
<div class="section" id="usage-2-preprocessor">
<h2><a class="toc-backref" href="#id7">Usage 2: Preprocessor</a></h2>
<p>A preprocessor can be easily implemented with an AST transformer. A
preprocessor has various and different usages.</p>
<p>Some examples:</p>
<ul class="simple">
<li>Remove debug code like assertions and logs to make the code faster to
run it for production.</li>
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Tail_call">Tail-call Optimization</a></li>
<li>Add profiling code</li>
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Lazy_evaluation">Lazy evaluation</a>:
see <a class="reference external" href="https://github.com/llllllllll/lazy_python">lazy_python</a>
(bytecode transformer) and <a class="reference external" href="https://github.com/lihaoyi/macropy#lazy">lazy macro of MacroPy</a> (AST transformer)</li>
<li>Change dictionary literals into collection.OrderedDict instances</li>
<li>Declare constants: see <a class="reference external" href="https://pypi.python.org/pypi/codetransformer">&#64;asconstants of codetransformer</a></li>
<li>Domain Specific Language (DSL) like SQL queries. The
Python language itself doesn't need to be modified. Previous attempts
to implement DSL for SQL like <a class="reference external" href="https://www.python.org/dev/peps/pep-0335/">PEP 335 - Overloadable Boolean
Operators</a> was rejected.</li>
<li>Pattern Matching of functional languages</li>
<li>String Interpolation, but <a class="reference external" href="https://www.python.org/dev/peps/pep-0498/">PEP 498 -- Literal String Interpolation</a> was merged into Python
3.6.</li>
</ul>
<p><a class="reference external" href="https://github.com/lihaoyi/macropy">MacroPy</a> has a long list of
examples and use cases.</p>
<p>This PEP does not add any new code transformer. Using a code transformer
will require an external module and to register it manually.</p>
<p>See also <a class="reference external" href="https://bitbucket.org/namn/pyxfuscator">PyXfuscator</a>: Python
obfuscator, deobfuscator, and user-assisted decompiler.</p>
</div>
<div class="section" id="usage-3-disable-all-optimization">
<h2><a class="toc-backref" href="#id8">Usage 3: Disable all optimization</a></h2>
<p>Ned Batchelder asked to add an option to disable the peephole optimizer
because it makes code coverage more difficult to implement. See the
discussion on the python-ideas mailing list: <a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2014-May/027893.html">Disable all peephole
optimizations</a>.</p>
<p>This PEP adds a new <tt class="docutils literal"><span class="pre">-o</span> noopt</tt> command line option to disable the
peephole optimizer. In Python, it's as easy as:</p>
<pre class="literal-block">
sys.set_code_transformers([])
</pre>
<p>It will fix the <a class="reference external" href="https://bugs.python.org/issue2506">Issue #2506</a>: Add
mechanism to disable optimizations.</p>
</div>
<div class="section" id="usage-4-write-new-bytecode-optimizers-in-python">
<h2><a class="toc-backref" href="#id9">Usage 4: Write new bytecode optimizers in Python</a></h2>
<p>Python 3.6 optimizes the code using a peephole optimizer. By
definition, a peephole optimizer has a narrow view of the code and so
can only implement basic optimizations. The optimizer rewrites the
bytecode. It is difficult to enhance it, because it written in C.</p>
<p>With this PEP, it becomes possible to implement a new bytecode optimizer
in pure Python and experiment new optimizations.</p>
<p>Some optimizations are easier to implement on the AST like constant
folding, but optimizations on the bytecode are still useful. For
example, when the AST is compiled to bytecode, useless jumps can be
emitted because the compiler is naive and does not try to optimize
anything.</p>
</div>
</div>
<div class="section" id="use-cases">
<h1><a class="toc-backref" href="#id10">Use Cases</a></h1>
<p>This section give examples of use cases explaining when and how code
transformers will be used.</p>
<div class="section" id="interactive-interpreter">
<h2><a class="toc-backref" href="#id11">Interactive interpreter</a></h2>
<p>It will be possible to use code transformers with the interactive
interpreter which is popular in Python and commonly used to demonstrate
Python.</p>
<p>The code is transformed at runtime and so the interpreter can be slower
when expensive code transformers are used.</p>
</div>
<div class="section" id="build-a-transformed-package">
<h2><a class="toc-backref" href="#id12">Build a transformed package</a></h2>
<p>It will be possible to build a package of the transformed code.</p>
<p>A transformer can have a configuration. The configuration is not stored
in the package.</p>
<p>All <tt class="docutils literal">.pyc</tt> files of the package must be transformed with the same code
transformers and the same transformers configuration.</p>
<p>It is possible to build different <tt class="docutils literal">.pyc</tt> files using different
optimizer tags. Example: <tt class="docutils literal">fat</tt> for the default configuration and
<tt class="docutils literal">fat_inline</tt> for a different configuration with function inlining
enabled.</p>
<p>A package can contain <tt class="docutils literal">.pyc</tt> files with different optimizer tags.</p>
</div>
<div class="section" id="install-a-package-containing-transformed-pyc-files">
<h2><a class="toc-backref" href="#id13">Install a package containing transformed .pyc files</a></h2>
<p>It will be possible to install a package which contains transformed
<tt class="docutils literal">.pyc</tt> files.</p>
<p>All <tt class="docutils literal">.pyc</tt> files with any optimizer tag contained in the package are
installed, not only for the current optimizer tag.</p>
</div>
<div class="section" id="build-pyc-files-when-installing-a-package">
<h2><a class="toc-backref" href="#id14">Build .pyc files when installing a package</a></h2>
<p>If a package does not contain any <tt class="docutils literal">.pyc</tt> files of the current
optimizer tag (or some <tt class="docutils literal">.pyc</tt> files are missing), the <tt class="docutils literal">.pyc</tt> are
created during the installation.</p>
<p>Code transformers of the optimizer tag are required. Otherwise, the
installation fails with an error.</p>
</div>
<div class="section" id="execute-transformed-code">
<h2><a class="toc-backref" href="#id15">Execute transformed code</a></h2>
<p>It will be possible to execute transformed code.</p>
<p>Raise an <tt class="docutils literal">ImportError</tt> exception on import if the <tt class="docutils literal">.pyc</tt> file of the
current optimizer tag is missing and the code transformers required to
transform the code are missing.</p>
<p>The interesting point here is that code transformers are not needed to
execute the transformed code if all required <tt class="docutils literal">.pyc</tt> files are already
available.</p>
</div>
</div>
<div class="section" id="code-transformer-api">
<h1><a class="toc-backref" href="#id16">Code transformer API</a></h1>
<p>A code transformer is a class with <tt class="docutils literal">ast_transformer()</tt> and/or
<tt class="docutils literal">code_transformer()</tt> methods (API described below) and a <tt class="docutils literal">name</tt>
attribute.</p>
<p>For efficiency, do not define a <tt class="docutils literal">code_transformer()</tt> or
<tt class="docutils literal">ast_transformer()</tt> method if it does nothing.</p>
<p>The <tt class="docutils literal">name</tt> attribute (<tt class="docutils literal">str</tt>) must be a short string used to identify
an optimizer. It is used to build a <tt class="docutils literal">.pyc</tt> filename. The name must not
contain dots (<tt class="docutils literal">'.'</tt>), dashes (<tt class="docutils literal"><span class="pre">'-'</span></tt>) or directory separators: dots
are used to separated fields in a <tt class="docutils literal">.pyc</tt> filename and dashes areused
to join code transformer names to build the optimizer tag.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It would be nice to pass the fully qualified name of a module in the
<em>context</em> when an AST transformer is used to transform a module on
import, but it looks like the information is not available in
<tt class="docutils literal">PyParser_ASTFromStringObject()</tt>.</p>
</div>
<div class="section" id="code-transformer-method">
<h2><a class="toc-backref" href="#id17">code_transformer() method</a></h2>
<p>Prototype:</p>
<pre class="literal-block">
def code_transformer(self, code, context):
    ...
    new_code = ...
    ...
    return new_code
</pre>
<p>Parameters:</p>
<ul class="simple">
<li><em>code</em>: code object</li>
<li><em>context</em>: an object with an <em>optimize</em> attribute (<tt class="docutils literal">int</tt>), the optimization
level (0, 1 or 2). The value of the <em>optimize</em> attribute comes from the
<em>optimize</em> parameter of the <tt class="docutils literal">compile()</tt> function, it is equal to
<tt class="docutils literal">sys.flags.optimize</tt> by default.</li>
</ul>
<p>Each implementation of Python can add extra attributes to <em>context</em>. For
example, on CPython, <em>context</em> will also have the following attribute:</p>
<ul class="simple">
<li><em>interactive</em> (<tt class="docutils literal">bool</tt>): true if in interactive mode</li>
</ul>
<p>XXX add more flags?</p>
<p>XXX replace flags int with a sub-namespace, or with specific attributes?</p>
<p>The method must return a code object.</p>
<p>The code transformer is run after the compilation to bytecode</p>
</div>
<div class="section" id="ast-transformer-method">
<h2><a class="toc-backref" href="#id18">ast_transformer() method</a></h2>
<p>Prototype:</p>
<pre class="literal-block">
def ast_transformer(self, tree, context):
    ...
    return tree
</pre>
<p>Parameters:</p>
<ul class="simple">
<li><em>tree</em>: an AST tree</li>
<li><em>context</em>: an object with a <tt class="docutils literal">filename</tt> attribute (<tt class="docutils literal">str</tt>)</li>
</ul>
<p>It must return an AST tree. It can modify the AST tree in place, or
create a new AST tree.</p>
<p>The AST transformer is called after the creation of the AST by the
parser and before the compilation to bytecode. New attributes may be
added to <em>context</em> in the future.</p>
</div>
</div>
<div class="section" id="changes">
<h1><a class="toc-backref" href="#id19">Changes</a></h1>
<p>In short, add:</p>
<ul class="simple">
<li>-o OPTIM_TAG command line option</li>
<li>sys.implementation.optim_tag</li>
<li>sys.get_code_transformers()</li>
<li>sys.set_code_transformers(transformers)</li>
<li>ast.PyCF_TRANSFORMED_AST</li>
</ul>
<div class="section" id="api-to-get-set-code-transformers">
<h2><a class="toc-backref" href="#id20">API to get/set code transformers</a></h2>
<p>Add new functions to register code transformers:</p>
<ul class="simple">
<li><tt class="docutils literal">sys.set_code_transformers(transformers)</tt>: set the list of code
transformers and update <tt class="docutils literal">sys.implementation.optim_tag</tt></li>
<li><tt class="docutils literal">sys.get_code_transformers()</tt>: get the list of code
transformers.</li>
</ul>
<p>The order of code transformers matter. Running transformer A and then
transformer B can give a different output than running transformer B an
then transformer A.</p>
<p>Example to prepend a new code transformer:</p>
<pre class="literal-block">
transformers = sys.get_code_transformers()
transformers.insert(0, new_cool_transformer)
sys.set_code_transformers(transformers)
</pre>
<p>All AST transformers are run sequentially (ex: the second transformer
gets the input of the first transformer), and then all bytecode
transformers are run sequentially.</p>
</div>
<div class="section" id="optimizer-tag">
<h2><a class="toc-backref" href="#id21">Optimizer tag</a></h2>
<p>Changes:</p>
<ul class="simple">
<li>Add <tt class="docutils literal">sys.implementation.optim_tag</tt> (<tt class="docutils literal">str</tt>): optimization tag.
The default optimization tag is <tt class="docutils literal">'opt'</tt>.</li>
<li>Add a new <tt class="docutils literal"><span class="pre">-o</span> OPTIM_TAG</tt> command line option to set
<tt class="docutils literal">sys.implementation.optim_tag</tt>.</li>
</ul>
<p>Changes on <tt class="docutils literal">importlib</tt>:</p>
<ul class="simple">
<li><tt class="docutils literal">importlib</tt> uses <tt class="docutils literal">sys.implementation.optim_tag</tt> to build the
<tt class="docutils literal">.pyc</tt> filename to importing modules, instead of always using
<tt class="docutils literal">opt</tt>. Remove also the special case for the optimizer level <tt class="docutils literal">0</tt>
with the default optimizer tag <tt class="docutils literal">'opt'</tt> to simplify the code.</li>
<li>When loading a module, if the <tt class="docutils literal">.pyc</tt> file is missing but the <tt class="docutils literal">.py</tt>
is available, the <tt class="docutils literal">.py</tt> is only used if code optimizers have the
same optimizer tag than the current tag, otherwise an <tt class="docutils literal">ImportError</tt>
exception is raised.</li>
</ul>
<p>Pseudo-code of a <tt class="docutils literal">use_py()</tt> function to decide if a <tt class="docutils literal">.py</tt> file can
be compiled to import a module:</p>
<pre class="literal-block">
def transformers_tag():
    transformers = sys.get_code_transformers()
    if not transformers:
        return 'noopt'
    return '-'.join(transformer.name
                    for transformer in transformers)

def use_py():
    return (transformers_tag() == sys.implementation.optim_tag)
</pre>
<p>The order of <tt class="docutils literal">sys.get_code_transformers()</tt> matter. For example, the
<tt class="docutils literal">fat</tt> transformer followed by the <tt class="docutils literal">pythran</tt> transformer gives the
optimizer tag <tt class="docutils literal"><span class="pre">fat-pythran</span></tt>.</p>
<p>The behaviour of the <tt class="docutils literal">importlib</tt> module is unchanged with the default
optimizer tag (<tt class="docutils literal">'opt'</tt>).</p>
</div>
<div class="section" id="peephole-optimizer">
<h2><a class="toc-backref" href="#id22">Peephole optimizer</a></h2>
<p>By default, <tt class="docutils literal">sys.implementation.optim_tag</tt> is <tt class="docutils literal">opt</tt> and
<tt class="docutils literal">sys.get_code_transformers()</tt> returns a list of one code transformer:
the peephole optimizer (optimize the bytecode).</p>
<p>Use <tt class="docutils literal"><span class="pre">-o</span> noopt</tt> to disable the peephole optimizer. In this case, the
optimizer tag is <tt class="docutils literal">noopt</tt> and no code transformer is registered.</p>
<p>Using the <tt class="docutils literal"><span class="pre">-o</span> opt</tt> option has not effect.</p>
</div>
<div class="section" id="ast-enhancements">
<h2><a class="toc-backref" href="#id23">AST enhancements</a></h2>
<p>Enhancements to simplify the implementation of AST transformers:</p>
<ul class="simple">
<li>Add a new compiler flag <tt class="docutils literal">PyCF_TRANSFORMED_AST</tt> to get the
transformed AST. <tt class="docutils literal">PyCF_ONLY_AST</tt> returns the AST before the
transformers.</li>
</ul>
</div>
</div>
<div class="section" id="examples">
<h1><a class="toc-backref" href="#id24">Examples</a></h1>
<div class="section" id="pyc-filenames">
<h2><a class="toc-backref" href="#id25">.pyc filenames</a></h2>
<p>Example of <tt class="docutils literal">.pyc</tt> filenames of the <tt class="docutils literal">os</tt> module.</p>
<p>With the default optimizer tag <tt class="docutils literal">'opt'</tt>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="60%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">.pyc filename</th>
<th class="head">Optimization level</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">os.cpython-36.opt-0.pyc</span></tt></td>
<td>0</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">os.cpython-36.opt-1.pyc</span></tt></td>
<td>1</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">os.cpython-36.opt-2.pyc</span></tt></td>
<td>2</td>
</tr>
</tbody>
</table>
<p>With the <tt class="docutils literal">'fat'</tt> optimizer tag:</p>
<table border="1" class="docutils">
<colgroup>
<col width="60%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">.pyc filename</th>
<th class="head">Optimization level</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">os.cpython-36.fat-0.pyc</span></tt></td>
<td>0</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">os.cpython-36.fat-1.pyc</span></tt></td>
<td>1</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">os.cpython-36.fat-2.pyc</span></tt></td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="bytecode-transformer">
<h2><a class="toc-backref" href="#id26">Bytecode transformer</a></h2>
<p>Scary bytecode transformer replacing all strings with
<tt class="docutils literal">&quot;Ni! Ni! Ni!&quot;</tt>:</p>
<pre class="literal-block">
import sys
import types

class BytecodeTransformer:
    name = &quot;knights_who_say_ni&quot;

    def code_transformer(self, code, context):
        consts = ['Ni! Ni! Ni!' if isinstance(const, str) else const
                  for const in code.co_consts]
        return types.CodeType(code.co_argcount,
                              code.co_kwonlyargcount,
                              code.co_nlocals,
                              code.co_stacksize,
                              code.co_flags,
                              code.co_code,
                              tuple(consts),
                              code.co_names,
                              code.co_varnames,
                              code.co_filename,
                              code.co_name,
                              code.co_firstlineno,
                              code.co_lnotab,
                              code.co_freevars,
                              code.co_cellvars)

# replace existing code transformers with the new bytecode transformer
sys.set_code_transformers([BytecodeTransformer()])

# execute code which will be transformed by code_transformer()
exec(&quot;print('Hello World!')&quot;)
</pre>
<p>Output:</p>
<pre class="literal-block">
Ni! Ni! Ni!
</pre>
</div>
<div class="section" id="ast-transformer">
<h2><a class="toc-backref" href="#id27">AST transformer</a></h2>
<p>Similary to the bytecode transformer example, the AST transformer also
replaces all strings with <tt class="docutils literal">&quot;Ni! Ni! Ni!&quot;</tt>:</p>
<pre class="literal-block">
import ast
import sys

class KnightsWhoSayNi(ast.NodeTransformer):
    def visit_Str(self, node):
        node.s = 'Ni! Ni! Ni!'
        return node

class ASTTransformer:
    name = &quot;knights_who_say_ni&quot;

    def __init__(self):
        self.transformer = KnightsWhoSayNi()

    def ast_transformer(self, tree, context):
        self.transformer.visit(tree)
        return tree

# replace existing code transformers with the new AST transformer
sys.set_code_transformers([ASTTransformer()])

# execute code which will be transformed by ast_transformer()
exec(&quot;print('Hello World!')&quot;)
</pre>
<p>Output:</p>
<pre class="literal-block">
Ni! Ni! Ni!
</pre>
</div>
</div>
<div class="section" id="other-python-implementations">
<h1><a class="toc-backref" href="#id28">Other Python implementations</a></h1>
<p>The <a class="reference external" href="/dev/peps/pep-0511">PEP 511</a> should be implemented by all Python implementation, but the
bytecode and the AST are not standardized.</p>
<p>By the way, even between minor version of CPython, there are changes on
the AST API. There are differences, but only minor differences. It is
quite easy to write an AST transformer which works on Python 2.7 and
Python 3.5 for example.</p>
</div>
<div class="section" id="discussion">
<h1><a class="toc-backref" href="#id29">Discussion</a></h1>
<ul class="simple">
<li><a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2016-January/037884.html">[Python-ideas] PEP 511: API for code transformers</a>
(January 2016)</li>
<li><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2012-August/121286.html">[Python-Dev] AST optimizer implemented in Python</a>
(August 2012)</li>
</ul>
</div>
<div class="section" id="prior-art">
<h1><a class="toc-backref" href="#id30">Prior Art</a></h1>
<div class="section" id="ast-optimizers">
<h2><a class="toc-backref" href="#id31">AST optimizers</a></h2>
<p>The Issue #17515 <a class="reference external" href="https://bugs.python.org/issue17515">&quot;Add sys.setasthook() to allow to use a custom AST&quot;
optimizer</a> was a first attempt of
API for code transformers, but specific to AST.</p>
<p>In 2015, Victor Stinner wrote the <a class="reference external" href="http://fatoptimizer.readthedocs.org/">fatoptimizer</a> project, an AST optimizer
specializing functions using guards.</p>
<p>In 2014, Kevin Conway created the <a class="reference external" href="http://pycc.readthedocs.org/">PyCC</a>
optimizer.</p>
<p>In 2012, Victor Stinner wrote the <a class="reference external" href="https://bitbucket.org/haypo/astoptimizer/">astoptimizer</a> project, an AST optimizer
implementing various optimizations. Most interesting optimizations break
the Python semantics since no guard is used to disable optimization if
something changes.</p>
<p>In 2011, Eugene Toder proposed to rewrite some peephole optimizations in
a new AST optimizer: issue #11549, <a class="reference external" href="https://bugs.python.org/issue11549">Build-out an AST optimizer, moving
some functionality out of the peephole optimizer</a>.  The patch adds <tt class="docutils literal">ast.Lit</tt> (it
was proposed to rename it to <tt class="docutils literal">ast.Literal</tt>).</p>
</div>
<div class="section" id="python-preprocessors">
<h2><a class="toc-backref" href="#id32">Python Preprocessors</a></h2>
<ul class="simple">
<li><a class="reference external" href="https://github.com/lihaoyi/macropy">MacroPy</a>: MacroPy is an
implementation of Syntactic Macros in the Python Programming Language.
MacroPy provides a mechanism for user-defined functions (macros) to
perform transformations on the abstract syntax tree (AST) of a Python
program at import time.</li>
<li><a class="reference external" href="https://code.google.com/p/pypreprocessor/">pypreprocessor</a>: C-style
preprocessor directives in Python, like <tt class="docutils literal">#define</tt> and <tt class="docutils literal">#ifdef</tt></li>
</ul>
</div>
<div class="section" id="bytecode-transformers">
<h2><a class="toc-backref" href="#id33">Bytecode transformers</a></h2>
<ul class="simple">
<li><a class="reference external" href="https://pypi.python.org/pypi/codetransformer">codetransformer</a>:
Bytecode transformers for CPython inspired by the <tt class="docutils literal">ast</tt> module’s
<tt class="docutils literal">NodeTransformer</tt>.</li>
<li><a class="reference external" href="http://code.google.com/p/byteplay/">byteplay</a>: Byteplay lets you
convert Python code objects into equivalent objects which are easy to
play with, and lets you convert those objects back into living Python
code objects. It's useful for applying crazy transformations on Python
functions, and is also useful in learning Python byte code
intricacies. See <a class="reference external" href="http://wiki.python.org/moin/ByteplayDoc">byteplay documentation</a>.</li>
</ul>
<p>See also:</p>
<ul class="simple">
<li><a class="reference external" href="http://pypi.python.org/pypi/BytecodeAssembler">BytecodeAssembler</a></li>
</ul>
</div>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id34">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
</div>

